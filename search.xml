<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[problem summary]]></title>
    <url>%2F2020%2F03%2F25%2Fproblem-summary%2F</url>
    <content type="text"><![CDATA[welcome to my blog,enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category></category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RDSNet]]></title>
    <url>%2F2020%2F03%2F18%2FRDSNet%2F</url>
    <content type="text"><![CDATA[RDSNetRDSNetobject levelpixel levelpixelpixel levelobject level - tight bounding boxbounding  pixel wisemask MASK-RCNNmaskproposal RDSNetRDSNet RDSNetFCN  RDSNet.1RDSNet23  RDSNetFPNLin.2017a LiuSEC.3.3 FCN2015SEC.3.2  $$M_{o}=\operatorname{softmax}\left(\Psi(U) \star \phi\left(v_{o}\right)\right)$$ $v_0$ obejct streamUM0pixelwiseloss U1xdxhxwv2xdx1x12Uv2x1xwxhanchorvUsoftmaxanchorsegmentation 2xkxdx1x1 representationanchor  objectmaskmaskbox1:1OHEM mask loss$$L=L_{c l s}+\lambda_{r} L_{r e g}+\lambda_{m} L_{m a s k}$$mask  GTsegmentationcocoploygon[x1,y1,x2,y2,x3,y3] boxGT dataset [img, gt_bboxes, gt_labels, gt_masks]  backbone: usually an FCN network to extract feature maps, e.g., ResNet, MobileNet. neck: the component between backbones and heads, e.g., FPN, PAFPN. head: the component for specific tasks, e.g., bbox prediction and mask prediction. roi extractor: the part for extracting RoI features from feature maps, e.g., RoI Align. IoUmaskGT$$I O U(A, B)=\frac{|A \cap B|}{|A \cup B|}$$diceIoUGT$$\operatorname{dice}(A, B)=\frac{2|A \cap B|}{|A|+|B|}$$diceIoU COCO 123456789101112Average Precision (AP) @[ IoU=0.50:0.95 | area= all | maxDets=100 ] = 0.397Average Precision (AP) @[ IoU=0.50 | area= all | maxDets=100 ] = 0.603Average Precision (AP) @[ IoU=0.75 | area= all | maxDets=100 ] = 0.499Average Precision (AP) @[ IoU=0.50:0.95 | area= small | maxDets=100 ] = 0.034Average Precision (AP) @[ IoU=0.50:0.95 | area=medium | maxDets=100 ] = 0.463Average Precision (AP) @[ IoU=0.50:0.95 | area= large | maxDets=100 ] = -1.000Average Recall (AR) @[ IoU=0.50:0.95 | area= all | maxDets= 1 ] = 0.443Average Recall (AR) @[ IoU=0.50:0.95 | area= all | maxDets= 10 ] = 0.465Average Recall (AR) @[ IoU=0.50:0.95 | area= all | maxDets=100 ] = 0.467Average Recall (AR) @[ IoU=0.50:0.95 | area= small | maxDets=100 ] = 0.135Average Recall (AR) @[ IoU=0.50:0.95 | area=medium | maxDets=100 ] = 0.501Average Recall (AR) @[ IoU=0.50:0.95 | area= large | maxDets=100 ] = -1.000 IoUprecisionrecall baseline segmentation  segmentation pa  mpa mIUIoU fwIUIoU FCNbaseline 574384  pa: 0.9326967388628634 person pa: 0.948784433562702; ski pa 0.7863983575482737 person mIU: 0.8811813306596593; ski mIU 0.47062399967040647  resize[(1333, 640), (1333, 800)]randomFilpNormalizePad maskbox:]]></content>
      <categories>
        <category></category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LR ]]></title>
    <url>%2F2020%2F03%2F14%2FLR-%E6%8E%A8%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[sigmoid  $h(\theta)$ $1-h(\theta)$   sigmoid$$h(\theta) = \frac{e^{wx}}{1+e^{wx}}$$ $$P(y | \boldsymbol{x})=\left{\begin{aligned} p, y &amp;=1 \ 1-p, y &amp;=0 \end{aligned}\right.$$$$P\left(y_{i} | \boldsymbol{x}_{i}\right)=p^{y_{i}}(1-p)^{1-y_{i}}$$$$\begin{aligned} P_{\breve{E}} &amp;=P\left(y_{1} | \boldsymbol{x}_{1}\right) P\left(y_{2} | \boldsymbol{x}_{2}\right) P\left(y_{3} | \boldsymbol{x}_{3}\right) \dots P\left(y_{N} | \boldsymbol{x}_{N}\right) \ &amp;=\prod_{n=1}^{N} p^{y_{n}}(1-p)^{1-y_{n}} \end{aligned}$$$$\begin{aligned} F(\boldsymbol{w})=\ln \left(P_{\breve{\mathbf{E}} \mathbf{h}}\right) &amp;=\ln \left(\prod_{n=1}^{N} p^{y_{n}}(1-p)^{1-y_{n}}\right) \ &amp;=\sum_{n=1}^{N} \ln \left(p^{y_{n}}(1-p)^{1-y_{n}}\right) \ &amp;=\sum_{n=1}^{N}\left(y_{n} \ln (p)+\left(1-y_{n}\right) \ln (1-p)\right) \end{aligned}$$psigmoid  sigmoid$$\begin{aligned} p^{\prime}=f^{\prime}(\boldsymbol{w}) &amp;=\left(\frac{1}{1+e^{-\boldsymbol{w}^{T} \boldsymbol{x}}}\right)^{\prime} \ &amp;=-\frac{1}{\left(1+e^{-\boldsymbol{w}^{T} \boldsymbol{x}}\right)^{2}} \cdot\left(1+e^{-\boldsymbol{w}^{T} \boldsymbol{x}}\right)^{\prime} \ &amp;=-\frac{1}{\left(1+e^{-\boldsymbol{w}^{T} \boldsymbol{x}}\right)^{2}} \cdot e^{-\boldsymbol{w}^{T} \boldsymbol{x}} \cdot\left(-\boldsymbol{w}^{T} \boldsymbol{x}\right)^{\prime} \ &amp;=-\frac{1}{\left(1+e^{-\boldsymbol{w}^{T} \boldsymbol{x}}\right)^{2}} \cdot e^{-\boldsymbol{w}^{T} \boldsymbol{x}} \cdot(-\boldsymbol{x}) \ &amp;=\frac{e^{-\boldsymbol{w}^{T} \boldsymbol{x}}}{\left(1+e^{-\boldsymbol{w}^{T} \boldsymbol{x}}\right)^{2}} \cdot \boldsymbol{x} \ &amp;=\frac{1}{1+e^{-\boldsymbol{w}^{T} \boldsymbol{x}}} \cdot \frac{e^{-\boldsymbol{w}^{T} \boldsymbol{x}}}{1+e^{-\boldsymbol{w}^{T} \boldsymbol{x}}} \cdot \boldsymbol{x} \ &amp;=p(1-p) \boldsymbol{x} \end{aligned}$$()$$\begin{aligned} \nabla F(\boldsymbol{w}) &amp;=\nabla\left(\sum_{n=1}^{N}\left(y_{n} \ln (p)+\left(1-y_{n}\right) \ln (1-p)\right)\right) \ &amp;=\sum\left(y_{n} \ln ^{\prime}(p)+\left(1-y_{n}\right) \ln ^{\prime}(1-p)\right) \ &amp;=\sum\left(\left(y_{n} \frac{1}{p} p^{\prime}\right)+\left(1-y_{n}\right) \frac{1}{1-p}(1-p)^{\prime}\right) \ &amp;=\sum_{n=1}\left(y_{n}(1-p) \boldsymbol{x}_{n}-\left(1-y_{n}\right) p \boldsymbol{x}_{n}\right) \ &amp;=\sum_{n=1}^{N}\left(y_{n}-p\right) \boldsymbol{x}_{n} \end{aligned}$$SGD $$\boldsymbol{w}_{t+1}=\boldsymbol{w}_{t}+\eta \nabla F(\boldsymbol{w})$$ $$\boldsymbol{w}_{t+1}= \boldsymbol{w}_{t} + \eta \sum_{n=1}^{N}\left(y_{n}-p\right) \boldsymbol{x}_{n}$$]]></content>
      <categories>
        <category></category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TrackIn:BERT five-classification on MSMARCO.md]]></title>
    <url>%2F2020%2F03%2F12%2FTrackIn-BERT%2F</url>
    <content type="text"><![CDATA[postBERTTrackIninference MS MARCOMS MARCONLP100000bingQnA https://microsoft.github.io/MSMARCO-Passage-Ranking/ MARCO triples.train.small.tsv:&lt;query,doc1,doc2&gt;doc1positivedoc2negative top1000.dev.tsv&lt;query_id ,doc_id,query,doc&gt;querydoc qrels.dev.small.tsv&lt;query_id,0,doc_id,1&gt;querydoc triples.train.small.tsvquery STSB15  1index genre filename year old_index source1 source2 sentence1 sentence2 score  12sentence1 sentence2 scoreA plane is taking off. An air plane is taking off. 5.000 wordembedding768pad_sequence512512 x 768512 x 768position embeddingBERT dataloader&lt;query,doc,label&gt;,dataloaderlabel = 0 label = 1   querydoctokenizer: [CLS] + tokens_query + [SEP] + tokens_doc + [SEP] vocabword idsegments_tensorquery0doc1batchtensor0 tensorpad_sequence,maskmaskbatch001 dataloader &lt;tokens_tensors, masks_tensors,segments_tensors, labels_ids&gt; tensortokens_tensor32x128 transformers.BertForSequenceClassification  BERT768label classloss STSB12345678def pearson_and_spearman(preds, labels): pearson_corr = pearsonr(preds, labels)[0] spearman_corr = spearmanr(preds, labels)[0] return &#123; "pearson": pearson_corr, "spearmanr": spearman_corr, "corr": (pearson_corr + spearman_corr) / 2, &#125; pearson:-1+1, 0$$\rho(X, Y)=\frac{E\left[\left(X-\mu_{X}\right)\left(Y-\mu_{Y}\right)\right]}{\sigma_{X} \sigma_{Y}}=\frac{E\left[\left(X-\mu_{X}\right)\left(Y-\mu_{Y}\right)\right]}{\sqrt{\sum_{i=1}^{n}\left(X_{i}-\mu_{X}\right)^{2}} \sqrt{\sum_{i=1}^{n}\left(Y_{i}-\mu_{Y}\right)^{2}}}$$ 0.8-1.0  0.6-0.8  0.4-0.6  0.2-0.4  0.0-0.2  spearmanrX()Y()$$\rho=\frac{\sum_{i}\left(x_{i}-\bar{x}\right)\left(y_{i}-\bar{y}\right)}{\sqrt{\sum_{i}\left(x_{i}-\bar{x}\right)^{2} \sum_{i}\left(y_{i}-\bar{y}\right)^{2}}}$$ trackIn TrackInmodelloss zz    t  SGD  zz batch checkpointcheckpoint wt wt+1zpositivenegative NLPNLP trackIn STS-B sentence1 sentence2 similar_score0-4 A plane is taking off. An air plane is taking off. 4 A man is playing a large flute. A man is playing a flute. 3 A man is smoking. A man is skating. 0 huggingfaceBertForSequenceClassification Bert + dropout + linear768x5+ corssentropy 10epoch corr = 0.8668199467352331 pearson = 0.8680211975793752 spearmanr = 0.865618695891091 gluetop20top1090 fix BERTlinear10epoch corr = 0.46851795469199176 pearson = 0.4883897702565989 spearmanr = 0.44864613912738466 Bertlinearfix bert Bert + linear768x100 + linear(100x5) + crossentropy corr = 0.4874025699052884 pearson = 0.48976918410773407 spearmanr = 0.4850359557028428 bert + linear(768,300) + linear(300,50) + linear(50,5): corr = 0.4901503255725512 pearson = 0.49249477605462705 spearmanr = 0.48780587509047535 Bert + linear(768,300) + linear(300,100) + linear(100,50) + linear(50,5) 123corr = 0.5010257366795687pearson = 0.5034574745457592spearmanr = 0.49859399881337824 bertlinearbert + linear(768,300) + linear(300,100) + linear(100,50) + linear(50,5) corr = 0.7648302644703243 pearson = 0.7663893373697331 spearmanr = 0.7632711915709155 pearson:-1+1, 0 0.8-1.0 0.6-0.8 0.4-0.6 0.2-0.4 0.0-0.2  trackIn$$\operatorname{TrackIn}\left(z, z^{\prime}\right)=\sum_{t: z_{t}=z} \eta_{t} \nabla \ell\left(w_{t}, z^{\prime}\right) \cdot \nabla \ell\left(w_{t}, z\right)$$ TrackIntz  $z^`$  $w_t$$w_t$ $w_t$TrackInlosst  Bertclassifier trackIn target example   train exampletrain exampletrackIn  datasetdataloader ttxt trackIn   aa: A plane is taking off. An air plane is taking off. 5.000 trackIn b1: A plane is taking off. A man wearing a hard hat is dancing. 5.000 :11326.170552326665 b2: A plane is taking off. The plane is about to take off. 5.0 done :11326.172044273939 b3: A plane is taking off. Spaceship is about to take off. 3.0 done :11326.17223393679]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[BertXLNetUNILMRoBERTaQA]]></title>
    <url>%2F2020%2F03%2F10%2FBert%EF%BC%8CXLNet%EF%BC%8CUNILM%EF%BC%8CRoBERTa%E4%BB%A5%E5%8F%8AQA%2F</url>
    <content type="text"><![CDATA[trackIn postBert QA QAQASQuADQApipelineQA -&gt; QA -&gt; Embedderembedding EncoderLSTM Interaction LayerAttentionquery-aware Answer Layerquery-aware Match-LSTMBiDAFFastQAExt R-NET  huggingfacebert-Squad pretrain modelBERT/RoBERTa/XLNet/XLM SQuAD https://www.cnblogs.com/xuehuiping/p/12262700.html SQuAD EMexact match F1 F1questionGTF1F1question$$F_1 = 2 \frac{precisionrecall}{precision + recall}$$ transformertransformerencoderdecoderencoderdecoderNx transformer6encoderdecoder NLPNLPGPTELMOXmaskmaskmaskfintuneBertBert Bert bertMASK15%15%80%[mask]10%10% Bert[MASK]finetune  finetune[MASK](mask)tokentokens XLNetXLNetMASK Permutation Language Model TT-1TT 1Transformer2Queryx3queryx3wembedding attention mask1234mask UNILMmaskUNILM UNILMLMLMsequence2sequence LM Transformerself-attention masks: self-attention maskstokenbatch1/3 RoBERTa1MaskingMaskingMasking 2next predict lossBERTfull-sentencesdoc-sentences512 3batch sizebatch sizetraining step 4text encodingbytesunknown16G160GBERT GLUENLPNLUNLGNLUGLUE(General Language Understanding Evaluation)NLU CoLA(The Corpus of Linguistic Acceptability):CoLA SST(The Stanford Sentiment Treebank)SSTSST-2SST-5SST-5 MRPC(Microsoft Research Paraphrase Corpus) STS-B(Semantic Textual Similarity Benchmark)SemEvalSentEval15 QQP(Quora Question Pairs)Quora MNLI(Multi-Genre Natural Language Inference)PremiseHypothesisMNLImatchedmismatchedMNLI QNLIQuestion Natural Language Inference)SQuAD 1.0 RTE(Recognizing Textual Entailment)MNLIMNLIRTE WNLI(Winograd Natural Language Inference)GLUE]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[AI]]></title>
    <url>%2F2020%2F03%2F10%2F%E5%A4%A9%E6%B1%A0%E5%AE%89%E5%85%A8AI%E6%8C%91%E6%88%98%E8%B5%9B%E7%BB%86%E6%9E%9D%E6%9C%AB%E8%8A%82%2F</url>
    <content type="text"><![CDATA[welcome to my blog,enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category></category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[]]></title>
    <url>%2F2020%2F03%2F08%2F%E7%B2%BE%E5%BD%A9%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E7%9A%84%E7%BB%86%E6%9E%9D%E6%9C%AB%E8%8A%82%2F</url>
    <content type="text"><![CDATA[welcome to my blog,enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category></category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[openpose]]></title>
    <url>%2F2020%2F03%2F07%2Fopenpose%E7%BB%86%E6%9E%9D%E6%9C%AB%E8%8A%82%2F</url>
    <content type="text"><![CDATA[welcome to my blog,enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category></category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[-SVM]]></title>
    <url>%2F2020%2F02%2F26%2F%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA-SVM%2F</url>
    <content type="text"><![CDATA[SVMhard-svmsoft-svm VCVC2DVC3. VCVC SVMmargin $$d(\mathbf{x})=\frac{|\mathbf{x} \cdot \mathbf{w}+b|}{\sqrt{|\mathbf{w}|_{2}^{2}}}=\frac{|\mathbf{x} \cdot \mathbf{w}+b|}{\sqrt{\sum_{i=1}^{d} w_{i}^{2}}}$$margin $$\operatorname{margin} \equiv \underset{\mathbf{x} \in D}{\arg \min } d(\mathbf{x})=\underset{\mathbf{x} \in D}{\arg \min } \frac{|\mathbf{x} \cdot \mathbf{w}+b|}{\sqrt{\sum_{i=1}^{d} w_{i}^{2}}}$$marginwb$$\underset{\mathbf{w}, b}{\operatorname{argmax}} \arg \min _{\mathbf{x} \in D} \frac{\left|b+\mathbf{x}_{i} \cdot \mathbf{w}\right|}{\sqrt{\sum_{i=1}^{d} w_{i}^{2}}}\\\text { subject to } \forall \mathbf{x}_{i} \in D: y_{i}\left(\mathbf{x}_{i} \cdot \mathbf{w}+b\right) \geq 0$$ $|xw + b|$1$$\begin{array}{l}{\underset{\mathbf{w}, b}{\operatorname{argmin}} \sum_{i=1}^{d} w_{i}^{2}} \ {\text { subject to } \forall \mathbf{x}_{i} \in D: y_{i}\left(\mathbf{x}_{i} \cdot \mathbf{w}+b\right) \geq 1}\end{array}$$SVMw soft-SVMtradesoff tradesofftradesoff hinge losshinge loss0-1loss  KKT SVM   $$K\left(x_{i}, x_{j}\right)=\phi\left(x_{i}\right) \cdot \phi\left(x_{j}\right)$$  SVMSVMhardsoftmaxminKTT]]></content>
      <categories>
        <category></category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[]]></title>
    <url>%2F2020%2F02%2F19%2F%E8%81%9A%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[        k-means  n$$p(\mathbf{x} | \boldsymbol{\theta})=\sum_{j=1}^{c} p\left(\mathbf{x} | \omega_{j}, \boldsymbol{\theta}_{j}\right) P\left(\omega_{j}\right)$$$\theta$  $\theta$$\theta$ K-]]></content>
      <categories>
        <category></category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[]]></title>
    <url>%2F2020%2F02%2F17%2F%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[     BP           3x3   autoencoder RNN]]></content>
      <categories>
        <category></category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[]]></title>
    <url>%2F2020%2F02%2F16%2F%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[   k-   - one-vs-allC one-vs-onec/2     ]]></content>
      <categories>
        <category></category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Learn To Rank]]></title>
    <url>%2F2020%2F02%2F14%2FLearn-To-Rank%2F</url>
    <content type="text"><![CDATA[Learn To RankNLPData Mining queryDocumentstermkeywordsemanticDocumentsTop NDocuments  f(q,d)querydocumentsWeb SearchWeb Search query-doc pairtraining data querydoc learn to rank traintest training data set learning to ranklabelfeature vectorlabelquery-doc pairlabel training dataquery-doc pair5perfectexcellentgoodfairbad query=MicrosoftdocumentMicrosoftperfectMicrosoftwikipediaexcellentMicrosoftgoodMicrosoftfairMicrosoftbadquery-doc pair query-doc pairquery-doc pairquerydoc docdoctrickygeneralposition bias docdocdocdoc Joachimsbias Click &gt; Skip Above, Last Click &gt; Skip Above, Click &gt; Earlier Click, Click &gt; Skip Previous, Click &gt; No Click Next docdoc5-10 click modeldocdocdoc/CTRdoc feature Learning to Rankfeaturerelevance  importancehotnessquery-doc pair featuredocfeature BM25  PageRank Evaluationground truthInformation RetrievalNDCGMAP NDCG NDCG1dockdoc   CGcumulative gain $$\mathrm{CG}_{\mathrm{p}}=\sum_{i=1}^{p} r e l_{i}$$reli DCG CG$$\mathrm{DCG}_{\mathrm{p}}=\sum_{i=1}^{p} \frac{r e l_{i}}{\log _{2}(i+1)}=r e l_{1}+\sum_{i=2}^{p} \frac{r e l_{i}}{\log _{2}(i+1)}$$NDCG DCG$$\mathrm{nDCG}_{\mathrm{p}}=\frac{D C G_{p}}{I D C G_{p}}$$IDCGDCG$$\mathrm{IDCG}_{\mathrm{p}}=\sum_{i=1}^{|R E L|} \frac{2^{r e l_{i}}-1}{\log _{2}(i+1)}$$p MAP queryAP$$A P=\frac{\sum_{j=1}^{n_{i}} P(j) \cdot y_{i, j}}{\sum_{j=1}^{n_{i}} y_{i, j}}$$$y_{ij}$doclabel10query-doc pairP$d_{ij}$docprecision$$P(j)=\frac{\sum_{k: \pi_{i}(k) \leq \pi_{i}(j)} y_{i, k}}{\pi_{i}(j)}$$pi Formulation$$\hat{R}(F)=\frac{1}{m} \sum_{i=1}^{m} L\left(F\left(\mathbf{x}_{i}\right), \mathbf{y}_{i}\right)$$ pointwise loss $$L^{\prime}(F(\mathbf{x}), \mathbf{y})=\sum_{i=1}^{n}\left(f\left(x_{i}\right)-y_{i}\right)^{2}$$pairwise loss hinge lossexponential losslogistic loss$$L^{\prime}(F(\mathbf{x}), \mathbf{y})=\sum_{i=1}^{n-1} \sum_{j=i+1}^{n} \phi\left(\operatorname{sign}\left(y_{i}-y_{j}\right), f\left(x_{i}\right)-f\left(x_{j}\right)\right)$$listwise loss$$L^{\prime}(F(\mathbf{x}), \mathbf{y})=\exp (-N D C G)$$ Learn To Rankpointwisedocquery pairwisequerydocquery listwisequerydocquery pointwisepairwiseclassificationregressionordinal classificationlistwiseranking listinstancequerydoc Learning to Rank 1) Pointwise: Subset Ranking, McRank, Prank, OC SVM 2) Pairwise: Ranking SVM, RankBoost, RankNet, GBRank, IR SVM, Lambda Rank, LambdaMart 3) Listwise: ListNet, ListMLE, AdaRank, SVM MAP, Soft Rank inference https://www.cnblogs.com/bentuwuying/p/6681943.html]]></content>
      <categories>
        <category>webSearch</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OpenPose: Realtime Multi-Person 2D Pose Estimation using Part Affinity Fields]]></title>
    <url>%2F2020%2F02%2F05%2FOpenPose-Realtime-Multi-Person-2D-Pose-Estimation-using-Part-Affinity-Fields%2F</url>
    <content type="text"><![CDATA[2017CVPRopenposeopenpose two-step bottom-up approachparsing architecture  baseline10VGG-19feature map feature map CNN a set of Part Confidence Maps  a set of Part Affinity Fields (PAFs)  Part Confidence Maps: a set of 2D confidence maps S for body part locations. Each joint location has a map.map2525map Part Affinity Fields (PAFs): a set of 2D vector fields L which encodes the degree of association between parts. parts Finally, the Confidence Maps and Part Affinity Fields are processed by a greedy algorithm to obtain the poses for each person in the image pose confidence maps2D $J$confidence map$$\text { the set } S=\left(S_{1}, S_{2}, \ldots, S_{J}\right) \text { where } S_{j} \in R^{w \times h}, j \in 1 \ldots J$$mapsize Part Affinity FieldsPAFsPAFnoseneckelbow$$\text { the set } L=\left(L_{1}, L_{2}, \ldots, L_{C}\right) \text { where } L_{c} \in R^{w \times h \times 2}, c \in 1 \ldots C$$body part2Djointjoint PAF Multi-Person Parsing using PAFs Step 1: Find all joints locations using the confidence maps. Step 2: Find which joints go together to form limbs (body parts) using the part affinity fields and joints in step 1. Step 3: Associate limbs that belong to the same person and get the final list of human poses. limb PAFs limbwrist_elbow wristelbow peakpeak  PAFs PAFslimb connectionscore scorelong distancemin(0.5*paf_height/limb_dist - 1,0) limblimb connecton candidate limb connection candidate sourcedestinationconnectionlist pytorch implementatongiithubhttps:/github.com/tensorboy/pytorch_Realtime_Multi-Person_Pose_Estimation preference https:/towardsdatascience.com/cvpr-2017-openpose-realtime-multi-person-2d-pose-estimation-using-part-affinity-fields-f2ce18d720e8 https://blog.csdn.net/qq_14845119/article/details/98192997]]></content>
      <categories>
        <category></category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(4)]]></title>
    <url>%2F2020%2F01%2F30%2F%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95-4%2F</url>
    <content type="text"><![CDATA[4  xy$$P\left(\omega_{i} | \mathbf{x}\right)=\frac{p\left(\mathbf{x} | \omega_{i}\right) P\left(\omega_{i}\right)}{p(\mathbf{x})}=\frac{p\left(\mathbf{x} | \omega_{i}\right) P\left(\omega_{i}\right)}{\sum_{i=1}^{c} p\left(\mathbf{x} | \omega_{j}\right) P\left(\omega_{j}\right)}$$     parzenk-nn GMEM  $$p(x)=\frac{1}{\sqrt{2 \pi} \sigma} \exp \left[-\frac{1}{2}\left(\frac{x-\mu}{\sigma}\right)^{2}\right]$$     $$p^{x_i}_i(1-q_i)^{1-x_i}$$  maximum likehoodbayesian estimation   $p(x|w_i,\theta_i)$$\theta$   0 $\mu$  $\sum$       p(x|w) EM bad EM EM  31 6 3 5 2 7 3 5 2 4 D6 D8 D8 D6 D4 D8 D6 D6 D4 D8 D61/3D61/6 hhmhhm          hhm  viterbi algorithm viterbi algorithm 11  forward algorithm forward algorithm  hhm viterbi forward   parzen window parzen window$h_n$ k k1]]></content>
      <categories>
        <category></category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[k(3)]]></title>
    <url>%2F2020%2F01%2F29%2Fk%E8%BF%91%E9%82%BB%E6%B3%95-3%2F</url>
    <content type="text"><![CDATA[ k kkkkk              $L_p$$$L_{p}\left(x_{i}, x_{j}\right)=\left(\sum_{l=1}^{n}\left|x_{i}^{(l)}-x_{j}^{(l)}\right|^{p}\right)^{\frac{1}{p}}$$L1L$$\begin{aligned} L_{2}\left(x_{i}, x_{j}\right) &amp;=\left(\sum_{l=1}^{n}\left|x_{i}^{(l)}-x_{j}^{(l)}\right|^{2}\right)^{\frac{1}{2}} \ L_{1}\left(x_{i}, x_{j}\right) &amp;=\sum_{l=1}^{n}\left|x_{i}^{(l)}-x_{j}^{(l)}\right| \ L_{\infty}\left(x_{i}, x_{j}\right) &amp;=\max _{l}\left|x_{i}^{(l)}-x_{j}^{(l)}\right| \end{aligned}$$k K  approximation error) estimation error)   K  K . K . KD treekkkd tree]]></content>
      <categories>
        <category></category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[(2)]]></title>
    <url>%2F2020%2F01%2F29%2F%E6%84%9F%E7%9F%A5%E6%9C%BA-2%2F</url>
    <content type="text"><![CDATA[ 1-1 +1-1     $$f(x)=\operatorname{sign}(w \cdot x+b)$$wb $$\frac{1}{|w|}\left|w \cdot x_{0}+b\right|$$$$-y_{i}\left(w \cdot x_{i}+b\right)&gt;0$$$$-\frac{1}{|w|} \sum_{x_{i} \in \mathcal{M}} y_{i}\left(w \cdot x_{i}+b\right)$$ wb$$\nabla_{w} L(w, b)=-\sum_{x_{i} \in M} y_{i} x_{i} \quad \nabla_{b} L(w, b)=-\sum_{x_{i}, m} y_{i}$$ $$w \leftarrow w+\eta y_{i} x_{i} \quad b \leftarrow b+\eta y_{i}$$ ]]></content>
      <categories>
        <category></category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[]]></title>
    <url>%2F2020%2F01%2F26%2F%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[     https://github.com/SmirkCao/Lihang  https://www.jiqizhixin.com/articles/2019-11-11-15  https://github.com/fengdu78/lihang-code  $H$:   = ++++ =  +        $P(X,Y)$    $P(Y|X)$  =  +  +      $$R_{\mathrm{exp}}(f)=E_{P}[L(Y, f(X))]=\int_{x \times y} L(y, f(x)) P(x, y) \mathrm{d} x \mathrm{d} y$$$f(x)$$P(X,Y)$$$R_{\mathrm{emp}}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)$$  $$\min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)$$  structure risk minimizationregularizationregularizer penalty term$$R_{\operatorname{srm}}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)+\lambda J(f)$$    $$L(w)=\frac{1}{N} \sum_{i=1}^{N}\left(f\left(x_{i} ; w\right)-y_{i}\right)^{2}+\frac{\lambda}{2}|w|^{2}$$   XYXX  TP true positive FN false negative FP false positive TN true negative $$P = \frac{TP}{TP+FP}$$ $$R = \frac{TP}{TP + FN}$$ F1 $$F_1 = \frac{2TP}{2TP + FP + FN}$$     ]]></content>
      <categories>
        <category></category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cs224N word vector I]]></title>
    <url>%2F2020%2F01%2F09%2Fcs224N-word-vector-I%2F</url>
    <content type="text"><![CDATA[CS224N winter2019 NLPNLP NLPLSTMtransformerNLPNLP NLPNLP word vector  one-hotonehotvocab size10  fix-windowword-embedding word vector2013Mikolov    c cfix-windowc c  mlog p  CBOWskip-gram CBOWContinuous Bag of Words Model, vwhen the word is in the context uwhen the word is in the center onehotsoftmax skip gram modelCBOW onehotfix-windowCBOW xwordvec negative sampling skip-gram  negative sampling   vocabulary 1  ( fox, quick)   fox  one-hot  quick  1 9999  099990 negative word. negative sampling   negative words 10 negative words onehot0  5-20  negative words 2-5 negative words.  negative sampling positive word- quick  10 negative words  11  300 x 11 = 3300  3    3/4 hierarchical softmaxsoftmaxhuffman k,h $O(hlog_2(k))$ wordvecNLPCBOWskip-gramwordvecpostwordvecwordsence]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[20192020]]></title>
    <url>%2F2020%2F01%2F01%2F2019%EF%BC%812020%EF%BC%81%2F</url>
    <content type="text"><![CDATA[2019 20191xuyingying201820182018 2019  201925      8   20192019        2020happy new year! 2019/12/31]]></content>
  </entry>
  <entry>
    <title><![CDATA[GPT]]></title>
    <url>%2F2019%2F12%2F29%2FGPT%2F</url>
    <content type="text"><![CDATA[GPTberttransformerGPT NLPfinetunebert transformer GPTgerneral pre-training transformerGPTtransformer   p(W)  TP(W)$$\begin{aligned}P\left(W_{1}^{T}\right) &amp;=P\left(\mathrm{w}_{1}, w_{2}, \ldots, w_{T}\right) \\&amp;=P\left(w_{1}\right) P\left(w_{2} | w_{1}\right) P\left(w_{3} | w_{1}, w_{2}\right) \ldots P\left(w_{T} | w_{1}, w_{2}, \ldots w_{T-1}\right)\end{aligned}$$P(w)GPT GPT GPT12transformerberttransformertokenpositionembedding12transformerlienarsoftmax$$P\left(y | x^{1}, \ldots, x^{m}\right)=\operatorname{softmax}\left(h_{l}^{m} W_{y}\right)$$$h_l^m$12transformerWlinear$$L_{2}(\mathcal{C})=\sum_{(x, y)} \log P\left(y | x^{1}, \ldots, x^{m}\right)$$GPT GPTfinetunefintune bertbertmask unsupervised learning GPT GPTpretraining For text classification, we can directly fine-tune the model. For textual entailment, we concatenate the premise and hypothesis token sequences, with a delimiter token in between. For similarity tasks, since there is no inherent ordering of the two sentences being compared, the input sequence is modified to contain both possible sentence orderings. Each input sequence is processed independently to produce two sequence representations, which are finally added element-wise before being fed into the linear output layer. For question answering and commonsense reasoning, we are given a context document zz, a question qq, and a set of possible answers akak. We concatenate the document context and question with each possible answer as [start;z;q;delim;ak;extract]. Each of these sequences are processed independently and then normalized via a softmax layer to produce an output distribution over possible answers.  bert GPT-2GPT-2 GPT-1 GPT-2GPT-2transformerGPT-2 GPT-2transformerberttransformerGPT-2auto-regressionTransformerXLXLNetXLNet GPT-2transformerDecoder transformer5121024 GPT-2 GPT-2 transformerGPT-250000 top1topktorch.distribution.categorical.Categorical GPT-2GPT-2 GPT-2 GPT-2word embedding 768 vocab transformertransformertransformer KeyQueryValueKQVKQquerykeysoftmaxV  transformer top-k40topk 1024]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[finetune-]]></title>
    <url>%2F2019%2F12%2F29%2Ffinetune-%E8%AF%97%E5%8F%A5%E7%94%9F%E6%88%90%2F</url>
    <content type="text"><![CDATA[bert language modelfinetunelanguage modelfinetunepostcontinue training pytorch DataLoaderwrapperGPUGPU 1net = nn.DataParallel(net) GPUpytorchGPU 0dataparallelgpugpudataloaderbatch_sizebatchnngpu GPUpytorch torch.utils.parallel.DistributedDataParalleldataloader torch.utils.data.distributed.DistributedSampler dataparallelbatchdistributedSamplerdataloaderload  123456789from torch.utils.data import Dataloader,Datasetfrom torch.utils.data.distributed import DistributedSamplerfrom torch.nn.parallel import DistributedDataParalleldataset = your_dataset()datasample =DistributedSampler(dataset,num_replicas=world_size,rank = rank)dataloader = Dataloader(dataset,batch_size=batch_size_per_gpu,sampler = datasampler)model = your_model()model = DistributedDataParallel(model,device_ids = [local_rank],output_device=local_rank) dataloaderbatch-sizebatch-sizeworld_sizeranklocal_rankDistributedDataParallel 1torch.distributed.init_process_group()   lossinfer loss.backward()  1-2 optimizer.step()optimizer.zero_grad()  batchbatchsize pytorchdataloader pytorchsamplerRandomSamplerdataloadershuffletruedataloadersequentialSamplersamplerdataloader pytorch and apex pytorch pytorchfp16batchnormf32 bnbn apexNVIDIA bert bertBertAdamAdamWFusedAdamBertAdamapexBertAdam bertAdam/AdamW  bertAdam/AdamW bias bert loss function bertMask-LMberttoken maskloss. bertgelu geluGELU  bertC++ bertwhole word marking]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bert]]></title>
    <url>%2F2019%2F12%2F19%2Fbert%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[post Bert bert  finetune   ELMOELMOLSTMLSTMembeddingembedding  finetune GPTbertfinetuneTransformerFine-tuning QA Bert bertencoder-decoderencoderBertencodertransformerdecoderbertdecoderbertdecoderbertbert bert berttransformerberttransformerfinetune]]></content>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pytorch ]]></title>
    <url>%2F2019%2F12%2F09%2Fpytorch-%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[pytorch  pytorch pytorchtorchpythontorchnumpypytorch TensorFlow tensorspytorchnumpyGPUpytorch  torch.floattensor 1234567891011# x = torch.empty(3,3) # 3x3# x = torch.rand(24,24,3dtype = torch.float) # 24x24x3dtype = floatx = torch.zeros(3,3,3) #3x3x3# x = torch.tensor([5.1,1]) # x = x.new_ones(5,4,dtype= torch.double)x = torch.randn_like(x,dtype = torch.float) # xx.size() # tupletensor  1234567891011121314151617181920212223242526272829303132333435#z = x + y#z = x - y# floattensorx.item()# tensorx.view(16) # 1*16x.view(-1,4)# 4x4x.view(-1,2,2)# 2x2x2# tensornumpyx[:10]# cattorch.cat((x,y),dim = 0) # ytorch.cat((x,y),dim = 1) # x# chunkx.chunk(chunks = 3,dim = 0) # yx.chunk(chunks = 3,dim = 1) # x# x.clamp(0.3,0.7) # x.sort(dim = 0) # xx.flatten() # # topKx.topk(2,dim=0) #  x.numel()#torch.stack((x,y), dim = 0/1) # x.permute(2,0,1) # x.squeeze(dim = 1) # 1x.unsqueeze(dim = 0) # 1x.cuda() # GPUtorch.where(x&gt;0,x,y) # x&gt;0 xyx.round() # x.contiguous() #  x.numpy() # numpyx = torch.from_numpy(a) # numpytensor pytorchautogradpytorchautogradtensortensorrequires_gradtruepytorchtensorbackward() detach()with torch.no_grad()grad_fnFunction 123456789x = torch.ones(2,2,requires_grad = True)"""x = tensor([[1,1], [1,1]],requires_grad = True)"""y = x + 2"""y = tensor([[3,3],[3,3]],grad_fn = &lt;AddBackward0&gt;)""" torch.nnnn.Module,forward()    loss   123456789101112131415161718192021222324252627class net(nn.Module): def __init__(self): super(net,self).__init__() #  . def forward(self,x): # x  .nets = net()print(nets) # netnet.parameters() # netnet.zero_grad() # output = nets(input)target = torch.rand(10)target = target.view(1,-1)criterion = nn.MSELoss() # loss# import torch.optim as optimoptimizer = optim.SGD(net.parameters(),lr = 0.01)optimizer.zero_grad()output = nets(input)loss = criterion(output,target)loss.backward()optimizer.step()  pillowopencv scipylibrosa pythonNTLKSpaCy GPU GPU 1234device = torch.device('cuda:0,1,2,3' if torch.cuda.is_available() else 'cpu')net.to(device)# gpuinputs,labels = inputs.to(device),labels.to(devices) pytorchGPUDataParallel()GPU 12import torch.nn as nnmodel = DataParallel(model) GPUDataParallel github  123456789101112import torchimport torch.nn as nnfrom torch.utils.data import Dataset,DataLoaderclass own_dataset(Dataset): def __init__(self,data): self.data = data def __getitem__(self,index): return self.data[index] def __len__(self): return len(self.data)data_loader = DataLoader(own_dataset,batch_size = 4,num_works = 2,shuffle = True) Dataset__getitem__()__len__() dataLoadermodelbatch_size DataLoader 123456789import torch.utils.data as Datax = torch.rand(10,10)y = torch.rand(10,1)# datasetdatas = Data.TensorDataset(x ,y)lloader = DataLoader(datas,batch_size=4,shuffle=True)for data_x,data_y in lloader: print(data_x,data_y) break python pytorch   123456789101112131415161718# save torch.save(model.state_dict(),'my_resnet.pth')resnet = ResNet()resnet.load_state_dict(torch.load('my_resnet.pth'))# save torch.save(model,'my_resnet.pth')resnet = torch.load('my_resnet.pth')# checkpointtorch.save(&#123; 'epoch':epoch, 'model_state_dict':model.state_dict(), 'optimizer_state_dict':optimizer.state_dict(), 'loss':loss, .&#125;, PATH)# DataParalleltorch.save(model.module.state_dict(),PATH)   12345pretrain = model_zoo.load_url(model_urls['resnet152'])model_dict = model.state_dict()pretrain = &#123;k:v for k,v in pretrain.items() if k in model_dict&#125;model_dict.update(pretrain)model.load_state_dict(model_dict) batch123456789101112131415import torch.nn.utils.rnn as rnn_utilsfrom torch import nnfrom torch.utils.data import DataLoaderimport torch.utils.data as datatrain = [tensor([1,1,1,1,1,1,1]),tensor([3,3,3,3,3]),tensor([6,6])]# train 0x = rnn_utils.pad_sequence(train, batch_first=True)# pack# # data=tensor([1., 3., 6., 1., 3., 6., 1., 3., 1., 3., 1., 3., 1., 1.]),# batch_sizes=tensor([3, 3, 2, 2, 2, 1, 1]))x = rnn_utils.pack_padded_sequence(x,[7,5,2],batch_first = True)# 0tensorx = rnn_utils.pad_packed_sequence(x,batch_first = True) pytorch 12345import torch.nn as nn # nn.Linear() from torch.utils.data import Dataset,DataLoader # import torch.nn.functional as F # import torch.optim as optim # import torch.nn.utils.rnn as rnn # rnn  123456789101112131415import torch.nn as nn# # embed = nn.embedding(n_vocabulary,embedding_size) ## embeddingyxdef word2vec(input_seq): # input_seqbatch #  # nn.utils.rnn.pad_sequence(x,batch_first = True) words = nn.utils.rnn.pad_sequence(x,batch_first = True) # batchnseq*batch words = word.T embed_word = embed(words) #  #  x = rnn_utils.pack_padded_sequence(x,lengths = [7,5,2],batch_first = True) encoderdecoder Encoderdecoder encoderdecoderLSTMGRU encoder: 12345678910111213141516171819202122# encoder"""encoderinput_seq*batch-size"""class EncoderRNN(nn.Module): def __init__(self,hidden_size,embedding,n_layers=1,dropout=0): super(EncoderRNN,self).__init__() self.n_layers = n_layers self.hidden_size = hidden_size self.embedding = embedding self.gru = nn.GRU(hidden_size,hidden_size,n_layers,droput=(0 if n_layers==1 else dropout),bidirectional=True) def forward(self,input_seq,input_lengths,hidden=None): embedded = self.embedding(input_seq) #  packed = nn.utils.rnn.pack_paded_sequence(embedding,input_lengths)#  # outputhidden outputs,hidden = self.gru(packed,hidden) # tensor outputs,_ = nn.utils.rnn.pad_packed_sequence(outputs) #  outputs = outputs[:,:,:self.hidden_size] + output[:,:,:self.hidden_size] return outputs,hidden GRU 123456gru = torch.nn.GRU(input_size,hidden_size,n_layers)# input_sizehidden_sizeRNN# n_layersGRU# GRU# GRUpack# GRUhidden  $h_s$GRU$h_t$GRU  linear linearoutputlinearhidden hiddenoutputshapehiddenoutputlineartanhhidden_shapevaluetanh softmaxoutputdecoder attention 12345678910111213class atten(nn.Moudle): def __init__(self,hidden_size): super(atten,self).__init__() self.fc = linear(hidden_size*2,hidden_size) self.v = nn.Parameter(torch.FloatTensor(hidden_size)) def forward(self,hidden,encoder_output): x = torch.cat((hidden.expand(encoder_output.size(0),-1,-1), encoder_output),2) x = self.fc(x) # shape = [hidden_size,hidden] x = F.tanh(x) x = torch.sum(self.v * x,dim = 2) x = F.softmax(x.T,dim = 1).unsqueze(1) return x softmax decoderencoderhidden-state&lt;SOS&gt;decoderword2vecencoderdecoderoutputtargetloss decoderdecoder 1234567891011121314151617181920212223242526272829# decoder class decoder(nn.Module): def __init__(self,embedding,hidden_size,n_layers = 1,dropout=0.1): super(decoder,self).__init__() self.hidden_size = hidden_size # encoder,decoder self.n_layers = n_layers self.dropout = dropout # decoder self.embedding = embedding self.embedding_dropout = nn.Dropout(dropout) self.gru = nn.GRU(hidden_size,hidden_size,n_layers,dropout) self.fc1 = nn.Linear(hidden_size*2,hidden_size) self.fc2 = nn.Linear(hidden_size,hidden_size) self.attn = atten(hidden_size) def forward(self,inputs,last_hidden,encoder_output): embedd = self.embedding(inputs) embedd = self.embedding_dropout(embedd) # GRU rnn_output,hidden = self.gru(embedd,last_hidden) # rnn_outputattention attention = self.attn(rnn_output,encoder_output) x = torch.cat((rnn_output,attention),1) x = self.fc1(x) x = torch.tanh(x) x = self.fc2(x) x = F.softmax(x,dim = 1) return output,hidden #  encoderdecoder 1234encoder_outputs, encoder_hidden = encoder(input_variable, lengths)attens = atten(encoder_hidden,encoder_output)encoder_outputs = encoder_outputs*attensdecoder_output,decoder_hidden = decoder(inputs,encoder_outputs,encoder_hidden)  maskNLLLoss binary maskmask tensor1 123456def maskNLLLoss(inp, target, mask): nTotal = mask.sum() crossEntropy = -torch.log(torch.gather(inp, 1, target.view(-1, 1)).squeeze(1)) loss = crossEntropy.masked_select(mask).mean() loss = loss.to(device) return loss, nTotal.item() githubhttps://github.com/WenHui-Zhou/NLP_pratice/blob/master/pytorh_review.ipynb inference https://www.cnblogs.com/duye/p/10590146.html https://plmsmile.github.io/2017/10/12/Attention-based-NMT/ http://www.nlpuser.com/pytorch/2018/11/04/Attention-In-TextClassification/]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[NLP ]]></title>
    <url>%2F2019%2F12%2F05%2FNLP%E5%AE%9E%E8%B7%B5-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E7%9A%84%E6%96%87%E6%9C%AC%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[       baselineSiameseCNNtextAtextBcosineL1 textAtextBfeatureA-BA*BMLP   Network1Network2QA    0/1  rank pointwise-learningpairwise-learninglistwise-learning     ABABBABBAB 3-way classification  query-titlequery-documentrerankrankingselection   simaeseattentionBERT  encoder attention attention  attentionattentionRNNencoder-decoderattentionsoft attentionx attentionBahdanau attention  attention source functionfocus $$\begin{equation}e_{i j}=a\left(c, y_{i}\right)=v_{a}^{T} \tanh \left(W_{a} c+U_{a} y_{i}\right)\end{equation}$$ alignment functionattention weightsoftmax $$\begin{equation}\alpha_{i j}=\frac{\exp \left(e_{i j}\right)}{\sum_{k=1}^{T_{x}} \exp \left(e_{i k}\right)}\end{equation}$$ generate context vector function: attention weight $$\begin{equation}z_{i}=\sum_{i} \alpha_{i j} * y_{i}\end{equation}$$ attentionseq2seq seq2seqattention keyquerysotfmaxvalueattention value https://nlp.stanford.edu/projets/snli/ SNLI1.0570000 (premise)(hypothesis) entailment)  ph contradiction  ph neutral  ph       inferencehttps://www.jiqizhixin.com/articles/2019-10-18-14]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[NLP ]]></title>
    <url>%2F2019%2F12%2F02%2FNLP%E5%AE%9E%E8%B7%B5-%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[NLPNLP nlptokentokenizetokenizer token tokenize tokenizer $$X = {(x^1 , y^1 ),(x^2,y^2)    , (x^N , y^N )}$$$ x_i $$ y_i $$$f(x_i) \to y_i$$    N  N (N-gram ),, N , N1N 2,,N 3, ,:{, ,,,}, 2  N , N , ,,,,N  3 ,, k  $$ \hat y =sign((f(z))) = sign(\theta^Tz+\theta_0) $$ signf(z) $$ f(z)  \theta^Tz+\theta_0 = \sum_{i=1}^{k}\theta_iz_i + \theta_0 = \sum_{i=0}^{k} = \hat \theta^T \hat z $$ $z_0=1$,$\hat\theta,\hat z$ $$ \hat z = \left( \begin{array} {ccc} 1 z_1 . . z_k \end{array} \right) = \left( \begin{array}{ccc} 1 z \\end{array} \right) $$ $$ \hat \theta = \left( \begin{array} {ccc} \theta_0 \theta_1 . . \theta_k \end{array} \right) = \left( \begin{array}{ccc} \theta_0 \theta \\end{array} \right) $$ ,, $ , z$    C , C  y , y , $$ \hat y = \mathop{argmax}_yf(\phi(x,y),\theta)$$ $\phi(x,y)$xy$\theta=[\theta_1;\theta_2;\theta_C]$$\phi(x,y)$ $f(\phi,\theta)$argmax y$\theta$ https://www.kaggle.com/c/sentiment-analysis-on-movie-reviews train.tsvtest.tsvtsvtab idid 0 - negative 1 - somewhat negative 2 - neutral 3 - somewhat positive 4 - positive  nltk beautifulsoup nlp bs4  pyenchant stemminglemmatizationstemmingnltk  12345678910111213141516171819# html# # tokenize# lemmatizedef clean_sentences(df): reviews = [] for sent in tqdm(df['Phrase']): review_text = BeautifulSoup(sent).get_text() # html review_text = re.sub('[^a-zA-Z]',' ',review_text) #  # tokenize the sentences words = word_tokenize(review_text.lower()) #  lemma_words = [lemmatizer.lemmatize(i) for i in words] #  reviews.append(lemma_words) return reviews# clear the datatrain_sentences = clean_sentences(train)test_sentences = clean_sentences(test)print(len(train_sentences))print(len(test_sentences)) htmllist 5keras.utilsto_categoricaltargetone-hot 1234# one-hottarget = train.Sentiment.valuesy_target = to_categorical(target)num_classes = y_target.shape[1] sklearn 12# split the data into train and valx_train,x_val,y_train,y_val = train_test_split(train_sentences,y_target,test_size = 0.2,stratify=y_target) token 123456789# unique_wordsunique_words = set()len_max = 0for sent in tqdm(x_train): unique_words.update(sent) if(len_max &lt; len(sent)): len_max = len(sent)print(len(list(unique_words)))print(len_max) kerastokentokenembeddingword2vec 12345678910111213# tokenizertokenizer = Tokenizer(num_words = len(list(unique_words)))tokenizer.fit_on_texts(list(x_train)) # tokenizer# tokenizer.word_count keyval# tokenizer.word_index ,keyval# x_train = tokenizer.texts_to_sequences(x_train)x_val = tokenizer.texts_to_sequences(x_val)x_test = tokenizer.texts_to_sequences(test_sentences)# pad0x_train = sequence.pad_sequences(x_train,maxlen=len_max)x_val = sequence.pad_sequences(x_val,maxlen=len_max)x_test = sequence.pad_sequences(x_test,maxlen=len_max)  12345678910111213141516# early stopearly_stopping = EarlyStopping(min_delta=0.001,mode ='max',monitor='val_acc',patience = 2)callback = [early_stopping]# kerasmodel = Sequential()# embedding(input_dim(),output_dim(vector)input_length())# sequencesword2vecvector128300model.add(Embedding(len(list(unique_words)),300,input_length=len_max))# embedding word2vec# LSTM return_sequences=trueFalseLSTMmodel.add(LSTM(128,dropout=0.5,recurrent_dropout=0.5,return_sequences=True))model.add(LSTM(64,dropout=0.5,recurrent_dropout=0.5,return_sequences=False))model.add(Dense(100,activation='relu'))model.add(Dropout(0.5))model.add(Dense(num_classes,activation = 'softmax'))model.compile(loss = 'categorical_crossentropy',optimizer=Adam(lr = 0.005),metrics=['accuracy'])model.summary()  embedding skip-gramsoftmax  12# history = model.fit(x_train,y_train,validation_data,(x_val,y_val),epochs=6,batch_size = 256,verbose=1,callbacks=callback)   12345678910import matplotlib.pyplot as plt%matplotlib inlineepoch_count = range(1,len(history.history['loss']) + 1)plt.plot(epoch_count,history.history['loss'],'r--')plt.plot(epoch_count,history.history['val_loss'],'b--')plt.legend(['Training loss','validation loss'])plt.xlabel('epoch')plt.ylabel('loss')plt.show()  12345# submissiony_pred = model.predict_classes(x_test)sub_file = pd.read_csv(os.path.join(root,'sampleSubmission.csv'),sep=',')sub_file.Sentiment = y_predsub_file.to_csv('submission.csv',index = False)  0 word2vecembeddingkeras.layers.embeddingembeddingembeding  RNN LSTMcvCNNtransform RNN $\hat{h}$hxRNNy$\hat{h}$softmaxWRNNDNN LSTM LSTMCLSTMhLSTMLSTM GRU Gate Recurrent UnitLSTMGRULSTMGRU  GRU1-zGRU nlpcvtokenizeword2veccv  https://github.com/WenHui-Zhou/NLP_pratice/tree/master/text_classification inferencehttps://www.kaggle.com/chiranjeevbit/movie-review-prediction]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[]]></title>
    <url>%2F2019%2F12%2F02%2F%E5%9B%BE%E5%83%8F%E7%9A%84%E5%8E%BB%E5%99%AA%2F</url>
    <content type="text"><![CDATA[  1 CCDCMOS 2           ,      Noise2Noise: Learning Image Restoration without Clean Data ICML 2018 Noise2Noise: Learning Image Restoration without Clean Data GT  y1,y2,)z$$argminzy{L(z,y)}\arg\min_z \mathbb{E}_y{L(z,y)}$$L2 $L(z,y)=(z-y)^2$ ()$$z=\mathbb{E}_y{y}$$L1,$L(z,y)=|z-y|$$$z=median{y}$$L0 ,$L(z,y)=|z-y|_0$ $$z=mode{y}$$-$(x_i,y_i)$$$\arg\min_\theta\mathbb{E}_{(x,y)}{L(f_(x),y)}$$thetaxyLossGT L2 loss0000GT0GT  0labelclearGT0 MRTMRT0  Guassian Noisepossion noisemonte Carlo renderingMRT0 inference  https://www.voidking.com/dev-gp-image-denoise/]]></content>
      <categories>
        <category>3D</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[NLPfinetune:GPTBert]]></title>
    <url>%2F2019%2F12%2F01%2FNLP%E6%A8%A1%E5%9E%8Bfinetune-GPT%E5%88%B0Bert%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[NLPELMO fine tuningGPT word embedding to GPTGPT GPTGenerative Pre-Trainingfine tuneELMOELMO ELMOword embeddingword embedding GPTELMO GPTtransformerELMOLSTM GPTGPTELMO  GPTGPTGPTGPT  fine tunecv  GPT  GPT  GPTBert Bert bertGPTtransformerELMObert Bert transformerCBOW  Masked15%[Mask][mask][mask]Bert15%[mask]80%[mask]10%10%Masked BertNLPNLP]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[NLPtransformer]]></title>
    <url>%2F2019%2F11%2F29%2FNLP%E4%B9%8Btransformer%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[NLP      NLP NLP        NLP RNNRNNNLPLSTMRNN RNNNLP RNNLSTMRNNNLPRNNNLP RNNRNN RNNRNNTT-1S(T-1)RNNRNNTT-1 CNNtransformers RNN CNN2014CNNNLP  dilated CNNpoolingpooling CNN CNN1-Dskip-connectiondilatedCNNnlpCNN transformerTransformerRNNself-attentionTransformerDNNtransformer NLP  X = [Hello, ,, how, are, you, ?] (Input sequence)Y = [Hola, ,, como, estas, ?] (Target sequence) transformerencoderdecoderencodertargettarget transformertransformerencoderdecoderski-connectionlayerNormFF  encoderdecoder encoder decoderseq2seq decoderdecodernlp  BERT512* * Nencoder*  batchpadding [, , , Hello, , , how, are, you, ?]  [5, 5, 5, 34, 90, 15, 684, 55, 193]  iyjemb-dim  encoder block encoder multi-head attention multi-head attentionh headQKVembedding  $$\begin{equation}\text { Attention }(Q, K, V)=\operatorname{softmax}\left(\frac{Q K^{T}}{\sqrt{d_{k}}}\right) V\end{equation}$$ multi-headXhheadhZ: Z$W^0$ *   Free ForwardReLU$$\begin{equation}\mathrm{FFN}(x)=\max \left(0, x W_{1}+b_{1}\right) W_{2}+b_{2}\end{equation}$$W1W2maxReLUb2decoderdecoderdecoder DecoderDecoderdecoderencoder to decoderdecoder encoderdecoder decoderencoderDecoder  target target* NDecoderdecoder target* decodersoftmax*  inputtargettarget [Hola, , , como, ests, ?][, Hola, , , como, ests, ?] train vs test traintestdecoder testgroundTruth trainGTtargettesttargettargettargettarget Decodertargetests mask multi-head attentionoutput mask multi-head attention encodermulti-head attention target*mask multi head mask  Encoder to decoder encoder to decoderdecoderencoder decoderQKVembedding QdecoderKVencoder encoderattention$$\begin{equation}\text { Attention }(Q, K, V)=\operatorname{softmax}\left(\frac{Q K^{T}}{\sqrt{d_{k}}}\right) V\end{equation}$$encoderhhead$W^0$decoder linear and softmax decoderN target*linear$$\begin{equation}x W_{1}\end{equation}$$softmax sshello encoderdecodertransformer  inference https://medium.com/dissecting-bert/dissecting-bert-appendix-the-decoder-3b86f66b0e5f https://jalammar.github.io/illustrated-transformer/ https://zhuanlan.zhihu.com/p/54356280 https://zhuanlan.zhihu.com/p/54743941 https://medium.com/dissecting-bert/dissecting-bert-part-1-d3c3d495cdb3]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[NLPWord2Vec]]></title>
    <url>%2F2019%2F11%2F29%2FNLP%E4%B9%8BWord2Vec%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[NLP     NLP NLP  word2vecNLP word2vecWord2vecword2vec word2vec  word2vec p one-hotword2vec one-hotVV10one-hot  Bengio 2003JMLR2013 $$\begin{equation}\left.P\left(W_{t}=\operatorname{Bert} | W_{1}, W_{2}, \ldots W_{(} t-1\right) ; \theta\right)\end{equation}$$Bertt-1Bertone-hotQword embedding Qword2vecVvectorQQQ word2vec CBOW skip-gram ELMOword2vecword2vecnlpbankQ ELMO ELMOWord EmbeddingWord EmbeddingWord EmbeddingWord Embedding ELMO word embedding word embedding word embeddingLSTM   vectorEMLOword2vec ELMO LSTMtransformer  transformer inferencehttps://zhuanlan.zhihu.com/p/49271699]]></content>
      <categories>
        <category>NLP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[effective cpp()]]></title>
    <url>%2F2019%2F11%2F26%2Feffective-cpp-%E4%B9%9D-%E6%9D%82%E9%A1%B9%E8%AE%A8%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[2019/11/26 effective cpp    C++boostC++ 53  54 TR1 55 Boost 53 warning warning    54 TR1C++standardC++ STL  Iostream   C89  C++TR1  C++STLiostreamslocatesC99 TR1hash-based10 TR1 55 BoostBoosthttp://boost.org  BoostC++BoostC++ BoostTR1 STLC++9]]></content>
      <categories>
        <category>effective cpp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[effective cpp()newdelete]]></title>
    <url>%2F2019%2F11%2F25%2Feffective-cpp-%E5%85%AB-%E5%AE%9A%E5%88%B6new%E5%92%8Cdelete%2F</url>
    <content type="text"><![CDATA[2019/11/25 effective cpp 8 newdelete C++C++ 49 new-handler 50 newdelete 51 newdelete 52 placement newplacement delete 49 new-handleroperator newoperator newnew-handlerset_new_handler&lt;new&gt; 1234namespace std&#123; typedef void (*new_handler)(); new_handler set_new_handler(new_handler p) throw();&#125; new_handlertypedefset_new_handler Set_new_handler 12345678910void outOfMem()&#123; std::cerr &lt;&lt; "unable doing something"; std::abort;&#125;int main()&#123; std::set_new_handler(outOfMem); int* pBig = new int[12323232333333]; // newoutOfMem&#125; new-handler handler new-handlernew-handlerhandler new-handlernullset_new_handlernew-handleroperator new bad_allocoperator new abortexit  set_new_handler Nothrow new 50 newdeletenewdelete      classnewdelete         newdeleteheapheap 51 newdeleteoperator newoperator newnew-handlingnew operator newbad-allocoperatornew-handlingnew-handlingnull operator new[]array operator delete null  operator newnew-handler0byteclass   operator deletenullclass  52 placement newplacement deleteplacement newplacement delete 1widget* pw = new widget; newwidgetdefaultnewnewC++ newdeletedelete newnewdelete base classnewdeleteusing  placement operator newplacement operator delete placement newplacement delete ]]></content>
      <categories>
        <category>effective cpp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[effective cpp() ]]></title>
    <url>%2F2019%2F11%2F19%2Feffective-cpp-%E4%B8%83-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E8%8C%83%E5%9E%8B%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[2019/11/19 effective cpp   C++ templatevectorlistmaptemplatetemplate template 41  42 typename 43  44 template 45  46  47 traits classes 48 template 41   widgetvirtualww template 12345678template&lt;typename T&gt;void doProcessing(T&amp; w)&#123; if (w.size() &gt; 10 &amp;&amp; w!= someWidget)&#123; T temp(w); temp.normalize(); ... &#125;&#125; Tsize(),normalize()  123456class widget&#123; widget(); virtual ~widget(); virtual void normalize(); ...&#125;  Tsizeoperationsize()operator&gt;  classestemplates classvirtual templatetemplate 42 typenametemplateclasstypename 12template&lt;class T&gt; class widget;template&lt;typename T&gt; class widget;  template templatetemplateC::iteratorC inttemplate typename 1234template&lt;typename T&gt;void func(const C&amp; container)&#123; C::const_iterator*x;&#125; C::const_iteratorlocal C++C++ typename 1234template&lt;typename C&gt;void func(const C&amp; container)&#123; typename C::cosnt_iterator iter(container.begin());&#125; typename 123template&lt;typename C&gt;void f(const C&amp; container, // typename typename C::iterator iter); // typename typename base class list mem init list typedeftypedef typename 1typedef typename std::iterator_traits&lt;iterT&gt;::value_type value_type;  templateclasstypename typenamebase class listsmem init listbase class 43 template 123456789template&lt;typename company&gt;class Loggin:public MsgSender&lt;company&gt;&#123; public: void sendClearMSG(const MsgSender&lt;Company&gt;)&#123; // do something sendClear(info); // sendClear // do something &#125;&#125; classtemplateMsgSender&lt;company&gt;classclasssendClear  base classthis-&gt; 123456789template&lt;typename company&gt;class Loggin:public MsgSender&lt;company&gt;&#123; public: void sendClearMSG(const MsgSender&lt;Company&gt;)&#123; // do something this-&gt;sendClear(info); // sendClear // do something &#125;&#125; using 12345678910template&lt;typename company&gt;class Loggin:public MsgSender&lt;company&gt;&#123; public: void sendClearMSG(const MsgSender&lt;Company&gt;)&#123; // do something using MsgSender&lt;company&gt;::sendClear; sendClear(info); // sendClear // do something &#125;&#125; base class 123456789template&lt;typename company&gt;class Loggin:public MsgSender&lt;company&gt;&#123; public: void sendClearMSG(const MsgSender&lt;Company&gt;)&#123; // do something MsgSender::sendClear(info); // sendClear // do something &#125;&#125; templatethis  derived class templatesthis-&gt;base class templatebase classusing  44 templatetemplate vectorlist  templateclasstemplatetemplate classtemplate  45 STLtemplate base-derivedtemplatebase-derived template 123456template&lt;typename T&gt;class SmartPtr&#123; public: template&lt;typename U&gt; SmartPtr(const SmartPtr&lt;U&gt;&amp; other); // ut&#125;; ututtemplatecopyUT  123456789template&lt;typename T&gt;class SmartPtr&#123; public: template&lt;typename U&gt; SmartPtr(const SmartPtr&lt;U&gt;&amp; other) :heldPtr(other.get())&#123;...&#125; // ut private: T* heldPtr;&#125;;  UT* copycopycopy  member function templatesu-&gt;t member templatescopyassignmentcopycopy assignmentcopy 46 template 123template&lt;typename T&gt;const Rational&lt;T&gt; operator* (const Rational&lt;T&gt;&amp; lhs,const Rational&lt;T&gt;&amp; rhs)&#123;...&#125;  1Rational&lt;int&gt; result = onehalf*2; templateRational&lt;T&gt;T2C++Tint Rational&lt;T&gt;class Rationalfriend 12345template&lt;typename T&gt;class Rational&#123; public: friend Rational operator*(const rational&amp; lhs,const&amp; rhs);&#125; template Rational  class templatetemplateclass templatefriend 47 traits classestraitsC++traittemplate 12template&lt;typename TT&gt;struct iterator_traits; traits   template traits trait trait  traits classtemplatetemplates trait classif  else  48 templatetemplate metaprogrammingtemplate-based c++   TMP  it is a little difficult for me,but never mind !]]></content>
      <categories>
        <category>effective cpp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[effective cpp() ]]></title>
    <url>%2F2019%2F11%2F16%2Feffective-cpp-%E5%85%AD-%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[2019/11/16 effective cpp   C++ 32 publicis-a 33  34  35 virtual 36 non-virtual 37  38 has-a 39 private 40  32 publicis-a publicis-apublic DpublicBBDDBBDDB 12class Person&#123;...&#125;;class student:public Person&#123;...&#125;; personstudent  publicis-abase classesderived class derived classes base classes 33 local derived classbase classderived classesbase classbase class  1234567891011121314class base&#123; private: int x; public: virtual void mf1() = 0; virtual void mf2(); void mf3(); ...&#125;;class Derived::public Base&#123; public: virtual void mf1(); boid mf4();&#125;; publicprivatepure virtualvirtualnon-virtualmf4 12345void Derived::mf4()&#123; ... mf2(); ...&#125; mf2mf2localbaseglobal  12345678910111213141516class base&#123; private: int x; public: virtual void mf1() = 0; virtual void mf1(int); virtual void mf2(); void mf3(); void mf3(double); ...&#125;;class Derived::public Base&#123; public: virtual void mf1(); void mf3();&#125;; mf1mf3base classmf1mf3 12345Derived d;d.mf1(); //d.mf1(x); // mf1d.mf3(); // d.mf3(x); //  using 123456class Derived:public Base&#123; using Base::mf1; using Base::mf3; void mf1(); void mf3();&#125; usingd.mf3(x)d.mf3(x) base classusing inline 123456class Derived:private Base&#123; public: virtual void mf1()&#123; //  Base::mf1(); // inline &#125;&#125;  base classespublic using  34  pure virtual impure virtual non-virtual  pure virtualclassclass 12345class shape&#123; public: virtual void draw() const = 0; ...&#125; pure virtualderived classes shape::drawshapedrawshape pure virtualclasspure virtual 1234shape* ps = new shape;shape* ps1 = new Rectangle;ps1-&gt;draw(); // Rectangledrawps1-&gt;shape::draw(); // draw impure virtualderived classes 12345class shape&#123; public: virtual void error(const string&amp; msg); ...&#125; classclass  12345678910class Airplane&#123; public: virtual void fly(cosnt sAirport&amp; destination) = 0; ... protected: void defaultFly(cosnt Ariport&amp; destination);&#125;;void Airplane::defaultFly(const Airport&amp; destination)&#123; //fly&#125; flyimpurepuredefaultFlyflydefaultFly   123456789101112131415class Airplane&#123; public: virtual void fly(cosnt Airport&amp; destination) = 0;&#125;;void Airplane::fly(cosnt Airport&amp; destination)&#123; //&#125;class ModelA:public Airplane&#123; public: virtual void fly(const Airport&amp; destination)&#123; Airplane::fly(destination); //  &#125;&#125;// fly defaultFlyfly non-virtualderived classes non-virtualnon-virtual  publicderived classesbase class pure virtual  non-virtual 35 virtualvirtual template method publicnon-virtualprivatevirtual 12345678910111213class GameCharacter&#123; public: int healthValue() const&#123; ... //  int retval = dohealthValue(); ... //  return retval; &#125; private: virtual int dohealthValue() const&#123; ... &#125;&#125;; public non-virtualprivate virtualNVI non-virtual interfacenon-virtualprivate virtual Function Pointersstrategy   12345int defaultHealth(const GameCharacter&amp; gc);//return_types (*func_pointer)( data_types arg1, data_types arg2, ..);int (*defaultHealth)(const GameCharacter&amp;);//defaultHealth public tr1::functionstrategy C++ Technical Report 1 TR1ISO/IEC TR 19768, C++ Library ExtensionsTR1C++ function std::function lambda c++11 functionbind C++(function signature) functionfunction 12345678910class GameCharacter&#123; public: typedef std::str1::function&lt;int (const GameCharacter&amp;)&gt; healthCalFunc; explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc):healthFunc(hfc)&#123;&#125; int healthValue() const&#123; return healthFunc(*this); &#125; private: HealthCalcFunc healthFunc;&#125; const reference strategy strategyvirtual  virtual non-virtual interfacetemplate methodpublic non-virtualvirtual virtualstrategy tr1::functionvirtual virtualvirtualstrategy  virtual NVIstrategyNVItemplate method classclassnon-public tr1::function 36 non-virtualnon-virtual  non-virtual 37 virtual virtual 1234567891011121314151617181920class Shape&#123;public: enum shapecolor&#123;red,green,blue&#125;; virtual void draw(shapecolor color = red) const = 0;&#125;;class rectangle:public Shape&#123;public: virtual void draw(shapecolor color = green) const;&#125;;void rectangle::draw(Shape::shapecolor color) const &#123; cout &lt;&lt; "---"; cout &lt;&lt; color; cout &lt;&lt; "---";&#125;Shape *ps = new rectangle();rectangle* rec = new rectangle();ps-&gt;draw(); // shaperec-&gt;draw(); // rectangle NVInon-virtualvirtual 12345678910111213141516class Shape&#123;public: enum shapecolor&#123;red,green,blue&#125;; void draw(shapecolor color = red)&#123; doDraw(color); &#125;private: virtual void doDraw(shapecolor color) const = 0;&#125;;class rectangle:public shape&#123; public: ... private: virtual void doDraw(shapecolor color) const; // &#125; non-virtual  virtual ###38 has-a has-acomposition 1234567class Person&#123; ... private: Address ad; //  string name; PhoneNumber num;&#125;  is-implemented-in-terms-of setsetlistlistlistsetis-alistset  public is-a 39 privateprivateis-a implemented-in-terms-of privatederived classbase classprotectedvirtualprivateprivate private private virtualEBOprivate  private protected base classcirtual privateempty base 40  virtualvirtualC++virtual  virtual basesnon-virtual virtual base   virtual virtualvirtual base classes publicinterface classprivateclass]]></content>
      <categories>
        <category>effective cpp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[effective cpp() ]]></title>
    <url>%2F2019%2F11%2F10%2Feffective-cpp-%E4%BA%94-%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[2019/11/10effective cpp  cpp 26  27  28 handles 29  30 inlining  31  26      27 C++ C++C++ const_cast&lt;T&gt; (expression) dynamic_cast&lt;T&gt;(expression) reinterpret_cast&lt;T&gt;(expression)point to int int static_cast&lt;T&gt;(expression)intdouble  (T)expression T(expression) ,const_cast dynamic_cast 1234567class special: public window&#123; public: virtual void onResize()&#123; static_cast&lt;window&gt;(*this).onResize(); ... &#125;&#125; thiswindowthisbase classwindowonsizethisonsize 1234567class special: public window&#123; public: virtual void onResize()&#123; window::onResize(); ... &#125;&#125; dynamic_castbase class 1234567typedef vector&lt;tr1::shared_ptr&lt;window&gt;&gt; vpw;vpw winptr;... for(vpw::iterator iter=winptr.begin();iter!=winptr.end();++iter)&#123; if(special* psw=dynamic_cast&lt;special*&gt;(iter-&gt;get())) psw-&gt;blink(); &#125;  123456typedef vector&lt;tr1::shared_ptr&lt;special&gt;&gt; vpsw;vpsw winptr;...for(vpsw::iterator iter = winptr.begin();iter!=winptr.end();++iter)&#123; (*iter)-&gt;blink();&#125; base classblink virtualdynamic_cast  dynamic_cast  dynamic_cast  C++ 28 handleshandlesreferencehandle  1234567891011121314151617181920class point&#123; public: point(int x,int y); ... void setX(int val); void setY(int val);&#125;;//struct RectData&#123; point ulhc; point lrhc;&#125;;//class Rectangle&#123; ... private: tr1::shared_ptr&lt;RectData&gt; pData; public: point&amp; upper() const &#123;return pData-&gt;ulhc;&#125;&#125; upperconstprivate 12const Rectangle rec(coord1,coord2);rec.upper().setX(50); //  reference constreference const 1const Point&amp; upperLeft() const &#123;return pData-&gt;ulhc;&#125; handlehandledangling handles handles  handlesconstconsthandles 29         1int doSomething() throw();   copy and swap 12345678void pretty::changeBackground(istream&amp; imgSrc)&#123; using std::swap; Lock ml(&amp;mutex); // mutex tr1::shared_ptr&lt;PMImpl&gt; pNew(new PMImpl(*pImpl)); pNew-&gt;bgImage.reset(new Image(imgSrc)); ++pNew-&gt;imageChanges; swap(pImpl,pNew); // mutex&#125;     copy and swap  30 inlining inlineinline inline inlineinlining inlineclassinlineinline inlineinline templatestemplatesinlinetemplatesinlineinline inline inlineinline virtualoutline inlininginlineoutline 1234inline void f() &#123;...&#125; //inlinefvoid (*f)() = f;f(); // inlinepf(); // outline  inlineC++ inline inline inlineinline  inlining inlinefunction templatesinlineinlineoutline 31  class  1234567891011121314#include&lt;string&gt;#include "data.h"#include "address.h"class Person&#123; public: Person(const string&amp; name,const Date&amp; birthday); string name() const; string birthday(); private: string thename; Data theData; address add;&#125;; stringDataPerson class  personclasses 12345678910111213#include&lt;string&gt;#include&lt;memory&gt;class Date; // class Address;class Person&#123; public: Person(const string&amp; name,const Date&amp; birthday); string name() const; string birthday(); private: str1::shared_ptr&lt;PersonImpl&gt; pImpl;&#125;; PersonImplpersonDataPersonperson   object references objects pointersobject classclass class Personhandle class   handle classes interface class   handle classesinterface classes templates]]></content>
      <categories>
        <category>effective cpp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[effective cpp() ]]></title>
    <url>%2F2019%2F11%2F09%2Feffective-cpp-%E5%9B%9B-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E%2F</url>
    <content type="text"><![CDATA[2019/11/09 effective cpp  cpp 18  19 classtype 20  pass-by-reference-to-const  pass-by-value 21 reference 22 private 23 non-membernon-friendmember 24 non-member 25 swap 18    1234567class Date&#123; public: Date(const Month&amp; m,const Day&amp; d,const Year&amp; y)&#123; ... &#125;&#125;Date d(Month(3),Day(30),year(1995));  const typestypeSTLsize shared_ptr 1str1:shared_ptr&lt;invest&gt; create(); shared_ptrshared_ptr 1str1::shared_ptr&lt;invest&gt; pInt(ptr,deleteMethod); str1::shared_ptrDLLdeleteshared_ptr shared_ptr     Tr1::shared_ptrDLL 19 classtypeclasstypetype type  typepassed by valuecopy type type type type  type type type type  class84 20  pass-by-reference-to-const  pass-by-valueC++ const const   intfloat  const STL 21 reference  stack stack 1234const Ration&amp; operator*(const Ration&amp; lhs,const Ration&amp; rhs)&#123; Ration result(lhs.n*rhs.n); return result&#125; reference heap heapnew-delete 1234const Ration&amp; operator*(const Ration&amp; lhs,const Ration&amp; rhs)&#123; Ration* result = new Ration(lhs.n*rhs.n); return *result;&#125;   static staticstatic staticstatic   localheap-allocatedstatic 22 privatepublicprotectedpublicprivate  private class 23 non-membernon-friendmember    C++non-member 12345678910111213//webbrowser.hnamespace webbrowserStuff&#123; class webbrowser&#123;...&#125;;&#125;//webbrowserbook.hnamespace webbrowserbook&#123; ...&#125;// webbrowsercookies.hnamespace webbrowsercookies&#123; ...&#125; include 123456789101112131415161718192021222324//web.h#include &lt;string&gt;namespace wweb&#123; class web&#123; public: string get_name()&#123; return name; &#125; web(string n):name(n)&#123;&#125; void say_hi(); private: string name; &#125;;&#125;//web.cpp#include "web.h"#include &lt;iostream&gt;using namespace::wweb;void web::say_hi() &#123; cout &lt;&lt; "hihi";&#125;  non-membermember non-memberclass 24 non-member 123456789class Ration&#123; public: ... const Ration operator* (const Ration&amp; rhs) const;&#125;Ration oneE(10);Ration result = oneE*2; // C++2RationRation result = 2*oneE; // this  123const Ration operator*(const Ration&amp; lhs,const Ration&amp; rhs)&#123; ...&#125;   non-member 25 swapswap 12345678namspace std&#123; template&lt;typename T&gt; void swap(T&amp; a,T&amp; b)&#123; T temp(a); a = b; b = temp; &#125;&#125; copyingswapswap 1234567891011121314class widget&#123; public: void swap(Widget&amp; other)&#123; using std::swap; //stdswap swap(pInt,other.pInt); &#125;&#125;namespace std&#123; template&lt;&gt; // void swap&lt;Widget&gt;(Widget&amp; a,Widget&amp; b) &#123; a.swap(b); &#125;&#125; copy public swap classtemplatenon-member swapswap classclassstd::swapswap  std::swapswap member swapnon-member swapclassesstd::swap  swapstd::swapusingswap std::templatestdstd]]></content>
      <categories>
        <category>effective cpp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[EncNet]]></title>
    <url>%2F2019%2F11%2F06%2FEncNet%E7%BB%93%E5%90%88%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%2F</url>
    <content type="text"><![CDATA[Context Encoding for Semantic Segmentation2018cvprinsightcontext encoding module pixel-level predict2016FCNCNN-poolingFCNdilated convdeeplabfeature mapfeature map EncNet context encoding muduleSE-Losschannel EncNetEncNetstate of the art  Context Encoding Modulecontext Enocding  feature mapreshapeWxHx Ccodebook $D = {d_1,d_2,d_k}$ ,$S = {s_1,s_2,s_k}$,soft-assignment$e_k = \sum_{i=1}^{N}e_{ik}$$e_{ik}$ $$\begin{equation}e_{i k}=\frac{\exp \left(-s_{k}\left|r_{i k}\right|^{2}\right)}{\sum_{j=1}^{K} \exp \left(-s_{j}\left|r_{i j}\right|^{2}\right)} r_{i k}\end{equation}$$$r_{ik} = x_i - d_k$$e = \sum_{k=1}^{K}\phi(e_k)$ekbatch normalizatione feature attention e$$\gamma = \sigma(We)$$w$\sigma$sigmoidfeature map Semantic Encoding Loss GTSE-Lossloss60 Context Encoding NetworkEncNetbackboneresnetdilated convstate34 stage3SE-lossencnetFCN pixAcc mIoUGTIoU feature mapGTfeature map channel]]></content>
  </entry>
  <entry>
    <title><![CDATA[]]></title>
    <url>%2F2019%2F11%2F06%2F%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%AF%84%E5%88%86%E9%A2%84%E6%B5%8B%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[  RMSE$$\operatorname{RMSE}=\frac{\sqrt{\sum_{(u, i) \in T}\left(r_{u i}-\hat{r}_{u i}\right)^{2}}}{|\mathrm{Test}|}$$         N  N $$\hat{r}_{u i}=\bar{r}_{u}+\frac{\sum_{v \in S(u, K) \cap N(i)} w_{u v}\left(r_{v i}-\bar{r}_{v}\right)}{\sum_{v \in S(u, K) \cap N(i)}\left|w_{u v}\right|}$$w$$w_{u v}=\frac{\sum_{i \in I}\left(r_{u i}-\bar{r}_{u}\right) \cdot\left(r_{v i}-\bar{r}_{v}\right)}{\sqrt{\sum_{i \in I}\left(r_{u i}-\bar{r}_{u}\right)^{2} \sum_{i \in I}\left(r_{v i}-\bar{r}_{v}\right)^{2}}}$$$$\hat{r}_{u i}=\bar{r}_{i}+\frac{\sum_{j \in S(u, K) \cap N(u)} w_{i j}\left(r_{u j}-\bar{r}_{i}\right)}{\sum_{j \in S(i, F) \cap W(u)}\left|w_{i j}\right|}$$w R SVD  SVDtopN SVD95% simon Funk SVD simonSVD$$\hat{r}_{u i}=\sum_{f} p_{u f} q_{i f}$$RMSE$$C(p, q)=\sum_{(u, i) \in \mathrm{Train}}\left(r_{u i}-\sum_{f=1}^{F} p_{u f} q_{i f}\right)^{2}+\lambda\left(\left|p_{u}\right|^{2}+\left|q_{i}\right|^{2}\right)$$pq LFM $$\hat{r}_{u i}=\mu+b_{u}+b_{i}+p_{u}^{T} \cdot q_{i}$$ubb  $$\begin{equation}\hat{r}_{u i t}=\frac{\sum_{j \in N(u) \cap S(i, K)} f\left(w_{i j}, \Delta t\right) r_{u j}}{\sum_{j \in N(u) \cap S(i, K)} f\left(w_{i j}, \Delta t\right)}\end{equation}$$ $$\begin{equation}\begin{array}{c}{f\left(w_{i j}, \Delta t\right)=\sigma\left(\delta \cdot w_{i j} \cdot \exp \left(\frac{-|\Delta t|}{\beta}\right)+\gamma\right)} \ {\sigma(x)=\frac{1}{1+\exp (-x)}}\end{array}\end{equation}$$ $\Delta t$d    KAA1A2A1KA2B  $$\begin{equation}\operatorname{sim}(i, j)=\frac{\sum_{u \in N(0) \cap N(i)} f\left(\left|t_{u i}-t_{u |}\right|\right)}{\sqrt{|N(i)||N(j)|}}\end{equation}$$$$\begin{equation}f\left(\left|t_{u i}-t_{u j}\right|\right)=\frac{1}{1+\alpha\left|t_{u i}-t_{u j}\right|}\end{equation}$$]]></content>
      <categories>
        <category></category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[effective cpp() ]]></title>
    <url>%2F2019%2F11%2F05%2Feffective-cpp-%E4%B8%89-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[2019/11/05 effective cpp  CPP 13  14  13  12345void f()&#123; Invest* ptr = create(); ... delete ptr;&#125; delete C++ auto_ptr heapauto_ptrdelete 123void f()&#123; auto_ptr&lt;invest&gt; Ptr(create());&#125;    auto_ptrauto_ptrauto_ptrnull 12auto_ptr&lt;invest&gt; ptr1(create());auto_ptr&lt;invest&gt; ptr2(ptr1); // ptr1null auto_ptrtr1::shared_ptr 1234void f()&#123; tr1::shared_ptr&lt;invest&gt; ptr(create()); tr1::shared_ptr&lt;invest&gt; ptr1(ptr); // ptrptr1&#125; auto_ptr, shared_ptr  RAII RAIItr1::shared_ptrauto_ptrshared_ptrcopy 14 copyingauto_ptr,shared_ptrheap-based  123456789class Lock&#123; public explicit Lock(Mutex* pm):mutexPtr(pm)&#123; //  lock(mutexPtr); &#125; ~Lock()&#123;unlock(mutexPtr);&#125; private: Mutex* mutexPtr;&#125; UnCopyableshared_ptrshared_ptr 1shared_ptr&lt;Mutex&gt; mutexPtr;   auto_ptrcopy  RAIIcopyingRAIIcopying RAII copyingcopying 15  12str1::shared_ptr&lt;Invest&gt; pInt(create()); // pIntint daysHeld(const Invest* pi); // piinvest*  daysHeld()pIntpInt 1daysHeld(pInt.get()); shared_ptr,auto_ptr-&gt;,*get get 12345678class Font&#123; public: explicit Font(Fhandle fh):f(fh)&#123;&#125; ~Font()&#123;release(fh);&#125; FHandle get() const &#123;return fh;&#125; //  private: FHandle fh;&#125; operator FHandle() const {return fh;}get  APIRAIIget  16 newdeletenewnew intnew int[10]deletenewdelete  new[]delete[]new[]delete[] CPPnewdelete new newC++heap new 12pointer-variable = new data-type;int* p = new int;  1int* p = new int(10); [] 1int* p = new int[10]; int a[10]; delete delete deletenew 12delete p; // delete[] p; //  17 newednew 1str1::shared_ptr&lt;Widget&gt; pw(new Widget);  1process(str1::shared_ptr&lt;Wdiget&gt;(new Widget),priority()); () new widget priority Shared_ptr newed 12str1::shared_ptr&lt;Widget&gt; pw(new Widget);process(pw,priority());  newed]]></content>
      <categories>
        <category>effective cpp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[()]]></title>
    <url>%2F2019%2F11%2F05%2F%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%94%A8%E6%88%B7%E6%A0%87%E7%AD%BE%E6%95%B0%E6%8D%AE-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[                   (u,i,b)uib1091        $$p(u, i)=\sum_{b} n_{u, b} n_{b, i}$$$n_{u,b}$ub$n_{b,i}$ ib TF-IDF $$p(u, i)=\sum_{b} \frac{n_{u, b}}{\log \left(1+n_{b}^{(u)}\right)} n_{b, i}$$$$p(u, i)=\sum_{b} \frac{n_{u, b}}{\log \left(1+n_{b}^{(u)}\right)} \frac{n_{b, i}}{\log \left(1+n_{i}^{(u)}\right)}$$  $$\operatorname{sim}\left(b, b^{\prime}\right)=\frac{\sum_{i \in N(b) \cap V(b)} n_{b i} n_{b ; i}}{\sqrt{\sum_{i \in N(b)} n_{b, i}^{2} \sum_{i \in N(b)} n_{b^{\prime}, i}^{2}}}$$       i  ]]></content>
      <categories>
        <category></category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[effective cpp () ]]></title>
    <url>%2F2019%2F11%2F02%2Feffective-cpp-%E4%BA%8C-%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[2019/11/02effective cpp  05C++ 06 07 virtual  08  09 virtual 10 operator= reference to *this 11 operator= 12  05 C++C++ 1234567class entry&#123;public: entry()&#123;...&#125; // ~entry(const entry&amp; rth)&#123;...&#125; // copy  ~entry()&#123;...&#125; //  entry&amp; operator=(const entry&amp; rhs)&#123;...&#125; //&#125; default copy string&amp; name;,constcopy  copycopy assignmentreferenceconstcopy 06 copycopycopy assignmentprivatefriend  123class homeforsale:private Uncopyable&#123; ...&#125;; Uncopyablecopycopy assignmentprivate  privateUncopyablebase class 07 virtual factory basic classdeleteC++basic classnon-virtualbasic class basic classvirtual virtualvirtual 12345class entry&#123;public: ... virtual ~entry();&#125; virtualvirtualvirtual non-virtualclass class 123456class AWOV&#123; virtual ~AWOV() = 0; ...&#125;AWOV::AWOV()&#123;&#125; //  classAWOV  base classvirtualclass virtualvirtual classesbase classesvirtual 08 C++ 1234567class DBConn&#123;public: ... ~DBConn()&#123; db.close(); // DBConndb.close()db.close &#125;&#125; C++  1234567891011121314151617181920212223DBConn::DBConn&#123; public: try&#123;bd.close();&#125; catch&#123;...&#125;&#123; std::abort(); // , &#125;&#125;// void close()&#123; db.close(); closed = true;&#125;~DBConn()&#123; if(!closed)&#123; try&#123; db.close(); &#125; catch(...)&#123; ... &#125; &#125;&#125;  trycatch class 09 virtualbase class derived classbase classbase classderived classbase class 1234567class transaction&#123; public: transaction()&#123; logtransaction(); // virtualbase class &#125; virtual void logtransaction() const;&#125;  virtualderived classvirtual 10 operator= reference to *this=x=y=z=15referenceclass 123456789class Widget&#123; public: ... widget&amp; operator=(const widget&amp; rhs)&#123; ... return *this; // this=rhsthis &#125; // +=&#125; CPP  reference to *this 11 operator= 12345678910class Bitmap&#123;...&#125;;class widget&#123; private: Bitmap* pb; widget&amp; operator=(const widget&amp; rhs)&#123; delete pb; // pbrhs.pb pb = new Bitmap(*rhs.pb); return *this; &#125;&#125;  1234567891011121314widget&amp; widget::operator=(const widget&amp; rhs)&#123; if(*this == &amp;rhs) return *this; delete pb; pb = new Bitmap(*rhs.pb); return *this;&#125;//widget&amp; widget::operator=(const widget&amp; rhs)&#123; Bitmap* pOrig = pb; pb = new Bitmap(*rhs.pb); // pbpb delete pOrig; return *this;&#125;  operator=  12 copycopy assignmentcopy 12345678910111213141516class Customer&#123; public: ... Customer(const Customer&amp; rhs); Customer&amp; operator=(const Customer&amp; rhs); private: string name;&#125;Customer::Customer(const Customer&amp; rhs):name(rhs.name)&#123; do something else;&#125;Customer&amp; Customer::operator=(const Customer&amp; rhs)&#123; name = rhs.name; do something else; return *this;&#125; int age;copyassignment classcopyassignment copyassignment 12345678910111213141516class Customer: public Person&#123; public: ... Customer(const Customer&amp; rhs); Customer&amp; operator=(const Customer&amp; rhs); private: string name;&#125;Customer::Customer(const Customer&amp; rhs):name(rhs.name)&#123; do something else;&#125;Customer&amp; Customer::operator=(const Customer&amp; rhs)&#123; name = rhs.name; do something else; return *this;&#125; CustomerPersonCustomercopyPersondefaultPerson copybase class copy 12345678Customer&amp; Customer(const Customer&amp; rhs):Person(rhs),name(rhs.name)&#123; do something else;&#125;Customer&amp; Customer::operator=(const Customer&amp; rhs)&#123; Person::operator=(rhs); do something else; return *this;&#125; copying1local2base classescopying  copyingbase class copyingcopyinginit]]></content>
      <categories>
        <category>effective cpp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[]]></title>
    <url>%2F2019%2F11%2F02%2F%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[post     Mm = 8M  M  recall = (  ) /  precision = (  ) /  coverage =  /    1992    N(u)Jaccarduv$$w_{u v}=\frac{|N(u) \cap N(v)|}{|N(u) \cup N(v)|}$$$$w_{u v}=\frac{|N(u) \cap N(v)|}{\sqrt{|N(u)||N(v)|}}$$  kk topK  $$w_{u v}=\frac{\sum_{i \in N(u) \cap N(v)} \frac{1}{\log (1+|N(i)|)}}{\sqrt{|N(u)||N(v)|}}$$uviN(i)ii]]></content>
      <categories>
        <category></category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[effective cpp() cpp]]></title>
    <url>%2F2019%2F10%2F31%2Feffective-cpp-%EF%BC%88%E4%B8%80%EF%BC%89-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFcpp%2F</url>
    <content type="text"><![CDATA[2019/10/31effective cpp 01c++ 02const, enum,inline #define 03 const 04 01 c++c++cc with classescppcpp cpp CcppC C++ template C++C++template STL  C++ 02  const, enum,inline #definecpp#define 1#define RATIO 1.25 defineRATIOdefine   constdefine 1const double ratio = 1.25; const 1const char* const author = "names"; static enumdefine 12enum&#123;num1 = 1,num2 = 2&#125;;cout &lt;&lt; num1 &lt;&lt; num2; enumenum  defineinline 1234template&lt;typename T&gt;inline void callwith(const T&amp; a ,const T&amp; b)&#123; f(a&gt;b ? a:b); // &#125;  constenumdefine template + inline  03 constconst const  const 12345char greeting[] = "hello";const char* p = greeting; // constchar const* p = greeting; // const*char* const p = greeting; // constconst char* const p = greeting; //  const const constconst,const 123456class A&#123;public: const char&amp; operator[](int position) const&#123; return tex[position]; &#125;; &#125; constconst constpassed-by-pointer-to-constpassed-by-reference-to-const. 123void point(cosnt TextBlock&amp; ctb)&#123; cout &lt;&lt; ctb[0];&#125; constmutableconstconst 12345678910class block&#123;public: mutable int len; int length() const;&#125;int block::length() const&#123; len = 10; return len; &#125; constnon-constnon-constconst 1234567891011class block&#123;public: const char&amp; operator[](int position) const&#123; ... &#125; char&amp; operator[](int position)&#123; return const_cast&lt;char&amp;&gt;(static_cast&lt;cosnt block&amp;&gt;)(*this)[position]; // const_cast const // static_cast thisconst &#125;&#125;  const constconst bitwise constnessconstconstconst constconstnon-const  04cpp cpp 123456789101112131415class AB&#123;public: int aa; int bb; AB(int a,int b);&#125;AB::AB(int a,int b)&#123; //  aa = a; bb = b;&#125;// AB::AB(int a,int b):aa(a),bb(b) // &#123; ...&#125; staticstaticlocal staticnon-local staticnon-local-staticstaticnon-local-staticreference  cpp  non-local-staticlocal static]]></content>
      <categories>
        <category>effective cpp</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[FastFCN: ]]></title>
    <url>%2F2019%2F10%2F31%2FFastFCN-%E5%A4%A7%E5%B7%A5%E4%B8%8D%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[FastFCN2019cvprJPUdilated convFPS  feature map aFCN bencoder-decoderencoderdecoderfeature mappooling  c DilatedFCNpoolingfeature mapfeature map ###JPU JPUjoint pyramid upsamplingDilateFCN ###FastFCN FastFCNbackboneFCNFCNJPU mIoU FCNdilated convFPS]]></content>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[]]></title>
    <url>%2F2019%2F10%2F30%2F%E5%85%B3%E4%BA%8E%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E8%A7%84%E5%88%92%E4%BB%A5%E5%8F%8A%E6%97%B6%E9%97%B4%E5%AE%89%E6%8E%92%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[welcome to my blog,enter password to read. Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gccg++clangcmakemake]]></title>
    <url>%2F2019%2F10%2F27%2F%E7%BC%96%E8%AF%91%E5%99%A8gcc%EF%BC%8Cg-%EF%BC%8Cclang%EF%BC%8Ccmake%EF%BC%8Cmake%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[postmacCLioncppcpp cpp  #include #define   #ifndef #ifdef #endif.i cpp.s .o .exe cppgccg++clang gcc:  GNU C Compiler, cGCC the GNU Compiler Collection g++GCCc++ clangmacCC++Objective-CObjective-C++BSDClanglambdaconstexpr clanggccgcc makecmakegccIDEVS studioCLionclangcmake make makemakemakefile makemake cmake makefilemakefile cmakemakefilemake cmakeCMakeLists.txtmakefileCLionIDECMakeLists.txtCMakeLists.txt 1234567cmake_minimum_required(VERSION 3.8)project(First_Code)set(CMAKE_CXX_STANDARD 11)#set(CMAKE_CXX_FLAGS "-std=c++0x $&#123;CMAKE_CXX_FLAGS&#125; -g -ftest-coverage -fprofile-arcs")#set(CMAKE_CXX_FLAGS "$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11")set(SOURCE_FILES main.cpp test.cpp assignment.cpp)add_executable(First_Code $&#123;SOURCE_FILES&#125;) CMakeLists.txt IDE C++11 C++11ISO/IEC 14882:2011C++(19982003C++98C++03)C++C++11C++201181220119C++9813 gcc4.7c++11 MACCLionterminalgcc -vAPPLEclangGUNgccclang 12brew search gcc // gccbrew install gcc //gccgcc9.2 gcc 1/usr/local/Cellar/gcc/9.2.0_1/bin CLioncmake(preference ) 1-D CMAKE_CXX_COMPILER=/usr/local/bin/g++-9 CLion CLioncmakeCLioncppcmakeLists.txt]]></content>
      <tags>
        <tag>learning cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpp STL]]></title>
    <url>%2F2019%2F10%2F27%2Fcpp-STL%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[postcppStandard Template Library STLSTL 1#include&lt;bits/stdc++.h&gt; includeSTL STL Algorithm containersvectormap functorSTLsortfunctor iterator algorithmsort(begin_adress,end_adress,compare) $O(nlogn)$. 12345678910111213int arr[10] = &#123;9,4,5,3,6,2,7,0,1,8&#125;;sort(arr,arr+10); //sort(arr,arr+10,greater&lt;int&gt;()); // // struct interval&#123; int val1; int val2;&#125;;interval arr[] = &#123;&#123;2,2&#125;,&#123;4,3&#125;,&#123;3,4&#125;,&#123;1,0&#125;&#125;bool compareInterval(interval v1,interval v2)&#123; return v1.val1 &lt; v2.val2; // &#125;sort(arr,arr+10,compareInterval); //  bool binary_search(start_adress,end_adress,value_find) value_find$O(logn)$ 1234int arr[10] = &#123;1,3,2,4,5,8,7,6,9,0&#125;;if(binary_search(arr,arr+10,2))&#123; cout &lt;&lt; "get it ";&#125; bool all_of(begin_adress,end_adress,lambda_func) arrlambda 1234void STL_allof(int*a)&#123; int lens = sizeof(a)/ sizeof(a[0]); all_of(a,a+lens,[](int x)&#123;return x &gt;= 0;&#125;) ? cout&lt;&lt;"all are positive" : cout&lt;&lt;"no all positive";&#125; bool any_of(begin_adress,end_adress,lambda_func) true 1any_of(arr_begin,arr_end,[](int x)&#123; return x == 0;&#125;) //bool bool none_of(begin_adress,end_adress,lambda_func) true 1none_of(arr_begin,arr_end,[](int x)&#123; return x == 0;&#125;) //bool copy_n(arr1,size,arr2) arr1sizearr2 123int arr[10] = &#123;1,2,3,4,5,6,7,8,9,0&#125;;int arr2[10];copy_n(arr,10,arr2); containers vectorvectorvector iterators vectorvector 123456789vector&lt;int&gt; vec;vec.begin(); // vec.end(); // for(auto i = vec.begin();i!=vec.end();i++)&#123;...&#125;vec.rbegin(); //vec.rend(); // for(auto i = vec.rbegin();i!=vec.end();i++)&#123;...&#125;// cconstvec.rbegin()//const capacity vectorvector 123456vector&lt;int&gt; vec;vec.size(); //vec.capacity(); //vec.max_size(); // vec.empty(); // vec.shrink_to_fit(); //   123456vector&lt;int&gt; vec = &#123;1,2,3,4,5&#125;;vec[1];vec.front();vec.back();vec.at(pos);vec.data(); //   12345678910vector&lt;int&gt; vec;vec.assign(val,time); //vectimevalvec.push_back(val);vec.pop_back(val);vec.insert(insert_adress,val);vec.erase(adress);vec.clear(); // vec.emplace(adress,val); // vec.emplace_back(val); // vec.swap(vec2); // vecvec1 listlistvector vector 123456789list&lt;int&gt; ll = &#123;1,7,3,8,2,6,4,9&#125;;ll.sort();ll.reverse();ll.push_front();ll.erase(adress) or ll.erase(begin,end);ll.remove(val); //valll.unique(); // ll.splice(l1.begin(),l2); // ll.merge(12); //  deque vector dequevectordeque 123deque&lt;int&gt; que;que.push_front(val);que.pop_front(val); froward_list listlist queue  12345queue&lt;int&gt; que;que.push(val); // que.pop(); // queue.empty();queue.size(); priority queue  12345priority_queue&lt;int&gt; que;que.push(val);que.push(val);que.pop();que.top();  1priority_queue&lt;int, vector&lt;int&gt;,greater&lt;int&gt;&gt; gg; stack  1234stack.empty();stack.push(val);stack.pop();stack.top();  set  123456789set&lt;int&gt; gg;set&lt;int,greater&lt;int&gt;&gt; gg; //begin();end();empty();gg.insert(val); // setset&lt;int&gt; gg = &#123;vec.begin(),vec.end()&#125;;gg.lower_bound(val); //. valgg.upper_bound(val); // val multiset setsetmultiset map  12345678map&lt;int,int&gt; amap;amap.insert(pair&lt;int,int&gt;(1,21));amap.insert(pair&lt;int,int&gt;(2,23));cout &lt;&lt; amap[1];auto ptr = amap.begin();cout &lt;&lt; ptr-&gt;first&lt;&lt; " "&lt;&lt; ptr-&gt;second;amap.erase(amap.begin());amap.erase(4);//key multimap mapmultimapkey unordered_set hashkey 123unordered_set&lt;string&gt; stringset;stringset.insert("code");stringset.find(key); // unordered_multiset unordered_set unordered_map mapkey 1234unordered_map&lt;string,double&gt; umap;umap['id'] = 11;umap.insert(make_pair("e",2.33));umap.find(key); unordered_multimap unordered_mapkey]]></content>
      <tags>
        <tag>learning cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpp]]></title>
    <url>%2F2019%2F10%2F25%2Fcpp%E8%AF%AD%E6%B3%95%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE%2F</url>
    <content type="text"><![CDATA[cpp  cpp 1234567#include&lt;iostream&gt;int main()&#123; cout &lt;&lt; "hello world" &lt;&lt; endl; return 0;&#125; cpp  #include #define   #ifndef #ifdef #endif.i cpp.s .o .exe #define cpp12 123#define pi 3.14 //// #define MIN(A,B) ((A) &lt; (B) ?(A):(B))  123#ifdef NULL #define NULL 0#endif ### # 12#define MACRO(x) #xcout&lt;&lt;MACRO(HOW ARE)&lt;&lt;endl; // "HOW ARE" ## 12#define ACFUNS(x,y) x##ycout&lt;&lt;ACFUNS("aa","bb")&lt;&lt;endl; // aabb typedef 1typedef short int wchar_t; wchar_tshort int  enum 123enum color&#123;red,blue,black&#125; c; //012c = blue; //c1cout &lt;&lt; c; // 1  cpp.h / .cpp,(lib)(.lib,dll)dll  extern int a;a extern  0   12#define WIDTH 10const int HEIGHT = 20;  charintdouble signed,unsigned,long short 12int* restrict restar = (int *)malloc(10 * sizeof(int));restar  auto  12auto f = 3.14;auto s = "hello"; static 123456789101112void func()&#123; static int i = 5; cout&lt;&lt;i&lt;&lt;'\n'; i--;&#125;int main() &#123; for(int i = 0;i&lt;10;i++)&#123; func(); &#125; return 0;&#125;// 54321.... static i thread_local thread_local int x;  1234567891011A = 00111100B = 00001101A&amp;B = 00001100A|B = 00111101A^B = 00110001~A = 11000011A &lt;&lt;= 1; //A = 01111000A &gt;&gt;= 1; //A = 00011110sizeof(A); //Ab = &amp;A; // c = *b; // b  123456789int sum(int a,int b)&#123; if(a &gt; b)&#123; return a; &#125; else&#123; return b; &#125;&#125;// lambda 12345[capture](parameter)-&gt; return-type&#123;body&#125;int s = 1;auto funa = [s](int a,int b)-&gt; int&#123;return a+b+s;&#125;;cout &lt;&lt; funa(1,2);    1j = rand()  123int a[10];int a[10] = &#123;10,10,1&#125;;int a[] = &#123;1,2,3&#125;;  12345678//cchar gre[] = &#123;'a','b','c','d'&#125;;cout&lt;&lt;gre;strcpy(str1,str2); // str2str1strcat(str1,str2); // str1+str2strcmp(s1,s2);//s1s2strchr(s1,ch); // chstrstr(s1,s2);// s2 string  12345678string a = "hello";string b = "el";a.find_first_of(b); // a.find(b);a.find_last_of(b);s.size();if(a.find(b) == string::npos)&#123; return dont exists;&#125;  cpp&amp;   12345678910int *ip;int var = 10;ip = &amp;var;cout &lt;&lt; *ip; //ipint *ptr[10]; ////int var[5] = &#123;1,2,3,4,5&#125;int *ip = var;ip++;cout &lt;&lt; ip[1];   1234int a = 1;int&amp; r = a;////   cpp 12345678910111213141516struct Book&#123; int count; string name;&#125;;struct Book b1;//typedeftypedef struct Book&#123; int count; string name;&#125;Book;Book b1,b2;//cout &lt;&lt; b1.name;//Book *ptr = &amp;b1;cout &lt;&lt; ptr-&gt;name;  cpp 12345678910111213class Box&#123; public: int width; int height; Box(); // int get_area()&#123; return width*height; &#125;&#125;;Box b1; //Boxcout&lt;&lt; b1.width;Box* ptr = &amp;b1;cout &lt;&lt; ptr-&gt;get_area();   1Box b2 = b1;  AAAfriend 123456789class A&#123; int val; public: int mon; friend void detial(A a1);&#125;void detail(A a1)&#123; cout &lt;&lt; a1.val; //&#125; this  this  staticstaticA:: = init static   1234567891011121314151617181920class book&#123; public: int page = 1; string name = "island"; void detail()&#123; cout&lt;&lt; this.page &lt;&lt; this.name; &#125;&#125;class finance: public book&#123; public: int profit = 0; finance(int pro); void detail();&#125;finance::finance(int pro):book()&#123; this.profit = pro;&#125;void finance::detail()&#123; cout &lt;&lt; this.page &lt;&lt; this.name &lt;&lt; this.pro;&#125;    1finance::finance(int profit,int page,string name):Book(page,name),profit(profit)&#123;&#125;  +-x/ 12345678910class Box&#123; public: int width; Box operator+(Box b)&#123; Box box; box.width = this.width + b.width; &#125;&#125;Box b1,b2;b = b1 + b2;   1234567class log&#123; public: int user = 1; int vip = 1; void log(int user); void log(int user,int vip);&#125;   virtual  123456789101112131415161718192021222324252627282930313233343536class shape&#123; public: int width = 0; int height = 0; shape(int w,int h):width(w),height(h); virtual int area()&#123; cout &lt;&lt; "shape"  return 0; &#125;&#125;class triangle:public shape&#123; public: triangle(int a,int b):shape(a,b)&#123;&#125; int area()&#123; cout &lt;&lt; "triangle area"&lt;&lt;endl; return a*b / 2; &#125;&#125;class rectangle:public shape&#123; public: rectangle(int a,int b):shape(a,b)&#123;&#125; int area()&#123; cout &lt;&lt; "rectangle area" &lt;&lt; endl; return a*b; &#125;&#125;shape* sh;rectangle rec(1,2);triangle tri(1,2);// sh = &amp;rec;sh-&gt;area();// sh = $tri;sh-&gt;area(); virtual virtualclass B : virtual public A{...}  virtual 12345678910111213141516class shape&#123; public: int width; int weight; shape(int a,int b):width(a),weight(b)&#123;&#125; //  virtual int get_area() = 0;&#125;class rectangle&#123; public: rectangle(int a,int b):shape(a,b)&#123;&#125; int get_area()&#123; return this.width*this.weight; &#125;&#125;  ifstream,ofstream&lt;&lt;&gt;&gt;  cpptry,catch,throw 12345678910111213try&#123; //&#125;catch(ExceptionName e1)&#123; //catch &#125;catch(ExceptionName e2)&#123; // something&#125;//catch if(error)&#123; throw "error message";&#125; cpp   cppnewdelete 12345678910111213141516double* ptr = new double;*ptr = 12.32;//int * ptr = new int[10];//delete[] ptr;// int ** ptr = new int *[10];for(int i=0;i&lt;10;i++)&#123; ptr[i] = new int[10];&#125;class Box&#123; ...&#125;Box* ptr = new Box[4];delete [] ptr;  123456namespace first_space&#123; void func()&#123; ... &#125;&#125;first_space::func(); cpp cppvector 123456789101112131415161718192021222324//template&lt;typename T&gt; // TT Max_val(T a,T b)&#123; return a &gt; b ? a:b;&#125;//Max_val(1,3);Max_val(1.2,3.4);//template&lt;class T&gt;class stack&#123; private: vector&lt;T&gt; elems; public: void push(T const&amp; val);&#125;template&lt;class T&gt;void stack&lt;T&gt;::push(T const&amp; val)&#123; elems.push(val);&#125;//stack&lt;int&gt; int_stack;stack&lt;string&gt; str_stack; const&amp; ,const&amp;const void* void * 12345void* c;int a = 0;int * ptr = &amp;a;c = ptr;int * d = (int *) c; cpp/    POSIX  C++ POSIXlinux 123456789101112131415161718192021222324#include &lt;pthread.h&gt;// void* say_hello(void* args)&#123; cout &lt;&lt; "Hello Runoob" &lt;&lt; endl; return 0;&#125; int main()&#123; //  id  pthread_t tids[NUM_THREADS]; for(int i = 0; i &lt; NUM_THREADS; ++i) &#123; //id int ret = pthread_create(&amp;tids[i], NULL, say_hello, NULL); if (ret != 0) &#123; cout &lt;&lt; "pthread_create error: error_code=" &lt;&lt; ret &lt;&lt; endl; &#125; &#125; // pthread_exit(NULL);&#125; cppSTLstandard template library STL algorithm vectormapset  Functorssort STLpost cpp C #include cppincludecppinclude 123#ifndef FOLDER_METHOD_H_#define FOLDER_METHOD_H_#endif Google include dir/foo.cc  dir/foo_test.cc  dir2/foo2.h , foo.cc : dir2/foo2.h (, ) C  C++   .h   .h   dir2/foo2.h  dir/foo.cc  dir/foo_test.cc  .cppincludehinclude cppCLionVS studio ]]></content>
      <tags>
        <tag>learning cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DeepLab ]]></title>
    <url>%2F2019%2F10%2F22%2FDeepLab-%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"></content>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpp]]></title>
    <url>%2F2019%2F10%2F21%2Fcpp%E5%B7%A5%E7%A8%8B%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[cpp cpp vsCLioncmakeList]]></content>
      <tags>
        <tag>learning cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RealSense]]></title>
    <url>%2F2019%2F10%2F18%2F%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9A%E5%9F%BA%E4%BA%8ERealSense%E5%92%8C%E6%A8%A1%E5%9E%8B%E5%BA%93%E7%9A%84%E4%BA%BA%E4%BD%93%E5%BB%BA%E6%A8%A1%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[  1.  2.  3.  RGBD RGB  RGBD RGBRGBRGB   Stacked hourglass network Varol et al.(CVPR 2017)  Varol RGBrealsenseRGB Telea 2004(FMM)RGBDIRGB$$I(p)=I(q)+\nabla I_{p}(q)(p-q)$$RGB$$I(p)=\frac{\sum w(p, q)\left[I(q)+s \cdot \nabla C_{p}(q)(p-q)\right]}{\sum w(p, q)}$$RGBGradientFMM  RGBD Bouaziz et al 2014 $$E = E_{match} + E_{prior}$$EM SCAPE151715311250025000 QRSQRS  RGBD cpp ]]></content>
      <tags>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[]]></title>
    <url>%2F2019%2F10%2F16%2F%E5%A6%82%E4%BD%95%E8%AF%BB%E8%AE%BA%E6%96%87%2F</url>
    <content type="text"><![CDATA[  feel free to stop reading the article at any point keywordsyou stop  abstract  conclusion       introduction  the result and the discussion dig extremely into the experience section  tips            https://www.zhihu.com/question/304334959/answer/553782865]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[resume detail 2019/10/15]]></title>
    <url>%2F2019%2F10%2F15%2Fresume-detail%2F</url>
    <content type="text"><![CDATA[welcome to my blog,enter password to read. Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DeepMVS:Learning Multi-view Stereopsis]]></title>
    <url>%2F2019%2F10%2F14%2FDeepMVS-Learning-Multi-view-Stereopsis%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[State of Art on 3D Reconstruction with RGB-D Cameras ]]></title>
    <url>%2F2019%2F10%2F10%2FState-of-Art-on-3D-Reconstruction-with-RGB-D-Cameras-%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA%E7%BB%BC%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[2018 introductionstructure lightTOFtime of flightRGB-DRGB-D3DRGB-D RGB-D cameras and their characteristicstriangulationTOFtime of flightstereo visionTOF static Scene Reconstruction SLAMsimultaneous Localization and Mapping kinect Fusionpossion surface reconstruction pipelineoutlierRGB-D  T M bilateral filter camera pose EstimateRGB-D6-DOF pose T]]></content>
      <categories>
        <category></category>
        <category>3D</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[3D]]></title>
    <url>%2F2019%2F10%2F08%2F3D%E9%87%8D%E5%BB%BA%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[insight State of Art on 3D Reconstruction with RGB-D Cameraseurographics 2018RGB-D  Underwater 3-D Scene Reconstruction Using Kinect v2 Based on Physical Models for Refraction and Time of Flight Correction2017IEEE accesskinect v2kinect v2RGBTOFkinect Fusion kinect v2 kinect fusionbilinear filter5 x 5median kinect TOF kinect v2 ground truth 2019/10/8]]></content>
      <categories>
        <category>3D</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[3D]]></title>
    <url>%2F2019%2F09%2F26%2F3D%E9%87%8D%E5%BB%BA%E7%BB%BC%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[ 5.25.2 6 DOF benchmarkKITTI MiddleBury Benchmark Image-based 3D Object Reconstruction:State-of-the-Art and Trends in the Deep Learning Era3Dpipeline generic objects -&gt;single images,multiple RGB-&gt;shape representationsnetwork architecturetraining mechanism  RGBGT  encoding stateI$$x = h(I)$$h Ix xperturbationI  3D2Dx disentangled  Wu3Dencoding 3Dvanillapooling layerRELUresidual networksresnet  VAEvariational Autoencoders3D hierarchical latent spaces  disentangled representation  volumetric decoding3D3D3D3D2D3D  10   SDF  SDF  3Ddecoderup-convolutional networkencoder3D ]]></content>
      <categories>
        <category>3D</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Stanford cs231A]]></title>
    <url>%2F2019%2F09%2F19%2FStanford-cs231A%2F</url>
    <content type="text"><![CDATA[Stanford cs231Acs231N slide 10: Active stereo &amp; Volumetric stereo   traditional stereo volumetric stereo slide 2019/09/26 silde 9: Detectors and descriptorsDetectors: :  canny corner/blobharris  SIFT HOG: slide 2019/09/25 slide 8: Fitting and Matching  nosiy outliers missing data intra-class variantion least square methods  RANSAC (inliers)(outliers) RANSACRandom Sample Consensus1981FischlerBolles  RANSACRANSAC    1inlier      (Hough Transform) Robustness ,    https://zhuanlan.zhihu.com/p/47649796 hough slide 2019/9/25 slide 7: Multi-view geometry mnmn3D   factorization method()centering the data: $$\hat{\mathbf{x}}_{i j}=\mathbf{x}_{i j}-\frac{1}{n} \sum_{k=1}^{n} \mathbf{x}_{i k}$$ centering3D m x nn DSVDrank=3FD MS  slide 6: Stereo() Systems Multi-view geometry   methodwindow base correlation:    SFM: structure from motion problemSFMRGB SFM (SIFT)  F5/8 E RTSVD    slide 2019/9/24 slide 5: Epipolar Geometry () K  K  Multi(stereo)-view geometry ()camera geometry scene geometry  A  K   F F,FF FFFthe eight-point algorithm8$P^{T}Fp = 0$,SVDF silde 2019/9/23 slide 4: Single View Metrology2D$$\left[\begin{array}{c}{\mathrm{x}^{\prime}} \ {\mathrm{y}^{\prime}} \ {1}\end{array}\right]=\left[\begin{array}{ll}{\mathrm{R}} &amp; {\mathrm{t}} \ {0} &amp; {1}\end{array}\right]\left[\begin{array}{l}{\mathrm{x}} \ {\mathrm{y}} \ {1}\end{array}\right]=\mathrm{H}_{\mathrm{e}}\left[\begin{array}{l}{\mathrm{x}} \ {\mathrm{y}} \ {1}\end{array}\right]$$ $$\left[\begin{array}{l}{x^{\prime}} \ {y^{\prime}} \ {1}\end{array}\right]=\left[\begin{array}{cc}{S R} &amp; {t} \ {0} &amp; {1}\end{array}\right]\left[\begin{array}{l}{x} \ {y} \ {1}\end{array}\right]=H_{s}\left[\begin{array}{l}{x} \ {y} \ {1}\end{array}\right]$$ $$\left[\begin{array}{c}{\mathrm{x}^{\prime}} \ {\mathrm{y}^{\prime}} \ {1}\end{array}\right]=\left[\begin{array}{cc}{\mathrm{A}} &amp; {\mathrm{t}} \ {0} &amp; {1}\end{array}\right]\left[\begin{array}{l}{\mathrm{x}} \ {\mathrm{y}} \ {1}\end{array}\right]=\mathrm{H}_{\mathrm{a}}\left[\begin{array}{l}{\mathrm{x}} \ {\mathrm{y}} \ {1}\end{array}\right]$$ $$\left[\begin{array}{c}{\mathrm{x}^{\prime}} \ {\mathrm{y}^{\prime}} \ {1}\end{array}\right]=\left[\begin{array}{cc}{\mathrm{A}} &amp; {\mathrm{t}} \ {\mathrm{V}} &amp; {\mathrm{b}}\end{array}\right]\left[\begin{array}{c}{\mathrm{x}} \ {\mathrm{y}} \ {1}\end{array}\right]=\mathrm{H}_{\mathrm{p}}\left[\begin{array}{l}{\mathrm{x}} \ {\mathrm{y}} \ {1}\end{array}\right]$$     silde 2019/9/23  ppt0K5k extensionkk slide 3: camera calibertion $$\mathrm{P}^{\prime}=\mathrm{M} \mathrm{P}_{\mathrm{w}}=\mathrm{K}[\mathrm{R} \quad \mathrm{T}] \mathrm{P}_{\mathrm{w}}$$ MM11116correspondencesrobots$$p_{i}=\left[\begin{array}{c}{u_{i}} \ {v_{i}}\end{array}\right]=\left[\begin{array}{c}{\frac{\mathbf{m}_{1} \mathrm{P}_{\mathrm{i}}}{\mathbf{m}_{3} \mathrm{P}_{\mathrm{i}}}} \ {\frac{\mathbf{m}_{2} \mathrm{P}_{\mathrm{i}}}{\mathbf{m}_{3} \mathrm{P}_{\mathrm{i}}}}\end{array}\right]=M P_{i}$$K slide 2019/09/20 slide 2: camera models 1452leonardo18221908  pinhole camera    kl $$P=(x, y, z) \rightarrow P^{\prime}=\left(\alpha \frac{x}{z}+c_{x}, \beta \frac{y}{z}+c_{y}\right)$$ homogeneous coordinates N+1Nw  camera matrix$$P^{\prime}=\left[\begin{array}{cccc}{\alpha} &amp; {-\alpha \cot \theta} &amp; {c_{x}} &amp; {0} \ {0} &amp; {\frac{\beta}{\sin \theta}} &amp; {c_{y}} &amp; {0} \ {0} &amp; {0} &amp; {1} &amp; {0}\end{array}\right]\left[\begin{array}{c}{x} \ {y} \ {z} \ {1}\end{array}\right]$$   &gt;&gt;  M Slide 2019/9/20 slide 1: introduction Geometry2D3Dvolumetric stereo3D Semantics slide 2019/9/19]]></content>
      <categories>
        <category>3D</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[some tip about resume]]></title>
    <url>%2F2019%2F09%2F18%2Fsome-tip-about-resume%2F</url>
    <content type="text"><![CDATA[welcome to my blog,enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category></category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux ]]></title>
    <url>%2F2019%2F09%2F06%2Flinux-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[linux python3.6Linux linuxlinux python3.6linuxpythonpython2.7python3.5python3.6sodulinux python3.6.tgzrootpython3.6/usr/bin,/local/binpython3.6https://my.oschina.net/moonrain/blog/739612`./configure` ./configure --prefix=./python36 python2.7,python3.6virtualenvpyhton3.6.bashrcpython3.6bin 1PATH=&apos;./python/bin:$PATH&apos;  1alias python=./python3.6/bin/python3.6 source ./bashrc pippython2.7pip3python3.6source bashpipvirtualenv virtualenvvirtualenvannacondamax 1pip3 install virtualenv virtualenvpythonpythonpythonpython 1virtualenv -p ./python3.6/bin/python3 zhou_env virtualenv 1source zhou_env/bin/activate python3.6pip  1deactivate linux https://perper.site/2019/04/24/linux%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/]]></content>
      <categories>
        <category>tool</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Image Super-Resolution Using Very Deep Residual Channel Attention Networks(RCAN)]]></title>
    <url>%2F2019%2F09%2F05%2FImage-Super-Resolution-Using-Very-Deep-Residual-Channel-Attention-Networks-RCAN%2F</url>
    <content type="text"><![CDATA[RCAN2018ECCVposterYunlun Zhangstate of the arthighlight arxiv https://arxiv.org/pdf/1807.02758.pdf githubhttps://github.com/yulunzhang/RCAN  RCANRIRresidual in residualRIRRGresidual groupRGresidual blockLSCRIRCAchannel attention  RIRCA Residual Channel Attention NetworkRCANRCAN RCANRIR RCANL1$$L(\Theta)=\frac{1}{N} \sum_{i=1}^{N}\left|H_{R C A N}\left(I_{L R}^{i}\right)-I_{H R}^{i}\right|_{1}$$ Residual in Residual (RIR)RIR10residual groupsRGlong skip connectionRG20residual channel attention blockRCAB RIRskip connection channel attentionCA  HWC64  11C   11  r  Relu Sigmoid C=64r = 16 Residual channel attention BlockRCAB  input-Relu- f f  CA  x x  input  33  RIRRG10RGRCAB20conv3 x 3channel64 scale16C/16 = 4]]></content>
      <categories>
        <category>super resolution</category>
      </categories>
      <tags>
        <tag>SR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[]]></title>
    <url>%2F2019%2F09%2F03%2F%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87%E8%AE%BA%E6%96%87%E6%91%98%E8%A6%81%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[  githubSOAThttps://github.com/YapengTian/Single-Image-Super-Resolution  https://www.zhihu.com/search?type=content&amp;q=%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87 Xuaner Zhang, Qifeng Chen, Ren Ng, and Vladlen Koltun. Zoom to Learn, Learn to Zoom, CVPR 2019. [Paper] CoBi loss functioninsight Image Super-Resolution Using Very Deep Residual Channel Attention Networks]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[]]></title>
    <url>%2F2019%2F08%2F30%2F%E7%94%B5%E9%98%BB%E7%8E%87%E6%88%90%E5%83%8F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[(ERI)  123012 M 3 M 4   /       2.5mm ]]></content>
      <categories>
        <category>super resolution</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python]]></title>
    <url>%2F2019%2F08%2F27%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%8Cpython%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[  A[0] = 1 01.  find_root 12345678joint = 10parent = [-1]*10def find_root(parent,x): x_root = x while parent[x_root] != -1: x_root = parent[x_root] return x_root xx union 123456789def union_joint(parent,x,y): x = find_root(parent,x) y = find_root(parent,y) if x == y: print('circle') return 0 else: parent[x] = y return 1 0 unionunionrankunionrankrankrankrank1 123456789101112131415rank = [0]*jointdef union(parent,x,y,rank): x = find_root(parent,x) y = find_root(parent,y) if x == y: print('circle') return 0 else: if rank[x] &gt; rank[y]: parent[y] = x elif rank[x] &lt; rank[y]: parent[x] = y else: parent[x] = y rank[y] += 1 union0 lettcode 547.Friend Circles parent-1  12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution(object): def findCircleNum(self, M): """ :type M: List[List[int]] :rtype: int """ edge = [] if M == [] or M[0] == []: return 0 for i in range(len(M)): for j in range(len(M[0])): if i &lt;= j: break if M[i][j] == 1: edge.append([i,j]) parent = [-1]*len(M) rank = [0]*len(M) def find_root(parent,x): x_root = x while parent[x_root] != -1: x_root = parent[x_root] return x_root def union_joint(parent,x,y,rank): x = find_root(parent,x) y = find_root(parent,y) if x != y: if rank[x] &lt; rank[y]: parent[x] = y elif rank[x] &gt; rank[y]: parent[y] = x else: parent[x] = y rank[y] += 1 for e in edge: union_joint(parent,e[0],e[1],rank) ans = 0 for i in parent: if i == -1: ans += 1 return ans]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python]]></title>
    <url>%2F2019%2F08%2F25%2F%E5%93%88%E5%B8%8C%E8%A1%A8-python%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[ (Key value)  keykeycollision java hashmapindex pythondict  python dict 123for i in dicts: print(i) print(dicts[i])  123dicts.pop(key)dicts.popitem() #del dicts #]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python]]></title>
    <url>%2F2019%2F08%2F22%2F%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%8Cpython%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[  O(nlog(n)) i(i - 1) /22i+1,2i+2  heapify  1234567891011121314151617181920212223242526272829303132333435nums = [9,3,4,1,5,6,8,7]def heapify(nums,n,i): ''' i  ''' c1 = 2*i + 1 c2 = 2*i + 2 max_index = i if c1 &lt;= n and nums[c1] &gt; nums[i]: max_index = c1 if c2 &lt;= n and nums[c2] &gt; nums[max_index]: max_index = c2 if max_index != i: nums[max_index],nums[i] = nums[i],nums[max_index] heapify(nums,n,max_index)def build_heap(nums): n = len(nums) - 1 last_index = (n - 1) // 2 for i in range(last_index+1)[::-1]: heapify(nums,n,i)def heap_sort(nums): print(nums) build_heap(nums) print(nums) for i in range(len(nums))[::-1]: print(i) nums[0],nums[i] = nums[i],nums[0] heapify(nums,i-1,0) print(nums) heap_sort(nums)]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[]]></title>
    <url>%2F2019%2F08%2F16%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E7%9A%84%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[pytorchNMS main mainargparseargparsehttps://docs.python.org/zh-cn/3/library/argparse.html main cococsvpascal voc  backbone   epochbatch_size dataloader annotationclass_idcsv CSVDatasettorch.utils.data.Dataset__len__,__getitem__ CSVDataset__init__ self.classes self.image_names : list  self.image_data: dict[image_name] = [ {x1,y1,x2,y2,class_name},] __getitem__image sample = {&#39;img&#39;: img, &#39;annot&#39;: annot} resizedataloader pytorchtransforms.Compose([Augumenter(),Resizer()])  Normalizer Normalizer__call__ 1234567891011class Normalizer(object): def __init__(self): self.mean = np.array([[[0.485, 0.456, 0.406]]]) self.std = np.array([[[0.229, 0.224, 0.225]]]) def __call__(self, sample): image, annots = sample['img'], sample['annot'] return &#123;'img':((image.astype(np.float32)-self.mean)/self.std), 'annot': annots&#125; argument  Resizer ,32 123456789101112131415161718192021222324252627282930313233class Resizer(object): """Convert ndarrays in sample to Tensors.""" def __call__(self, sample, min_side=608, max_side=1024): #resize6081024 image, annots = sample['img'], sample['annot'] #  rows, cols, cns = image.shape smallest_side = min(rows, cols) # rescale the image so the smallest side is min_side scale = min_side / smallest_side # check if the largest side is now greater than max_side, which can happen # when images have a large aspect ratio largest_side = max(rows, cols) if largest_side * scale &gt; max_side: scale = max_side / largest_side # resize the image with the computed scale image = skimage.transform.resize(image, (int(round(rows*scale)), int(round((cols*scale))))) rows, cols, cns = image.shape pad_w = 32 - rows%32 pad_h = 32 - cols%32 new_image = np.zeros((rows + pad_w, cols + pad_h, cns)).astype(np.float32) new_image[:rows, :cols, :] = image.astype(np.float32) # 320 annots[:, :4] *= scale return &#123;'img': torch.from_numpy(new_image), 'annot': torch.from_numpy(annots), 'scale': scale&#125;  dataloaderpytorchdataloaderiterationdataloaderdataset__getitem__()batchcollate_fnbatch torch.utils.data.Dataloader dataset(Dataset)  dataset from which to load the data. batch_size(int, optional)  how many samples per batch to load (default: 1). shuffle(bool, optional)  set to Trueto have the data reshuffled at every epoch (default: False). sampler(Sampler, optional)  defines the strategy to draw samples from the dataset. If specified, shufflemust be False. batch_sampler(Sampler, optional)  like sampler, but returns a batch of indices at a time. Mutually exclusive with batch_size, shuffle, sampler, and drop_last. num_workers(int, optional)  how many subprocesses to use for data loading. 0 means that the data will be loaded in the main process. (default: 0) collate_fn(callable, optional)  merges a list of samples to form a mini-batch. pin_memory(bool, optional)  If True, the data loader will copy tensors into CUDA pinned memory before returning them. drop_last(bool, optional)  set to Trueto drop the last incomplete batch, if the dataset size is not divisible by the batch size. If Falseand the size of dataset is not divisible by the batch size, then the last batch will be smaller. (default: False) timeout(numeric, optional)  if positive, the timeout value for collecting a batch from workers. Should always be non-negative. (default: 0) worker_init_fn(callable, optional)  If not None, this will be called on each worker subprocess with the worker id (an int in [0, num_workers - 1]) as input, after seeding and before data loading. (default: None)  1dataloader_train = DataLoader(dataset_train, num_workers=3, collate_fn=collater, batch_sampler=sampler) dataset_trainDatasetnum_workersbatch_sampler batchsamplecollate_fn mini-batch batch_sampler: __len____iter__grouplist 12345678910111213141516171819202122232425class AspectRatioBasedSampler(Sampler): def __init__(self, data_source, batch_size, drop_last): self.data_source = data_source self.batch_size = batch_size self.drop_last = drop_last self.groups = self.group_images() def __iter__(self): random.shuffle(self.groups) for group in self.groups: yield group def __len__(self): if self.drop_last: return len(self.data_source) // self.batch_size else: return (len(self.data_source) + self.batch_size - 1) // self.batch_size def group_images(self): # determine the order of the images order = list(range(len(self.data_source))) order.sort(key=lambda x: self.data_source.image_aspect_ratio(x)) # divide into groups, one group = one batch return [[order[x % len(order)] for x in range(i, i + self.batch_size)] for i in range(0, len(order), self.batch_size)] groupgroupslist__iter__()batch collate_fn batch_sampler 12345678910111213141516171819202122232425def collater(data): imgs = [s['img'] for s in data] annots = [s['annot'] for s in data] scales = [s['scale'] for s in data] widths = [int(s.shape[0]) for s in imgs] heights = [int(s.shape[1]) for s in imgs] batch_size = len(imgs) max_width = np.array(widths).max() max_height = np.array(heights).max() padded_imgs = torch.zeros(batch_size, max_width, max_height, 3) for i in range(batch_size): img = imgs[i] padded_imgs[i, :int(img.shape[0]), :int(img.shape[1]), :] = img max_num_annots = max(annot.shape[0] for annot in annots) if max_num_annots &gt; 0: annot_padded = torch.ones((len(annots), max_num_annots, 5)) * -1 if max_num_annots &gt; 0: for idx, annot in enumerate(annots): #print(annot.shape) if annot.shape[0] &gt; 0: annot_padded[idx, :annot.shape[0], :] = annot else: annot_padded = torch.ones((len(annots), 1, 5)) * -1 padded_imgs = padded_imgs.permute(0, 3, 1, 2) return &#123;'img': padded_imgs, 'annot': annot_padded, 'scale': scales&#125; batchannotationRGBdict loaderfor retinanetretinanet retinanetresnetresnet18345010115250101: 123456789def resnet50(num_classes, pretrained=False, **kwargs): """Constructs a ResNet-50 model. Args: pretrained (bool): If True, returns a model pre-trained on ImageNet """ model = ResNet(num_classes, Bottleneck, [3, 4, 6, 3], **kwargs) if pretrained: model.load_state_dict(model_zoo.load_url(model_urls['resnet50'], model_dir='.'), strict=False) return model ResNet()ResNetResNetnn.Module,__init__forward()__init__()forward ResNet resnetResNetResNetResNetbasicBlock  bottleneckbottleneck bottleneckfeature1x13x31x1 bottleneck 1234567891011121314151617181920212223242526272829303132class Bottleneck(nn.Module): expansion = 4 def __init__(self, inplanes, planes, stride=1, downsample=None): super(Bottleneck, self).__init__() self.conv1 = nn.Conv2d(inplanes, planes, kernel_size=1, bias=False) self.bn1 = nn.BatchNorm2d(planes) self.conv2 = nn.Conv2d(planes, planes, kernel_size=3, stride=stride, padding=1, bias=False) self.bn2 = nn.BatchNorm2d(planes) self.conv3 = nn.Conv2d(planes, planes * 4, kernel_size=1, bias=False) self.bn3 = nn.BatchNorm2d(planes * 4) self.relu = nn.ReLU(inplace=True) self.downsample = downsample self.stride = stride def forward(self, x): residual = x out = self.conv1(x) out = self.bn1(out) out = self.relu(out) out = self.conv2(out) out = self.bn2(out) out = self.relu(out) out = self.conv3(out) out = self.bn3(out) if self.downsample is not None: residual = self.downsample(x) out += residual out = self.relu(out) return out pytorch Conv2d 12345678910111213141516import torch.nn as nnnn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True)in_channels(int)  out_channels(int)  kerner_size(int or tuple) - stride(int or tuple, optional) - padding(int or tuple, optional) - 0dilation(int or tuple, optional)  groups(int, optional)  bias(bool, optional) - bias=Trueinput: (N,C_in,H_in,W_in) output: (N,C_out,H_out,W_out)Fout = (Fin + 2*padding-kernel)/stride + 1 batchNorm2d 0.1 / 12345678BatchNorm2d(num_features, eps=1e-05, momentum=0.1, affine=True)num_features 'batch_size x num_features x height x width'eps 0,1e-5momentum 0.1affine trueN, CH, W) - N, C, H, Wnum_featurechannel ReLU 1234nn.ReLU(inplace=False)inplace MaxPool2d  1234567891011nn.MaxPool2d(kernel_size, stride=None, padding=0, dilation=1, return_indices=False, ceil_mode=False)kernel_size(int or tuple) - max poolingstride(int or tuple, optional) - max poolingkernel_sizepadding(int or tuple, optional) - 0dilation(int or tuple, optional)  return_indices - Trueceil_mode - True: (N,C,H_&#123;in&#125;,W_in) : (N,C,H_out,W_out)Fout = (Fin + 2*padding - kernel)/stride + 1 nn.Upsample channel 12nn.Upsample(size=None, scale_factor=None, mode='nearest', align_corners=None)modescale_factor nn.Sequential 12345downsample = nn.Sequential( nn.Conv2d(self.inplanes, planes * block.expansion, kernel_size=1, stride=stride, bias=False), nn.BatchNorm2d(planes * block.expansion), ) nn.Module,__init__forward()initforward retinanet 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class PyramidFeatures(nn.Module): def __init__(self, C3_size, C4_size, C5_size, feature_size=256): super(PyramidFeatures, self).__init__() # upsample C5 to get P5 from the FPN paper self.P5_1 = nn.Conv2d(C5_size, feature_size, kernel_size=1, stride=1, padding=0) self.P5_upsampled = nn.Upsample(scale_factor=2, mode='nearest') self.P5_2 = nn.Conv2d(feature_size, feature_size, kernel_size=3, stride=1, padding=1) # add P5 elementwise to C4 self.P4_1 = nn.Conv2d(C4_size, feature_size, kernel_size=1, stride=1, padding=0) self.P4_upsampled = nn.Upsample(scale_factor=2, mode='nearest') self.P4_2 = nn.Conv2d(feature_size, feature_size, kernel_size=3, stride=1, padding=1) # add P4 elementwise to C3 self.P3_1 = nn.Conv2d(C3_size, feature_size, kernel_size=1, stride=1, padding=0) self.P3_2 = nn.Conv2d(feature_size, feature_size, kernel_size=3, stride=1, padding=1) # "P6 is obtained via a 3x3 stride-2 conv on C5" self.P6 = nn.Conv2d(C5_size, feature_size, kernel_size=3, stride=2, padding=1) # "P7 is computed by applying ReLU followed by a 3x3 stride-2 conv on P6" self.P7_1 = nn.ReLU() self.P7_2 = nn.Conv2d(feature_size, feature_size, kernel_size=3, stride=2, padding=1) def forward(self, inputs): C3, C4, C5 = inputs P5_x = self.P5_1(C5) P5_upsampled_x = self.P5_upsampled(P5_x) P5_x = self.P5_2(P5_x) P4_x = self.P4_1(C4) P4_x = P5_upsampled_x + P4_x P4_upsampled_x = self.P4_upsampled(P4_x) P4_x = self.P4_2(P4_x) P3_x = self.P3_1(C3) P3_x = P3_x + P4_upsampled_x P3_x = self.P3_2(P3_x) P6_x = self.P6(C5) P7_x = self.P7_1(P6_x) P7_x = self.P7_2(P7_x) return [P3_x, P4_x, P5_x, P6_x, P7_x] retinanet featurechannelnum_anchors x 4channelnum_anchors x 4  1234567891011121314151617181920212223242526272829303132333435363738class RegressionModel(nn.Module): def __init__(self, num_features_in, num_anchors=9, feature_size=256): super(RegressionModel, self).__init__() self.conv1 = nn.Conv2d(num_features_in, feature_size, kernel_size=3, padding=1) self.act1 = nn.ReLU() self.conv2 = nn.Conv2d(feature_size, feature_size, kernel_size=3, padding=1) self.act2 = nn.ReLU() self.conv3 = nn.Conv2d(feature_size, feature_size, kernel_size=3, padding=1) self.act3 = nn.ReLU() self.conv4 = nn.Conv2d(feature_size, feature_size, kernel_size=3, padding=1) self.act4 = nn.ReLU() self.output = nn.Conv2d(feature_size, num_anchors*4, kernel_size=3, padding=1) def forward(self, x): out = self.conv1(x) out = self.act1(out) out = self.conv2(out) out = self.act2(out) out = self.conv3(out) out = self.act3(out) out = self.conv4(out) out = self.act4(out) out = self.output(out) # out is B x C x W x H, with C = 4*num_anchors out = out.permute(0, 2, 3, 1) return out.contiguous().view(out.shape[0], -1, 4) view()numpyreshapepermuteviewcontiguousoutshape[batch_sizew x h 4]outcriterionloss channelchannelanchornum_anchor x num_classes 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class ClassificationModel(nn.Module): def __init__(self, num_features_in, num_anchors=9, num_classes=80, prior=0.01, feature_size=256): super(ClassificationModel, self).__init__() self.num_classes = num_classes self.num_anchors = num_anchors self.conv1 = nn.Conv2d(num_features_in, feature_size, kernel_size=3, padding=1) self.act1 = nn.ReLU() self.conv2 = nn.Conv2d(feature_size, feature_size, kernel_size=3, padding=1) self.act2 = nn.ReLU() self.conv3 = nn.Conv2d(feature_size, feature_size, kernel_size=3, padding=1) self.act3 = nn.ReLU() self.conv4 = nn.Conv2d(feature_size, feature_size, kernel_size=3, padding=1) self.act4 = nn.ReLU() self.output = nn.Conv2d(feature_size, num_anchors*num_classes, kernel_size=3, padding=1) self.output_act = nn.Sigmoid() def forward(self, x): out = self.conv1(x) out = self.act1(out) out = self.conv2(out) out = self.act2(out) out = self.conv3(out) out = self.act3(out) out = self.conv4(out) out = self.act4(out) out = self.output(out) out = self.output_act(out) # out is B x C x W x H, with C = n_classes + n_anchors out1 = out.permute(0, 2, 3, 1) batch_size, width, height, channels = out1.shape out2 = out1.view(batch_size, width, height, self.num_anchors, self.num_classes) return out2.contiguous().view(x.shape[0], -1, self.num_classes) outanchor x num_classesview[x.shape[0],W x H x anchor, num_classes]criterion Torch.cat https://blog.csdn.net/qq_39709535/article/details/80803003 anchor anchoranchorretinaNetP3P4P5P6P7anchorscale9anchorfeature map 12self.ratios = np.array([0.5,1,2])self.scales = np.array([2**0,2**(1.0/3.0),2**(2.0/3.0)])  1234a = [1,2,3]a = np.tile(a,(2,3))# a = [[1,2,3,1,2,3,1,2,3] [1.2,3,1,2,3,1,2,3]] np.repeat 1234a = [1,2,3]a = np.repeat(a,2)# a = [1,1,2,2,3,3]# np.tiletile anchor 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293class Anchors(nn.Module): def __init__(self, pyramid_levels=None, strides=None, sizes=None, ratios=None, scales=None): super(Anchors, self).__init__() if pyramid_levels is None: self.pyramid_levels = [3, 4, 5, 6, 7] if strides is None: self.strides = [2 ** x for x in self.pyramid_levels] if sizes is None: self.sizes = [2 ** (x + 2) for x in self.pyramid_levels] if ratios is None: self.ratios = np.array([0.5, 1, 2]) if scales is None: self.scales = np.array([2 ** 0, 2 ** (1.0 / 3.0), 2 ** (2.0 / 3.0)]) def forward(self, image): # image = [2,3,640,832] image_shape = image.shape[2:] image_shape = np.array(image_shape) image_shapes = [(image_shape + 2 ** x - 1) // (2 ** x) for x in self.pyramid_levels] # compute anchors over all pyramid levels all_anchors = np.zeros((0, 4)).astype(np.float32) for idx, p in enumerate(self.pyramid_levels): anchors = generate_anchors(base_size=self.sizes[idx], ratios=self.ratios, scales=self.scales) shifted_anchors = shift(image_shapes[idx], self.strides[idx], anchors) all_anchors = np.append(all_anchors, shifted_anchors, axis=0) all_anchors = np.expand_dims(all_anchors, axis=0) return torch.from_numpy(all_anchors.astype(np.float32)).cuda()def generate_anchors(base_size=16, ratios=None, scales=None): """ Generate anchor (reference) windows by enumerating aspect ratios X scales w.r.t. a reference window. """ if ratios is None: ratios = np.array([0.5, 1, 2]) if scales is None: scales = np.array([2 ** 0, 2 ** (1.0 / 3.0), 2 ** (2.0 / 3.0)]) num_anchors = len(ratios) * len(scales) # 9 # initialize output anchors anchors = np.zeros((num_anchors, 4)) # 9 # scale base_size,feature scaleanchor anchors[:, 2:] = base_size * np.tile(scales, (2, len(ratios))).T # compute areas of anchors areas = anchors[:, 2] * anchors[:, 3] # correct for ratios  anchors[:, 2] = np.sqrt(areas / np.repeat(ratios, len(scales))) anchors[:, 3] = anchors[:, 2] * np.repeat(ratios, len(scales)) # transform from (x_ctr, y_ctr, w, h) -&gt; (x1, y1, x2, y2) anchors[:, 0::2] -= np.tile(anchors[:, 2] * 0.5, (2, 1)).T anchors[:, 1::2] -= np.tile(anchors[:, 3] * 0.5, (2, 1)).T return anchors def shift(shape, stride, anchors): shift_x = (np.arange(0, shape[1]) + 0.5) * stride shift_y = (np.arange(0, shape[0]) + 0.5) * stride shift_x, shift_y = np.meshgrid(shift_x, shift_y) # shifts = [shape[0]*shape[1],4] shifts = np.vstack(( shift_x.ravel(), shift_y.ravel(), shift_x.ravel(), shift_y.ravel() )).transpose() # add A anchors (1, A, 4) to # cell K shifts (K, 1, 4) to get # shift anchors (K, A, 4) # reshape to (K*A, 4) shifted anchors A = anchors.shape[0] K = shifts.shape[0] #  # [1,A,4] + [k,1,4] = [k,A,4],k = shape[0]*shape[1] # 9anchoranchor shape # level__init__ all_anchors = (anchors.reshape((1, A, 4)) + \ shifts.reshape((1, K, 4)).transpose((1, 0, 2))) all_anchors = all_anchors.reshape((K * A, 4)) return all_anchors feature maplevelstridesizesratiosscalesforwardgenerate_anchor()levelfeaturesizeanchor9anchor shift()shift()anchorlevelsizeanchor9anchor$[shape[0]shape[1]9,4]$   123456789np.meshgrid(x,y)# xynp.vstack((x,y))# xy#ravel()a = [[2,2],[1,1]]a.ravel() #  a = [2,2,1,1]a.flatten() # np.squeeze([[1],[2],[3]]) # 1[1,2,3]a = a.reshape(-1) # 1a.transpose() #  for5anchorlistanchor torch.cat 1234a = [1,2,3]b = [3,4,5]torch.cat((a,b),0) #  [[1,2,3],[3,4,5]]torch.cat((a,b),1) #  [[1,2,3,4,5,6]] focalLossfocalLoss ResNet5feature mapP3P4P5P6P7regressionclassification$[batch,wh,4]$$[batch,wh*anchors,class_nums]$catlevelanchor catregression_anchor classification_anchoranchoranchoranchoranchorfocalLossanchorloss focalLoss focalLossbatchbatchlossanchorGTIoU /  12345678910111213def calc_iou(a, b): area = (b[:, 2] - b[:, 0]) * (b[:, 3] - b[:, 1]) iw = torch.min(torch.unsqueeze(a[:, 2], dim=1), b[:, 2]) -\ torch.max(torch.unsqueeze(a[:, 0], 1), b[:, 0]) ih = torch.min(torch.unsqueeze(a[:, 3], dim=1), b[:, 3]) -\ torch.max(torch.unsqueeze(a[:, 1], 1), b[:, 1]) iw = torch.clamp(iw, min=0) ih = torch.clamp(ih, min=0) ua = torch.unsqueeze((a[:, 2] - a[:, 0]) * (a[:, 3] - a[:, 1]), dim=1) + area - iw * ih ua = torch.clamp(ua, min=1e-8) intersection = iw * ih IoU = intersection / ua return IoU focalLossanchorclassificationfocalLoss losslosslosslossfocal losslossloss 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126class FocalLoss(nn.Module): #def __init__(self): def forward(self, classifications, regressions, anchors, annotations): alpha = 0.25 gamma = 2.0 batch_size = classifications.shape[0] classification_losses = [] regression_losses = [] anchor = anchors[0, :, :] anchor_widths = anchor[:, 2] - anchor[:, 0] anchor_heights = anchor[:, 3] - anchor[:, 1] anchor_ctr_x = anchor[:, 0] + 0.5 * anchor_widths anchor_ctr_y = anchor[:, 1] + 0.5 * anchor_heights for j in range(batch_size): classification = classifications[j, :, :] regression = regressions[j, :, :] bbox_annotation = annotations[j, :, :] bbox_annotation = bbox_annotation[bbox_annotation[:, 4] != -1] if bbox_annotation.shape[0] == 0: regression_losses.append(torch.tensor(0).float().cuda()) classification_losses.append(torch.tensor(0).float().cuda()) continue classification = torch.clamp(classification, 1e-4, 1.0 - 1e-4) IoU = calc_iou(anchors[0, :, :], bbox_annotation[:, :4]) # num_anchors x num_annotations IoU_max, IoU_argmax = torch.max(IoU, dim=1) # num_anchors x 1 #import pdb #pdb.set_trace() # compute the loss for classification # target  targets = torch.ones(classification.shape) * -1 targets = targets.cuda() # lt : less than IoU_max0.4 targets[torch.lt(IoU_max, 0.4), :] = 0 positive_indices = torch.ge(IoU_max, 0.5) num_positive_anchors = positive_indices.sum() # IoU_argmaxanchorGT # anchorGT # anchoranchor assigned_annotations = bbox_annotation[IoU_argmax, :] targets[positive_indices, :] = 0 # IoUanchorone hottarget targets[positive_indices, assigned_annotations[positive_indices, 4].long()] = 1 alpha_factor = torch.ones(targets.shape).cuda() * alpha alpha_factor = torch.where(torch.eq(targets, 1.), alpha_factor, 1. - alpha_factor) # focal weight focal_weight = torch.where(torch.eq(targets, 1.), 1. - classification, classification) focal_weight = alpha_factor * torch.pow(focal_weight, gamma) # y=1,targets=1 y=0targets=0 bce = -(targets * torch.log(classification) + (1.0 - targets) * torch.log(1.0 - classification)) # cls_loss = focal_weight * torch.pow(bce, gamma) cls_loss = focal_weight * bce # targetIoU0.40.5target=-1losscls_loss cls_loss = torch.where(torch.ne(targets, -1.0), cls_loss, torch.zeros(cls_loss.shape).cuda()) # loss classification_losses.append(cls_loss.sum()/torch.clamp(num_positive_anchors.float(), min=1.0)) # compute the loss for regression #loss if positive_indices.sum() &gt; 0: assigned_annotations = assigned_annotations[positive_indices, :] anchor_widths_pi = anchor_widths[positive_indices] anchor_heights_pi = anchor_heights[positive_indices] anchor_ctr_x_pi = anchor_ctr_x[positive_indices] anchor_ctr_y_pi = anchor_ctr_y[positive_indices] gt_widths = assigned_annotations[:, 2] - assigned_annotations[:, 0] gt_heights = assigned_annotations[:, 3] - assigned_annotations[:, 1] gt_ctr_x = assigned_annotations[:, 0] + 0.5 * gt_widths gt_ctr_y = assigned_annotations[:, 1] + 0.5 * gt_heights # clip widths to 1 gt_widths = torch.clamp(gt_widths, min=1) gt_heights = torch.clamp(gt_heights, min=1) targets_dx = (gt_ctr_x - anchor_ctr_x_pi) / anchor_widths_pi targets_dy = (gt_ctr_y - anchor_ctr_y_pi) / anchor_heights_pi targets_dw = torch.log(gt_widths / anchor_widths_pi) targets_dh = torch.log(gt_heights / anchor_heights_pi) targets = torch.stack((targets_dx, targets_dy, targets_dw, targets_dh)) targets = targets.t() targets = targets/torch.Tensor([[0.1, 0.1, 0.2, 0.2]]).cuda() negative_indices = 1 - positive_indices regression_diff = torch.abs(targets - regression[positive_indices, :]) regression_loss = torch.where( torch.le(regression_diff, 1.0 / 9.0), 0.5 * 9.0 * torch.pow(regression_diff, 2), regression_diff - 0.5 / 9.0 ) regression_losses.append(regression_loss.mean()) else: regression_losses.append(torch.tensor(0).float().cuda()) return torch.stack(classification_losses).mean(dim=0, keepdim=True), torch.stack(regression_losses).mean(dim=0, keepdim=True)  lossregression lossstack  12345torch.cat(a,b) #abtorch.clamp(a,min_val,max_val) # amin_valmax_valmin_valmax_valmax_val, max_index = torch.max(a,dim = 1) # torch.lt(a,0.4) # a0.4getorch.where(condition,true_val,false_val) # true_val,false_val,   dataloader loss losslearning rate batch epochevaluate mAP  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# gpu use_gpu = Trueif use_gpu: retinanet = retinanet.cuda()retinanet = torch.nn.DataParallel(retinanet).cuda()retinanet.training = True # adamoptimizer = optim.Adam(retinanet.parameters(), lr=1e-5) # learning ratescheduler = optim.lr_scheduler.ReduceLROnPlateau(optimizer, patience=3, verbose=True)loss_hist = collections.deque(maxlen=500) # retinanet.train()retinanet.module.freeze_bn()print('Num training images: &#123;&#125;'.format(len(dataset_train)))# dataloader for epoch_num in range(parser.epochs): retinanet.train() retinanet.module.freeze_bn() epoch_loss = [] for iter_num, data in enumerate(dataloader_train): try: # pytorchbackward # RNN #  # backward optimizer.zero_grad() # loss classification_loss, regression_loss = retinanet([data['img'].cuda().float(), data['annot']]) classification_loss = classification_loss.mean() regression_loss = regression_loss.mean() loss = classification_loss + regression_loss if bool(loss == 0): continue #  loss.backward() # ,0.1 torch.nn.utils.clip_grad_norm_(retinanet.parameters(), 0.1) optimizer.step() loss_hist.append(float(loss)) epoch_loss.append(float(loss)) print('Epoch: &#123;&#125; | Iteration: &#123;&#125; | Classification loss: &#123;:1.5f&#125; | Regression loss: &#123;:1.5f&#125; | Running loss: &#123;:1.5f&#125;'.format(epoch_num, iter_num, float(classification_loss), float(regression_loss), np.mean(loss_hist))) del classification_loss del regression_loss except Exception as e: print(e) continue if parser.dataset == 'coco': print('Evaluating dataset') #  coco_eval.evaluate_coco(dataset_val, retinanet) elif parser.dataset == 'csv' and parser.csv_val is not None: print('Evaluating dataset') mAP = csv_eval.evaluate(dataset_val, retinanet) scheduler.step(np.mean(epoch_loss)) #  torch.save(retinanet.module, '&#123;&#125;_retinanet_&#123;&#125;.pt'.format(parser.dataset, epoch_num)) retinanet.eval()torch.save(retinanet, 'model_final.pt'.format(epoch_num))   123model.train()# or evaluatemodel.eval() trainevalbatchNormDropouteval eval evalbatchepoch evalmAPrecallprecisionevalannomAP  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849def _get_detections(dataset, retinanet, score_threshold=0.05, max_detections=100, save_path=None): """ Get the detections from the retinanet using the generator. The result is a list of lists such that the size is: all_detections[num_images][num_classes] = detections[num_detections, 4 + num_classes] # Arguments dataset : The generator used to run images through the retinanet. retinanet : The retinanet to run on the images. score_threshold : The score confidence threshold to use. max_detections : The maximum number of detections to use per image. save_path : The path to save the images with visualized detections to. # Returns A list of lists containing the detections for each image in the generator. """ all_detections = [[None for i in range(dataset.num_classes())] for j in range(len(dataset))] retinanet.eval() with torch.no_grad(): for index in range(len(dataset)): data = dataset[index] scale = data['scale'] # run network scores, labels, boxes = retinanet(data['img'].permute(2, 0, 1).cuda().float().unsqueeze(dim=0)) scores = scores.cpu().numpy() labels = labels.cpu().numpy() boxes = boxes.cpu().numpy() # correct boxes for image scale boxes /= scale # select indices which have a score above the threshold indices = np.where(scores &gt; score_threshold)[0] if indices.shape[0] &gt; 0: # select those scores scores = scores[indices] # find the order with which to sort the scores # scoremax_detections scores_sort = np.argsort(-scores)[:max_detections] # select detections score image_boxes = boxes[indices[scores_sort], :] image_scores = scores[scores_sort] image_labels = labels[indices[scores_sort]] image_detections = np.concatenate([image_boxes, np.expand_dims(image_scores, axis=1), np.expand_dims(image_labels, axis=1)], axis=1) # copy detections to all_detections for label in range(dataset.num_classes()): # indexlabellabelanchor, all_detections[index][label] = image_detections[image_detections[:, -1] == label, :-1] else: # copy detections to all_detections for label in range(dataset.num_classes()): all_detections[index][label] = np.zeros((0, 5)) print('&#123;&#125;/&#123;&#125;'.format(index + 1, len(dataset)), end='\r') return all_detections  123456789101112131415161718def _get_annotations(generator): """ Get the ground truth annotations from the generator. The result is a list of lists such that the size is: all_detections[num_images][num_classes] = annotations[num_detections, 5] # Arguments generator : The generator used to retrieve ground truth annotations. # Returns A list of lists containing the annotations for each image in the generator. """ all_annotations = [[None for i in range(generator.num_classes())] for j in range(len(generator))] for i in range(len(generator)): # load the annotations annotations = generator.load_annotations(i) # copy detections to all_annotations for label in range(generator.num_classes()): all_annotations[i][label] = annotations[annotations[:, 4] == label, :4].copy() print('&#123;&#125;/&#123;&#125;'.format(i + 1, len(generator)), end='\r') return all_annotations mAPmAPrecallprecisionmAP recall = TP/(TP + FN)  precision = TP/(TP + FN)  TP,FP,TN,FNmAP  mAP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117def compute_overlap(a, b): """ Parameters ---------- a: (N, 4) ndarray of float b: (K, 4) ndarray of float Returns ------- overlaps: (N, K) ndarray of overlap between boxes and query_boxes """ area = (b[:, 2] - b[:, 0]) * (b[:, 3] - b[:, 1]) iw = np.minimum(np.expand_dims(a[:, 2], axis=1), b[:, 2]) - np.maximum(np.expand_dims(a[:, 0], 1), b[:, 0]) ih = np.minimum(np.expand_dims(a[:, 3], axis=1), b[:, 3]) - np.maximum(np.expand_dims(a[:, 1], 1), b[:, 1]) iw = np.maximum(iw, 0) ih = np.maximum(ih, 0) ua = np.expand_dims((a[:, 2] - a[:, 0]) * (a[:, 3] - a[:, 1]), axis=1) + area - iw * ih ua = np.maximum(ua, np.finfo(float).eps) intersection = iw * ih return intersection / uadef _compute_ap(recall, precision): """ Compute the average precision, given the recall and precision curves. Code originally from https://github.com/rbgirshick/py-faster-rcnn. # Arguments recall: The recall curve (list). precision: The precision curve (list). # Returns The average precision as computed in py-faster-rcnn. """ # correct AP calculation # first append sentinel values at the end mrec = np.concatenate(([0.], recall, [1.])) mpre = np.concatenate(([0.], precision, [0.])) # compute the precision envelope for i in range(mpre.size - 1, 0, -1): mpre[i - 1] = np.maximum(mpre[i - 1], mpre[i]) # to calculate area under PR curve, look for points # where X axis (recall) changes value i = np.where(mrec[1:] != mrec[:-1])[0] # and sum (\Delta recall) * prec ap = np.sum((mrec[i + 1] - mrec[i]) * mpre[i + 1]) return apdef evaluate( generator, retinanet, iou_threshold=0.5, score_threshold=0.05, max_detections=100, save_path=None): """ Evaluate a given dataset using a given retinanet. # Arguments generator : The generator that represents the dataset to evaluate. retinanet : The retinanet to evaluate. iou_threshold : The threshold used to consider when a detection is positive or negative. score_threshold : The score confidence threshold to use for detections. max_detections : The maximum number of detections to use per image. save_path : The path to save images with visualized detections to. # Returns A dict mapping class names to mAP scores. """ # gather all detections and annotations all_detections = _get_detections(generator, retinanet, score_threshold=score_threshold, max_detections=max_detections, save_path=save_path) all_annotations = _get_annotations(generator) average_precisions = &#123;&#125; for label in range(generator.num_classes()): false_positives = np.zeros((0,)) true_positives = np.zeros((0,)) scores = np.zeros((0,)) num_annotations = 0.0 for i in range(len(generator)): detections = all_detections[i][label] annotations = all_annotations[i][label] num_annotations += annotations.shape[0] detected_annotations = [] for d in detections: scores = np.append(scores, d[4]) if annotations.shape[0] == 0: #  false_positives = np.append(false_positives, 1) true_positives = np.append(true_positives, 0) continue overlaps = compute_overlap(np.expand_dims(d, axis=0), annotations) assigned_annotation = np.argmax(overlaps, axis=1) # , max_overlap = overlaps[0, assigned_annotation] if max_overlap &gt;= iou_threshold and assigned_annotation not in detected_annotations: false_positives = np.append(false_positives, 0) true_positives = np.append(true_positives, 1) detected_annotations.append(assigned_annotation) else: false_positives = np.append(false_positives, 1) true_positives = np.append(true_positives, 0) # no annotations -&gt; AP for this class is 0 (is this correct?) if num_annotations == 0: average_precisions[label] = 0, 0 continue # sort by score indices = np.argsort(-scores) false_positives = false_positives[indices] true_positives = true_positives[indices] # compute false positives and true positives #  false_positives = np.cumsum(false_positives) true_positives = np.cumsum(true_positives) # compute recall and precision recall = true_positives / num_annotations precision = true_positives / np.maximum(true_positives + false_positives, np.finfo(np.float64).eps) # compute average precision average_precision = _compute_ap(recall, precision) average_precisions[label] = average_precision, num_annotations print('\nmAP:') for label in range(generator.num_classes()): label_name = generator.label_to_name(label) print('&#123;&#125;: &#123;&#125;'.format(label_name, average_precisions[label][0])) return average_precisions  123np.argsort(scores) # np.argmax(overlaps,axis = 1) # np.cumsum(nums) #  loss  dataloader   ]]></content>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[normalization]]></title>
    <url>%2F2019%2F07%2F24%2Fnormalization%2F</url>
    <content type="text"><![CDATA[Normalization wikipedialoss[0,1]  Normalization is useful when your data has varying scales and the algorithm you are using does not make assumptions about the distribution of your data, such as k-nearest neighbors and artificial neural networks.       0   norm  L0 0  L00  L00L0NP hardL1L0L1L0 L1  L10L1$$L = L_0 + \frac{\lambda}{n}\sum_{w}|W|$$L2   L200L2$$C=C_{0}+\frac{\lambda}{2 n} \sum_{w} w^{2}$$lasso L1lossoL1lossL2L2,LossL1L2L1 standardization Standardization is useful when your data has varying scales and the algorithm you are using does make assumptions about your data having a Gaussian distribution, such as linear regression, logistic regression and linear discriminant analysis.  rescale $mean = 0,\sigma = 1$$$z=\frac{x-\mu}{\sigma}$$mean = 0lossMSE Batch Normalizationbatch$r,\beta$  batchbatchmeanvariance Batch Normalization ReLu0mean0BNN(0,1) BNN(0,1)BN$\gamma, \beta$ scaleshit$y_i$ trade off Batch Normalization batch normalization BN  layer normalization layer normalization featureCHWbatch normalization sampleNHW]]></content>
      <categories>
        <category>super resolution</category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[image upsample-downsample method]]></title>
    <url>%2F2019%2F07%2F23%2Fimage-upsample-downsample-method%2F</url>
    <content type="text"><![CDATA[trade-off https://clouard.users.greyc.fr/Pantheon/experiments/rescaling/index-en.html#bicubic    1D,y:    [1,1,0][0.5,1,0.5] 2Dxy Nearest Neighbor Resampling  Bilinear Resampling (B-spline order 1)  xy Bicubic Resampling  16B(X,Y)a-0.5bicubic $$\sum_{i=0}^{3} \sum_{j=0}^{3} a_{i j} x^{i} y^{j}$$awiki 16]]></content>
      <categories>
        <category>super resolution</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Deep Learning for image Super-resolution: a Survey]]></title>
    <url>%2F2019%2F07%2F23%2FDeep-Learning-for-image-Super-resolution-a-Survey%2F</url>
    <content type="text"><![CDATA[20192arxiv  (problem setting) benchmark datasets  (performance metrics)   (domain-specific application) (open issuse)  problem settingLRHR $$I_{x}=\mathcal{D}\left(I_{y} ; \delta\right)$$$I_x$ $I_y$ $D()$ $\delta$ $$\mathcal{D}\left(I_{y} ; \delta\right)=\left(I_{y} \otimes \kappa\right) \downarrow_{s}+n_{\zeta},{\kappa, s, \zeta} \subset \delta$$$I_{y} \otimes \kappa$ HRblur kernelk$n_{\zeta}$ $\zeta$  LRSR((bicubic interpolation))anti aliasing(blur)   $$\hat{I}_{y}=\mathcal{F}\left(I_{x} ; \theta\right)$$$\mathcal{F}()$  LRHRHR$$\hat{\theta}=\underset{\theta}{\arg \min } \mathcal{L}\left(\hat{I}_{y}, I_{y}\right)+\lambda \Phi(\theta)$$$\mathcal{L}\left(\hat{I}_{y}, I_{y}\right)$ HRLosslossMSE lossloss Benchmark dataset Image Quality AssessmentMSE Peak Signal-to-Noise Ratio()$$\begin{aligned}\operatorname{MSE} &amp;=\frac{1}{N} \sum_{i=1}^{N}(I(i)-\hat{I}(i))^{2} \\\operatorname{PSNR} &amp;=10 \cdot \log _{10}\left(\frac{L^{2}}{\mathrm{MSE}}\right) \\\end{aligned}$$L8L = 255PSNR2040 PSNR     SSIMStructural Similarity SSIM meanvariance$$\begin{aligned}\mu_{I} &amp;=\frac{1}{N} \sum_{i=1}^{N} I(i) \\\sigma_{I} &amp;=\left(\frac{1}{N-1} \sum_{i=1}^{N}\left(I(i)-\mu_{I}\right)^{2}\right)^{\frac{1}{2}} \\\end{aligned}$$luminance$\hat{I}$ :$$\mathcal{C}_{l}(I, \hat{I})=\frac{2 \mu_{I} \mu_{\hat{I}}+C_{1}}{\mu_{I}^{2}+\mu_{\hat{I}}^{2}+C_{1}}$$contrast$$\mathcal{C}_{c}(I, \hat{I})=\frac{2 \sigma_{I} \sigma_{\hat{I}}+C_{2}}{\sigma_{I}^{2}+\sigma_{\hat{I}}^{2}+C_{2}}$$structure comparison$$\begin{aligned}\sigma_{I \hat{I}} &amp;=\frac{1}{N-1} \sum_{i=1}^{N}\left(I(i)-\mu_{I}\right)\left(\hat{I}(i)-\mu_{\hat{I}}\right) \\\mathcal{C}_{s}(I, \hat{I}) &amp;=\frac{\sigma_{I \hat{I}}+C_{3}}{\sigma_{I} \sigma_{\hat{I}}+C_{3}} \\\end{aligned}$$$C_1 = (K_1L)^2$,$C_2 = (K_2L)^2$,$C_3 = C_2 / 2$ SSIM$$\operatorname{SSIM}(I, \hat{I})=\left[\mathcal{C}_{l}(I, \hat{I})\right]^{\alpha}\left[\mathcal{C}_{c}(I, \hat{I})\right]^{\beta}\left[\mathcal{C}_{s}(I, \hat{I})\right]^{\gamma}$$$$\operatorname{SSIM}(I, \hat{I})=\frac{\left(2 \mu_{I} \mu_{\hat{I}}+C_{1}\right)\left(\sigma_{I \hat{I}}+C_{2}\right)}{\left(\mu_{I}^{2}+\mu_{\overline{I}}^{2}+C_{1}\right)\left(\sigma_{I}^{2}+\sigma_{\tilde{I}}^{2}+C_{2}\right)}$$$k_1 = 0.01,k_2 = 0.03, L =255$ mean opinion score RGBYCbCr  Pre-upsampling Super-resolution Post-upsampling Super-resolution Progressive Upsampling Super-resolution Iterative Up-and-down Sampling Super-resolution  Pre-upsampling Super-resolution bicubic interpolationCNNLRHR HR  Post-upsampling Super-resolution LRHRtraininference upsampleupsample Progressive Upsampling Super-resolution postLapSRN laplacian pyramid SR networkCNNHR248  Iterative Up-and-down Sampling Super-resolution back projectionLRHRDBPNNTIRE 2018up-downDBPN        transposed/ deconvolution layer 0 03 X 3 padding= 1 stride = 1 SR sub-pixel layer feature mapreshape feature mapschannel$s^2$$w*h*c$$w*h*s^2 c$ reshape$sh*sw*c$s    residual Learning resNet  global residual learning SRhigh waypre-upsample local residual learning resNet Recursive Learning performance image upsample multi-path learning  Global Multi-path Learning visibleupsample  local multi-path learning inceptionblockblock feature map3X35X5 scale-specific multi-path learning upsample Dense Connections feature map channel attentionchannelchannelsqueeze-and-excitation poolingimagesize1 X 1 X Cchannelfeature mapfeature map advanced convolution dilated convolution   group convolution feature mapchannelfeature  pixel recurisiveSRpixel by pixelHR poolingEDSR-PP  Loss Functions HRHR$\hat{I}$ $I$  loss pixel loss GTL1L2 loss$$\begin{aligned}\mathcal{L}_{\text {pixel_L1 }}(\hat{I}, I) &amp;=\frac{1}{h w c} \sum_{i, j, k}\left|\hat{I}_{i, j, k}-I_{i, j, k}\right| \\\mathcal{L}_{\text {pixel_L2}}(\hat{I}, I) &amp;=\frac{1}{h w c} \sum_{i, j, k}\left(\hat{I}_{i, j, k}-I_{i, j, k}\right)^{2} \\\end{aligned}$$L2 loss L1 loss L1 lossL2PSNRpixel lossPSNRpixel loss content loss lossL2 lossGT$l$ pixel wiseloss$$\mathcal{L}_{\text {content }}(\hat{I}, I ; \phi, l)=\frac{1}{h_{l} w_{l} c_{l}} \sqrt{\sum_{i, j, k}\left(\phi_{i, j, k}^{(l)}(\hat{I})-\phi_{i, j, k}^{(l)}(I)\right)^{2}}$$h,w,h lossVGGresNet Texture Loss Gram matrix$$G_{i j}^{(l)}(I)=\operatorname{vec}\left(\phi_{i}^{(l)}(I)\right) \cdot \operatorname{vec}\left(\phi_{j}^{(l)}(I)\right)$$ $l$ ijL2GT$$\mathcal{L}_{\text {texture }}(\hat{I}, I ; \phi, l)=\frac{1}{c_{l}^{2}} \sqrt{\sum_{i, j}\left(G_{i, j}^{(l)}(\hat{I})-G_{i, j}^{(l)}(I)\right)^{2}}$$patchpatch adversarial loss SRD$$\begin{aligned}\mathcal{L}_{\text {gan_ce_g}}(\hat{I} ; D) &amp;=-\log D(\hat{I}) \ \mathcal{L}_{\text {gan_ce_d }\left(\hat{I}, I_{s} ; D\right)} &amp;=-\log D\left(I_{s}\right)-\log (1-D(\hat{I})) \\\end{aligned}$$$$\begin{aligned}\mathcal{L}_{\text{gan_ls_g}}(\hat{I} ; D) &amp;=(D(\hat{I})-1)^{2} \ \mathcal{L}_{\text{gan_ls_d}}\left(\hat{I}, I_{s} ; D\right) &amp;=(D(\hat{I}))^{2}+\left(D\left(I_{s}\right)-1\right)^{2} \end{aligned}$$hinge loss$$\begin{aligned} \mathcal{L}_{\text{gan_hi_g}}(\hat{I} ; D) &amp;=-D(\hat{I}) \ \mathcal{L}_{\text{gan_hi_d}}\left(\hat{I}, I_{s} ; D\right) &amp;=\min (0, D(\hat{I})-1)+\min \left(0,-D\left(I_{s}\right)-1\right) \\\end{aligned}$$PSNRMOS  Cycle Consistency Loss GANLRSRSRLRLRloss $$\mathcal{L}_{\text {cycle }}\left(I^{\prime}, I\right)=\frac{1}{h w c} \sqrt{\sum_{i, j, k}\left(I_{i, j, k}^{\prime}-I_{i, j, k}\right)^{2}}$$total variation loss loss$$\mathcal{L}_{\mathrm{TV}}(\hat{I})=\frac{1}{h w c} \sum_{i, j, k} \sqrt{\left(\hat{I}_{i, j+1, k}-\hat{I}_{i, j, k}\right)^{2}+\left(\hat{I}_{i+1, j, k}-\hat{I}_{i, j, k}\right)^{2}}$$prior based loss  Batch NormalizationBNbachBNSR BNBN  Curriculum learning ill-posed problem 8248  multi-supervisionloss  context-wise network fusion SRCNNstate of art data augmentation random cropping, flipping,scaling,rotation, color jittering, random shuffle RGB,RGB multi-task learning SRSRSFT-GANSRDNSRSR network interpolation pxiel losslossPSNR   zero-shot super-resolutiondegradationCNNSR weakly-supervised Super-resolutionHR-to-LRSRcycle-in-cycleLR-to-HRHR-to-LR learning degradation GANHR to LRLR-HRLR to SRGAN cycle in cycle super resolution CinCGANnoise LR -&gt; clean LR -&gt; clean HRLRSR CNNCNN  Hyperspectral Image Super-resolution  W. Huang, L. Xiao, Z. Wei, H. Liu, and S. Tang, A new pan- sharpening method with deep neural networks, GRSL, vol. 12, 2015. G. Masi, D. Cozzolino, L. Verdoliva, and G. Scarpa, Pansharp- ening by convolutional neural networks, Remote Sensing, vol. 8, 2016. Y.Wei,Q.Yuan,H.Shen,andL.Zhang,Boostingtheaccuracyof multispectral image pansharpening by learning a deep residual network, GRSL, vol. 14, 2017. Y. Qu, H. Qi, and C. Kwan, Unsupervised sparse dirichlet-net for hyperspectral image super-resolution, in CVPR, 2018.   cnn  DIV2kEDSR20s   pixel wise NormalizationBN PSNRSSIMMOSPSNRSSIMMOS degradation ]]></content>
      <categories>
        <category>super resolution</category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[]]></title>
    <url>%2F2019%2F07%2F23%2F%E4%B8%80%E4%BA%9B%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[wordppt mathpix snipperlatex https://www.latex4technics.com/ latexmathml wordmathmlword pptword jupyterjupyterjupyter jupyterjianshu.com/p/4012f7149eb8 mac jupyter notebook no-browser port=8898 ssh-N -f -L 127.0.0.1:8898:127.0.0.1:8898 zhouwenhui@remote-machine http://127.0.0.1:8898/]]></content>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xigua-]]></title>
    <url>%2F2019%2F07%2F21%2Fxigua-%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[ ]]></content>
      <categories>
        <category>xigua</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[xigua-]]></title>
    <url>%2F2019%2F07%2F20%2Fxigua-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[ 1943MP 1949Hebb   1956 1962 1969percetion 1982hopfieldhopfieldboltzmannBP 2006hiton 1943M-P $\theta$ sigmoid $$\sigma(z)=\frac{1}{1+\mathrm{e}^{-z}}$$sigmoid sigmoid $$\sigma(z)=\frac{\mathrm{e}^{-z}}{(1+\mathrm{e}^{-z})^{2}} = \frac{1+\mathrm{e}^{-z}-1}{(1+\mathrm{e}^{-z})^{2}} = \sigma(z)*(1 - \sigma(z))$$sigmoid(0,1)  Bengio hR-&gt;R $\lim_{s-&gt;\inf} f(s) = 0$ x0cxc0. ReLu relu$x&lt;0$0$x&gt;0$1 relu0 BP$\Delta$     BP pytorchtorch.nnpytorchtorch.nntorch.nn.functionaltorch.nntorch.nntorch.nn.functionaltensorVariabletorch.nntorch.nn.functional https://blog.csdn.net/hawkcici160/article/details/80140059 pytorchtorch.autogradautograd.Variable.backward().data.grad Variabletensordata,grad_fn,grad,variable https://www.jianshu.com/p/cbce2dd60120 variable]]></content>
      <categories>
        <category>xigua</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[19/7/2019 preview]]></title>
    <url>%2F2019%2F07%2F19%2F19-7-2019-preview%2F</url>
    <content type="text"><![CDATA[welcome to my blog,enter password to read. Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>dialog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[:trie]]></title>
    <url>%2F2019%2F07%2F17%2F%E5%89%8D%E7%BC%80%E6%A0%91%F0%9F%8C%B2-trie%2F</url>
    <content type="text"><![CDATA[O(m).      12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Trie(object): def __init__(self): """ Initialize your data structure here. """ self.res = &#123;&#125; def insert(self, word): """ Inserts a word into the trie. :type word: str :rtype: None """ a = self.res for i in word: if i not in a: a[i] = &#123;&#125; a = a[i] a['end'] = &#123;&#125; def search(self, word): """ Returns if the word is in the trie. :type word: str :rtype: bool """ a = self.res for i in word: if i not in a: return False a = a[i] if 'end' in a: return True else: return False def startsWith(self, prefix): """ Returns if there is any word in the trie that starts with the given prefix. :type prefix: str :rtype: bool """ a = self.res for i in prefix: if i not in a: return False a = a[i] return True # Your Trie object will be instantiated and called as such:# obj = Trie()# obj.insert(word)# param_2 = obj.search(word)# param_3 = obj.startsWith(prefix) dictkeykeyend]]></content>
      <tags>
        <tag> leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xigua:]]></title>
    <url>%2F2019%2F07%2F14%2Fxigua-%E5%86%B3%E7%AD%96%E6%A0%91%2F</url>
    <content type="text"><![CDATA[    170  entropy  0.5  $$\mathrm{H}(X)=\mathrm{E}[\mathrm{I}(X)]=\mathrm{E}[-\ln (\mathrm{P}(X))]$$$$\mathrm{H}(X)=\sum_{i} \mathrm{P}\left(x_{i}\right) \mathrm{I}\left(x_{i}\right)=-\sum_{i} \mathrm{P}\left(x_{i}\right) \log _{2} \mathrm{P}\left(x_{i}\right)$$ $$\operatorname{Gain}(D, a)=\operatorname{Ent}(D)-\sum_{v=1}^{V} \frac{\left|D^{v}\right|}{|D|} E n t\left(D^{v}\right)$$$$g_{R}(D, A)=\frac{g(D, A)}{H_{A}(D)}$$$$H_{A}(D)=-\sum_{i=1}^{n} \frac{\left|D_{i}\right|}{|D|} \log _{2} \frac{\left|D_{i}\right|}{|D|}$$  $$\operatorname{Gini}(\mathrm{p})=\sum_{k=1}^{K} p_{k}\left(1-p_{k}\right)=1-\sum_{k=1}^{K} p_{k}^{2}$$ k ]]></content>
      <categories>
        <category>xigua</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[xigua:(linear model)]]></title>
    <url>%2F2019%2F07%2F14%2Fxigua-%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B-linear-model%2F</url>
    <content type="text"><![CDATA[ $$f(x) = \omega^T x + b$$ (x,y) $\omega$ b  pytorchpipeline label torch.nn.Module__init__(),forward() criterionoptimizer step  1234import torchfrom torch.autograd import Variablex_data = Variable(torch.Tensor([[1.0],[2.0],[3.0]]))y_data = Variable(torch.Tensor([[2.0],[4.0],[6.0]])) Vari3able Tensorvariable pytorchtorch.nn.Module. torch.nn.module torch.nnlinearconvinitlinear 1234567891011121314151617class LinearRegressionModel(torch.nn.Module): """ torch.nn.Moduleinitforward: torch.nn.Module: torch.nnnnautograd nn.Modulenn,forward __init__() """ def __init__(self): super(LinearRegressionModel,self).__init__() """ torch.nn.Linear(in_features,out_features,bias=True) """ self.linear = torch.nn.Linear(1,1) # one in one out def forward(self,x): y_pred = self.linear(x) return y_pred criterion and optimizerCriterion groundTruthMSE losscrossentropytorch.nn.MSELoss() Optimizer torch.optim.SGD(linear_model.parameters(),lr = 0.01) traincriteriongroundtruth 1234567for epoch in range(500): pre = linear_model(x_data) loss = criterion(pre,label) #  optimizer.zero_grad() loss.backgrad() #  optimzer.step() evaluate 12result = linear_model(new_var)print('result &#123;&#125;'.format(result.data[0]))]]></content>
      <categories>
        <category>xigua</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Something about keras]]></title>
    <url>%2F2019%2F05%2F24%2FSomething-about-keras%2F</url>
    <content type="text"><![CDATA[PART I : keras progress prepare data,process data create model,loss,optimizer feed data to model,set hyperparamers add some callbacks method train and save model,save the log there is a example go through the process PART II: data prepare cococsvbatch size 12345def generate_func(): for i in range(10): yield ifor item in generate_func(): print(item) __next__() 1234567class generate(object): def __init__(self): pass def __next__(self): ... data processing return batch_size data 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import numpy as npimport mathfrom keras.models import Sequentialfrom keras import layers# some layer in layers Dense,Dropout,Activation,Flatten# cnn layerfrom keras.layers import Convolution2D,MaxPooling2Dfrom keras.utils import np_utils # useful to transfrom datafrom keras.datasets import mnistfrom keras.callbacks import ModelCheckpoint # save modelfrom keras import callbacksfrom keras.models import load_model# prepare data(x_train,y_train),(x_test,y_test) = mnist.load_data()print(x_train.shape)#from matplotlib import pyplot as plt#plt.imshow(x_train[0])# tensorflow input(HxWxC)x_train = x_train.reshape(x_train.shape[0],28,28,1)x_test = x_test.reshape(x_test.shape[0],28,28,1)x_train = x_train.astype('float32') /255x_test = x_test.astype('float32') /255print(x_train.shape)print(y_train.shape)# convert label to one hotprint(y_train[:10])y_train = np_utils.to_categorical(y_train,10)y_test = np_utils.to_categorical(y_test,10)print(y_train[:10])### define modelmodel = Sequential()# 32,3,3 : output channel ,kernel_sizemodel.add(Convolution2D(32,3,3,activation = 'relu',input_shape=(28,28,1)))print(model.output_shape)model.add(Convolution2D(32,3,3,activation='relu'))model.add(MaxPooling2D(pool_size = (2,2)))model.add(layers.Dropout(0.25))model.add(layers.Flatten())model.add(layers.Dense(128,activation='relu'))model.add(layers.Dropout(0.5))model.add(layers.Dense(10,activation='sigmoid'))### define loss and optimizer,and then compile itmodel.compile(loss = 'categorical_crossentropy',optimizer='adam',metrics=['accuracy'])print(model.summary())#print(model.get_config())# callbackwhen a epoch/batch_size start/end,it will be calledcheckpointer = ModelCheckpoint(filepath='best_model.h5',verbose=1,save_best_only=True)earlyStopping = callbacks.EarlyStopping(monitor='loss',patience=20,verbose=1,mode = 'auto')reduce_lr = callbacks.ReduceLROnPlateau(monitor='loss',factor = 1/math.e,verbose=1,patience=10,min_lr=0.0001)tensorboard = callbacks.TensorBoard(log_dir='./log')# write log to csvcsv_historyger = callbacks.CSVLogger('training.history',separator=',',append='True')### feed data to the network#print('exist model')#del model#print('loading model ...')#model = load_model('./best_model.h5')history = model.fit(x_train,y_train,batch_size=32,epochs=2,verbose=1,validation_data=(x_test,y_test),callbacks = [checkpointer,earlyStopping,reduce_lr,tensorboard,csv_historyger])score = model.evaluate(x_test,y_test,verbose=0)print(score)print(history.history)print(history.epoch)print(history.history['val_loss']) csvimage nameannotation]]></content>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RetinaNet ]]></title>
    <url>%2F2019%2F05%2F16%2FRetinaNet-%E5%8E%9F%E7%90%86%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[RetinaNetone stage featureanchoranchor RetinaNetone stageanticipate anchortwo stage anchorregion proposal1k2kanchorobjecteasy negativate anchor  easy negativate loss easy negativate losseasy negativate losslosseasyhardlosshard Focal Lossfocal loss cross entropy loss cross entropy lossCE losslossanchorpCE lossRetinaNetfocal loss panchor1-plosslossloss RetinaNetRetinaNetlossRetinaNetresnetbackboneFPN RetinaNetfeature mapfeature mapanchor Resnet C3C4C5P3P4P5C5P6P7 keras retinanetgithub 12345678910111213141516171819202122232425262728293031323334def __create_pyramid_features(C3, C4, C5, feature_size=256): """ Creates the FPN layers on top of the backbone features. Args C3 : Feature stage C3 from the backbone. C4 : Feature stage C4 from the backbone. C5 : Feature stage C5 from the backbone. feature_size : The feature size to use for the resulting feature levels. Returns A list of feature levels [P3, P4, P5, P6, P7]. """ # upsample C5 to get P5 from the FPN paper P5 = keras.layers.Conv2D(feature_size, kernel_size=1, strides=1, padding='same', name='C5_reduced')(C5) P5_upsampled = layers.UpsampleLike(name='P5_upsampled')([P5, C4]) P5 = keras.layers.Conv2D(feature_size, kernel_size=3, strides=1, padding='same', name='P5')(P5) # add P5 elementwise to C4 P4 = keras.layers.Conv2D(feature_size, kernel_size=1, strides=1, padding='same', name='C4_reduced')(C4) P4 = keras.layers.Add(name='P4_merged')([P5_upsampled, P4]) P4_upsampled = layers.UpsampleLike(name='P4_upsampled')([P4, C3]) P4 = keras.layers.Conv2D(feature_size, kernel_size=3, strides=1, padding='same', name='P4')(P4) # add P4 elementwise to C3 P3 = keras.layers.Conv2D(feature_size, kernel_size=1, strides=1, padding='same', name='C3_reduced')(C3) P3 = keras.layers.Add(name='P3_merged')([P4_upsampled, P3]) P3 = keras.layers.Conv2D(feature_size, kernel_size=3, strides=1, padding='same', name='P3')(P3) # "P6 is obtained via a 3x3 stride-2 conv on C5" P6 = keras.layers.Conv2D(feature_size, kernel_size=3, strides=2, padding='same', name='P6')(C5) # "P7 is computed by applying ReLU followed by a 3x3 stride-2 conv on P6" P7 = keras.layers.Activation('relu', name='C6_relu')(P6) P7 = keras.layers.Conv2D(feature_size, kernel_size=3, strides=2, padding='same', name='P7')(P7) return [P3, P4, P5, P6, P7] anchoranchor anchor-size = [32, 64, 128, 256, 512] P3P7 anchorscale = [2 xx0 2 xx(1/3 )2 xx (2/3)] anchor-wh = [1:2 1 2:1] anchoranchor-size  anchor-scaleanchoranchor Loss ]]></content>
      <categories>
        <category></category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[pytorch ]]></title>
    <url>%2F2019%2F05%2F12%2Fpytorch-%E5%BC%A0%E9%87%8F%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[pytorch  dim = 0  dim = 1  torch.cat() torch.cat dim 1234567891011121314&gt;&gt;&gt; atensor([[1., 1., 1.], [2., 2., 2.]])&gt;&gt;&gt; btensor([[3., 3., 3.], [4., 4., 4.]])&gt;&gt;&gt; torch.cat((a,b),0) # tensor([[1., 1., 1.], [2., 2., 2.], [3., 3., 3.], [4., 4., 4.]])&gt;&gt;&gt; torch.cat((a,b),1) # tensor([[1., 1., 1., 3., 3., 3.], [2., 2., 2., 4., 4., 4.]]) torch.view() torch.view  -1 12345678910111213141516&gt;&gt;&gt; atensor([[1., 1., 1.], [2., 2., 2.]])&gt;&gt;&gt; a.view(1,-1)tensor([[1., 1., 1., 2., 2., 2.]])&gt;&gt;&gt; a.view(3,-1)tensor([[1., 1.], [1., 2.], [2., 2.]])&gt;&gt;&gt; a.view(1,2,3)tensor([[[1., 1., 1.], [2., 2., 2.]]])&gt;&gt;&gt; a.view(2,1,3)tensor([[[1., 1., 1.]], [[2., 2., 2.]]]) torch.squeeze() 1dim = 0dim=1 1234567891011121314151617181920212223&gt;&gt;&gt; btensor([[[1., 1., 1.], [2., 2., 2.]]])&gt;&gt;&gt; b.shapetorch.Size([1, 2, 3])&gt;&gt;&gt; b = torch.squeeze(b,dim = 0)&gt;&gt;&gt; btensor([[1., 1., 1.], [2., 2., 2.]])&gt;&gt;&gt; b.shapetorch.Size([2, 3])&gt;&gt;&gt; b = a.view(1,2,3)&gt;&gt;&gt; btensor([[[1., 1., 1.], [2., 2., 2.]]])&gt;&gt;&gt; b.shapetorch.Size([1, 2, 3])&gt;&gt;&gt; b = torch.squeeze(b,dim = 0) #&gt;&gt;&gt; btensor([[1., 1., 1.], [2., 2., 2.]])&gt;&gt;&gt; b.shapetorch.Size([2, 3]) torch.Tensor.narrow() torch.Tensor.narrow(dim,start,length),dim01startlength 123456&gt;&gt;&gt; atensor([[1., 2., 3.], [4., 5., 5.]])&gt;&gt;&gt; a.narrow(1,1,2)tensor([[2., 3.], [5., 5.]]) torch.Tensor.permute()  1234567&gt;&gt;&gt; atensor([[1., 2., 3.], [4., 5., 5.]])&gt;&gt;&gt; a.permute(1,0)tensor([[1., 4.], [2., 5.], [3., 5.]])]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GIT]]></title>
    <url>%2F2019%2F05%2F06%2FGIT%2F</url>
    <content type="text"><![CDATA[githubgithubgitps githubrepositorygit  repositorygithubrepositoryREMEAD.mdDL_HW repository git clonegit clone git@github.com:WenHui-Zhou/DL_HW.git clonegitDL_HW .gitignore.gitignore git 123tmp # *.jpg # .DS_Store .gitignoregitignore  add and commitgitDL_HWindexhead git add * : index.gitignoreindex  git commit -m &quot;&quot;indexhead git pushGitHub git push origin master headmaster  some tip1.Git clonecloneclone 1git clone git@github.com:WenHui-Zhou/DL_HW.git --depth=1 2.clone 1git pull origin master() last ]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dog and cat -- USE tf.contrib.slim]]></title>
    <url>%2F2019%2F05%2F06%2Fdog-and-cat-USE-tf-contrib-slim%2F</url>
    <content type="text"><![CDATA[tensorflow tf.contrib.slim gaggle trainvallabellabel tfrecordtf.record:  To read data efficiently it can be helpful to serialize your data and store it in a set of files (100-200MB each) that can each be read linearly. This is especially true if the data is being streamed over a network. This can also be useful for caching any data-preprocessing. The TFRecord format is a simple format for storing a sequence of binary records. tensorflowDataset APIgraphlabeltf.record TFRecord  Example Example  protocolbuf  protocolbuf protocolbuf Google &amp;   () labeltf.recordtensorflowAPI ps: 123for i in range(10000): filename = "%05d.txt" % i open(filename, "w") i1000005]]></content>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux]]></title>
    <url>%2F2019%2F04%2F24%2Flinux%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[linux  linuxbash shell /etc/profileLinuxshell /etc/profile.d /.bash_profile()$~/.bashrc $/.bashrc/etc/bashrc Vimvim/etc/vim/vimrc/etc/vimrc~/.vimrcvim linux bashshelllinux alias iffor  cd PATH Linux  linux /bincpcd/usr/bin/usr/local/bin /lib/usr/lib/usr/local/lib /homeLinux /rootroot$HOME /etc /usr/etcHOMEHOME/etc /usr/usr/bin/usr/bin PATH /usr/local(/usr/local/bin/usr/local/include /usr/PATH/usr//home/.bashrc   python3.7python3.6python2.7]]></content>
      <tags>
        <tag>tip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell ]]></title>
    <url>%2F2019%2F04%2F10%2Fshell-%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[shell  Linuxshell shell shell#!/bin/bash /bin/bashbash bash ;  echo shell 12#!/bin/bashecho hello world shellshell  val=value val = value  echo $val  echo ${val}  HTTP_PROXY export shell PATHPATH 12echo $PATH/home/zhouwenhui/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr /games PATH : linuxPATHPATH /etc/environment  /etc/profile  ~/.bashrc  1export PATH="$PATH:/new/folder" trick 1cat a.txt | tr 'replace' 'value' replacevalue  12var=1234length=$&#123;#var&#125; UID rootUID0. shell let $. 1234567#!/bin/bashno1=4;no2=5;let result=no1+no2let no1++;let no1--;let no1+=1 [ ] let 1result=[ $no1 + no2 ]; bc 123&gt;&gt; echo "4 * 0.56" | bc&gt;&gt; 2.24&gt;&gt;result='echo "$no1 * 1.5"|bc' temp.txt 1echo "this string will be save" &gt; temp.txt  1echo "add to the file temp" &gt;&gt; temp.txt 1arr=(1,2,3,4,5,6) 1alias new_command = 'command sequence'  1echo 'alias cmd="command seq"' &gt;&gt; ~/.bashrc 12345678910111213141516function fname()&#123; statements;&#125;# fname; # #fname arg1,arg2;fname()&#123; echo $1; #  echo $2; #  echo $@; # "$1" "$2" ...&#125; for 1234for var in list;do commanddone; while 1234while condition;do commanddone; util123456x=0;until [ $x -eq 9 ];do let x++; echo $x;done 12[ condition ] &amp;&amp; action; # conditionaction[ condition ] || action; # conditionaction 12345678if condition;then commands;else if condition; then; commands;else commands;fi 12[ $var -eq 0 ] # [ $var -ne 0 ] # var0 -gt -lt -ge -le  12[ $var1 -ne 0 -a $var2 -gt 2 ] # -a[ $var1 -ne 0 -o $var2 -gt 2 ] #  -o 123456[ -f $file_name ] file_name[ -x $var ] var [ -d $var ] var[ -e $var ] var[ -w $var ] var[ -r $var ] var 12345678[[ $str1 = $str2 ]] # [[ $str1 &gt; $str2 ]] # [[ -z $str1 ]] # [[ -n $str1 ]] # if [[ -n $str1 ]] || [[ -z $str2 ]];then echo 'something'fi Linux12345678910a=$(ls)for file in $a;do if [ -f $file ]; then echo 'afile' else echo 'not file' fidone cat 1234cat file1 file2 file3cat -s file # cat -T file # cat -n file #  find12345678find base_path # bash_path find . -name 'car*' # find . \( -name "*.txt" -o -name "*.pdf" \) # find /home/ -path "*/slynux/*" # find . ! -name '*.txt' # txtfind . -maxdepth 1 -name 'f*' # 1find . -type d # flfind . -type f -name "*.swp" -delete #  find-exec 12find . -type f -name ".c" -exec &#123;&#125;\; #&#123;&#125;find . -type f -name ".jpg" -exec cp &#123;&#125; ./file/ \;#   xargsxargscommand| xargsxargsstdin]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VOC ]]></title>
    <url>%2F2019%2F04%2F09%2FVOC-%E6%95%B0%E6%8D%AE%E9%9B%86%2F</url>
    <content type="text"><![CDATA[VOCCSVCSV VOC VOC  train VOCtrainval_11-May-2012.tarVOCtrainval_06-Nov-2007.tar testVOCtest_06-Nov-2007.tar  VOCDevkit: Annotationsbox,xml ImageSetsMaintxt JPEGImages SegmentationClass SegmentationObject  scvvoccsv 1image_url,x1,y1,x2,y2,label txttraintextxml  12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import csvimport osimport globfrom PIL import Imagefrom traceback import print_excimport syscount = 1def write_anno_xml(img,annos): anno_folder = "./Annotations" im = Image.open('./JPEGImages/' + img) width, height = im.size xml_file = open((anno_folder + '/' + img.split('.')[0] + '.xml'), 'w') xml_file.write('&lt;annotation&gt;\n') xml_file.write(' &lt;filename&gt;' + img + '&lt;/filename&gt;\n') xml_file.write(' &lt;folder&gt;cartoon_VOC&lt;/folder&gt;\n') xml_file.write(' &lt;size&gt;\n') xml_file.write(' &lt;width&gt;' + str(width) + '&lt;/width&gt;\n') xml_file.write(' &lt;height&gt;' + str(height) + '&lt;/height&gt;\n') xml_file.write(' &lt;depth&gt;3&lt;/depth&gt;\n') xml_file.write(' &lt;/size&gt;\n') for anno in annos: xml_file.write(' &lt;object&gt;\n') xml_file.write(' &lt;name&gt;' + anno[-1] + '&lt;/name&gt;\n') xml_file.write(' &lt;pose&gt;Unspecified&lt;/pose&gt;\n') xml_file.write(' &lt;truncated&gt;0&lt;/truncated&gt;\n') xml_file.write(' &lt;difficult&gt;0&lt;/difficult&gt;\n') xml_file.write(' &lt;bndbox&gt;\n') xml_file.write(' &lt;xmin&gt;' + anno[0] + '&lt;/xmin&gt;\n') xml_file.write(' &lt;ymin&gt;' + anno[1] + '&lt;/ymin&gt;\n') xml_file.write(' &lt;xmax&gt;' + anno[2] + '&lt;/xmax&gt;\n') xml_file.write(' &lt;ymax&gt;' + anno[3] + '&lt;/ymax&gt;\n') xml_file.write(' &lt;/bndbox&gt;\n') xml_file.write(' &lt;/object&gt;\n') xml_file.write('&lt;/annotation&gt;') xml_file.close()for file_name in ['train','test']: ftxt = open(file_name+'.txt','w') with open(file_name+'_dataset.csv','r') as f: reader = csv.reader(f) img = '' pre_img = '' annos = [] reader = list(reader) for line in reader: if img != line[0] and img != '': # ceate soft link pos = line[0].split('/')[-1].find('.') img_id = '0'*(5-len(str(count)))+str(count) count += 1 try: os.symlink(line[0],'JPEGImages/'+img_id+line[0].split('/')[-1][pos:]) except Exception as e: print(e.__class__.__name__) print_exc() ftxt.write(img_id+'\n') write_anno_xml(img_id+line[0].split('/')[-1][pos:],annos) img = line[0] annos.clear() annos.append(line[1:]) else: img = line[0] annos.append(line[1:]) sys.stdout.write('&#123;&#125;/&#123;&#125;\r'.format(count,len(reader))) sys.stdout.flush() ftxt.close()]]></content>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pytorch ]]></title>
    <url>%2F2019%2F03%2F29%2Fpytorch-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[pytorchtrick pytorch 0 123import torchimport torch.nn as nnimport numpy as np 1 123a = torch.tensor(1.,requires_grad=True)x = torch.randn(10,3) # 10*3y = torch.randn(10,2) # 10*2 2 12345# pytorchlinear = nn.Linear(3,2) # channel3channel2print(linear.weight) # torchprint(linear.bias) 3 12criterion = nn.MSELoss()optimizer = nn.optim.SGD(linear.parameters(),lr = 0.01) 4 1234pred = linear(x)# lossloss = criterion(pred,y)print(loss) tensorflowtensorflowfeedpytorch 5 123456789# loss.backward()print('dl/dw',linear.weight.grad)print('dl/db',linear.bias.grad)# optimizeroptimizer.step() # pred = linear(x)loss = criterion(pred,y) ##  torchnumpy123456import numpy as npimport torchx = np.array([[3,2],[1,4]]) # numpy.arrayy = torch.from_numpy(x) # torch.tensorz = y.numpy() # tensor to numpy torch piplinetorchvisiontorch  torchvision.datasets: cifar torchvision.models: alexnetVGGresnet torchvision.transforms: random croprotate torchvision.utils:  torchvision.datasets batch 12345678# get the datasettrain_data = torchvision.datasets.CIFAR10(root='.',train=True,transform=torchvision.transforms.toTensor(),download = True)image,label = train_data[0]# load dataloader = torch.utils.data.Dataloader(dataset = train_data,batch_size = 64,shuffle=True)#load 64batchtrain_iter = iter(loader)image,label = train_iter.next() pytorch minist123456## train = torchvision.datasets.MNIST(root='./',train=True,transform=torchvision.transforms.ToTensor(),download = True)# data loaderdata_loader = torch.utils.data.DataLoader(dataset = train,batch_size = 100,shuffle = True)for image,label in data_loader: pass 123456789for epoch in num_epoch: for i ,(image,label) in enumerate(train_loader): output = model(image.reshape(-1,28*28)) loss = criterion(output,label) optimizer.zero_grad() # loss.backward() optimizer.step() if i+1 == 100: print('epoch:&#123;&#125;/&#123;&#125;,step:&#123;&#125;/&#123;&#125;,loss:&#123;:.4f&#125;'.format(epoch+1,num_epochs,i+1,total_step,loss)) 1234567891011# with torch.no_grad(): correct = 0 total = 0 for image,label in val_loader: output = model(image.reshape(-1,28*28)) _,predict = torch.max(output.data,1) total+= label.size(0) correct += (predict == label).sum().numpy()print('accuracy: &#123;&#125;'.format(correct/total))torch.save(model.state.dict,'model_param.ckpt') val,index = torch.max(matrix,1)matrix torch.nn torch.nntorch.nnnn.Modulenn.Module__init__(),forward() 1234567891011class NerualNet(nn.Module): def __init__(self,input_size,hidden_size,output_size): super(NerualNet,self).__init__() self.fc1 = nn.Linear(input_size,hidden_size) self.ReLu = nn.ReLU() self.fc2 = nn.Linear(hidden_size,output_size) def forward(self,x): out = self.fc1(x) out = self.ReLu(out) out = self.fc2(out) return out model = NerualNet(input_size,hidden_size,output_size)model(x)forward 1nn.Conv2d(in_channels,out_channels,kernel_size,stride=1,padding=0,dilation=1,groups=1,bias=True) sequencesequence  1234567891011121314# Example of using Sequentialmodel = nn.Sequential( nn.Conv2d(1,20,5), nn.ReLU(), nn.Conv2d(20,64,5), nn.ReLU() )# Example of using Sequential with OrderedDictmodel = nn.Sequential(OrderedDict([ ('conv1', nn.Conv2d(1,20,5)), ('relu1', nn.ReLU()), ('conv2', nn.Conv2d(20,64,5)), ('relu2', nn.ReLU()) ])) 123456# Image preprocessing modulestransform = transforms.Compose([ transforms.Pad(4), transforms.RandomHorizontalFlip(), transforms.RandomCrop(32), transforms.ToTensor()]) transforms.ToTensor() PIL image tensor (H, W, C) in range [0,255] to a torch.Tensor(C, H, W) in the range [0.0, 1.0] pytorch 12345678model = ResNet(residual,[2,2,2]).to(device)...torch.save(model,'model.ckpt') # save the structuretorch.save(model.state_dict(),'model_para.ckpt') # save the parameter# loadmodel = torch.load('model.ckpt')# resnet resnet.load_state_dict(torch.load('model_para.ckpt')) resent1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# Residual blockclass ResidualBlock(nn.Module): def __init__(self, in_channels, out_channels, stride=1, downsample=None): super(ResidualBlock, self).__init__() self.conv1 = conv3x3(in_channels, out_channels, stride) self.bn1 = nn.BatchNorm2d(out_channels) self.relu = nn.ReLU(inplace=True) self.conv2 = conv3x3(out_channels, out_channels) self.bn2 = nn.BatchNorm2d(out_channels) self.downsample = downsample def forward(self, x): residual = x out = self.conv1(x) out = self.bn1(out) out = self.relu(out) out = self.conv2(out) out = self.bn2(out) if self.downsample: residual = self.downsample(x) out += residual out = self.relu(out) return out# ResNetclass ResNet(nn.Module): def __init__(self, block, layers, num_classes=10): super(ResNet, self).__init__() self.in_channels = 16 self.conv = conv3x3(3, 16) self.bn = nn.BatchNorm2d(16) self.relu = nn.ReLU(inplace=True) self.layer1 = self.make_layer(block, 16, layers[0]) self.layer2 = self.make_layer(block, 32, layers[1], 2) self.layer3 = self.make_layer(block, 64, layers[2], 2) self.avg_pool = nn.AvgPool2d(8) self.fc = nn.Linear(64, num_classes) def make_layer(self, block, out_channels, blocks, stride=1): downsample = None if (stride != 1) or (self.in_channels != out_channels): downsample = nn.Sequential( conv3x3(self.in_channels, out_channels, stride=stride), nn.BatchNorm2d(out_channels)) layers = [] layers.append(block(self.in_channels, out_channels, stride, downsample)) self.in_channels = out_channels for i in range(1, blocks): layers.append(block(out_channels, out_channels)) return nn.Sequential(*layers) def forward(self, x): out = self.conv(x) out = self.bn(out) out = self.relu(out) out = self.layer1(out) out = self.layer2(out) out = self.layer3(out) out = self.avg_pool(out) out = out.view(out.size(0), -1) out = self.fc(out) return out residualresidualresnetresidualnn.moduleresnet 12out = out.view(out.size(0),-1) # flattenreshapeout = out.shape(out.size(0),-1) resentevaluatemodel.eval()bndropout pytorchLSTM1234567891011121314151617181920# Recurrent neural network (many-to-one)class RNN(nn.Module): def __init__(self, input_size, hidden_size, num_layers, num_classes): super(RNN, self).__init__() self.hidden_size = hidden_size self.num_layers = num_layers self.lstm = nn.LSTM(input_size, hidden_size, num_layers, batch_first=True) self.fc = nn.Linear(hidden_size, num_classes) def forward(self, x): # Set initial hidden and cell states h0 = torch.zeros(self.num_layers, x.size(0), self.hidden_size).to(device) c0 = torch.zeros(self.num_layers, x.size(0), self.hidden_size).to(device) # Forward propagate LSTM out, _ = self.lstm(x, (h0, c0)) # out: tensor of shape (batch_size, seq_length, hidden_size) # Decode the hidden state of the last time step out = self.fc(out[:, -1, :])#  return out LSTM 12345nn.LSTM(input_size,hidden_size,num_layersbatch_first=True)# input_size # hidden_size # num_layer LSTM# batch_first LSTMhcbatch hhidden 12345h0 = torch.zeros(self,num_layers,x.size(0),self.hidden_size)# hidden# num_layers# batch_size=x.size(0) batch# hidden_size: hidden c 12c0 = torch.zeros(self.num_layers,x.size(0),self.hidden_size)#   1out,(hn,cn) = self.lstm(x,(h0,c0)) train.py :  1argparsemodel 1234if __name__ = '__main__': parse = argparse.ArgumentParser() parse.add_element('--model_path',type=str,default='./models',help='saving training model') ... 2main()  123456789101112131415161718192021222324# image progressingtransform = transforms.Compose([ transforms.RandomCrop(args.crop_size), trnasforms.RandomHorizontalFlip(), ...])# build data loader# torch.utils.data.Dataset__init____getitem__data_loader = get_loader(args.image_dir, args.caption_path, vocab,transform, args.batch_size,shuffle=True, num_workers=args.num_workers) # build the model# modelnn.Moduleencoder = EncoderCNN(args.embed_size).to(device)decoder = DecoderRNN(args.embed_size, args.hidden_size, len(vocab), args.num_layers).to(device)# lossoptimizercriterion = nn.CrossEntropyLoss() params = list(decoder.parameters()) + list(encoder.linear.parameters()) + list(encoder.bn.parameters()) optimizer = torch.optim.Adam(params, lr=args.learning_rate) ## train the model,data loaderfor epoch in range(args.num_epochs): # batch]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSD ]]></title>
    <url>%2F2019%2F03%2F29%2FSSD-%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[SSDone-stageFaster RCNNYOLOV1SSDpytorchSSDflag SSDpytorchtorch.utils.data.Dataset(torch.nn.Module)  pytorch Dataset DataLoader DataLoaderIter DatasetDatasetLoaderDataLoaderDataLoaderIter pytorch 1 torch.utils.data.Dataset Dataset__len__()__getitem__() 12345678910111213141516import torchimport torch.utils.data as datadata_set = &#123;1:'a',2:'b',3:'c'&#125;class CustomDataset(data.Dataset):#data.Dataset def __init__(self): # 1. Initialize file path or list of file names. self.data = data_set def __getitem__(self, index): # label # fliptorchvision.Transform). # (image,label)pair # init()csv_reader,list return index, self.data[index] def __len__(self): return len(self.data) Datasetimglabellistgenerator __getitem__() torchvision.transformsResize , RandomCrop , Normalize , ToTensor (, PILnumpytorch.Tensor 2dataLoader dataLoader 1class torch.utils.data.DataLoader(dataset, batch_size=1, shuffle=False, sampler=None, batch_sampler=None, num_workers=0, collate_fn=&lt;function default_collate&gt;, pin_memory=False, drop_last=False) datasetdatasetbatch_sizenum_workers1collate_fn batchlambda dataLoader__iter__() dataLoaderdataLoaderIter  1234567dataset = CustomClass()dataloader = data.DataLoader(dataset,batch_size = 10,...)for data in dataloader: # data[0] # data[1] # 10 pass pytorch nn.Module pytorchnn.Modulenn.Module __init__()  forward()nn.Linear 12345678910class MyLinear(nn.Module): def __init__(): super(MyLinear,self).__init__() self.w = nn.Parameter(torch.randn(outp,inp)) self.b = nn.Parameter(torch.randn(outp)) def forward(self,x): x = x @ self.w.t() + self.b return x pytorch nn.conV2d nn.MaxPool2d nn.ReLu nn.BatchNorm2d nn.Sequential 1234567self.net = nn.Sequential( nn.Conv2d(in_size,out_size,kernel_size,1,1) nn.MaxPool2d(2,2) nn.ReLu() nn.BatchNorm2d(32) ...)  nn.Modulenn.parameters() nn.module  SSD github 1 csvcsvgithubpycocotooldata.DatasetdataLoader 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import torchimport torch.utils.data as dataimport torchvision.transforms as transformsimport csvimport numpy as npimport cv2# csvurl,x1,y1,x2,y2,labelTRAIN_ROOT = './data/train_dataset.csv'VAL_ROOT = './data/val_dataset.csv'def detection_collate(batch): targets = [] imgs = [] for sample in batch: imgs.append(sample[0]) targets.append(sample[1]) return imgs,targetsclass csv_loader(data.Dataset): def __init__(self,data_root,transform = transforms.ToTensor()): self.data_root = data_root self.dataset = &#123;&#125; self.imgs_index = &#123;&#125; self.transform = transform self.index = 0 with open(self.data_root,'r') as f: lines = csv.reader(f) for line in lines: if line[0] in self.dataset: self.dataset[line[0]].append(line[1:5]) else: self.dataset[line[0]] = [line[1:5],] self.imgs_index[self.index] = line[0] self.index += 1 def __getitem__(self,index): img_path = self.imgs_index[index] label = self.dataset[img_path] img = cv2.imread(img_path) img = self.transform(img) for i in range(len(label)): label[i][0] = float(label[i][0]) label[i][1] = float(label[i][1]) label[i][2] = float(label[i][2]) label[i][3] = float(label[i][3]) label = np.array(label) return img,label def __len__(self): return self.index+1dataset = csv_loader(TRAIN_ROOT)dataloader = data.DataLoader(dataset,batch_size = 2,collate_fn = detection_collate)for img,label in dataloader: print(img) print(label) break detection_collatebatch size 2  ssdbackbonevggvgg vgg backbone 12345base = &#123; '300': [64, 64, 'M', 128, 128, 'M', 256, 256, 256, 'C', 512, 512, 512, 'M', 512, 512, 512], '512': [],&#125; hard negative miningSSD feature map64GTIoU0.50.3 1:3hard negative miningnegative hard negative hard negative mining(false positive )losslabelpredictionhard negative/ nn.Moduleinitforward 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#!/usr/bin/env python #-*- coding: utf-8 -*-import torchimport torch.nn as nn# channelbase = [64,64,'M',128,128,'M',256,256,256,'C',512,512,512,'M',512,512,512] # MfloorMaxpoolingCceilMaxpooling# vggextras = [256,'S',512,128,'S',256,128,256,128,256]#mboxes = [4,6,6,6,4,4]def vgg(base,input_channel,batch_norm=None): ''' base: channel input_channel batch_normbn listbase ''' layers = [] in_channels = input_channel for v in base: if v == 'M':# maxpooling layers += [nn.MaxPool2d(kernel_size=2,stride=2)] elif v == 'C': layers += [nn.MaxPool2d(kernel_size=2,stride=2,ceil_mode=True)] else: conv2d = nn.Conv2d(in_channels,v,kernel_size=3,padding=1) if batch_norm: layers += [conv2d,nn.BatchNorm2d(v),nn.ReLU(inplace=True)] # inplace=True input else: layers += [conv2d,nn.ReLU(inplace=True)] in_channels = v pool5 = nn.MaxPool2d(kernel_size=3,stride=1,padding=1) conv6 = nn.Conv2d(512,1024,kernel_size=3,padding=6,dilation=6) conv7 = nn.Conv2d(1024,1024,kernel_size=1) layers += [pool5,conv6,nn.ReLU(inplace=True),conv7,nn.ReLU(inplace=True)] return layersdef add_extras(extras,in_channel,batch_norm=None): # extra layers added to vgg for feature scaling layers = [] in_channels = in_channel flag = False for k,v in enumerate(extras): if in_channels!='S': if v == 'S': layers += [nn.Conv2d(in_channels,extras[k+1],kernel_size=(1,3)[flag],stride=2,padding=1)] else: layers += [nn.Conv2d(in_channels,v,kernel_size=(1,3)[flag])] flag = not flag in_channels = v return layersdef multibox(vgg,extras_layers,mbox,num_classes): loc_layers = [] conf_layers = [] vgg_source = [21,-2] # vgg21conv4_3,-2fc7 for k,v in enumerate(vgg_source): loc_layers += [nn.Conv2d(vgg[v].out_channels,mbox[k]*4,kernel_size=3,padding=1)] # location  conf_layers += [nn.Conv2d(vgg[v].out_channels,mbox[k]*num_classes,kernel_size=3,padding=1)] # class_num for k,v in enumerate(extras_layers[1::2],2): # extrasbounding box loc_layers += [nn.Conv2d(v.out_channels,mbox[k]*4,kernel_size=3,padding=1)] conf_layers += [nn.Conv2d(v.out_channels,mbox[k]*num_classes,kernel_size=3,padding=1)] return vgg,extras_layers,(loc_layers,conf_layers)class priorBox(obejct): """ feature map """ def __init__(self,cfg): # config self.image_size = cfg['min_dim'] self.num_priors = len(cfg['aspect_ratios']) self.variance = cfg['variance'] or [0.1] self.feature_maps = cfg['feature_maps'] self.min_sizes = cfg['min_sizes'] self.max_sizes = cfg['max_sizes'] self.steps = cfg['steps'] self.aspect_ratios = cfg['aspect_ratios'] self.clip = cfg['clip'] self.version = cfg['name'] for v in self.variance: if v &lt;= 0: raise ValueError('Variances must be greater than 0') def forward(self): mean = [] for k ,f in enumerate(self.feature_maps): f_k = self.image_size / self.steps[k] s_k = self.min_sizes[k] / self.image_size s_k_prime = sqrt(s_k*(self.max_sizes[k]/self.image_size)) for i,j in product(range(f),repeat=2): # unit center x,y cx = (j + 0.5) / f_k cy = (i + 0.5) / f_k #aspect_ratio: 1 mean += [cx,cy,s_k,s_k] mean += [cx,cy,s_k_prime,s_k_prime] for ar in self.aspect_ratios[k]: mean += [cx,cy,s_k*sqrt(ar),s_k/sqrt(ar)] mean += [cx,cy,s_k/sqrt(ar),s_k*sqrt(ar)] # back to torch land output = torch.Tensor(mean).view(-1,4) if self.clip: output.clamp_(max=1,min=0) return outputclass SSD(nn.Module): def __init__(self,phase,size,base,extras,head,num_classes): ''' phase: train,test size: ssd base: vgg extras: vgg head: locconf boxes ''' super(SSD,self).__init__() self.phase = phase self.num_classes = num_classes self.cfg = (coco,voc)[num_classes == 21] # config.py  self.priorbox = PriorBox(self.cfg) self.priors = Variable(self.priorbox.forward(),volatile=True) self.size = size ## ssd net self.vgg = nn.ModuleList(base) self.L2Norm = L2Norm(512,20) self.extras = nn.ModuleList(head[1]) self.loc = nn.ModuleList(head[0]) self.conf = nn.ModuleList(head[1]) if phase == 'test': self.softmax = nn.Softmax(dim = -1) ## detection.py self.detect = Detect(num_classes,0,200,0.01,0.45) def forward(self,x): sources = list() loc = list() conf = list() # apply vgg to conv4_3 relu for k in range(23): x = self.vgg[k](x) s = self.L2Norm(x) sources.append(s) # apply vgg up to fc7 for k in range(23,len(self.vgg)): x = self.vgg[k](x) sources.append(x) # apply extra layers for k,v in enumerate(self,extras): x = F.relu(v(x),inplace=True) if k%2 == 1: sources.append(x) for (x,l,c) in zip(sources,self.loc,self.conf): loc.append(l(x).permute(0,2,3,1).contiguous()) conf.append(c(x).permute(0,2,3,1).contiguous()) loc = torch.cat([o.view(o.size(0),-1) for o in loc],1) conf = torch.cat([o.view(o.size(0),-1) for o in conf],1) if self,phase == 'test': output = self.detect( loc.vire(loc.size(0),-1,4), self.softmax(conf.view(conf.size(0),-1,self.num_classes)), self.priors.type(type(x.data)) ) else: output = ( loc.view(loc.size(0),-1,4), conf,vire(conf.size(0),-1,self.num_classes), self.priors ) return output def load_weights(self,base_file): other,ext = os.path.splitext(base_file) if ext == '.pkl' or '.pth': self.load_state_dict(torch.load(base_file, map_location=lambda storage,loc:storage)) else: print('sorry wrong')def build_ssd(phase,size=300,num_classes=21): if phase != 'test' and phase != 'train': print('error') return if size != 300: print('error') return base_,extras_,head_ = multibox(vgg(base[str(size)],3),add_extras(extras[str(size)],1024), mbox[str(size)],num_classes) return SSD(phase,size,base_,extras_,head_,num_classes)]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mAP]]></title>
    <url>%2F2019%2F03%2F22%2F%E6%89%8B%E6%92%95mAP%2F</url>
    <content type="text"><![CDATA[mAPCOCOAPImAPpycocotoolsmAPRetina-net mAPmAP mean Average Precision, APCOCO80+1APmAPAP APAPPRprecision-recallx PricisionTP/TP+FPTP RecallTP/TP+FN TPFPTNFNTFPN TP FP TN FN GTPASCALIoU0.50.5 IoUGT / mAP-IoU[0.5, 0.95]COCOIOU[0.5, 0.95]0.05IoU10IoUmAP10mAP  IoUGTGTGT+IoU APAP precisionrecallAP IoUPrecisionRecallAP csv 1/path/to/1.jpg,10,78,25,34,face,0.9 x,y,w,h)label GT 1/path/to/1.jpg,15,80,30,32,face   precisionrecall 1all_detections = [img_index][label][box_index] labellabel csvdcitlabelboxesdict 1234[ img1:&#123;label1:[[box1],[box2]...],label2:[[box1],[box2]...]..&#125; img2:&#123;label1:[[box1]]&#125; ] list[],keyvallabelboxeskeylabelvalboxeslist csv 1234567891011121314151617181920212223242526272829303132import csvimg_name = &#123;&#125; # imgId: 1boxes_label_scores = &#123;&#125; # imgId: [[x,y,w,h,score],...]class_num = 1 # pre_gt_csv = 'score_mintest.csv' with open(pre_gt_csv,'r') as f: reader = csv.reader(f) lines = list(reader) for line in lines: if len(line) &lt; 7: line.append('1') # GT1 if float(line[-1]) &lt; score_threshold: continue if line[0] not in img_name.keys(): img_name[line[0]] = 1 temp = line[1:5] temp.append(line[-1]) # [x,y,w,h,score] box_dict = &#123;&#125; box_dict[line[5]] = [temp] # label:[[],[]] #&#123;img: &#123;label_name:[x,y,w,h,socre],[x2,y2,w2,h2,score2]...&#125;,img:&#123;...&#125;.. &#125; boxes_label_scores[line[0]] = box_dict else: # the image is exist temp = line[1:5] temp.append(line[-1]) if line[5] in boxes_label_scores[line[0]].keys(): boxes_label_scores[line[0]] [line[5]].append(temp) else: boxes_label_scores[line[0]][line[5]] = [temp] IoUboxes_label_scoresboxes() 123456for img in boxes_label_scores: labels = boxes_label_scores[img] for label in labels.keys(): boxes = boxes_label_scores[img][label] boxes = sorted(boxes, key=lambda x: float(x[-1]),reverse=True) boxes_label_scores[img][label] = boxes keylabelall_detectionslistlabel IdGT label 0  1234567891011# all_detections : [img1[label1],[label2]..] ; img2: label1,label2...all_detections = [[None for i in boxes_label_scores[img].keys()] for img in boxes_label_scores.keys()] #inds_keys = list(img_name.keys()) # [img1,img2,...n-1]inds = img_name.keys() # id# indfor ind,img in (enumerate(inds)): # img_name  # index label for index,label in enumerate(boxes_label_scores[img].keys()): all_detections[ind][index] = boxes_label_scores[img][label] ## indindex0return all_detections precisionrecall TPFPTNFNlabelAP precisionrecallTPGTlabelTPFP 1234567891011121314151617181920212223242526272829inds = list(range(len(img_name.keys()))) # id for label in range(class_num): # false_positives = np.zeros((0,)) # precision = TP/TP+FPRecall = TP/TP+FN true_positives = np.zeros((0,)) scores = np.zeros((0,)) num_annotations = 0.0 for i in inds: detections = all_detections[i][label] # imageiclasslabel annotations = all_annotations[i][label] num_annotations += len(annotations) #.shape[0] # boxes detected_annotations = [] for d in detections: scores = np.append(scores, float(d[4])) #if annotations.shape[0] == 0: if len(annotations) == 0: # label0 false_positives = np.append(false_positives, 1) true_positives = np.append(true_positives, 0) continue overlaps = compute_overlap(np.expand_dims(d, axis=0), annotations) assigned_annotation = np.argmax(overlaps, axis=1) max_overlap = overlaps[0, assigned_annotation] if max_overlap &gt;= iou_threshold \ and assigned_annotation not in detected_annotations: # IoU false_positives = np.append(false_positives, 0) # FP += 0 true_positives = np.append(true_positives, 1) # TP += 1 detected_annotations.append(assigned_annotation) else: #  false_positives = np.append(false_positives, 1) true_positives = np.append(true_positives, 0) false_positivestrue_positivesTPFP10 1false_positives = [0,1,0,1,1,1] # 01 APPR  labelAPPRAPPRPRrecallxprecisionyPRPRPR 1234567891011121314151617 # no annotations -&gt; AP for this class is 0 (is this correct?)if num_annotations == 0: average_precisions[label] = 0, 0 continue # sort by scoreindices = np.argsort(-scores)false_positives = false_positives[indices] true_positives = true_positives[indices]# compute false positives and true positivesfalse_positives = np.cumsum(false_positives) # true_positives = np.cumsum(true_positives)# compute recall and precision num_annotationsrecall = true_positives / num_annotationsprecision = true_positives / np.maximum(true_positives + false_positives, np.finfo(np.float64).eps) scoresPR1nTPFPTPFP AP AP0711 Calculating the interpolation performed in all pointsgithubPrecisionRecall precisionprecisionmpre[i - 1] = np.maximum(mpre[i - 1], mpre[i])precision,  12345678910111213141516171819202122232425def _compute_ap(recall, precision): """ Compute the average precision, given the recall and precision curves. Code originally from https://github.com/rbgirshick/py-faster-rcnn. # Arguments recall: The recall curve (list). precision: The precision curve (list). # Returns The average precision as computed in py-faster-rcnn. """ # correct AP calculation # first append sentinel values at the end mrec = np.concatenate(([0.], recall, [1.])) mpre = np.concatenate(([0.], precision, [0.])) # compute the precision envelope for i in range(mpre.size - 1, 0, -1): mpre[i - 1] = np.maximum(mpre[i - 1], mpre[i]) # to calculate area under PR curve, look for points # where X axis (recall) changes value i = np.where(mrec[1:] != mrec[:-1])[0] # and sum (\Delta recall) * prec ap = np.sum((mrec[i + 1] - mrec[i]) * mpre[i + 1]) return ap IoUPrecisionRecallIoUIoUGTIoUIoUGT 1234import compute_overlapoverlaps = compute_overlap(np.expand_dims(d, axis=0), annotations) assigned_annotation = np.argmax(overlaps, axis=1) max_overlap = overlaps[0, assigned_annotation] compute_overlap.so.coverlapgithubretina-netfast rcnn GT mAPboxpred_csv, GT_csvAP]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python Tip]]></title>
    <url>%2F2019%2F03%2F20%2Fpython-Tip%2F</url>
    <content type="text"><![CDATA[123astr = '1234'astr.find('1') # -1astr.rfind('1') #  python lambda 12345678910g = lambda x:x+1 # xx+1: g(1) = 2# python lambda# foo =[2, 18, 9, 22, 17, 24, 8, 12, 27]# [18, 9, 24, 12, 27]filter(lambda x:x%3 ==0,foo)# map,foo#[14, 46, 28, 54, 44, 58, 26, 34, 64]map(lambda x: x * 2 + 10, foo)#reduce reduce(lambda x, y: x + y, foo) 123from PIL import Imageim = Image.open('whatever.png')width, height = im.size python 123456class Animal(object): def __init__(self,name): self.name = name self.__sex = man ## _  def greet(self): print('hello'+self.name) python__ver__,_name, dog = Animal(&#39;dog&#39;): type(dog) dog isinstance(dog,Animal) dog hasattr(obj, attr) attr/ getattr(obj,attr[,default]): setattr(obj, attr, value):  dir(dog): dog  1234567class A(object): @classmethod def class_info(cls): print(cls) @staticmethod def static_info(): print('something') python__new__ __new__(cls): __new__(cls)__init__() __str__: print(dog),&lt;__main__.Animal object at 0x10c37aa50&gt;,__str__  __repr__: print 1234567class A(object): def __str__(self): return 'Animal object (name: %s)' % self.name def __repr__(self): return 'lalal'print(Animal(dog)) ## __str__()Animal(dog) ##  __repr__() __iter__(),__next__(): ,__iter__() nextiter __geitem__ __setitem__ __delitem__  123456789101112131415161718192021class Point(object): def __init__(self): self.coordinate = &#123;&#125; def __str__(self): return "point(%s)" % self.coordinate def __getitem__(self, key): return self.coordinate.get(key) def __setitem__(self, key, value): self.coordinate[key] = value def __delitem__(self, key): del self.coordinate[key] print 'delete %s' % key def __len__(self): return len(self.coordinate) __repr__ = __str__  1234567891011121314151617&gt;&gt;&gt; p = Point()&gt;&gt;&gt; p['x'] = 2 #  p.__setitem__('x', 2)&gt;&gt;&gt; p['y'] = 5 #  p.__setitem__('y', 5)&gt;&gt;&gt; p #  __repr__point(&#123;'y': 5, 'x': 2&#125;)&gt;&gt;&gt; len(p) #  p.__len__2&gt;&gt;&gt; p['x'] #  p.__getitem__('x')2&gt;&gt;&gt; p['y'] #  p.__getitem__('y')5&gt;&gt;&gt; del p['x'] #  p.__delitem__('x')delete x&gt;&gt;&gt; ppoint(&#123;'y': 5&#125;)&gt;&gt;&gt; len(p)1 __getattr__()   __getattr__  __setattr__, __delattr__ obj.attr = value, del obj.attr: 12345678910111213141516171819202122232425262728293031323334353637383940class Point(object): def __init__(self, x=0, y=0): self.x = x self.y = y def __getattr__(self, attr): if attr == 'z': return 0 raise AttributeError("Point object has no attribute %s" % attr) def __setattr__(self, *args, **kwargs): print 'call func set attr (%s, %s)' % (args, kwargs) return object.__setattr__(self, *args, **kwargs) def __delattr__(self, *args, **kwargs): print 'call func del attr (%s, %s)' % (args, kwargs) return object.__delattr__(self, *args, **kwargs)&gt;&gt;&gt; p = Point(3, 4)call func set attr (('x', 3), &#123;&#125;)call func set attr (('y', 4), &#123;&#125;)&gt;&gt;&gt; p.z0&gt;&gt;&gt; p.z = 7call func set attr (('z', 7), &#123;&#125;)&gt;&gt;&gt; p.z7&gt;&gt;&gt; p.wTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "&lt;stdin&gt;", line 8, in __getattr__AttributeError: Point object has no attribute w&gt;&gt;&gt; p.w = 8call func set attr (('w', 8), &#123;&#125;)&gt;&gt;&gt; p.w8&gt;&gt;&gt; del p.wcall func del attr (('w',), &#123;&#125;)&gt;&gt;&gt; p.__dict__&#123;'y': 4, 'x': 3, 'z': 7&#125; __call__ , 12345class A(object): def __call__(self): return 1+1a = A()a() # __call__  __slots__  Python  12345678class Point(object): __slots__ = ('x', 'y') #  x  y def __init__(self, x=0, y=0): self.x = x self.y = ya = Point()a.z = 1 # x,y @property@setter  1234567891011121314151617181920212223242526class Exam(object): def __init__(self, score): self._score = score @property def score(self): return self._score @score.setter def score(self, val): if val &lt; 0: self._score = 0 elif val &gt; 100: self._score = 100 else: self._score = val&gt;&gt;&gt; e = Exam(60)&gt;&gt;&gt; e.score60&gt;&gt;&gt; e.score = 90&gt;&gt;&gt; e.score90&gt;&gt;&gt; e.score = 200&gt;&gt;&gt; e.score100 super():super 12345678910class Animal(object): def __init__(self, name): self.name = name def greet(self): print111class Dog(Animal): def greet(self): super().greet() print 'WangWang...'  1234567891011121314151617class PrefixMetaclass(type): def __new__(cls, name, bases, attrs): #  my_ _attrs = (('my_' + name, value) for name, value in attrs.items()) _attrs = dict((name, value) for name, value in _attrs) #  _attrs['echo'] = lambda self, phrase: phrase #  echo  return type.__new__(cls, name, bases, _attrs)class Foo(metaclass=PrefixMetaclass): name = 'foo' def bar(self): print 'bar'class Bar(Foo): prop = 'bar'  123456789101112class Fib(object): def __init__(self): self.a, self.b = 0, 1 #  def __iter__(self): return self #  def __next__(self): self.a, self.b = self.b, self.a + self.b return self.a __iter__() __next__()  1234567891011&gt;&gt;&gt; def fib():... a, b = 0, 1... while True:... a, b = b, a + b... yield a...&gt;&gt;&gt; f = fib()&gt;&gt;&gt; for item in f: # yieldf.next()yield... if item &gt; 10:... break... print item Python OS123456789101112131415import osfor dir in os.listdir('./'): #  print(dir)os.path.abspath('.') # os.path.dirname('file.txt') # os.path.basename('./path/to/file.txt') # file.txtos.path.splitext('afile.txt') # (afile,txt),os.path.split('/path/file.txt')# (path,file.txt)os.path.isfile/os.path.isdir() ###for root, dirs, files in os.walk('/Users/ethan/coding'): print root print dirs print files python zip123a = [1,2,3]b = [4,5,6]zipped = zip(a,b)#[(1,4),(2,5),(3,6)] print 12345with open('afile.txt','w') as f: a = 'this is a string' b = 11 print &gt;&gt; a,b## a,bafile.txt  sys.stdout 12sys.stdout.write('&#123;&#125;/&#123;&#125;\r'.format(step,len(lines)))# sys.stdout.flush() #  xlsx123456789101112131415161718import xlrdXLSX_PATH = './video_id.xlsx'workbook = xlrd.open_workbook(XLSX_PATH)print(workbook.sheet_names()) #id_list = []for sheet in workbook.sheet_names(): booksheet = workbook.sheet_by_name(sheet) #  col = booksheet.col_values(0)[1:] #  id_list += col print('sheet name: '+ sheet) print(col)print('total account:' +str(len(id_list)))from_slsx_get_video(id_list) progressbar 1234from progress import *progress = ProgressBar()for i in progress(range(1000)): pass python enumerate12for i,label in enumerate(labels): print(i,label) python argsort()argsortnumpy 1234import numpy as npa = np.array([1,2,4,-1])sort_index = np.argsort(a)a = a[b] #  numpy cumsum()cumsum() 123import numpy as npa = np.array([1,2,3])b = np.cumsum(a) # b = [1,3,6] numpy maximum() 1234import numpy as npa = np.array([1,2,3])b = np.array([2,2,2])c = np.maximum(a,b) # c = [2,2,3] python 123a = [3,2,4]a.sort() # asorted(a) # a Python python inlisttuplestr list listlist()strtuplelistlist index1234# index nums = [1,2,3,4,5,6,7]nums.index(2)nums.index(9) #  count12# nums.count(1) append123# nums.append(8)nums.append([9,8]) # [9,8] nums = [1,2,..,[8,9]] extend1234567# lista = [1,2,3]b = [4,5,6]a.extend(b) # a = [1,2,3,4,5,6]## extend a.extend(3) # a.extend([3]) insert123#insert(pos,val)a = [1,2,3]a.insert(1,4) # a = [1,4,2,3] pop1234# list,a = [1,2,3,4]a.pop() # a = [1,2,3]a.pop(1) # a = [1,3] remove1234# remove(val) listvala = [1,2,2,3,3,4]a.remove(2) # a = [1,2,3,3,4]a.remove(8) # list reverse123# a = [1,2,3]a.reverse() # a = [3,2,1] sort12345678910111213141516# listlista = [3,1,2]a.sort() # a, a = [1,2,3]a.sort(reverse=True) # # keystudent_tuples = [ ('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10),]sorted(student_tuples,key=lambda student:student[2])# cmp def compare(x,y): return x-ysorted(alist,cmp = compare) sorted123# listaa = [3,1,2]sorted(a) # [1,2,3]a tupletuple() 1234a = (1,2,3)b = (1,) # c =() # tuple #   find12345# findastr = 'this is a dog'astr.find('is') # astr.find('is',4) # astr.find('is',4,7) #  split123# split a = 'a,b,c,d'a.split(',') # list join123# join split','.join(['1','2','3']) # '1,2,3'''.join(['a','b','c']) # abc strip12345# a = ' sdssd 'a.strip() # a = 'sdssd'a = '##sadsd sasd%%%'a.strip('#%') # #% replace123# a = 'this is a dog'a.replace('is','isnt') # a = 'this isnt a dog' lower/upper123# a = 'ABC'a.lower() # abca dict dictkey-value  1234567adict = &#123;&#125;adict['a'] = 1# for k in adict: print(k,adict[k])for k in adict.keys(): print(k,adict[k])  12345d = &#123;&#125;d['a'] = 1d['b'] = 2if 'b' in d: print('b is a key') clear1d.clear() #  copy12345# d2 = d1.copy() # d2d1# from copy import deepcopyd2 = deepcopy(d1) # d2d1 get123#d.get('key_val') # Noned.get('key_val''default val') # default val update1234#a = &#123;'a':1&#125;b = &#123;'b':2&#125;b.update(a) # b = &#123;'a':1,'b':2&#125; Items,keys,values12345678#itemsdictlistkeyskeylistd = &#123;'a':1,'b':2,'c':3&#125;for k ,v in d.items(): passfor k in d.keys(): passfor v in d.values(): pass pop1234#keyd = &#123;'a':1,'b':2&#125;d.pop('a') # aval 1d.popitem() #  1234student = [&#123;'name': 'john', 'score': 'B', 'age': 15&#125;, &#123;'name': 'jane', 'score': 'A', 'age': 12&#125;, &#123;'name': 'dave', 'score': 'B', 'age': 10&#125;]sorted(student,key = lambda stu:stu['age']) setset 123456a = set()a.add('0') # #for e in a: print(e)e.remove('0') #  1234567s1 = &#123;1,2,3&#125;s2 = &#123;3,4,5&#125;s3 = s1&amp;s2 # s3 = &#123;3&#125;s4 = s1|s2 # s4 = &#123;1,2,3,4,5&#125;s5 = s1 - s2 # s5 = &#123;1,2&#125;# s1.issubset(s2) # s1s2 12345def func(x, y, z=0, *args, **kwargs): pass# x,yz# *args list#**kwargs dict map1234def square(x): return xa = [1,2,3]map(square,a) # [1,4,9] reduce1reduce(lambda x, y: x * y, [1, 2, 3, 4]) #  ((1 * 2) * 3) * 4 filter1filter(lambda x: x &lt; 'g', 'hijack') #  ac 12345678def makeitalic(func): def wrapped(): return "&lt;i&gt;" + func() + "&lt;/i&gt;" return wrapped@makeitalicdef hello(): return 'hello world' hellomakeitalichello pdb pythonpdb 1234567import pdb a = "aaa"pdb.set_trace() b = "bbb"c = "ccc"final = a + b + c print final set_trace()n + enterqprint 11 1l  1ll  12b line-numbertbreak line-number #   12cl # cl line-number #   1p expression  123456n s r c unt line-number line-numbera  pythonpython.. . module__name__ 123456package/ __init__.py subpackage1/ __init__.py moduleX.py moduleA.py packagemoduleX.py__name__.package.subpackage1.moduleXmoduleXmoduleAfrom .. import moduleA top-level scriptname__main__  python 1234567from traceback import print_exctry: if something wrongexcept Exception, e: print 'type is:', e.__class__.__name__ print_exc() # print "exception happened!"]]></content>
      <tags>
        <tag>tip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Faster RCNN ]]></title>
    <url>%2F2019%2F03%2F16%2FFaster-RCNN-%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[Faster RCNNbenchmarkFaster RCNNFaster RCNNgithubrepo .so.soLinuxELFDLL.so .o,windows.obj .a,.o,  pycocotools:cocoapi 1pip install 'git+https://github.com/cocodataset/cocoapi.git#subdirectory=PythonAPI' tensorpack readme COCO train2017json 1234567&#123; "info": info, "licenses": [license], "images": [image], "annotations": [annotation], "categories": [category]&#125; info,licenses images 1234567891011"images": [ &#123; "license": 4, "file_name": "000000397133.jpg", "coco_url": "/val2017/000000397133.jpg", "height": 427, "width": 640, "date_captured": "2013-11-14 17:02:52", "flickr_url": url, "id": 397133 &#125;, coco_urlid:annotationsimage_idid annotation 123456789annotation&#123; "id": int, "image_id": int, "category_id": int, "segmentation": RLE or [polygon], "area": float, "bbox": [x,y,width,height], "iscrowd": 0 or 1,&#125; image_id:imagesid category_idimages box segmentationmask bboxboundding box[top left x position, top left y position, width, height] iscrowd0 or 10segmentationRLE1polygon COCO  holder bias   step by step 1234567import argparseparser = argparse.ArgumentParser()parser.add_argument('--logdir', help='log directory', default='train_log/maskrcnn')...args = parser.parse_args()## print(args.logdir) COCO81]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[awk,grep ]]></title>
    <url>%2F2019%2F03%2F16%2Fawk%2Cgrep-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[awkawk    awkawk-&gt;-&gt; read executeawk repeat awkawk 1awk [option] afile.py awk 1awk '&#123;print&#125;' afile.py  1awk -F , '&#123;print $3 "\t" $4&#125;' marks.txt -F,awkprint$3,$434$0 () 12awk '/a/' aw.txt # aawk '/a/ &#123;print $1 $2&#125;' aw.txt # a1,2 awk 1awk '/a/' aw.txt &gt;&gt; new.txt  1awk -F , '!seen[$1]++' aw.txt seendict!seen[$1] == 0,  1awk -F , '$1&gt;$2 &#123;print $0&#125;' aw.txt  1234567891011121314151617#log.txt 141$ awk '&#123;print $1,$4&#125;' log.txt#  , -F$ awk -F, '&#123;print $1,$2&#125;' log.txt#   ,$ awk -F '[ ,]' '&#123;print $1,$2,$5&#125;' log.txt#  -v$ awk -va=1 -vb=s '&#123;print $1,$1+a,$1b&#125;' log.txt# 2$ awk '$1&gt;2' log.txt # CSV_PATHTRAIN_PATH ,-v awk -v min_area=$&#123;MIN_AREA&#125; -F ',' '&#123; area=(($4-$2)*($5-$3)); if(area&gt;min_area)&#123; print $0; &#125;&#125;'&lt;$&#123;CSV_PATH&#125; &gt;&gt; $&#123;TRAIN_PATH&#125; awk grepgrepunix ,grep15  12grep 'tf' afile.pycat afile.py |grep 'tf'  123#  demo_1.txt,demo_2 grep 'this' demo_1.txt demo_2.txtgrep 'this' demo_* (-i) 1grep -i 'The' demo.txt  1grep 'a*b' demo.txt grep -w  12grep -w 'ab' demo.txtgrep -iw 'ab' demo.txt #  grep 123grep -A 3 'a' demo.txt # agrep -B 3 'a' demo.txt # agrep -C 3 'a' demo.txt # a GREP_OPTIONS 1export GREP_OPTIONS='--color=auto' GREP_COLOR='100;8' grep -r 1grep -r 'file' *  1grep -v 'match' demo.txt  12grep -e '1' -e 'a' -e 'q' demo.txtgrep -v -e '1' -e 'q' demo.txt #   12grep -c 'a' aw.txtgrep -v -c 'a' aw.txt #  : 1grep -l 'a' a* #a  1grep -o 'a.*b' aw.txt #  : 1grep -n 'a' aw.txt  1grep -b 'a' aw.txt]]></content>
      <categories>
        <category>tool</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vim ]]></title>
    <url>%2F2019%2F03%2F13%2FVim-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Vim VimLinuxwindowssublime Vim Vim    dd  d+  2dd:   iaESC    :/?! hjkl w: b:  i :  A:  o:  a:  Vim:x: :wq :q!:  :q:  shift + zz:   x:  X: dd:  dw:  D:  d^:  dG:  d1G:  .N&lt;command&gt;,10x,20dd,d5w : :set nu NG: N gg:  G:  ctrl + o:  w:  e:  0:  $:  f  F  t   T   ~:  yy:  3yy3 y0:  y$:  r + &lt;&gt;:  R esc cc:  cw:  C:  u:  U:  1%s/imgs/car_openimg\/imgs # car_openimg/imgsimgs shift + &gt;:  shift + &lt;:  / + word: wordnN ? + word:  \*:  g\*  :new:  :close:  :q:  shell:! command:shell  :w filename: filename vim  shift + e:   . VIM 12vim 1.py 2.py:bn ##  Vim 1dd,k,p kp tabe :tabe a.txt a.txt  gt:  :tabc :x vim 12[ ,ctrl+i #ctrl + o : # gd]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag>tip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux trick]]></title>
    <url>%2F2019%2F03%2F13%2Flinux-trick%2F</url>
    <content type="text"><![CDATA[pickle pickle It is used for serializing and de-serializing a Python object structure. Any object in python can be pickled so that it can be saved on disk. python Pickling is a way to convert a python object (list, dict, etc.) into a character stream. pickledump load pickle has two main methods. The first one is dump, which dumps an object to a file object and the second one is load, which loads an object from a file object. dumpdictlistpickle 12345import picklea = &#123;'a':1,'b':2,'c':3&#125;file = open('pickleObject.pickle','wb')pickle.dump(a,file)file.close() loadpicklepython object 1234import picklefile = open('pickleObject.pickle','rb')b = pickle.load(file) # b == a is a dictprint(b['a']) linux  ?  ls -l |grep &quot;^-&quot;|wc -l txt 12345a = &#123;'a':1,'b':2,'c':3&#125;f = open('a.txt','w')for key in a.keys(): f.write(key+'\n')f.close() txt 123f = open('a.txt','r')for line in f.readlines(): print(line,end = '') assert  1assert expression,''  12if not expression: raise AssertionError  1assert type(a_str)== str  123import osfor path in os.listdir('./'): print(path) file1dir1 1cp file1 dir1 python . 1str.rfind('.', beg=0 end=len(str)) python setset key  1aset = &#123;'apple','orange','pea'&#125; setkey 12if 'apple' in aset: pass set 1234a-b # aba|b # aba&amp;b # aba^b # ab Set  1aset.remove('apple') Linux  1cp -r dirname . Vim u python  1234567f1.open('a.txt','r')content = f1.read()pos = content.find('word')content = content[:word+4]+'add something'+content[word+4:]f1.close()f2 = open('a.txt','w')f2.write(content) shell shell.shBash linuxshellkernel  123456789#!/bin/bash# Program:# This program shows "Hello World!" in your screen.# History:# 2015/07/16 VBird First releasePATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATHecho -e "Hello World! \a \n"exit 0 #!/bin/bash bashsh#  # script1. 2. 3. 4.5. PATH echo sh hello.sh  shell  12your_name='zhouwh'echo $your_name  123#!/bin/bashmyUrl="http://www.google.com"readonly myUrl #   1unset variable_name Shell  12str=''str="this is \" $your_name \"" #  123# greeting="hello, "$your_name" !"echo $greeting  123string="abcd"echo $&#123;#string&#125; # 4echo $&#123;string:1:3&#125; #  bcd   12345678910111213141516171819# if if conditionthen command1 command2 ...else commandN fi# for for loop in 1 2 3 4 5do echo "The value is: $loop"done#whilewhile conditiondo commanddone awk awkawk 1awk '&#123;[pattern] action&#125;' &#123;filenames&#125;  1234567891011121314151617181920212223#log.txt 141$ awk '&#123;print $1,$4&#125;' log.txt#  , -F$ awk -F, '&#123;print $1,$2&#125;' log.txt#   ,$ awk -F '[ ,]' '&#123;print $1,$2,$5&#125;' log.txt#  -v$ awk -va=1 -vb=s '&#123;print $1,$1+a,$1b&#125;' log.txt# 2$ awk '$1&gt;2' log.txt # CSV_PATHTRAIN_PATHawk -v min_area=$&#123;MIN_AREA&#125; -F ',' '&#123; area=(($4-$2)*($5-$3)); if(area&gt;min_area)&#123; print $0; &#125;&#125;'&lt;$&#123;CSV_PATH&#125; &gt;&gt; $&#123;TRAIN_PATH&#125;## awk '&#123;$1="";print $0&#125;' file.txt## awk -F '\t' 'NR==1&#123;next&#125; &#123;print $0&#125;' # NR==1 CSV Comma Separated Values file python csv 1234567import csvwith open('stocks.csv') as f: f_csv = csv.reader(f) headers = next(f_csv) for row in f_csv: # Process row ... pythoncsv 1234import csvwith open('some.csv', 'w', newline='') as f: writer = csv.writer(f) writer.writerow([1,2,3,4]) python dict 1merge_dict = dict(dict1.items()+dict2.items()) Python virtualenvvirtualenv`, , pythonpython  1pip install virtualenv  1virtualenv zhou_env  1source ./bin/activate  1deactivate matplotlib 123456789101112131415161718192021222324import matplotlib.pyplot as pltimport numpy as npimport matplotlibdata = np.array([1,2,3,4,5,6,7,8,1,1,1,1,1])print(type(data))"""data:bins:10normed:0normed=1facecolor:edgecolor:alpha:"""plt.hist(data, bins=40, normed=0, facecolor="blue", edgecolor="black", alpha=0.7)# plt.xlabel("")# plt.ylabel("count")# plt.title("bboxcount")plt.savefig('aimg.jpg')plt.show() rz: iterm2rz sz filename: iterm2  vim ctrl + z vimfg linux 12ls -lshdu -sh * tar czvf file.tar ./filename,czvfcreate zip view filetar xzvf file.tarxzvfextract zip view file   1cat all_box.csv | grep '' # grepcat delete_imgs.txt  delete_imgs.txt all_box.csv() 1grep -f delete_imgs.txt all_box.csv new_box 1grep -v -f delete_imgs.txt all_box.csv &gt; new_box.csv  1cat new_box.csv |wc -l # -l  -w  1cat *.csv &gt; all_box.csv awk1 1awk -F ',' '!seen[$1++]' train_set.csv |wc -l linux  1nvidia-smi python shuffleshuffle 123import randomlist = [1,2,3]random.shuffle(list) tmux: tmux  session , 1234567tmux ls # tmuxtmux new -s zhouwenhui # tmux -2 attach -t zhouwenhui # sessionctrl + b , d # ctrl + b , c # ctrl + b , w # exit #  Linux123useradd zhouwhpasswd zhouwhuserdel [-r] zhouwh #  Linux root vim /etc/passwd ID 0 zhouwhx:0:1002::/home/zhouwh:/bin/bash Linux/home/zhouwh 12su - zhouwh # zhouwh su - root # root  Linux anacondaanaconda 1234bash Anaconda3-4.4.0-Linux-x86_64.sh ## echo 'export PATH="~/anaconda3/bin:$PATH"' &gt;&gt; ~/.bashrc# conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ # rm -rf anaconda #  Json 123456# Writing JSON data:&#123;'a': 'Runoob', 'b': 7&#125;with open('data.json', 'w') as f: json.dump(data, f)# Reading data backwith open('data.json', 'r') as f: data = json.load(f) dict to json12with open('data.json','w') as f: json.dump(data,f) /12cat afile.txt|head -n 100cat afile.txt|tail -n 100 GPU1CUDA_VISIBLE_DEVICES=1,2 python train.py GPU1nvidia-smi -l 1 1ctrl+b  + [ .bashrclinux/unix bash  shell bashrc  .bashrc,bash  bashrc .bashrcsource ~/.bashrc linux Linuxlinux   /etc/profileCLASSPATH 12vim /etc/profile export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib .bash_profile, 12vim ~/.bash.profileexport CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib export =shell .bashrc,profile,.bash.profile  Linux PATH, 1PATH=&lt;PATH1&gt;:&lt;PATH2&gt;:&lt;PATH3&gt;:&lt;PATH4&gt; PATH 1export PATH='~/anaconda3/bin/:$PATH' HOME HISTSIZE LOGNAME HOSTNAME SHELLShell LANG/LANGUGE Linux  echo  echo $PATH export HELLO=hi  env  linux 1alias ict="ssh xxx@ictvr.ml -p 11111" Linux 1for f in 'ls cat';do echo '/data/cartoon_detect_data/'$f;done &gt; total.txt python 1ls -lht runonce,sh tmp.sh,/root/cartoon_data_prepareid linuxn1cut -c1-100 file.py # 100 linux shell12345678910#!/bin/bashif [ ! -n "$1" ] ;then #  echo "you have not input a word!"else echo "the word you input is $1"fi## if [-e "$1"] ; then #/ linux 1rename 's/search/replace/;' test*.jpg linux awk1awk -F ',' '&#123;print $1&#125;' ~/zhouwenhui/mAP/test_set.csv| while read day ; do cp "$day" "./aaa"; done 1ln -s a/path to/soft_path soft_path linux 1rm -rf PAD8_*.jpg macrz,sz 12345split -b100k ev.zip ev # ev.zip100kevevab ...md5sum ev.zip # md5sz ev* # cat ev* &gt; ev.zip #md5sum ev.zip #md5 1ps aux  ctrl+zid]]></content>
      <tags>
        <tag>tip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow CNNVI]]></title>
    <url>%2F2019%2F03%2F13%2FTensorflow%20%E7%AC%94%E8%AE%B0%EF%BC%88CNN%E5%88%86%E7%B1%BB%E5%99%A8VI%EF%BC%89%2F</url>
    <content type="text"><![CDATA[CNNCNNdropout  Assemble graph: read data create placeholder create weight and bias in a layer create a net structure specify loss function create optimizer train model: specify the epochs,iteration,batch-size initial variables step by step run the optimizeruse feed_dict to feed data into x,y placeholder tf.Session() encapsulates the environment mnist28*28*1 12xs = tf.placeholder(tf.float32,[None,784])x_image = tf.reshape(xs,[-1,28,28,1]) # [nsample,width,height,channel] tensorflowtf.nn.conv2d 12345tf.nn.conv2d(input,W,stride,padding)# input# filter:W[kernel_w,kernel_h,in_channel,out_channel]# stride[1,x_move,y_move,1]# padding = 'SAME' / 'VALID'  /   1234567def conv2d(x): # conv weight: [kernel_w,kernel_h,in_channel,out_channel] Weights = tf.truncated_normal([5,5,1,32],stddev = 0.1) bias = tf.constant(0.1,[32]) # stride = [1,x_move,y_move,1] output = tf.nn.conv2d(x,Weight,[1,1,1,1],padding = 'SAME') return output+bias tensorflowtf.nn.max_pool 12345tf.nn.max_pool(input,ksize,stride,padding)# input# ksize:[1,kernel_w,kernel_h,1]# stride: [1,x_move,y_move,1]# padding = 'SAME' / 'VALID' max pooling : 12def max_pooling(x): return tf.nn.max_pool(x,ksize=[1,2,2,1],strides = [1,2,2,1],padding = 'SAME') dropout 1234tf.nn.dropout(x,keep_prob = 0.5)# x: # keep_probdropout# keep_probtf.placeholder,1  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import osos.environ['KMP_DUPLICATE_LIB_OK']='True'import tensorflow as tffrom tensorflow.examples.tutorials.mnist import input_data# load datamnist = input_data.read_data_sets('MNIST',one_hot=True)# create placeholderwith tf.name_scope('input'): xs = tf.placeholder(tf.float32,[None,784])/255. ys = tf.placeholder(tf.float32,[None,10]) keep_prob = tf.placeholder(tf.float32) # dropout rate x_image = tf.reshape(xs,[-1,28,28,1]) # nsample,28,28,channelwith tf.name_scope('conv1'): Weights = tf.Variable(tf.random.truncated_normal([5,5,1,32],stddev=0.1)) bias = tf.Variable(tf.constant(0.1,shape = [32])) out_conv1 = tf.nn.conv2d(x_image,Weights,[1,1,1,1],padding='SAME')+bias # 28,28,32with tf.name_scope('pool1'): out_pool1 = tf.nn.max_pool(out_conv1,ksize=[1,2,2,1],strides=[1,2,2,1],padding='SAME') # 14,14,32with tf.name_scope('conv2'): Weights = tf.Variable(tf.random.truncated_normal([5,5,32,64],stddev=0.1)) bias = tf.Variable(tf.constant(0.1,shape = [64])) out_conv2 = tf.nn.conv2d(out_pool1,Weights,[1,1,1,1],padding='SAME') #[14,14,64]with tf.name_scope('pool2'): out_pool2 = tf.nn.max_pool(out_conv2,ksize=[1,2,2,1],strides=[1,2,2,1],padding='SAME')#[7,7,64] out_pool2 = tf.reshape(out_pool2,[-1,7*7*64]) # nsample,7*7*64with tf.name_scope('fc1'): Weights = tf.Variable(tf.random.truncated_normal([7*7*64,1024],stddev=0.1)) bias = tf.Variable(tf.constant(0.1,shape = [1024])) out_fc1 = tf.nn.relu(tf.matmul(out_pool2,Weights)+bias) drop_out_fc1 = tf.nn.dropout(out_fc1,keep_prob) # nsample,1024with tf.name_scope('fc2'): Weights = tf.Variable(tf.random.truncated_normal([1024,10],stddev=0.1)) bias = tf.Variable(tf.constant(0.1,shape=[10])) prediction = tf.matmul(drop_out_fc1,Weights)+bias # nsample,10# create running environmentsess = tf.Session()## compute accuracydef compute_accuracy(X,Y): pred = sess.run(prediction,feed_dict=&#123;xs:X,keep_prob:1&#125;) correct = tf.equal(tf.argmax(pred,1),tf.argmax(Y,1)) accuracy = tf.reduce_mean(tf.cast(correct,tf.float32)) return sess.run(accuracy)# losswith tf.name_scope('loss'): loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits_v2(logits=prediction,labels=ys))with tf.name_scope('optimizer'): optimizer = tf.train.AdamOptimizer(1e-4).minimize(loss)#initializationinit = tf.global_variables_initializer()sess.run(init)# visualizationwriter = tf.summary.FileWriter('./log',sess.graph)# trainfor step in range(1000): x_batch,y_batch = mnist.train.next_batch(100) sess.run(optimizer,feed_dict=&#123;xs:x_batch,ys:y_batch,keep_prob:0.5&#125;) if step%50 == 0: print(compute_accuracy(mnist.test.images[:1000],mnist.test.labels[:1000])) Tensorflow 12345678910import tensorflow as tfw = tf.Variable([[1,2],[3,4]],dtype = tf.float32,name = 'weight')b = tf.Variable([[1,2,3]],dtype = tf.float32,name = 'bias')init = tf.global_variables_initializer()saver = tf.train.Saver()with tf.Session() as sess: sess.run(init) save_path = saver.save(sess, "my_net/save_net.ckpt") print("Save to path: ", save_path) restore12345678910111213import tensorflow as tf#  W, b W = tf.Variable(np.arange(6).reshape((2, 3)), dtype=tf.float32, name="weights")b = tf.Variable(np.arange(3).reshape((1, 3)), dtype=tf.float32, name="biases")#  init= tf.initialize_all_variables()saver = tf.train.Saver()with tf.Session() as sess: #  saver.restore(sess, "my_net/save_net.ckpt") print("weights:", sess.run(W)) print("biases:", sess.run(b))]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SSD M2Det ]]></title>
    <url>%2F2019%2F03%2F10%2FSSD-M2Det-%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[SSDone-stageone-stage M2Det2019CPVRSSDM2Det  single-scale inference  11 FPS, AP 41  multi-scale inference  AP 44.2  SSD  SSD: Single Shot MultiBox Detector submit time2015 arxiv link  SSDSSD proposal one-stageYOLO SSD    SSD SSD bc88444 c 1c2cp  L1 [6]Softmax SSD, 300x300 VGG-16conv4_3 feature map feature map3x3feature map cellk4bounding box offset64anchor46anchoranchork4 38x38, 3x3, 1x1feature mapfeature map cell4anchor: 1:11:2, 2:1feature mapfeature map cell6anchor: 1:11:2, 2:11:3 3:1$$38* 38*4+19*19*6+10*10*6+5*5*6+3*3*4+1*1*4=8732$$anchor anchorfeature map cellanchor$$(\frac{i+0.5}{|fk|},\frac{j+0.5}{|fk|})$$i,jfkfeature map anchor:$$S_k = S_{min}+\frac{S_{max}-S_{min}}{m-1} (k-1),k\in[1,m]$$ feature mapanchormm feature maps,kfeature mapanchor$ S_k$ $S_{min}$  0.2$S_{max}$  0.9scale[0.2,0.9] anchor$$\begin{align}w_k^{\alpha} &amp;= S_k \sqrt{\alpha_r} \\h_k^{\alpha} &amp;= S_k \sqrt{\alpha_r}\\\alpha \in &amp;{1,2,3,\frac{1}{2},\frac{1}{3}}\end{align}$$ $a_r=1$  $s_k = \sqrt{s_{k-1}{s_{k+1}}}$ 6anchor4anchor3$\frac{1}{3}$ SSDsoftmax loss)L1 loss$$L(x,c,l,g)=\frac{1}{N}(L_{conf}(x,c)+\alpha L_{loc}(x,l,g))$$NGTN = 0loss0$\alpha$loss loss $$L_{conf}(x,c) = - \sum_{i\in Pos}^N x_{ij}^p log(\hat{c}_{i}^p) - \sum_{i\in Neg} log(\hat{c}_{i}^0)\quad where \quad\hat{c}_{i}^p=\frac{exp^{c_{i}^p}}{\sum_p exp(c_{i}^p)}$$softmaxloss $$\begin{align}L_{loc}(x,l,g)&amp;=\sum_{i\in Pos}^N \sum_{m \in {cx,cy,w,h}}x_{ij}^k smooth_{L1}(l_i^m-\hat{g}_j^m) \\\hat{g}_j^{cx}&amp;=(g_j^{cx}-d_i^{cx})/d_i^w \quad \hat{g}_j^{cy}=(g_j^{cy}-d_i^{cy})/d_i^h\\\hat{g}_j^{w}&amp;=log(\frac{g_j^w}{d_i^w})\quad \hat{g}_j^{h}=log(\frac{g_j^h}{d_i^h})\end{align}$$gGTdlossFaster RCNNloss lg GT0.5 1:3. train trick SSD    crop resize MS COCOSSDcoco M2Det M2Detone-stageSSDMulti-Level Feature Pyramid Network(MLFPN)    end-to-endSSDbenchmark    feature mapsingle level SSD4stride=2 FPNUscale STDNDenseNetdense blockscale-transfer MLFPNMulti-level&amp;Multi-scale MLFPN(vgg)TUMFFMMulti-level&amp;Mutli-scaleSFAM FFMv1FFMv1VGGconv4_3conv5_3base featureFigure11*1channelupsamplebase feature ###TUM TUMU-NetFigure1 TUMfeature mapSFAMfeature map(128,40,40)FFMv2TUM FFMv2FFMv2base featurefeature map TUMFFMv2feature mapshallowmediumdeepTUMFFMv2 SFAMSFAMMulti-level feature pyramidprediction layer TUMSFAMchannelSENet Fully-connected layer  feature  prediction layer  i  Feature maps  M2Det VGG-16ResNet-101 MLFPN8TUMTUM556scale 6 soft-NMS SSDsoftmax]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[data training tip]]></title>
    <url>%2F2019%2F03%2F08%2Fdata%20training%20tip%2F</url>
    <content type="text"><![CDATA[Json JsonJson 1234567import jsonjson.dumps(&#123;'a': 'Runoob', 'b': 7&#125;, sort_keys=False, indent=4, separators=(',', ': '))# #&#123;# "a": "Runoob",# "b": 7#&#125;  12345import jsonwith open('../dataset/train_round1/train_no_poly.json', 'r') as fin: js = json.load(fin) with open('train_no_poly.json', 'w+') as fout: json.dump(js, fout,sort_keys=False, indent=4, separators=(',', ': '),ensure_ascii=False) Json  json.loads(fileDir)json.dumps(dataDict)Json  123456# Writing JSON datawith open('data.json', 'w') as f: json.dump(data, f)# Reading data backwith open('data.json', 'r') as f: data = json.load(f) MAC git Git githubssh -T git@github.com hi wenhui-zhou. GitHub GitHub clone clone: git clone git@github.com:WenHui-Zhou/learnGit.git learnGit GitHub git add fileName git add .  git commit -m &quot;some comments&quot; git push github  git status git add file git commit -m &quot;comment&quot; git pushGitHub git getchgit fetch  git fetch origin master:tmptmpmaster tmp git diff tmp git merge tmpmaster git branch -d tmptmp git pullgit pullgit fetch + git merge git push 123git add .git commit -m "comment" // git push //  forkGitHubforkGitHubclonegit pushGitHubpull requestrequestrequestmerge fork 1234git remote add //git fetch // fetchgit merge // git push // GitHub iterationepochbatchsize epochepochepoch batch-size iterationbatch-sizedataset/batch-sizeepochiteration = epoch * (dataset/batch-size) python dict12345678adict = &#123;'a':1,'b':2,'c':3&#125; #dict(zip(['a', 'b', 'c'], [1, 2, 3])) print(adict['a']) # adict['a'] = 2 # adict.pop('a') # adict.get('a') # keyNonefor key,values in dict.items(): # keyval print(key,values) python 12345678910111213141516class Student(object): # object #  def __init__(self,name,score): # self self.name = name self.score = score ## ,__, self.__name = name #  def getname(self): return self.name def getscore(self): return self.score#stu = Student('xiaoming',100)print(stu.getname())stu.sex = 'man' #  12345678910111213141516171819class Animal(object): def run(): print('animal is runing')class cat(Animal): passacat = cat()acat.run() # runclass cat(Animal): def run(): print('cat is runing')acat.run() # run#def runrun(animal): animal.run()# runrun(animal) # animalrunrun(cat) # animal runrun(aman) # run() property12345678910111213class Student(object): @property def socre(self): # socre return self._score @birth.setter def score(self, value):# scoresetter if value&gt;100: raise ValueError('score must between 0 ~ 100!') self._score = value# s = Student()s.score = 100print(s.score) classmethod 12345678910 class A(object): bar = 1 def func1(self): print ('foo') @classmethod def func2(cls): # cls print ('func2') print (cls.bar) cls().func1() #  foo A.func2() #  staticmethod12345 class A(object): @staticmethod def func2(): #  print ('func2')A.func2() #  github https://github.com/tensorpack/tensorpack/tree/master/examples/FasterRCNN  1svn checkout https://github.com/tensorpack/tensorpack/trunk/examples/FasterRCNN]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YOLO V2,V3]]></title>
    <url>%2F2019%2F03%2F08%2FYOLO-V2-V3%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[YOLO V2,YOLO V3YOLO V1 mAPV2V3 YOLO V2  YOLO9000: Better, Faster, Stronger submit time: 2016 arxiv link YOLO V2 V1 batch normBatch NormalizationYOLOv2Batch NormalizationdroputBatch NormalizationYOLOv2mAP2.4% high resolution classifierImageNet224*224fintuneYOLO V2448*448fintune10 epochYOLOv2mAP4% Convolutional With Anchor BoxesYOLOv1YOLOv1YOLOv2YOLOv1anchor boxesYOLOv2Faster R-CNNRPNRPNCNNfeature map YOLOv2 416 * 416 32 416*41613*13YOLO V2cellyolov1IoUanchorYOLO V2GTanchor Dimension ClustersFaster RCNNyolov2kmeansboxboxIOU New Network: Darknet-19YOLOv2Darknet-19195maxpoolingDarknet-19YOLOv2mAP33% Direct location predictionyolov2 RPNyolov2cell yolov2cell5bounding boxbounding box YOLOv2mAP5% Multi-Scale TrainingYOLOv2YOLOv2iterationsYOLOv23232. YOLO V2 YOLOv2 ImageNetDarknet-19 224 * 224 160epochs  448*448 ImageNetfinetune10epochs Darknet-19finetune  YOLO V3 YOLOv3: An Incremental Improvement Submit time: 2018 arxiv link YOLO V3YOLO V2YOLO V3  Darknet-53YOLOV3Darknet 53 Darknet 53Imagenet.YOLOV3 106 fully convolutional YOLOV2 Detection at three Scales v332168YOLO1 x 1$N N [3(4+1+80)] $418080  No more softmaxing the classessigmoidsoftmaxsoftmaxCOCOpersonwomensigmoid]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow  III]]></title>
    <url>%2F2019%2F03%2F08%2FTensorFlow-%E7%AC%94%E8%AE%B0%EF%BC%88%E5%88%86%E7%B1%BB%E5%99%A8-III%EF%BC%89%2F</url>
    <content type="text"><![CDATA[mnist mnist  sizesize placeholder loss.  train 123import tensorflow as tffrom tf.examples.tutorials.minst import input_datamnist = input_data.read_data_sets('MNIST',one_hot = True) 123456789def add_layer(input,in_size,out_size,activation_Function=None): Weights = tf.Variables(tf.random.normal([in_size,out_size])) bias = tf.Variables(tf.zeros([1,out_size])+0.1) Wx_add_b = tf.matmul(input,Weights)+bias if actication_Function is None: outputs = Wx_add_b else: outputs = activation_Function(Wx_add_b) return outputs  123xs = tf.placeholder(tf.float32,[None,784])ys = tf.placeholder(tf.float32,[None,10])prediction = add_layer(xs,784,10,None)# LossSGD 123loss = tf.nn.softmax_cross_entropy_with_logits_v2(logits = prediction,labels = ys)optimizer = tf.train.GradientDescentOptimizer(0.2).minimize(loss)sess = tf.Session() GTone-hot, 123456def computeAccuracy(xtest,ylabel): pred = sess.run(prediction,feed_dict=&#123;xs = xtest&#125;) correct = tf.equal(tf.argmax(pred,1),tf.argmax(ylabel,1)) accuracy = tf.reduce_mean(tf.cast(correct,tf.float32)) result = sess.run(accuracy,feed_dict=&#123;xs:xtest&#125;) return result train batch-size SGD 1234567init = tf.global_variables_initializer()sess.run(init)for step in range(1000): x_batch,y_batch = mnist.train.next_batch(100) sess.run(opertimizer,feed_dict = &#123;xs:x_batch,ys:y_batch&#125;) if step%50 == 0: print(computeAccuracy(mnist.test.images,mnist.test.labels)) learning rate 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import osos.environ['KMP_DUPLICATE_LIB_OK']='True'""",lossopertimizer"""import tensorflow as tffrom tensorflow.examples.tutorials.mnist import input_data#get the datamnist = input_data.read_data_sets('MNIST',one_hot=True)# def add_layer(input,in_size,out_size,activation_Fcuntion = None): Weights = tf.Variable(tf.random.normal([in_size,out_size])) bias = tf.Variable(tf.zeros([1,out_size])+0.1) Wx_add_b = tf.matmul(input,Weights)+bias if activation_Fcuntion is None: outputs = Wx_add_b else: outputs = activation_Fcuntion(Wx_add_b) return outputs# mnist #xs = tf.placeholder(tf.float32,[None,784])ys = tf.placeholder(tf.float32,[None,10])#prediction = add_layer(xs,784,10,tf.nn.leaky_relu)# lossloss = tf.nn.softmax_cross_entropy_with_logits_v2(logits=prediction,labels=ys)optimizer = tf.train.GradientDescentOptimizer(0.2).minimize(loss)sess = tf.Session()# def computeLoss(xtest,ylabel): pre = sess.run(prediction,feed_dict=&#123;xs:xtest&#125;) correct_rate = tf.equal(tf.argmax(pre,1),tf.argmax(ylabel,1)) accuracy = tf.reduce_mean(tf.cast(correct_rate,tf.float32)) result = sess.run(accuracy,feed_dict=&#123;xs:xtest&#125;) return result# traininit = tf.global_variables_initializer()sess.run(init)for step in range(1000): x_batch,y_batch = mnist.train.next_batch(100) sess.run(optimizer,feed_dict=&#123;xs:x_batch,ys:y_batch&#125;) if step%50 == 0: print(computeLoss(mnist.test.images,mnist.test.labels))]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[YOLO V1 ]]></title>
    <url>%2F2019%2F03%2F07%2FYOLO-V1-%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[YOLO RCNNFaster RCNNFaster RCNNYOLO V1. You Only Look Once:Unified, Real-Time Object Detection Submit time: 2016.5 arxiv link YOLOone-stage YOLO YOLOYOLOpineline YOLO YOLO YOLO SxSCconfidence X IoU SxSB(x,y,width,height,confidence) YOLO V1yoloS*SBGTIoU5(x,y,width,height,confidence)x,yconfidence $Pr(Class_i|Object)$CC$$Class-confidence = Pr(Class_i|Object) * IOU_{truth}^{predict}$$ 24 LossYOLOGTIOU loss  $\mathbb I_{i}^{obj}$i $\mathbb I_{ij}^{obj}$ ijlossGTMSE lossGTMSE lossMSE lossMSE lossCMSE loss lossdropout YOLO V1  YOLO Pascal VOC98 YOLO  IOU YOLO V1S*S2C  loss ]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bag of Freebies for Training Object Detection Neural Networks]]></title>
    <url>%2F2019%2F03%2F05%2FBag-of-Freebies-for-Training-Object-Detection-Neural-Networks%2F</url>
    <content type="text"><![CDATA[Faster-RCNNYOLO Bag of Freebies for Training Object Detection Neural Networkssubmit time: 2019.2arxiv link  mixuppipeline learning rate scheduling, weight decay synchronized BatchNorm.  mixupvisually coherentmixupbetaa&gt;=1,b&gt;=1(0.2)mixupmixupnoisemixupdistort Classification Head Label Smoothingloss softmaxlossloss 10softmax$$p_i = \frac{e^{z_i}}{\sum_j e^{z_j}}$$loss$e^{z_i} &gt;&gt; e^{z_j},i != j$label smoothing groundtruth qsmoothingqone hot$$q_i = (1 - \epsilon )q_i + \frac{\epsilon}{K}$$$\epsilon$ smoothing  Data Pre-processing . , ,   cosine learning rate decay and Warm up learning rate Step scheduleEpoch 0.1Step schedule  Cosine  Synchronized Batch NormalizationGPUbatch sizeBNBN]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MobileNet V2 ]]></title>
    <url>%2F2019%2F03%2F04%2FMobileNet-V2-%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[MobileNet V2 V1inverted residual Linear BottlenecksmobileNet v2  MobileNetV2: Inverted Residuals and Linear Bottleneckssubmit time: 2018arxiv link mobileNetsmobileNet V1deepwise separable conv ResNetinverted residual depthwise Convolution depthwise conv1x1BNrelu0,1x1kernelrelukernel sizelinear bottlenecks. mobileNet v2 inverted residuallinear bottleneckrelu MobileNetV2 depthwise conv linear conv MobileNet v2  mobileNet v2V1 mobileNet v2v1depthwise seperable conv V2DWPWchannelDWfeature mapPWfeature mapPWMx1x1feature mapchannel dReLuReLUBx0ReLUrelu0 ReLU ReLU channel Linear BottleneckV2  PW  Linear Bottleneck PW  V2 shortcut ResNetPWfeature map6DWshortcutfeature mapPW mobileNet  ]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow -II]]></title>
    <url>%2F2019%2F03%2F04%2FTensorflow%20%E7%AC%94%E8%AE%B0%EF%BC%88%E6%90%AD%E5%BB%BA%E7%BD%91%E7%BB%9C-II%EF%BC%89%2F</url>
    <content type="text"><![CDATA[  sizesize weightbiases output 123456789def add_layer(input,in_size,out_size,activation_function = None): Weights = tf.Variable(tf.random.normal([in_size,out_size])) biases = tf.Variable(tf.zeros([1,out_size])+0.01) Wx_plus_b = tf.matmul(input,Weights)+biases if activation_function is None: output = Wx_plus_b else: output = activation_function(Wx_bias_b) return output outsize 1110  placeholderlossoptimizer  1234567891011121314151617181920212223242526import tensorflow as tfimport numpy as np# create datax_data = np.linspace(-1,1,300)[:,np.newaxis]noise = np.random.rand(x_data.shape[0],x_data.shape[1])y_GT = np.square(x_data)+0.5+noise# placeholderxs = tf.placeholder(tf.float32,[None,1]) #1ys = tf.placeholder(tf.float32,[None,1])# structurel1 = add_layer(ms,1,10,tf.nn.relu)output = add_layer(l2,10,1,None)# lossloss = tf.reduce_mean(tf.reduce_sum(tf.square(output-ys),1))optimizer = tf.train.GrandientDescentOptimizer(0.1).minimize(loss)#traininit = tf.global_variables_initializer()with tf.Session() as sess: sess.run(init) for step in range(1000): sess.run(optimizer,feed_dict=&#123;xs:x_data,ys:y_GT&#125;) if step%20 == 0: print(loss,feed_dict=&#123;xs:x_data,ys:y_GT&#125;)  x_data = np.linspace(-1,1,300)[:,np.newaxis]np.linspace(-1,1)-11300[:,np.newaxis]1x300300x11300 xs = tf.placeholder(tf.float32,[None,1]) #1[None,1] tf.reduce_sum(tf.square(output-ys),1): tf.reduce_sum()0011tf.reduce_mean() placeholder matplotlib.plot as plt  matplotlibmatplotlibFigure : plotplotPython12345678910111213import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-np.pi,np.pi,300)xsin = np.sin(x)xcos = np.cos(x)plt.subplot(221) # 22plt.plot(x,xsin) # plt.xlabel('x') # plt.subplot(222) # 22plt.plot(x,xcos)plt.subplot(223) # 22plt.scatter(x,xsin) # plt.show() plt.subplot(xxx) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import tensorflow as tfimport numpy as npimport matplotlib.pyplot as pltimport osos.environ['KMP_DUPLICATE_LIB_OK']='True'""""""def add_layer(input,in_size,out_size,activation_function = None): # Weights = tf.Variable(tf.random.normal([in_size,out_size])) bias = tf.Variable(tf.zeros([1,out_size])+ 0.01) Wx_plus_b = tf.matmul(input,Weights) + bias if activation_function is None: outputs = Wx_plus_b else: outputs = activation_function(Wx_plus_b) return outputs"""1. 1012. placeholderloss optimizer"""# np.linspace(-1,1,10)[:,np.newaxis],# create datax_data = np.linspace(-1,1,300)[:,np.newaxis]noise = np.random.rand(300,1)y_GT = np.square(x_data) + 0.5+noise# create networkxs = tf.placeholder(tf.float32,x_data.shape)ys = tf.placeholder(tf.float32,y_GT.shape)l1 = add_layer(xs,1,10,activation_function=tf.nn.relu)output = add_layer(l1,10,1,activation_function=None)# lossloss = tf.reduce_mean(tf.reduce_sum(tf.square(output-ys),1))optimizer = tf.train.GradientDescentOptimizer(0.1).minimize(loss)#illustrationax = plt.subplot(111)plt.scatter(x_data,y_GT)plt.ion() # plt.show()# traininit = tf.global_variables_initializer()with tf.Session() as sess: sess.run(init) for step in range(500): sess.run(optimizer,feed_dict=&#123;xs:x_data,ys:y_GT&#125;) if step%20 == 0: print(sess.run(loss,feed_dict=&#123;xs:x_data,ys:y_GT&#125;)) predict = sess.run(output,feed_dict=&#123;xs:x_data&#125;) # plt.plot(x_data,predict) try: ax.lines.remove(lines[0]) except Exception: pass # plot the prediction lines = plt.plot(x_data, predict, 'r-', lw=5) plt.pause(0.5) TensorBoard Tensorboard tensorflowtf.name_scope(&quot;name&quot;): 123with tf.name_scope("layer"): with tf.name_scope("Weight"): Weights = tf.Variable(tf.random.normal([300,1]),name = 'W') tensorboard 12sess = tf.Session()writer = tf.summary.FileWriter('./log',sess.graph)  1tensorboard --logdir = 'log/' 0.0.0.0:6006 tensorboardhistogramtf.summary.histogram 123with tf.name_scope("Weight"): Weights = tf.Variable(tf.random.normal([300,1]),name = 'W') tf.summary.histogram(name,Weight) tensorboardlosstf.summary.scalar 123with tf.name_scope('loss'): loss = tf.reduce.mean(tf.reduce.sum(tf.square(y-p_pred),1),1) tf.summary.scalar('loss',loss) summary 1merged = tf.summary.merge_all() ,writer.add_summary(result,step)summary 12345678init = tf.global_variables_initializer()with tf.Session() as sess: sess.run(init) for step in range(1000): sess.run(optimizer,feed_dict=&#123;xs:x_data,ys:y_GT&#125;) if step%20 == 0: result = sess.run(merged,feed_dict=&#123;xs:x_data,ys:y_GT&#125;) writer.add_summary(result,step) .x]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MobileNets ]]></title>
    <url>%2F2019%2F03%2F03%2FMobileNets-%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[mobileNets MobileNets: Efficient Convolutional Neural Networks for Mobile Vision Applicationssubmit time: 2017arxiv link mobileNetsCNN mobileNetsmoblieNets MobileNets  $M*N*D_k*D_k$$D_F*D_F$features map$N*M*D_k*D_k*D_F*D_F$.MobileNetsdepthwise convolutionspointwise convolutions$M*N*D_k*D_k$channel$D_k$MN$D_k$ depthwise convolution$M*D_k*D_k$$1*D_k*D_k$MN$D_F*D_F$features map$M*D_k*D_k*D_F*D_F$. Pointwise convolution1x1$M*D_k*D_k$$M*1*1$Ndepthwise$N*M*D_F*D_F$. Deep-wise $$\frac{M*D_k*D_k*D_F*D_F+N*M*D_F*D_F}{N*M*D_k*D_k*D_F*D_F} = \frac{1}{N} + \frac{1}{D_K^2}$$MobileNetsBatchNormalizationReLU  MobileNets 28deepwiseargpoolingsoftmax1*1BN  Width multiplier$\alpha$width multiplier$\alpha$M$\alpha M$N$\alpha$N$\alpha$(0,1]10.750.50.25Width multiplier$$\alpha M*D_k*D_k*D_F*D_F+\alpha N* \alpha M*D_F*D_F$$  Resolution Multiplier Reduced Representation$\rho$$\rho$(0,1]$$\alpha M*D_k*D_k* \rho D_F* \rho D_F+\alpha N* \alpha M*\rho D_F* \rho D_F$$ $\alpha,\rho$ feature mapsoftmax loss$$Loss = \sum_I y_i \log p_i$$ MobileNets CNNdeepWise pointWiseMobileNetsFaster RCNN]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow -I]]></title>
    <url>%2F2019%2F03%2F03%2FTensorFlow-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[TensorFlow MSE lossSGD GroundTruth tensorflow(weight,bias) tensorflowtf.Session()tensorflowepoch 1234567891011121314151617181920212223import tensorflow as tfimport numpy as np#create datax_data = np.random.rand(100) # 100 01y_data = x_data*0.3 + 0.9# create tensorflow structureWeights = tf.Variable(tf.random.uniform([1],-1.0,1.0))Bias = tf.Variable(tf.zeros([1]))y = Weights*x_data + Biasloss = tf.reduce_mean(tf.square(y - y_data))optimizer = tf.train.GradientDescentOptimizer(0.5)train = optimizer.minimize(loss)# executeinit = tf.global_variables_initializer()sess = tf.Session()sess.run(init)for step in range(500): sess.run(train) if step%20 == 0: print(sess.run(Weights),sess.run(Bias)) np.random.rand(100), numpynumpy np.random.rand(4,2): 01float4x2. np.random.rand(4,2,3):4x2x3. np.random.randn(4,2):  N ( 0,1 )4x2. np.random.randint(low,high,size = (4,2)): 4x2[low,high) np.random.seed(1) np.random.rand(5):seedseed tensorflowtf.Variable()tensorflowtf.Variable opweights = tf.Variable(&lt;initial-value&gt;,name = &lt;optional&gt;)tensorflowtensorflowGraphGraphGraphtf.Session()init = tf.global_variables_initializer()sess = tf.Session()sess.run(init) tensorflow  tf.random.uniform([2,3],minval = -1,maxval = 1,seed = None)[minval,maxval] tf.random.normal([2,3],mean = 0,stddev = 1) N01 tf.truncated.normal([2,3],mean = 0,stddev = 1)[mean-2stddev,mean+2stddev] tf.random.shuffle([1,2,3,4]) 0: tf.zeros([2,3]) tensorflow LossMSE Loss(L2)mse = tf.reduce_mean(tf.square(y_pre,y))MAE Loss: (L1)mae = tf.losses.absolute_difference(y_pre,y)mae_loss = tf.reduce_sum(mae) Losssoftmax_sparse = tf.nn.sparse_softmax_cross_entropy_with_logits(labels = y,logits = y_pred)loss = tf.reduce_mean(softmax_sparse)y-true one-hot  tensorflowtf.train optimizer = tf.train.GradientDescentOptimizer(0.5)train = optimizer.minimize(optimizer) tf.Session() Session lossSession123with tf.Session() as sess: sess.run(init) sess.run(train) tf.constant() tensorflow  tf.constant() matrix1 = tf.constant([[1,2],[3,4]]) tf.placeholdertf.placeholder(tf.float32,[3,2]):tf.float323x2placeholder placeholder  tensorflowplaceholder 123456import tensorflow as tfinput1 = tf.placeholder(tf.float32,[2,2])input2 = tf.placeholder(tf.float32,[2,2])ouput = tf.multiply(input1,input2)with tf.Session() as sess: print(sess.run(output,feed_dict=&#123;input1:[[1,2],[2,2]],input2:[[1,2],[3,4]]&#125;)) 1234567891011tf.nn.relu(features,name = None) # tf.nn.relu6tf.nn.crelutf.nn.elutf.nn.selutf.nn.softplustf.nn.softsigntf.nn.dropouttf.nn.bias_addtf.sigmoidtf.tanh]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ESRGAN ]]></title>
    <url>%2F2019%2F03%2F02%2FESRGAN-%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[ESRGAN ESRGANSRGANresidual-in residual Dense Block()BNGANESRGANpush ESRGAN: Enhanced Super-Resolution Generative Adversarial Networkssubmit time:2018 ECCVarxiv link ESRGAN SRsuper resolutionPeak Signal-to-Noise Ratio(PSNR)GTMSE lossSRGAN RDDBBN GANRaGAN SRGANVGG features mapSRGANfeature map  BN  BNBN tip101$\beta$2 $D(x_r) = \sigma (C(x))$,$\sigma$ sigmoid$C(x)$sigmoid$$D_{ra}(x_r,x_f) = \sigma(C(x_r) - E[C(x_f)] )$$$E[C(x_f)]$mini-batch loss $$L_G = L_{percep}+ \lambda L_G^{Ra} + \eta L_1$$$L_{percep}$vggfeatures mapGTfeatures mapMSE lossSRGAN$L_{G}^{Ra}$$$L_G^{Ra} = -E_{x_r}[log(1-D_{Ra}(x_r,x_f))] - E_{x_f}[log(D_{Ra}(x_f,x_r))]$$$L_1$ loss L1 $$L_1 = E_{x_a} || G(x_i)-y||_1$$ lossloss$$L_D^{Ra} = -E_{x_r}[log(D_{Ra}(x_r,x_f))] - E_{x_f}[log(1 - D_{Ra}(x_f,x_r))]$$  BN GAN features mapMSE PSNRPSNR $G_{PSNR}$GAN$G_{GAN}$fine tune,$$\theta_{G}^{INTERP} = (1-\alpha) \theta_G^{PSNR}+\alpha \theta_G^{GAN}$$$\alpha$PSNR SRGANloss]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[]]></title>
    <url>%2F2019%2F03%2F02%2F%E5%BE%AE%E7%94%B5%E9%98%BB%E6%88%90%E5%83%8F%2F</url>
    <content type="text"><![CDATA[      workFlow 2019.3.5tensorflow ESRGAN 2019.3.3do something in this place 2019.3.2 ]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux]]></title>
    <url>%2F2019%2F03%2F02%2Flinux%E6%93%8D%E4%BD%9C%E5%8F%8A%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[welcome to my blog,enter password to read. Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>tip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SRGAN ]]></title>
    <url>%2F2019%2F03%2F01%2FSRGAN-%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[SRGANSRGANCNNSRGAN Photo-Realistic Single Image Super-Resolution Using a Generative Adversarial Networksubmit time:2017arxiv link SRGANSRGAN CNN4MSElossSRGANfeature mapMSE loss  SRResnetBNPReLULeaky ReLU,BN SGGANcontent lossadversarial losscontent lossGTMSEfeatures mapVGG feature map loss$\phi_{i,j}$feature mapj-th conv i-th Max pooling GTfeature mapfeatures mapMSE loss adversarial losslosslossloss SRGANSRGANGTtrain data  SRResnetResnetGTVggMSE loss  Lossfeatures mapMSE LossLoss Lossloss GTbatchGT]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[project two]]></title>
    <url>%2F2019%2F02%2F25%2Fproject-two%2F</url>
    <content type="text"><![CDATA[welcome to my blog,enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category></category>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[]]></title>
    <url>%2F2019%2F02%2F23%2F%E8%B0%88%E7%9C%8B%E8%AE%BA%E6%96%87%E5%92%8C%E8%AE%B0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ ()     ,       ]]></content>
      <tags>
        <tag>tip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GAN]]></title>
    <url>%2F2019%2F02%2F23%2FGAN%E7%B3%BB%E5%88%97%E8%AE%BA%E6%96%87%2F</url>
    <content type="text"><![CDATA[GANGenerative Adversarial Networks(GAN) Generative Adversarial Networkssubmit time: 2014arxiv link  G D GDDsigmoid D$\log(D(x))$.G$\log(1D(G(z)))$DG$V(G,D)$$$\min_G \max_D V(D,G)=E_{xpdata(x)}[\log D(x)]+E_{zpz(z)}[log(1D(G(z)))].$$ $Pdata(x)$$x$$P(Z)$$Z$$G(Z)$$D(X)$ GAN1. discriminatorlogD(x)11 - D(G(x))101. generatorG(x)D(x) = 1GDD$$D(x) = \frac{P_{data}(x)}{P_{data}(x) + P_g(x)}$$GKLlog(4)KL0$P_z(z) = P_{g}(x)$-log(4)DG$$P_z(z) = P_{g}(x)$$D(x)G(x)GAND(x)$$D(x) = \frac{1}{2}$$ Conditional GANGANpixel GAN Conditional Generative Adversarial NetworksGANGD GDyylabeltags $$\min_G \max_D V(D,G)=E_{xpdata(x)}[\log D(x|y)]+E_{zpz(z)}[log(1D(G(z|y)))].$$ yadditional input layerp(z) yx   MNISTlabelone-hot10078428*28maxoutmaxout pix2pix Image-to-Image Translation with Conditional Adversarial Networkssubmit time: 2016arxiv link pix2pixpix2pixCGANCGANGDL1 loss pix2pix conv-BatchNorm-ReLuG(X)U-Netencoder-decoderskip layer1234567891011121314151617encoder_1: [batch, 256, 256, in_channels] =&gt; [batch, 128, 128, ngf]encoder_2: [batch, 128, 128, ngf] =&gt; [batch, 64, 64, ngf * 2]encoder_3: [batch, 64, 64, ngf * 2] =&gt; [batch, 32, 32, ngf * 4]encoder_4: [batch, 32, 32, ngf * 4] =&gt; [batch, 16, 16, ngf * 8]encoder_5: [batch, 16, 16, ngf * 8] =&gt; [batch, 8, 8, ngf * 8]encoder_6: [batch, 8, 8, ngf * 8] =&gt; [batch, 4, 4, ngf * 8]encoder_7: [batch, 4, 4, ngf * 8] =&gt; [batch, 2, 2, ngf * 8]encoder_8: [batch, 2, 2, ngf * 8] =&gt; [batch, 1, 1, ngf * 8]decoder_8: [batch, 1, 1, ngf * 8] =&gt; [batch, 2, 2, ngf * 8 * 2]decoder_7: [batch, 2, 2, ngf * 8 * 2] =&gt; [batch, 4, 4, ngf * 8 * 2]decoder_6: [batch, 4, 4, ngf * 8 * 2] =&gt; [batch, 8, 8, ngf * 8 * 2]decoder_5: [batch, 8, 8, ngf * 8 * 2] =&gt; [batch, 16, 16, ngf * 8 * 2]decoder_4: [batch, 16, 16, ngf * 8 * 2] =&gt; [batch, 32, 32, ngf * 4 * 2]decoder_3: [batch, 32, 32, ngf * 4 * 2] =&gt; [batch, 64, 64, ngf * 2 * 2]decoder_2: [batch, 64, 64, ngf * 2 * 2] =&gt; [batch, 128, 128, ngf * 2]decoder_1: [batch, 128, 128, ngf * 2] =&gt; [batch, 256, 256, generator_outputs_channels] 12345layer_1: [batch, 256, 256, in_channels * 2] =&gt; [batch, 128, 128, ndf]layer_2: [batch, 128, 128, ndf] =&gt; [batch, 64, 64, ndf * 2]layer_3: [batch, 64, 64, ndf * 2] =&gt; [batch, 32, 32, ndf * 4]layer_4: [batch, 32, 32, ndf * 4] =&gt; [batch, 31, 31, ndf * 8]layer_5: [batch, 31, 31, ndf * 8] =&gt; [batch, 30, 30, 1]  pix2pixPatchGAN patchGANpatchPatchPatchGAN70x70 L1 lossL1L2 lossL1L2()() 12 pix2pixpix2pixCGANL1 loss$$L_{L1}(G)=E_{yp_{data(x,y)},zp_z(z)}[yG(x,z)_1]$$L1 lossloss $$G^=\min_G \max_D L_{cGAN}(G,D)+\lambda L_{L1}(G)$$$$\min_G \max_D L_{cGAN}(D,G)=E_{xpdata(x)}[\log D(x|y)]+E_{zpz(z)}[log(1D(G(z|y)))].$$ L1 loss pix2pix pix2pixcGANconv-BatchNorm-ReLuU-NetL1 lossSGD + adamBNdropout]]></content>
      <categories>
        <category></category>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[project one]]></title>
    <url>%2F2019%2F02%2F22%2Fproject-one%2F</url>
    <content type="text"><![CDATA[welcome to my blog,enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category></category>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[]]></title>
    <url>%2F2019%2F02%2F22%2F%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E7%AE%80%E8%A6%81%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[CNN padding  valid padding SAME padding0    GCN      SegNetFCNCNNSegNetFCNshortcutfeature mapMax pooling Dilated ConvolutionsFCNpoolingupsamplingpoolingdilated conv pooling7x7patcha93x3kernelkernelsize7x7(a) 1-dilated convolution$3 \times 3 = 9$(b) 2-dilated convolution$7 \times 7 = 49$(c) 4-dilated convolution$15 \times 15 = 225$dilated convolution  kernel  pixel  checker-board   Hybrid Dilated Convolution (HDC) HDC   dilation rate 1 [2, 4, 6]  gridding effect  dilation rate   [1, 2, 5, 1, 2, 5]  pixelDeepLab V1 DCNNsDCNNs,  DCNNpooling  DCNN:  DCNNmax-poolingdownsampling(striding),   DCNN atrouspoolingastride2poolingpooling7bstride = 1pooling5cstride=1hole = 27features map $$r = (m-1) stride+ksize$$mdilate rate = 1dilate rate = 23\35*5dilate rate = 39*9 CRFDCNNCRFDCNNDenseDRFi$x_i$()$y_i$()$x_i$$y_i$denseCRFCRF dilate conv + CRF Deeplab v2deeplab v2v1ASPPResNet DCNNDeepLabdeeplab v2 Atrous Convolution  (ASPP)ASPPfeatures map DCNNCRF DCNN: DCNN()atrous convolution  DCNN space pyramid pooling(ASPP) DCNN(skip-layers)(CRF) deeplap v2  conv5features mapsoftmaxfeatures map1/8 features map8 CRF CRFDCNNCRFDCNN1210CRF deeplab v3V3v2v3v3+Xecptionflagstate of art ]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Interview Summary]]></title>
    <url>%2F2019%2F02%2F21%2FInterview-Summary%2F</url>
    <content type="text"><![CDATA[welcome to my blog,enter password to read. Incorrect Password! No content to display! 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]]></content>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DP]]></title>
    <url>%2F2019%2F02%2F21%2FDP%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[DP  (array,tree,graph)    DP  n $A_1,A_2,A_3..A_n$$A_i$$A_{i+1}$i=1,2,n-1n $A_1A_2A_3,.A_n$  k1kk+1n  $$ OPT[1,n] = OPT[1,k]+OPT[k+1,n] + p_0p_kp_{n+1} $$  $2^{n-1}$12345678910111213recursive_matrix_chain(i,j)&#123; if i == j then return 0 OPT(i,j) = INF for k=i to j-1: q = recursive_matrix_chain(i,k)+ recursive_matrix_chain(k+1,j)+ p[i]*p[k+1]*p[j+1] if q&lt;OPT(i,j): OPT(i,j) = q return OPT(i,j)&#125; memorizing techniquedynamic programmingprogramming tabulartabularDP123456789101112131415memorize_matrix_chain(i,j)&#123; if OPT[i,j] != NULL: // return OPT[i,j] if i == j: // OPT[i,j] = 0 else: for k = i to j - 1: // q = memorize_matrix_chain(i,k)+ memorize_matrix_chain(k+1,j) + p[i]*p[k+1]*p[j+1] if q &lt; OPT[i,j]: OPT[i,j] = q return OPT[i,j] &#125;  $T(n) = O(n^3)$  $O(n^2)n = O(n^3) $ 2nij123456789101112131415matrix_chain_multiplication()&#123; for i = 1 to n : OPT[i,i] = 0 for l = 2 to n : //2n for i = 1 to n - l + 1: //li j = i + l -1 // j opt[i,j] = INF for k = i to j - 1: // q = opt[i,k]+opt[k+1,j]+p[i]*p[k+1]*p[j+1] if q &lt; opt[i,j]: opt[i,j] = q s[i,j] = k return opt[1,n]&#125; 0/1 Si w_i  v_i W 0/1ii$$ opt({1,2,n},W) = \max \begin{cases} opt({1,2,n-1},W) &amp; opt({1,2,n-1},W-w_n)+v_n \end{cases}$$123456789Knapsack(n,w)&#123; for w = 1 to W: OPT[0,w] = 0 for i = 1 to n: //i for w = 1 to W: // w if w &gt; w[i]: // OPT[i,w] = max(opt[i-1][w],opt[i-1][w-w[i]]+v[i])&#125; 12345678910void traceback()&#123; for i = n to 2: if(m[i][c] == m[i-1][c]): x[i] = 0 else: x[i] = 1 c -= w[i] x[1] = m[1][c]&gt;0? 1:0;&#125;  O(nW) $ O(nW) = O(n*2^{logW})$ WW    $$ opt(root) = \min ( 1 + \sum_copt(c) , children + \sum_gopt(g) )$$1234567vertex_cover(root)&#123; if(root == NULL): return 0 opt(root) = min(sum_of_child+opt(g),1+opt(c)) return opt(root) &#125; ]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ -- FCN]]></title>
    <url>%2F2019%2F02%2F20%2F%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2%E7%B3%BB%E5%88%97-FCN%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[  FCNFCN convolutionalFCN (upsample)deconvolution (skip layer) FCNFully Convolutional Networks for Semantic Segmentationsubmit time: 2015arxiv link FCNCNNCNN, (feature map)AlexNetCNNAlexNetImageNet1000(softmax), AlexNet, 1000, , tabby catFCNAlexnet, VGG, Googlenetsemantic segmentationFCNCNNFCNCNNimage patchpatchFCNCNNFCCNNfeature mapCNNsoftmaxFCNCNNFCCNNC+1C+1channelsheat mapcnnfeature mapFCNCNNPoolreceptive fieldsheat mapfeature mapssstrideSemantic segmentationheat mapinput raw imageFCNsdeconvolutionheat map-&gt; [7x7x512]k=7padding = 0,stride = 1,4096[1x1x4096] K=14096[1x1x4096] K=11000[1x1x1000] feature mappaddingpaddingKernel size - 1padding0feature strides()1FULLfull: 1N1xN1N2xN2N1+N2-1 x N1+N2-120stride2stride20.52 (skip layer)feature map16*16*409616*16*213216FCN-32s33pooling 8FCN-8s LOSSFCNloss losssoft Maxtensorflow 12loss = tf.reduce_mean((tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits,labels=tf.squeeze(annotation, squeeze_dims=[3]),name="entropy"))) CNN SGD]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cross entropy softmax]]></title>
    <url>%2F2019%2F02%2F20%2Fcross-entropy-%E4%BA%A4%E5%8F%89%E7%86%B5%E4%BB%A5%E5%8F%8Asoftmax%2F</url>
    <content type="text"><![CDATA[cross entropy softmaxCNNloss $$I(x_0) = - \log(P(x_0))$$$p(x_0) = 0.1,I(x_0) = 3.32$$p(x_0) = 0.999,I(x_0) = 0.0014$ $$H(x) = - \sum_{x\in X}p(x) \log p(x)$$$$H(A,B) = -\sum_i P_{A}(x_i)log(P_{B}(x_i))$$  KLKLKLKL$$D_{KL}(A||B) = \sum_i P_A(x_i)\log(\frac{P_A(x_i)}{P_B(x_i)}) = \sum_{i}P_{A}(x_i)log(P_{A}(x_i ))- \sum_i P_{A}(x_i)log(P_{B}(x_i))$$KL = -  + KL KL P(model) groundtruth P(real) KLKLgroundtruthKL softmaxx, KLsoftmax0,1softmax$$S_i = \frac{e^{V_i}}{\sum_j{e^{V_j}}}$$V softmaxV$$D = max(V) \\S_i = \frac{e^{V_i - D}}{\sum_j{e^{V_j - D}}} = \frac{e^{V_i}}{\sum_j{e^{V_j}}} / \frac{D}{D}$$ CNNsoftmax + cross entropyLOSS$$Loss = -\sum_i P_{groundtruth} \log P_{predict}$$$P_{groundtruth}$$P_{groundtruth}$one hot[0,0,,1,0,0]$P_{predict}$softmaxLoss $$-\log p_i$$i + softmax$p_i$softmaxsoftmax$$L = - \log \frac{e^{V_{i}}}{\sum_j e^{V_{j}}}$$ BP$-\log p_i$,$W_{ij}$$$\frac{\partial{L}}{\partial{W_{ij}}} = - \frac{1}{\frac{e^{a_i}}{\sum_k e^{a_k}}} \frac{\partial{ \frac{e^{a_i}}{\sum_k e^{a_k}} }}{\partial{a_{j}}} \frac{\partial{a_j}}{\partial{W_{ij}}}$$softmaxsoftmax$$ y_i = \frac{e^{a_i}}{\sum_{k=1}^{C}e^{a_k}}$$softmax$$\frac{\partial{y_{i}}}{\partial{a_{j}}} = \frac{\partial{ \frac{e^{a_i}}{\sum_k e^{a_k}} }}{\partial{a_{j}}}$$ i!=j $$\frac{\partial{y_{i}}}{\partial{a_{j}}} = \frac{\partial{ \frac{e^{a_i}}{\sum_{k=1}^{C}e^{a_k}} }}{\partial{a_{j}}}= \frac{ 0 - e^{a_i}e^{a_j}}{\Sigma^2}=-\frac{e^{a_i}}{\Sigma}\frac{e^{a_j}}{\Sigma}=-y_iy_j$$ i==j $$\frac{\partial{y_{i}}}{\partial{a_{j}}} = \frac{\partial{ \frac{e^{a_i}}{\sum_{k=1}^{C}e^{a_k}} }}{\partial{a_{j}}}= \frac{ e^{a_i}\Sigma - e^{a_i}e^{a_j}}{\Sigma^2}=\frac{e^{a_i}}{\Sigma}\frac{\Sigma - e^{a_j}}{\Sigma}=y_i(1 - y_j)$$CNNSGD SGD $x_0 -&gt; x_1$$$x_{k+1} = x_k + \eta P_k$$$P_k$$P_k = -\nabla f_k$,SGDSGD GD:$$x_{t+1}=x_t+\eta_t g_t$$ $g_t$ Stochastic Gradient $E[g_t]=-\nabla f(x_t)$softmax tensorflow 12345678910111213141516171819202122232425262728293031323334import tensorflow as tfimport numpy as np# downlown the datafrom tensorflow.examples.tutorials.mnist import input_datamnist = input_data.read_data_sets("MNIST_data/",one_hot=True)# input dataX = tf.placeholder(tf.float32,[None,784])Y = tf.placeholder(tf.float32,[None,10])# model variableW = tf.Variable(tf.zeros([784,10]))b = tf.Variable(tf.zeros([10]))# define modely_predict = tf.matmul(X,W) + bcross_entropy = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels=Y,logits=y_predict))optimizer = tf.train.GradientDescentOptimizer(0.5)train_step = optimizer.minimize(cross_entropy)sess = tf.InteractiveSession()global_initial = tf.global_variables_initializer()sess.run(global_initial)for i in range(1000): batch = mnist.train.next_batch(100) sess.run(train_step,feed_dict=&#123;X:batch[0],Y:batch[1]&#125;)correct_prediction = tf.equal(tf.argmax(y_predict,1),tf.argmax(Y,1))accuracy = tf.reduce_mean(tf.cast(correct_prediction,tf.float32))print(sess.run(accuracy,feed_dict=&#123;X:mnist.test.images,Y:mnist.test.labels&#125;))print(sess.run(b))]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode ()]]></title>
    <url>%2F2019%2F02%2F20%2FLeetCode-%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[tip 2019 28/5/2019 116.Populating Next Right Pointers in Each Node,117leetcode116117 12345678910111213141516171819202122232425262728293031323334353637383940"""# Definition for a Node.class Node(object): def __init__(self, val, left, right, next): self.val = val self.left = left self.right = right self.next = next"""class Solution(object): def connect(self, root): """ :type root: Node :rtype: Node """ if root == None: return root que = [] que.append(root) count = 1 record = 0 while len(que) &gt; 0: node = que.pop(0) count -= 1 if node.left: que.append(node.left) record += 1 if len(que)&gt;1: que[-2].next = que[-1] if node.right: que.append(node.right) record += 1 if len(que)&gt;1: que[-2].next = que[-1] if count == 0: node.next = None count = record record = 0 return root 21/5/2019 103. Path Sum IIpathsumsum(path) + root.val valpath 123456789101112131415161718192021222324252627282930313233# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def __init__(self): self.result = [] def find_path(self,root,sums,path): if root == None: return if sum(path) + root.val == sums and root.left == None and root.right == None: self.result.append((path+[root.val])[:]) return path.append(root.val) self.find_path(root.left,sums,path) self.find_path(root.right,sums,path) if path!=[]: path.pop() def pathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: List[List[int]] """ path = [] self.find_path(root,sum,path) return self.result 114.Flatten Binary Tree to Linked List 1234567891011121314151617181920212223# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def flatten(self, root): """ :type root: TreeNode :rtype: None Do not return anything, modify root in-place instead. """ self.prev = None def dfs(root): if root == None: return None dfs(root.right) dfs(root.left) root.right = self.prev root.left = None self.prev = root dfs(root) 19/4/2019 107. Binary Tree Level Order Traversal II 12345678910111213141516171819202122232425class Solution(object): def levelOrderBottom(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ res = [] line =[root] if root == None: return res num = 1 val = [] while len(line): node = line.pop(0) num-=1 val.append(node.val) if node.left: line.append(node.left) if node.right: line.append(node.right) if num == 0: res.insert(0,val[:]) val = [] num = len(line) return res 18/4/2019 102. Binary Tree Level Order Traversallist list0list 1234567891011121314151617181920212223242526class Solution(object): def levelOrder(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ res = [] if root == None: return res line = [] line.append(root) val = [] num = 1 while len(line): node = line.pop(0) val.append(node.val) num -= 1 if node.left != None: line.append(node.left) if node.right != None: line.append(node.right) if num == 0: res.append(val) val = [] num = len(line) return res 103. Binary Tree Zigzag Level Order TraversalZ 1234567891011121314151617181920212223242526272829303132class Solution(object): def zigzagLevelOrder(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ res = [] if root == None: return res line = [] line.append(root) val = [] num = 1 level = 0 while len(line): node = line.pop(0) num -= 1 val.append(node.val) if node.left: line.append(node.left) if node.right: line.append(node.right) if num == 0: num = len(line) if level%2 == 1: val.reverse() res.append(val) else: res.append(val) val = [] level += 1 return res 15/4/2019 96. Unique Binary Search Trees f(1) = f(0) x f(2), f(2)=f(1) x f(1),  f(n) = f(n-1)xf(0) 12345678class Solution(object): def numTrees(self,n): res = [0] *(n+1) res[1] = 1 for i in range(1,n+1): for j in range(j): res[i] += res[j]*res[i-j-1] return res 94. Binary Tree Inorder Traversal  1234567891011121314151617class Solution(object): def __init__(self): self.res = [] def dfs(self,root): if root == None: return self.dfs(root.left) self.res.append(root.val) self.dfs(root.right) def inorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ self.dfs(root) return self.res 101. Symmetric TreeFalse 12345678910111213141516171819class Solution(object): def dfs(self,left,right): if left == None or right == None: if left != right: return False else: return True if left.val != right.val: return False return self.dfs(left.left,right.right) and self.dfs(left.right,right.left) def isSymmetric(self, root): """ :type root: TreeNode :rtype: bool """ if root == None: return True return self.dfs(root.left,root.right) 25/3/2019 92. Reverse Linked List IItailhead 12345678910111213141516171819202122232425262728293031323334# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def reverseBetween(self, head, m, n): """ :type head: ListNode :type m: int :type n: int :rtype: ListNode """ if m == n: return head dummy = ListNode(-1) dummy.next = head p = dummy newhead = p for i in range(m): newhead = p p = p.next tail = p q = p p = p.next for i in range(n-m): p_pre = p.next p.next = q q = p p = p_pre tail.next = p_pre newhead.next = q return dummy.next 93. Restore IP Addresses13ip 123456789101112131415161718class Solution(object): def __init__(self): self.res = [] def helper(self,s,ret,index,count): if count&gt;4: return if count == 4 and index == len(s): self.res.append(res[:-1]) for i in range(1,4): if i + index &gt; len(s): break temp = s[index,index+i] if (temp[0] == '0' and len(temp)&gt;1) and (len(temp) and int(temp)&gt;=256): continue helper(s,ret+temp+'.',index+i,count+1) def restoreIpAddresses(self,s): self.helper(s,'',0,0) return self.res 24/3/2019 91. Decode Ways0 123456789101112131415161718192021222324252627class Solution(object): def numDecodings(self, s): #  """ :type s: str :rtype: int """ if len(s) == 0 or s[0] == '0': return 0 dp = [0]*len(s) dp[0] = 1 for i in range(1,len(s)): if s[i] == '0': #  if s[i-1] == '2' or s[i-1] == '1' : if i == 1: dp[i] = 1 else: dp[i] = dp[i-2] elif int(s[i-1:i+1])&lt;=26 and s[i-1]!='0': if i == 1: dp[i] = 2 else: dp[i] = dp[i-1]+dp[i-2] else: dp[i] = dp[i-1] return dp[len(s)-1] 23/3/2019  90. Subsets IImedian 12345678910111213141516171819class Solution(object): def dfs(self,nums,pos,temp,res): if sorted(temp) not in res: res.append(sorted(temp)) for i in range(pos,len(nums)): temp.append(nums[i]) self.dfs(nums,i+1,temp,res) temp.pop() def subsetsWithDup(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ res = [] if len(nums) == 0: return [] self.dfs(nums,0,[],res) return res  12345678temp = [1,2,3]a = temp # atempa = temp[:] # atempimport copya = copy.deepcopy(temp) # ## a.sort() # asorted(a) #  89. Gray CodeG(i) = i ^ (i/2) 12345678910class Solution(object): def grayCode(self, n): """ :type n: int :rtype: List[int] """ res = [] for i in range(1&lt;&lt;n): res.append(i^i&gt;&gt;1) return res 21/3/2019 100. Same Tree    123456789101112131415161718192021# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def isSameTree(self, p, q): """ :type p: TreeNode :type q: TreeNode :rtype: bool """ if p == None: return q==None if q == None: return False if p.val != q.val: return False return self.isSameTree(p.right,q.right) and self.isSameTree(p.left,q.left) 18/3/2019 73. Set Matrix Zeroes   10python 1234matrix[key] = [0]*n # key#,for i in range(n): matrix[i][key] = 1 1234567891011121314151617181920212223242526class Solution(object): def setZeroes(self, matrix): """ :type matrix: List[List[int]] :rtype: None Do not return anything, modify matrix in-place instead. """ dict_x = &#123;&#125; dict_y = &#123;&#125; if len(matrix) == 0: return if len(matrix[0]) == 0: return m = len(matrix) n = len(matrix[0]) for i in range(m): for j in range(n): if matrix[i][j] == 0: if i not in dict_x: dict_x[i] = 1 if j not in dict_y: dict_y[j] = 1 for key in dict_x.keys(): matrix[key] = [0]*n for key in dict_y.keys(): for i in range(m): matrix[i][key] = 0 77. Combinations listlistlist.append(list1[:]) 12345678910111213141516class Solution(object): def dfs(self,n,idx,k,res,cur): if k == 0: res.append(cur[:]) else: for i in range(idx,n): if k &gt; n-i: return [] cur.append(i+1) self.dfs(n,i+1,k-1,res,cur) cur.pop() def combine(self,n,k): res = [] cur = [] dfs(n,0,k,res,cur) return res 78. Subsets  1234567891011121314151617181920class Solution(object): def dfs(self,nums,idx,ilen,res,cur): if ilen &gt; len(nums): return if len(cur) == ilen: res.append(cur[:]) for i in range(idx,len(nums)): cur.append(nums[i]) self.dfs(nums,i+1,ilen+1,res,cur) cur.pop() def subsets(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ res = [] cur = [] self.dfs(nums,0,0,res,cur) return res 80. Remove Duplicates from Sorted Array IIle 12345678910111213141516171819202122class Solution(object): def removeDuplicates(self, nums): """ :type nums: List[int] :rtype: int """ if len(nums) == 0: return 0 le = 0 pos = 0 for i in range(1,len(nums)): if nums[i-1] == nums[i]: le += 1 if le&lt;2: pos+=1 nums[pos] = nums[i] else: le = 0 pos+=1 nums[pos] = nums[i] # nums[pos] = nums[len(nums)-1] return pos+1 14/3/2019  pythonpython,stack/dict 1234567891011121314151617181920class Solution(object): def simplifyPath(self, path): """ :type path: str :rtype: str """ str = path.split('/') res = [] for ch in str: if ch == '..': if len(res) != 0: res.pop() elif ch!='' and ch!='.': res.append(ch) ans = '/' for ch in res: ans += ch+'/' if len(ans) == 1: return ans return ans[:len(ans)-1] 11/3/2019 63. Unique Paths II $path[i][j] = path[i-1][j]+path[i][j-1]$1 1234567891011121314151617181920212223class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; if(obstacleGrid.size() == 0||obstacleGrid[0].size() == 0) return 0; if(obstacleGrid[0][0] == 1 ) return 0; int height = obstacleGrid.size(); int width = obstacleGrid[0].size(); vector&lt;vector&lt;double&gt;&gt; path(height,vector&lt;double&gt;(width,0)); for(int i = 0;i&lt;width&amp;&amp;obstacleGrid[0][i]!=1;i++)&#123; path[0][i] = 1; &#125; for(int i = 1;i&lt;height&amp;&amp;obstacleGrid[i][0]!=1;i++)&#123; path[i][0] = 1; &#125; for(int i = 1;i&lt;height;i++)&#123; for(int j = 1;j&lt;width;j++)&#123; if(obstacleGrid[i][j] == 1) continue; path[i][j] = path[i-1][j]+path[i][j-1]; &#125; &#125; return path[height-1][width-1]; &#125;&#125;; 64. Minimum Path Sum min 1234567891011121314151617181920class Solution &#123;public: int minPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; if(grid.size() == 0 || grid[0].size() == 0) return 0; int height = grid.size(); int width = grid[0].size(); for(int i = 1;i&lt;width;i++)&#123; grid[0][i] += grid[0][i-1]; &#125; for(int j = 1;j&lt;height;j++)&#123; grid[j][0] += grid[j-1][0]; &#125; for(int i = 1 ;i&lt;height;i++)&#123; for(int j = 1;j&lt;width;j++)&#123; grid[i][j] += min(grid[i-1][j],grid[i][j-1]); &#125; &#125; return grid[height-1][width-1]; &#125;&#125;; 65. Valid Number  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Solution &#123;public: bool isNumber(string s) &#123; if( !s.empty() )&#123; s.erase(0,s.find_first_not_of(" ")); s.erase(s.find_last_not_of(" ") + 1); &#125; if(s.size() == 0) return false; if(s.size() == 1&amp;&amp;s[0] == '.') return false; unordered_map&lt;char,int&gt; amap; amap['-'] = 0; amap['+'] = 0; amap['.'] = 0; amap['e'] = 0; int i = 0; int flag = 0; while(i&lt;s.size())&#123; if('0'&lt;=s[i]&amp;&amp;s[i]&lt;='9')&#123; flag = 1; i++; continue; &#125; if(s[i] == '-'||s[i] == '+')&#123; if(amap['-'] + amap['+'] &gt; 0)&#123; if(i&gt;0&amp;&amp;s[i-1]=='e')&#123; i++; if(i&gt;=s.size()) return false; continue; &#125;else&#123; return false; &#125; &#125; else&#123; if(i!= 0&amp;&amp;s[i-1]!='e') return false; i++; if(i&gt;=s.size()) return false; continue; &#125; amap[s[i]]++; i++; if(i&gt;=s.size()) return false; continue; &#125; if(s[i] == '.')&#123; if(amap['.'] != 0) return false; if(amap['e']!=0) return false; if(i==0||('0'&lt;=s[i-1]&amp;&amp;s[i-1]&lt;='9'))&#123; i++; amap['.']++; continue; &#125; if(s[i-1]=='-'||s[i-1]=='+')&#123; i++; amap['.']++; continue; &#125; &#125; if(s[i] == 'e')&#123; if(amap['e']!=0) return false; if(i&gt;0&amp;&amp;('0'&lt;=s[i-1]&amp;&amp;s[i-1]&lt;='9'))&#123; i++; amap['e']++; if(i&gt;=s.size()) return false; continue; &#125; if(s[i-1]=='.'&amp;&amp;flag == 1)&#123; i++; amap['e']++; if(i&gt;=s.size()) return false; continue; &#125; &#125; return false; &#125; if(amap['.']||amap['-']||amap['+'])&#123; if(flag == 0) return false; &#125; return true; &#125;&#125;; 69. Sqrt(x)  123456789101112131415161718192021class Solution &#123;public: int mySqrt(int x) &#123; // int a = 0;// a = sqrt(x);// return a; int l = 1; int r = x; while(l&lt;=r)&#123; int m = l+(r-l)/2; if(m&gt;(x/m))&#123; r = m-1; &#125; else&#123; l = m+1; &#125; &#125; return l-1; &#125;&#125;; 10/3/2019 54. Spiral Matrix begin&lt;end 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;int&gt; res; if(matrix.size() == 0 || matrix[0].size() == 0) return res; int rowbegin = 0; int rowend = matrix.size()-1; int colbegin = 0; int colend = matrix[0].size()-1; while(rowbegin&lt;=rowend&amp;&amp;colbegin&lt;=colend)&#123; for(int i = colbegin;i&lt;=colend;i++)&#123; res.push_back(matrix[rowbegin][i]); &#125; rowbegin++; for(int i = rowbegin;i&lt;=rowend;i++)&#123; res.push_back(matrix[i][colend]); &#125; colend--; if(rowbegin&gt;rowend || colbegin&gt;colend) return res; for(int i = colend;i&gt;=colbegin;i--)&#123; res.push_back(matrix[rowend][i]); &#125; rowend--; if(rowbegin&gt;rowend || colbegin&gt;colend) return res; for(int i = rowend;i&gt;=rowbegin;i--)&#123; res.push_back(matrix[i][colbegin]); &#125; colbegin++; &#125; return res; &#125;&#125;; 55. Jump Game  1234567891011121314151617class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &lt;= 1)&#123; return true; &#125; int lastindex = 0; int cur = 0; while(lastindex&lt;nums.size())&#123; cur = max(lastindex+nums[lastindex],cur); if(cur&gt;=nums.size()-1) return true; if(cur==lastindex &amp;&amp; nums[lastindex] == 0) return false; lastindex++; &#125; return true; &#125;&#125;; 59. Spiral Matrix II nxn 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generateMatrix(int n) &#123; vector&lt;vector&lt;int&gt;&gt; matrix(n,vector&lt;int&gt;(n,0)); if(n==0) return matrix; int rowbegin = 0; int rowend = n-1; int colbegin = 0; int colend = n-1; int count = 1; while(rowbegin&lt;=rowend &amp;&amp; colbegin&lt;=colend)&#123; for(int i = colbegin;i&lt;=colend;i++)&#123; matrix[rowbegin][i] = count++; &#125; rowbegin++; for(int i = rowbegin;i&lt;=rowend;i++)&#123; matrix[i][colend] = count++; &#125; colend--; if(rowbegin&gt;rowend &amp;&amp; colbegin&gt;colend) return matrix; for(int i = colend;i&gt;=colbegin;i--)&#123; matrix[rowend][i] = count++; &#125; rowend--; if(rowbegin&gt;rowend &amp;&amp; colbegin&gt;colend)&#123; return matrix; &#125; for(int i = rowend;i&gt;=rowbegin;i--)&#123; matrix[i][colbegin] = count++; &#125; colbegin++; &#125; return matrix; &#125;&#125;; 60. Permutation Sequence k 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int count = 0; string res = ""; string ans; vector&lt;int&gt; visit; void dfs(int n,int k)&#123; if(res.size() == n)&#123; count++; if(count == k)&#123; ans = res; return; &#125; &#125; if(count!=k)&#123; for(int i = 1;i&lt;=n;i++)&#123; if(visit[i]==1) continue; res += to_string(i); visit[i] = 1; dfs(n,k); res = res.substr(0,res.size()-1); visit[i] = 0; &#125; &#125; &#125; string getPermutation(int n, int k) &#123; visit = vector&lt;int&gt;(n+1,0); dfs(n,k); return ans; &#125;&#125;; 61. Rotate List  123456789101112131415161718192021222324252627class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; if(k == 0||head == NULL) return head; int n = 0; auto p = head; while(p!=NULL)&#123; n++; p = p-&gt;next; &#125; k = k%n; if(k == 0) return head; p = head; while(n - k -1 &gt; 0)&#123; p = p-&gt;next; k++; &#125; auto q = p-&gt;next; auto ans = q; p-&gt;next = NULL; while(q-&gt;next!=NULL)&#123; q = q-&gt;next; &#125; q-&gt;next = head; return ans; &#125;&#125;; 70. Climbing Stairs  1234567891011121314class Solution &#123;public: int climbStairs(int n) &#123; if(n == 0) return 0; if(n == 1) return 1; vector&lt;int&gt; dp(n,0); dp[0] = 1; dp[1] = 2; for(int i = 2;i&lt;n;i++)&#123; dp[i] = dp[i-1]+dp[i-2]; &#125; return dp[n-1]; &#125;&#125;; 7/3/2019 6 51. N-Queens N  visit  visit temp.size()&gt;=n  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Solution &#123;public: // vector&lt;vector&lt;string&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; visit; void dfs(vector&lt;string&gt; temp,int pos,int n)&#123; if(temp.size() == n)&#123; res.push_back(temp); return; &#125; if(pos&gt;=n) return; for(int i = 0;i&lt;n;i++)&#123; string s(n,'.'); if(pos == 0)&#123; s[i] = 'Q'; temp.push_back(s); visit[pos][i] = 1; dfs(temp,pos+1,n); temp.pop_back(); visit[pos][i] = 0; &#125; else if((i==0||visit[pos-1][i-1]!=1)&amp;&amp; (i+1==n||visit[pos-1][i+1]!=1))&#123; int flag = 0; for(int j = 0;j&lt;n;j++)&#123; if(visit[j][i] == 1) &#123;flag = 1;break;&#125; &#125; int tempi = i-1; int tempj = pos-1; while(tempj&gt;=0&amp;&amp;tempi&gt;=0)&#123; if(visit[tempj--][tempi--] == 1)&#123;flag = 1;break;&#125; &#125; tempi = i+1; tempj = pos+1; while(tempj&lt;n&amp;&amp;tempi&lt;n)&#123; if(visit[tempj++][tempi++] == 1) &#123;flag = 1;break;&#125; &#125; tempi = i+1; tempj = pos-1; while(tempj&gt;=00&amp;&amp;tempi&lt;n)&#123; if(visit[tempj--][tempi++] == 1) &#123;flag = 1;break;&#125; &#125; tempi = i-1; tempj = pos+1; while(tempj&lt;n&amp;&amp;tempi&gt;=0)&#123; if(visit[tempj++][tempi--] == 1) &#123;flag = 1;break;&#125; &#125; if(flag == 0)&#123; s[i] = 'Q'; temp.push_back(s); visit[pos][i] = 1; dfs(temp,pos+1,n); temp.pop_back(); visit[pos][i] = 0; &#125; &#125; else&#123; continue; &#125; &#125; &#125; vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; if(n&lt;=0) return res; visit = vector(n,vector&lt;int&gt;(n,0)); vector&lt;string&gt; temp; dfs(temp,0,n); return res; &#125;&#125;; 206. Reverse Linked List 1234567891011121314151617181920212223class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(head == NULL||head-&gt;next == NULL) return head; ListNode* p = head-&gt;next; ListNode* q = head; q-&gt;next = NULL; while(p)&#123; auto temp = p-&gt;next; p-&gt;next = q; q = p; p = temp; &#125; return q; ///* if(head==NULL||head-&gt;next == NULL) return head; auto last = head-&gt;next; head-&gt;next = NULL; ListNode* newhead = reverseList(last); last-&gt;next = head; return newhead;*/ &#125;&#125;; 226. Invert Binary Tree  123456789101112class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if(root == NULL) return NULL; auto p = root-&gt;left; root-&gt;left = root-&gt;right; root-&gt;right = p; invertTree(root-&gt;left); invertTree(root-&gt;right); return root; &#125;&#125;; 104. Maximum Depth of Binary Tree  12345678910111213141516class Solution &#123;public: int maxn = 0; void dfs(TreeNode* root,int level)&#123; if(root == NULL) return; dfs(root-&gt;left,level+1); dfs(root-&gt;right,level+1); if(maxn&lt;level) maxn = level; &#125; int maxDepth(TreeNode* root) &#123; if(root == NULL) return 0; dfs(root,1); return maxn; &#125;&#125;; 5/3/2019 49. Group Anagrams  12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; vector&lt;vector&lt;string&gt;&gt; res; if(strs.size() == 0) return res; unordered_map&lt;string,int&gt; amap; for(int i = 0;i&lt;strs.size();i++)&#123; auto temp = strs[i]; sort(temp.begin(),temp.end()); if(amap.count(temp) == 0)&#123; amap[temp] = res.size(); vector&lt;string&gt; a; a.push_back(strs[i]); res.push_back(a); &#125; else&#123; res[amap[temp]].push_back(strs[i]); &#125; &#125; return res; &#125;&#125;; 82. Remove Duplicates from Sorted List II ,nextnext 123456789101112131415161718192021class Solution&#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(head == NULL) return head; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; auto p = dummy; while(p-&gt;next &amp;&amp; p-&gt;next-&gt;next)&#123; if(p-&gt;next-&gt;val == p-&gt;next-&gt;next-&gt;val)&#123; int same = p-&gt;next-&gt;val; while(p-&gt;next&amp;&amp;p-&gt;next-&gt;val == same)&#123; p-&gt;next = p-&gt;next-&gt;next; &#125; &#125; else&#123; p = p-&gt;next; &#125; &#125; return dummy-&gt;next; &#125;&#125; 83. Remove Duplicates from Sorted List p 1234567891011121314class Solution&#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(head == NULL) return head; auto p = head; while(p-&gt;next)&#123; if(p-&gt;next-&gt;val == p-&gt;val)&#123; p-&gt;next = p-&gt;next-&gt;next; &#125; else p = p-&gt;next; &#125; return head; &#125;&#125; 86. Partition List  12345678910111213141516171819202122232425262728293031class Solution &#123;public: ListNode* partition(ListNode* head, int x) &#123; if(head == NULL) return head; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; auto p = dummy; auto q = head; int count = 0; while(p-&gt;next)&#123; p = p-&gt;next; count++; &#125; q = p; p = dummy; while(count)&#123; count--; if(p-&gt;next-&gt;val &lt; x)&#123; p = p-&gt;next; &#125; else&#123; q-&gt;next = p-&gt;next; p-&gt;next = p-&gt;next-&gt;next; q = q-&gt;next; &#125; &#125; q-&gt;next = NULL; return dummy-&gt;next; &#125;&#125;; 87. Scramble String  1234567891011121314151617181920212223242526class Solution &#123;public: bool isScramble(string s1, string s2) &#123; if(s1.size()==0||s2.size() == 0) return false; if(s1 == s2) return true; vector&lt;int&gt; letters(26); for(int i = 0;i&lt;s1.size();i++)&#123; letters[s1[i]-'a']++; letters[s2[i]-'a']--; &#125; for(int i = 0;i&lt;26;i++)&#123; if(letters[i]!=0) return false; &#125; for(int i = 1;i&lt;s1.size();i++)&#123; if(isScramble(s1.substr(0,i),s2.substr(0,i))&amp;&amp; isScramble(s1.substr(i),s2.substr(i))) return true; if(isScramble(s1.substr(0,i),s2.substr(s1.size()-i))&amp;&amp; isScramble(s1.substr(i),s2.substr(0,s1.size()-i))) return true; &#125; return false; &#125;&#125;; 4/3/2019 46. Permutations1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; res; void dfs(vector&lt;int&gt; nums,vector&lt;int&gt; visit,vector&lt;int&gt; temp)&#123; if(temp.size() == nums.size())&#123; res.push_back(temp); return; &#125; for(int i = 0;i&lt;nums.size();i++)&#123; if(visit[i] == 0)&#123; visit[i] = 1; temp.push_back(nums[i]); dfs(nums,visit,temp); temp.pop_back(); visit[i] = 0; &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() == 0) return res; vector&lt;int&gt; visit(nums.size(),0); vector&lt;int&gt; temp; dfs(nums,visit,temp); return res; &#125;&#125;; 47. Permutations II1234567891011121314151617181920212223242526272829class Solution &#123;public: // set&lt;vector&lt;int&gt;&gt; res; vector&lt;vector&lt;int&gt;&gt; res; void dfs(vector&lt;int&gt; nums,vector&lt;int&gt; visit,vector&lt;int&gt; temp)&#123; if(temp.size() == nums.size())&#123; res.push_back(temp); return; &#125; for(int i = 0;i&lt;nums.size();i++)&#123; if(visit[i] == 0)&#123; if(i&gt;0&amp;&amp;nums[i-1] == nums[i]&amp;&amp;visit[i-1] == 0) continue; temp.push_back(nums[i]); visit[i] = 1; dfs(nums,visit,temp); visit[i] = 0; temp.pop_back(); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() == 0) return res; vector&lt;int&gt; visit(nums.size(),0); vector&lt;int&gt; temp; sort(nums.begin(),nums.end()); dfs(nums,visit,temp); return res; &#125;&#125;; 45. Jump Game IIgreedydpi$O(n^2)$ , greedycurlast1234567891011121314151617181920212223242526272829303132class Solution &#123;public:/* int jump(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() == 0) return 0; vector&lt;int&gt; dp(nums.size(),INT_MAX); dp[0] = 0; for(int i = 0;i&lt;nums.size() ;i++)&#123; for(int j = 0;j&lt;i;j++)&#123; if(nums[j]&gt;=i-j)&#123; dp[i] = min(dp[i],dp[j]+1); &#125; &#125; &#125; return dp[nums.size()-1]; &#125;*/ int jump(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() == 0) return 0; int res = 0; int last = 0; int cur = 0; for(int i = 0;i&lt;nums.size()-1 ;i++)&#123; cur = max(cur,i+nums[i]); if(i == last)&#123; last = cur; res++; if(last&gt;=nums.size()-1) return res; &#125; &#125; return res; &#125;&#125;; 50. Pow(x, n)12345678910111213141516class Solution &#123;public: double myPow(double x, int n1) &#123; if(n1 == 0) return 1.0; if(n1 == 1) return x; long long n = n1; if(n&lt;0)&#123; n = -n; x = 1.0/x; &#125; double res = myPow(x,n/2); if(n%2 == 0) return res*res; return res*res*x; &#125;&#125;; 3/3/2019 40. Combination Sum II12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; res; void dfs(vector&lt;int&gt; candidates,vector&lt;int&gt; temp,int target,int pos)&#123; if(target == 0)&#123; res.push_back(temp); return; &#125; for(int i = pos;i&lt;candidates.size()&amp;&amp;target&gt;=candidates[i];i++)&#123; temp.push_back(candidates[i]); dfs(candidates,temp,target-candidates[i],i+1); while(i+1&lt;candidates.size()&amp;&amp;candidates[i] == candidates[i+1]) i++; temp.pop_back(); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; if(candidates.size() == 0) return res; sort(candidates.begin(),candidates.end()); vector&lt;int&gt; temp; dfs(candidates,temp,target,0); return res; &#125;&#125;; 42. Trapping Rain Watervalval12345678910111213141516171819202122class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; if(height.size() == 0) return 0; vector&lt;int&gt; left(height.size()); vector&lt;int&gt; right(height.size()); left[0] = height[0]; right[height.size()-1] = height[height.size()-1]; for(int i = 1;i&lt;height.size();i++)&#123; left[i] = max(left[i-1],height[i]); &#125; for(int i = height.size()-2;i&gt;=0;i--)&#123; right[i] = max(right[i+1],height[i]); &#125; int res = 0; for(int i = 0;i&lt;height.size();i++)&#123; int temp = min(left[i],right[i])-height[i]; if(temp&gt;0) res += temp; &#125; return res; &#125;&#125;; 44. Wildcard Matchingp[j] = &#39;*&#39;: s[i-1]p[j-1]s[i]p[j]*1 s[i-1]p[j]s[i]p[j]*n s[i]p[j - 1]*0 p[j] = &#39;?&#39;p[j-1]s[i-1]p[j],s[i] 12345678910111213141516171819202122class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.size(),n = p.size(); vector&lt;vector&lt;bool&gt;&gt; dp(m+1,vector&lt;bool&gt;(n+1,false)); dp[0][0] = true; for(int i = 1;i&lt;=n;i++)&#123; if(p[i-1] == '*') dp[0][i] = dp[0][i-1]; // sp*  &#125; for(int i = 1;i&lt;=m;i++)&#123; for(int j = 1;j&lt;=n;j++)&#123; if(p[j-1] == '*')&#123; dp[i][j] = dp[i-1][j]||dp[i][j-1]||dp[i-1][j-1]; &#125; else if(p[j-1] == '?'||p[j-1] == s[i-1])&#123; dp[i][j] = dp[i-1][j-1]; &#125; &#125; &#125; return dp[m][n]; &#125;&#125;; 67. Add Binary1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: string addBinary(string a, string b) &#123; int n = a.size()-1; int m = b.size()-1; int add = 0; string res = ""; while(n&gt;=0&amp;&amp;m&gt;=0)&#123; int le = a[n] - '0'; int ri = b[m] - '0'; if(le+ri+add&gt;=2)&#123; res = to_string(le+ri+add -2) + res; add = 1; &#125; else&#123; res = to_string(le+ri+add) + res; add = 0; &#125; n--; m--; &#125; res = (n&gt;=0? a.substr(0,n+1):b.substr(0,m+1)) + res; if(add == 0) return res; int left = n&gt;=0? n:m; while(left&gt;=0)&#123; if(res[left] == '0')&#123; res[left] = '1'; return res; &#125; else&#123; res[left] = '0'; &#125; left--; &#125; res = '1'+ res; return res; &#125;&#125;; 2/3/2019 32. Longest Valid Parentheses1234567891011121314151617181920212223class Solution &#123;public: int longestValidParentheses(string s) &#123; if(s.size() == 0) return 0; int maxn = 0; stack&lt;int&gt; sta; sta.push(-1); for(int i = 0;i&lt;s.size();i++)&#123; if(s[i] == '(')&#123; sta.push(i); &#125; else&#123; sta.pop(); if(!sta.empty()) maxn = max(maxn,i-sta.top()); else&#123; sta.push(i); &#125; &#125; &#125; return maxn; &#125;&#125;; 34. Find First and Last Position of Element in Sorted ArrayO(log(n)) targettarget12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; res = &#123;-1,-1&#125;; if(nums.size() == 0) return res; int low = 0; int high = nums.size()-1; int mid; while(low&lt;=high)&#123; mid = (low+high)/2; if(nums[mid] == target) break; else if(nums[mid]&gt;target)&#123; high = mid-1; &#125; else&#123; low = mid+1; &#125; &#125; if(low&gt;high) return res; int i = 0; for(i = mid-1;i&gt;=0;i--)&#123; if(nums[i] != target) &#123;break;&#125; &#125; res[0] = i+1; for(i = mid + 1;i&lt;nums.size();i++)&#123; if(nums[i]!=target) &#123; break;&#125; &#125; res[1] = i-1; return res; &#125;&#125;; 36. Valid Sudoku123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; if(board.size() == 0) return false; // for(int i = 0;i&lt;9;i++)&#123; unordered_map&lt;char,int&gt; amap; for(int j = 0;j&lt;9;j++)&#123; if(amap.count(board[i][j]) != 0 &amp;&amp;board[i][j]!='.') return false; amap[board[i][j]] = 1; &#125; &#125; // for(int i = 0;i&lt;9;i++)&#123; unordered_map&lt;char,int&gt; amap; for(int j = 0;j&lt;9;j++)&#123; if(amap.count(board[j][i])!=0&amp;&amp;board[j][i]!='.') return false; amap[board[j][i]] = 1; &#125; &#125; // for(int i = 0;i&lt;9;i += 3)&#123; for(int j = 0;j&lt;9;j+=3)&#123; unordered_map&lt;char,int&gt; amap; for(int h = i;h&lt;i+3;h++)&#123; for(int k = j;k&lt;j+3;k++)&#123; if(amap.count(board[h][k])!=0&amp;&amp;board[h][k]!='.') return false; amap[board[h][k]] = 1; &#125; &#125; &#125; &#125; return true; &#125;&#125;; 39. Combination Sum123456789101112131415161718192021class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; res; void digui(vector&lt;int&gt;&amp; candidates,int target,vector&lt;int&gt; temp,int pos)&#123; if(target == 0) res.push_back(temp); for(int i = pos;i&lt;candidates.size();i++)&#123; if(target&gt;=candidates[i])&#123; temp.push_back(candidates[i]); digui(candidates,target-candidates[i],temp,i); temp.pop_back(); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; if(candidates.size() == 0) return res; vector&lt;int&gt; temp; digui(candidates,target,temp,0); return res; &#125;&#125;; 1/3/2019 38. Count and Sayn = 0  1for123456789101112131415161718class Solution &#123;public: string countAndSay(int n) &#123; if(n &lt;= 0) return ""; if(n == 1) return "1"; string s = countAndSay(n-1); string newS = ""; for(int i = 0;i&lt;s.size();i++)&#123; int count = 1; while(i+1&lt;s.size()&amp;&amp;s[i] == s[i+1])&#123; count++; i++; &#125; newS += to_string(count) + s[i]; &#125; return newS; &#125;&#125;; 2/28/2019 30. Substring with Concatenation of All Wordswordshash_map 1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; findSubstring(string s, vector&lt;string&gt;&amp; words) &#123; vector&lt;int&gt; res; if(s.empty()||words.size() == 0) return res; int m = words[0].size(); int n = words.size(); unordered_map&lt;string,int&gt; m1; for(int i = 0;i&lt;words.size();i++)&#123; ++m1[words[i]]; &#125; for(int i = 0;i&lt;=(int)s.size()-m*n;i++)&#123; cout&lt;&lt;s.size(); unordered_map&lt;string,int&gt; m2; int j = 0; for(;j&lt;words.size();j++)&#123; string t = s.substr(i+j*m,m); if(m1.find(t) == m1.end()) break; ++m2[t]; if(m2[t]&gt;m1[t]) break; &#125; if(j == words.size()) res.push_back(i); &#125; return res; &#125;&#125;; 2/26/2019 53. Maximum SubarrayDP01234567891011121314class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() == 0) return 0; int maxn = INT_MIN; int ans = 0; for(int i = 0;i&lt;nums.size();i++)&#123; if(ans&lt;0) ans = 0; ans += nums[i]; maxn = max(maxn,ans); &#125; return maxn; &#125;&#125;; 15. 3Sum 0 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(),nums.end()); vector&lt;vector&lt;int&gt;&gt; res; if(nums.size() == 0) return res; for(int i = 0;i&lt;nums.size();i++)&#123; int begin = i+1,end = nums.size()-1; if(i&gt;0&amp;&amp;nums[i-1]==nums[i]) continue; while(begin&lt;end)&#123; int result = nums[i]+nums[end]+nums[begin]; if(i!=end&amp;&amp; result == 0)&#123; vector&lt;int&gt; temp = &#123;nums[i],nums[begin],nums[end]&#125;; res.push_back(temp); end--; while(end&gt;=0&amp;&amp;nums[end+1] == nums[end]) end--; begin++; while(begin&lt;nums.size()&amp;&amp;nums[begin-1] == nums[begin]) begin++; &#125; else if(i==end||result&gt;0) end--; else begin++; &#125; &#125; return res; &#125;&#125;; 16. 3Sum Closest11234567891011121314151617181920212223242526class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; if(nums.size() == 0) return 0; int sum = INT_MAX; int ans; sort(nums.begin(),nums.end()); for(int i = 0;i&lt;nums.size();i++)&#123; int j = i+1,k = nums.size()-1; while(j&lt;k)&#123; int result = nums[i]+nums[j]+nums[k]; if(i!=k&amp;&amp;abs(result-target)&lt;=sum)&#123; sum = abs(result-target); ans = result; if(result&lt;target)j++; else if(result&gt;target) k--; else return result; &#125; else if(result&gt;target) k--; else j++; &#125; &#125; return ans; &#125;&#125;; 17. Letter Combinations of a Phone Number12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;string&gt; letterCombinations(string digits) &#123; vector&lt;string&gt; res; if(digits.size() == 0) return res; vector&lt;vector&lt;char&gt;&gt; alphabet = &#123; &#123;&#125;, &#123;&#125;,&#123;'a','b','c'&#125;,&#123;'d','e','f'&#125;,&#123;'g','h','i'&#125;,&#123;'j','k','l'&#125;,&#123;'m','n','o'&#125;, &#123;'p','q','r','s'&#125;,&#123;'t','u','v'&#125;,&#123;'w','x','y','z'&#125; &#125;; vector&lt;char&gt; tem(alphabet[digits[0]-'0']); string a =""; for(int i = 0;i&lt;tem.size();i++)&#123; a += tem[i]; res.push_back(a); a = ""; &#125; for(int i = 1;i&lt;digits.size();i++)&#123; vector&lt;char&gt; te(alphabet[digits[i]-'0']); int resSize = res.size(); for(int j = 0;j&lt;resSize;j++)&#123; string ahead = res[0]; for(int k = 0;k&lt;te.size();k++)&#123; res.push_back(ahead+te[k]); &#125; res.erase(res.begin()); &#125; &#125; return res; &#125;&#125;; 18. 4Sum12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; fourSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;vector&lt;int&gt;&gt; res; if(nums.size() &lt; 4) return res; sort(nums.begin(),nums.end()); for(int i = 0;i&lt;nums.size();i++)&#123; if(i&gt;0&amp;&amp;nums[i] == nums[i-1]) continue; for(int j = i+1;j&lt;nums.size();j++)&#123; if(j&gt;i+1&amp;&amp;nums[j] == nums[j-1]) continue; int begin = j+1,end = nums.size()-1; while(begin&lt;end)&#123; int result = nums[i]+nums[j]+nums[begin]+nums[end]; if(result == target)&#123; res.push_back(&#123;nums[i],nums[j],nums[begin],nums[end]&#125;); begin++; end--; while(end&gt;begin&amp;&amp;nums[end] == nums[end+1]) end--; while(begin&lt;end&amp;&amp;nums[begin-1] == nums[begin]) begin++; &#125; else if(result &gt; target) end--; else begin++; &#125; &#125; &#125; return res; &#125;&#125;; 19. Remove Nth Node From End of Listnnn12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; if(head == NULL) return NULL; ListNode* pre = head; ListNode* last = head; ListNode* pos = head; while(n--)&#123; pos = pos-&gt;next; &#125; if(pos == NULL) return head-&gt;next; // while(pos!=NULL)&#123; pre = last; last = last-&gt;next; pos = pos-&gt;next; &#125; pre-&gt;next = last-&gt;next; return head; &#125;&#125;; 22. Generate Parentheses1234567891011121314151617class Solution &#123;public: int nn; vector&lt;string&gt; ans; void digui(string res,int left,int right)&#123; if(res.size() == 2*nn)&#123; ans.push_back(res);return;&#125; if(left&lt;nn) digui(res+"(",left+1,right); if(right&lt;nn&amp;&amp;right&lt;left) digui(res+")",left,right+1); &#125; vector&lt;string&gt; generateParenthesis(int n) &#123; if(n == 0) return ans; nn = n; digui("",0,0); return ans; &#125;&#125;; 24. Swap Nodes in Pairshead123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; if(head == NULL) return NULL; ListNode* pre = new ListNode(-1); ListNode* first = head; ListNode* second = head-&gt;next; pre-&gt;next = head; if(second == NULL) return head; head = second; while(second != NULL)&#123; pre-&gt;next = second; first-&gt;next = second-&gt;next; second-&gt;next = first; pre = first; first = first-&gt;next; if(first!=NULL) second = first-&gt;next; else return head; &#125; return head; &#125;&#125;; 29. Divide Two Integerslong long12345678910111213141516171819class Solution &#123;public: int divide(int dividend, int divisors) &#123; long long divide = dividend; long long divisor = divisors; if(divisor == 0) return divide; int sign = 1; if(divisor&lt;0) sign = -1,divisor *= -1; if(divide&lt;0) sign *= -1,divide *= -1; long time = 0; while(divide&gt;=divisor)&#123; time++; divide -= divisor; &#125; if(time*sign&gt;INT_MAX) return INT_MAX; if(time*sign&lt;INT_MIN) return INT_MIN; return time*sign; &#125;&#125;; 4. median of two sorted array   123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; //nums1nums2 int m = nums1.size(); int n = nums2.size(); if(m&gt;n)&#123; auto temp = nums1; nums1 = nums2; nums2 = temp; swap(n,m); &#125;// n &gt; m int imin = 0,imax = m,half = (m+n+1)/2; //half //nums2 while(imin&lt;=imax)&#123; int i = (imax-imin)/2 + imin; // seperate nums1 int j = half - i; // jnum2j if(i&lt;m &amp;&amp; nums1[i]&lt;nums2[j-1]) // i is too small &#123; imin = i+1; &#125; else if(i&gt;0&amp;&amp;nums1[i-1]&gt;nums2[j])&#123; // i is to big imax = i-1; &#125; else&#123; // ferfect int max_left,min_right; if(i == 0)&#123; max_left = nums2[j-1]; &#125; else if(j == 0)&#123; max_left = nums1[i-1]; &#125; else&#123; max_left = max(nums2[j-1],nums1[i-1]); &#125; if((m+n)%2 == 1)&#123; return max_left; &#125; else&#123; if(i == m)&#123; min_right = nums2[j]; &#125; else if(j == n)&#123; min_right = nums1[i]; &#125; else&#123; min_right = min(nums1[i],nums2[j]); &#125; return (min_right+max_left)/2.0; &#125; &#125; &#125; return -1.0; &#125;&#125;; 26. Remove Duplicates from Sorted Array ijj++j123456789101112131415161718class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() == 0) return 0; int count = 0; int j = 0; for(int i = 1;i&lt;nums.size();i++)&#123; while(i&lt;nums.size()&amp;&amp;nums[j] == nums[i])&#123; i++; &#125; if(i&lt;nums.size()) &#123; j++;nums[j] = nums[i]; &#125; &#125; return j+1; &#125;&#125;; 837. New 21 Game Alice1WAliceKAliceNAliceN AliceAliceN DP,dp[i]iidp[i] = 1/w * (dp[i-1]+dp[i-2]...dp[i-w])i-11WW i&lt;K : Wsum += dp[i] i i-W&gt;=0: Wsum -= dp[i-W] iWdp[i-W] N&gt;= i &gt;=K: res += dp[i]res,KN 1234567891011121314151617181920class Solution &#123;public: double new21Game(int N, int K, int W) &#123; if(K == 0) return 1; // N+1 vector&lt;double&gt; dp(N+1); double Wsum = 1.0; // W double res = 0.0; dp[0] =1; for(int i = 1;i&lt;=N;i++)&#123; dp[i] = Wsum/W; if(i&lt;K) Wsum+=dp[i]; // i else&#123; res += dp[i]; &#125; if(i-W&gt;=0) Wsum -= dp[i-W]; //ii-W &#125; return res; &#125;&#125;; 481. Magical String 1211 1 12 1222112211 122 123456789101112class Solution &#123;public: int magicalString(int n) &#123; if(n == 0) return 0; string s = "122"; int i = 2; while(s.size()&lt;n)&#123; s+= string(s[i++]-'0',s.back() == '1'? '2':'1'); &#125; return count(s.begin(),s.begin()+n,'1'); &#125;&#125;; 12s = string(char_num,char); //char_numcharcount(s.begin(),s.begin()+n,&apos;1&apos;);//s&apos;1&apos; 2. Add Two Numbers  1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* head = new ListNode(-1); auto p = head; int step = 0; while(l1!=NULL&amp;&amp;l2!=NULL)&#123; int sum = l1-&gt;val + l2-&gt;val+step; if(sum&gt;=10)&#123; sum -= 10; step = 1; &#125; else&#123; step = 0; &#125; p-&gt;next = new ListNode(sum); p = p-&gt;next; l1 = l1-&gt;next; l2 = l2-&gt;next; &#125; auto l = l1 != NULL ? l1 : l2; if(l!=NULL)&#123; while(l!=NULL)&#123; int sum = l-&gt;val +step; if(sum&gt;=10)&#123; sum -= 10; step = 1; &#125; else&#123; step = 0; &#125; p-&gt;next = new ListNode(sum); p = p-&gt;next; l = l-&gt;next; &#125; &#125; if(step==1)&#123; p-&gt;next = new ListNode(1); &#125; return head-&gt;next; &#125;&#125;;  int 12-1&lt;&lt;31INT_MIN1&lt;&lt;31 -1,INT_MAX  123unsigned int -&gt;UINT_MAXlong-&gt;LONG_MAXunsigned long-&gt;ULONG_MAX  1const int INF = 0x7fffffff; 0x7fffffff 32-bit int 1const int INF = 0x3f3f3f3f 0x3f3f3f3f106110956710^910^90x3f3f3f3f * 2 =212221913432-bit int0x3f3f3f3fmemset(a,0,sizeof(a))memsetmemset0x3f3f3f3f0x3f3f3f3f0x3fmemset(a,0x3f,sizeof(a)) 123#include&lt;cstring&gt;memset(a,0,sizeof(a)); //a0memset(a0x3f,sizeof(a));//a 1const long double eps = 1e-8; 1e-8 0.00000001 2/22/1019 3. Longest Substring Without Repeating CharactersDP res[j]s[i]resres[j]++;j++;res[j] = res[j-1]-112345678910111213141516171819202122232425262728class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; if(s.size() == 0) return 0; vector&lt;int&gt; res(s.size()); int j = 0; res[0] = 1; int flag = 0; for(int i = 1;i&lt;s.size();i++)&#123; for(int k = j;k&lt;i;k++)&#123; // if(s[k]==s[i])&#123; flag = 1; &#125; &#125; if(j&gt;=i) continue; //i--j&lt;i if(flag == 0)&#123; // all different res[j]++; &#125; else&#123; // flag = 0; j++; //res i--; // res[j] = res[j-1]-1&gt;0? res[j-1]-1 : 1; //res[j]1 &#125; &#125; return *max_element(res.begin(),res.end()); &#125;&#125;; tipvector12int maxValue = *max_element(s.begin(),s.end());int minValue = *min_element(s.begin(),s.end()); 5. Longest Palindromic Substring 2$O(n^2)$ 1234567891011121314151617181920212223242526272829class Solution &#123;public: string longestPalindrome(string s) &#123; if(s.size() == 0) return ""; int pos = 0; int length = 1; for(int l = 2;l&lt;=s.size();l++)&#123; //  cout&lt;&lt;l&lt;&lt;" "; for(int i = 0;i&lt;s.size()-l+1;i++)&#123; int j = i+l-1; int temp = i; while(temp&lt;j)&#123; //  if(s[temp]==s[j])&#123; temp++; j--; &#125; else&#123; break; &#125; &#125; if(temp&gt;=j)&#123; // pos = i; length = l; &#125; &#125; &#125; return s.substr(pos,length); &#125;&#125;; 2/23/2019 6. ZigZag ConversionzigZagij V j += 2*numRows-i-1 Vj +=2i V 1234567891011121314151617181920class Solution &#123;public: string convert(string s, int numRows) &#123; if(s.size() == 0) return ""; if(numRows == 1) return s; string res = ""; for(int i = 0;i&lt;numRows;i++)&#123; int j = i; while(j&lt;s.size())&#123; res += s[j]; j += 2*(numRows-i-1); if(j&lt;s.size()&amp;&amp;i!=0&amp;&amp;i!=numRows-1)&#123; res += s[j]; &#125; j += 2*i; &#125; &#125; return res; &#125;&#125;; 8. String to Integer (atoi)  string intlong long char int str[i] - &#39;0&#39;; 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: int myAtoi(string str) &#123; if(str.size() == 0) return 0; string s = ""; for(int i = 0;i&lt;str.size();i++)&#123; if(s ==""&amp;&amp;str[i] == ' ') continue; if(s=="")&#123; if(isdigit(str[i])) s = str[i]; else if(str[i] =='-') s += '-'; else if(str[i] == '+') s += '+'; else return 0; &#125; else&#123; if(!isdigit(str[i])) break; s+=str[i]; &#125; &#125; if(s.size() == 0) return 0; if(s.size() == 1 &amp;&amp; s[0] == '-') return 0; int flag = 1; if((s[0]=='+'||s[0]=='-')&amp;&amp;!isdigit(s[1])) return 0; if(s[0] == '-')&#123; flag = -1; s = s.substr(1,s.size()-1); &#125; else if(s[0] == '+') &#123; s = s.substr(1,s.size()-1); &#125; if(s.size()&gt;1)&#123; while(s.size()&gt;1&amp;&amp;s[0]=='0')&#123; s = s.substr(1,s.size()-1); &#125; &#125; string min = "2147483648"; if(s.size()&gt;10) return flag == 1? INT_MAX:INT_MIN; if(s.size()&gt;=min.size()&amp;&amp;s&gt;=min) return flag == 1? INT_MAX:INT_MIN; else return stoi(s)*flag; &#125;&#125;; 12345678910111213int myAtoi(string str) &#123; if(str.size() == 0) return 0; long long base = 0; int sign = 1,i = 0; while(str[i] == ' ') i++; if(str[i] == '+') i++; else if(str[i] == '-') sign = -1,i++; while(i&lt;str.size()&amp;&amp;str[i]&gt;='0'&amp;&amp;str[i]&lt;='9')&#123; base = base*10 + str[i++]-'0'; if(base&gt;INT_MAX) return sign == 1?INT_MAX:INT_MIN; &#125; return base*sign;&#125; 35. Search Insert Position num[high]highhigh&gt;=0highhigh+112345678910111213141516class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; if(nums.size() == 0) return 0; int low = 0; int high = nums.size()-1; while(low&lt;=high)&#123; int mid = (high+low)/2; if(nums[mid] == target) return mid; else if(nums[mid]&gt;target) high = mid -1; else low = mid + 1; &#125; if(high&gt;=0&amp;&amp;nums[high]&gt;target) return high; else return high+1; &#125;&#125;; 24/2/2019 10. Regular Expression Matching*12 p[1] == &#39;*&#39;: *match p[1]!=*: match 12345678910111213class Solution &#123;public: bool isMatch(string s, string p) &#123; if(p.empty()) return s.empty(); if(p[1]=='*')&#123; return isMatch(s,p.substr(2))||(!s.empty()&amp;&amp;(s[0] == p[0]||p[0]=='.')&amp;&amp;isMatch(s.substr(1),p)); &#125; else return !s.empty()&amp;&amp;(s[0]==p[0]||p[0]=='.')&amp;&amp;isMatch(s.substr(1),p.substr(1)); &#125;&#125;; dp dp[i][j]: s(0,i) ,p(0,j)match  p[j-1] != *: dp[i][j] == d[i-1][j-1]&amp;&amp;s[i-1] == p[j-1] p[j-1] == * 123dp[i][j] = dp[i-1][j] //in this case, a* counts as multiple a dp[i][j] = dp[i][j-1] // in this case, a* counts as single a dp[i][j] = dp[i][j-2] // in this case, a* counts as empty 123456789101112131415161718192021class Solution &#123;public: bool isMatch(string s, string p) &#123; if(p.empty()) return s.empty(); int len1=s.size(),len2=p.size(); vector&lt;vector&lt;bool&gt;&gt; dp(len1+1,vector&lt;bool&gt;(len2+1,false)); dp[0][0]=true; for(int i=0;i&lt;=len1;i++) &#123; for(int j=1;j&lt;=len2;j++) &#123; if(p[j-1]=='*') dp[i][j] = dp[i][j-2] || ( i&gt;0 &amp;&amp; dp[i-1][j] &amp;&amp; (s[i-1]==p[j-2] || p[j-2]=='.') ); else dp[i][j] = i&gt;0 &amp;&amp; dp[i-1][j-1] &amp;&amp; (s[i-1]==p[j-1] || p[j-1]=='.'); &#125; &#125; return dp[len1][len2]; &#125; &#125;; 12. Integer to Roman 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: string intToRoman(int num) &#123; string res = ""; while(num&gt;=1000)&#123; res += "M"; num -= 1000; &#125; if(num&gt;=900)&#123; res+= "CM"; num -= 900; &#125; else if(num&gt;=100)&#123; if(num&gt;=500) res+='D',num -= 500; else if(num&gt;=400) res += "CD",num -= 400; while(num&gt;=100)&#123; res +='C'; num-=100; &#125; &#125; if(num&gt;=90)&#123; res += "XC"; num -= 90; &#125; else if(num&gt;=10)&#123; if(num&gt;=50) res += 'L',num -= 50; else if(num&gt;=40)res+="XL",num -= 40; while(num&gt;=10)&#123; res +='X'; num -= 10; &#125; &#125; if(num&gt;=9)&#123; res += "IX"; num -= 9; &#125; else if(num&gt;=1)&#123; if(num&gt;=5) res += "V",num -= 5; else if(num&gt;=4)res +="IV",num-=4; while(num&gt;=1)&#123; res +='I'; num -= 1; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[-- CNN]]></title>
    <url>%2F2019%2F02%2F19%2F%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-CNN%2F</url>
    <content type="text"><![CDATA[  CNNCNNLeCun 1998Gradient-based learning applied to document recognitionLeNet-52012ImageNetCNNAlexNet10%CNNVGG NetGoogle NetResNetCNN CNNCNNRELUCNNRGBCNNfilterkernelskernel sizepaddingstridepooling layerconvfeature mapreluCNNrelurelupooling flattensoft Max CNNpoolingkernel = 2x2, stride = 2  padding = 0,pooling kernel = 3x3, stride = 1 padding = 1 CNNCNN 1000X10001000X1000106CNN10x10100feature mapchannel dropoutdropout0.5keep_prob,0.5true:false11keep_prob=0.5dropout12345678910111213141516171819#0/1#dropoutdef dropout(x, level): if level &lt; 0. or level &gt;= 1:#level0~1 raise Exception('Dropout level must be in interval [0, 1[.') retain_prob = 1. - level #binomialxbinomial # pn #n=1size sample=np.random.binomial(n=1,p=retain_prob,size=x.shape)#010dropout print sample x *=sample#01x0 print x x /= retain_prob #  return x#dropoutx=np.asarray([1,2,3,4,5,6,7,8,9,10],dtype=np.float32)dropout(x,0.4) dropoutdropoutXPXdropoutX/pdropout dropout 50 CNNLeNet32*3235x52pooling 2x2    feature maps  166  1010 loss  MSE lossAlexNetAlexNet2012imageNetAlexNet55poollosssoftMax loss A. ReLU tanh  sigmoid  ReLU  tanh B. Training on Multiple GPUs2 GPU GPU GPUs C. Overlapping Pooling0.4%0.3%D. Data Augmentation label-preserving transformations  -  -   -  RGB  -  -  E. DropoutDropout  hidden neuron 50% loss Dropout  Dropout Dropout  VGG NetVGGGooglenetAlexnetLenetConvNetVGG16/VGG19Faster-RCNN/SSDResnetVGGnet3x3Conv kernelpad/stride1ConvMaxPoolFCsSoftmaxVGG16VGG19 3x3 conv3x3 conv5x5 conv7x7 convconv channelsVGGAlexNetSGDVGG16AlexNet3x3AlexNet11x115x5AlexNet GoogleNetinceptionVGGImageNetGPUVGGVGGCNNLeNet/Alexnet/VGGConv/Pool/Normalization/Activationchannelschannels GoogleNetspared layer architectureinception moduleMaxPoolInception v1GoogleNetGPUInception v1Inception modulea1x1/3x3/5x5Conv kernelskernels,paddingaconv1x1convfeature mapschannels 256  feature map 256  feature map  Inception  3x3  (256x256) x (3x3)  589,000 channel256 Bottleneck layer  ()256(channel)64()  11 = 16,000s -&gt; 1x16464(channel) 64()  33 = 36,000s64 256()  11 = 16,000s7x7AvgPoolfeature mapsFC1000Softmax1000 ResNetResnetCNN2015XHXH(X)CNNAlexnet/VGGHH(X)H(X) - X (H(X) - X) +XXidentity mappingH(X) - Xidentity mappingidentity mapXchannel01x1 convbottleneck1x1 convconvconvconv identity map inception V2/V3inception V2/V3inception v15x53x3features mappoolingVGGnetpooling features mapchannelgooglenetfeatures mapconvpoolingfeature mapsfeature mapinception v1 inception v3 inception v2BNregularizationlosslabel inception v4inception v4tensorflow]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[]]></title>
    <url>%2F2019%2F02%2F19%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8A%80%E6%9C%AF%EF%BC%88%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9%EF%BC%89%2F</url>
    <content type="text"><![CDATA[ early stop data expanding () dropout   BN dropoutdropout0.5keep_prob,0.5true:false11keep_prob=0.5dropout12345678910111213141516171819#0/1#dropoutdef dropout(x, level): if level &lt; 0. or level &gt;= 1:#level0~1 raise Exception('Dropout level must be in interval [0, 1[.') retain_prob = 1. - level #binomialxbinomial # pn #n=1size sample=np.random.binomial(n=1,p=retain_prob,size=x.shape)#010dropout print sample x *=sample#01x0 print x x /= retain_prob #  return x#dropoutx=np.asarray([1,2,3,4,5,6,7,8,9,10],dtype=np.float32)dropout(x,0.4) dropoutdropoutXPXdropoutX/pdropout dropout 50 Batch Normalization Internal Covariate ShiftInternal Covariate Shift Internal Covariate Shift  ReLU Internal Covariate shiftICSICSPCA01ZCA0batch normalization normalizaiton()01BNBN   normalize $\epsilon$ 0  batch normalization BN BN BNBNscaleBNBNbad BNsigmoidtanh BNBatch Normalizationmini-batchbatchmini-batch L1  L1,$$\min \frac{1}{N}\sum_{i = 1}^{N}{(y_{i} -\omega^{T} x_{i})^{2} } + C||\omega||_1$$L2 $$\min \frac{1}{N} \sum_{i = 1}^{N}{(y_{i} -\omega^{T} x_{i})^{2} } + C||\omega||_{2}^{2}$$L1L2loss functionh = f+normalfnormaltrade-off L1lossL1L2L200  L1loss functionL1L10 L2loss functionL2L2wwL2 Faster RCNNL2lossL2 losssmooth L1L2 losssmooth L1 L1    EMKNN  $(\mu -3\sigma,\mu+3\sigma)$ K nearnest neighbourK cannycannycanny max pooling  average pooling poolingaverage-poolingmax-poolingmax-pooling   RMSprop CNN80% GAPfeature1010 feature mapfeature map confidence valuesoftmaxGAP 23 K-means  nn    (DBSCAN) rminPoints. rminPointsminPointscentral pointnoise point noise pointcentral pointnoise point GMMEM K-Means   23  mSSESum of the Squared Error SSEk L1 loss LL2 lossL+L2L1L+L1 L1 lossx0 &gt;0 ()x0 C|x|-C L  La  La -C &lt;0C&gt;Lax0 Lb + C &gt; 0 C&gt;-LbCL0 10G5G1G10G1G10G1G1G2G2G2G5G pooling  max poolingmax pooling0 mean poolingmean pooling]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Faster RCNN]]></title>
    <url>%2F2019%2F02%2F14%2FFaster-RCNN%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Faster RCNNFaster RCNN Fast RCNNselect search  Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networkssubmit time: 2016arxiv link fast R-CNNfaster R-CNNregion proposalregion proposal networkRPNfeatures map region proposalsproposalFast R-CNNRoIfast RCNNFaster RCNNFaster RCNN  Conv layersCNNFaster RCNNconv+relu+poolingimagefeature mapsfeature mapsRPN Region Proposal NetworksRPNregion proposalssoftmaxanchorsforegroundbackgroundbounding box regressionanchorsproposals Roi Poolingfeature mapsproposalsproposal feature maps Classificationproposal feature mapsproposalbounding box regression Faster RCNN  conv layer feature map RPNfeatures mapregion proposalfeatures map anchors9softmax anchorforegroundbackgroundbounding box regressionanchorsproposal RoI poolingproposalfeatures mapproposalfeatures map region features mappooling classificationproposal feature mapsproposalbounding box regressionproposal   Faster RCNN  PxQMxNMxN Conv layers13conv+13relu+4poolingRPN3x3foreground anchorsbounding box regressionproposalsRoi Poolingproposalsfeature mapsproposal featuresoftmaxclassification conv layer Conv layers13conv13relu4pooling conv kernel_size=3  pad=1 stride=1conv pooling kernel_size=2 pad=0  stride=2pooling  Conv layerMxN(M/16)x(N/16) Region Proposal Networks(RPN)Faster RCNN fast RCNN  RPN2softmaxanchorsforegroundbackgroundforegroundanchorsbounding box regressionproposalProposalforeground anchorsbounding box regressionproposalsproposalsProposal Layer anchorsanchor91:1,1:2;2:1Faster RCNNConv layersfeature mapsfeature map9anchorsRPN2bounding box regressionkanchorconv layer256anchorforegroundbackground2kscoreanchor$(x_1,y_1,x_2,y_2)$4kcoordinatesanchoranchorRPN9anchorcnnAnchorforeground anchorbackgroudAnchor800x600VGG16feature map9Anchor$$ceil(800/16) \times ceil(600/16) \times 9=50\times38 \times9=17100$$ceil()VGGfeature map size= 50*38 softmaxforegroundbackgroundRPNanchorssoftmaxforeground anchorsfeatures map 1*1$W*H*(9*2)$foregroundbackground2*k scoresoftmaxforeground anchorsboxforeground anchorsreshape clc layerk2softmax losscross entropy lossY=0,1groundtruthgroundtruthkK ground truth(GT)IoU GTIoU0.7 GTIoU0.3 bounding box regression (x, y, w, h)  11AForeground AnchorsGGTanchor AGG $anchor A=(A_{x}, A_{y}, A_{w}, A_{h})  GT=[G_{x}, G_{y}, G_{w}, G_{h}]$F$F(A_{x}, A_{y}, A_{w}, A_{h})=(G_{x}^{}, G_{y}^{}, G_{w}^{}, G_{h}^{})$$(G_{x}^{}, G_{y}^{}, G_{w}^{}, G_{h}^{})(G_{x}, G_{y}, G_{w}, G_{h})$F10anchor AG RCNNbounding box RPN1*1$W*H*(9*4)$box4k coordinate RPN: - RPNanchor- anchorfeature map9- soft Maxanchor- bounding box regression anchor- proposalanchoranchoranchoranchorproposal- bounding box W1*14K regreason,anchorxy,w,hW CNN pool5features mapanchor- bounding box regression anchor  ground truth- proposalproposalproposal#### proposal layerRPN proposal layeranchorsanchor$[d_{x}(A),d_{y}(A),d_{w}(A),d_{h}(A)]$im_info=[M, N, scale_factor]Faster RCNNreshapeMxNim_infoproposalproposalproposalProposal Layer forwardcaffe layer- anchors$[d_{x}(A),d_{y}(A),d_{w}(A),d_{h}(A)]$anchorsbbox regressionanchors- foreground softmax scoresanchorspre_nms_topN(e.g. 6000)anchorsforeground anchors- foreground anchorsroi poolingproposal- width&lt;threshold or height&lt;thresholdforeground anchors- nonmaximum suppression- nmsforeground softmax scoresfg anchorspost_nms_topN(e.g. 300)proposal = [x1, y1, x2, y2]proposal=[x1, y1, x2, y2]anchorsproposalMxNRPNanchors -&gt; softmax anchors -&gt; bbox reg anchors -&gt; Proposal Layerproposals#### RoI pooling layerRoI Pooling layerproposalproposal feature mapsRol pooling2- feature maps- RPNproposal boxesRoI Pooling layer forward- proposal$ M\times N$ spatial_scale $(M/16)\times(N/16) $feature map- proposalfeature map $\text{pooled_w}\times \text{pooled_h} $- max poolingproposal $\text{pooled_w}\times \text{pooled_h}$ #### ClassificationClassificationproposal feature mapsfull connectsoftmaxproposalcls_probbounding box regressionproposalbbox_predPoI Pooling7x7=49proposal feature maps2- softmaxproposals- proposalsbounding box regressionrect box#### Faster R-CNNFaster R-CNNmodelVGG_CNN_M_1024VGGZF6- modelRPN- 1RPN- Fast RCNN- RPN- 4RPN- Fast RCNN22A similar alternating training can be run for more iterations, but we have observed negligible improvements#### RPN Conv Layersfeature mapsLoss$$L({p_i},{t_i})=\frac{1}{N_{cls}}\sum_{i} L_{cls}(p_i,p_i^*)+\lambda \frac{1}{N_{reg}}\sum_{i} p_i^* L_{reg} (t_i,t_i^*)$$ i anchors index$ p_{i}$ foreground softmax probability$p_{i}^{*}$GT predictianchorGTIoU&gt;0.7anchorforeground$p_{i}^{*}=1$IoU&lt;0.3anchorbackground$ p_{i}^{*}=0 $0.3&lt;IoU&lt;0.7anchortpredict bounding box$ t^{*} $ foreground anchorGT boxLoss2- cls lossrpn_cls_losssoftmax lossanchorsforgroundbackground- reg lossrpn_loss_bboxsoomth L1 lossbounding box regressionloss $p_{i}^{*}$ foreground anchorsbackgroundSmooth L1 loss L2 lossL2 lossx-tL1L1 loss  softMax loss  lossfast RCNN ]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fast RCNN]]></title>
    <url>%2F2019%2F02%2F14%2FFast-RCNN%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Fast RCNNSPP-NetRCNNSPP layerregion proposalSPP-netfine-tuneSPPpyramid BPfine-tunetuneFast RCNN SPP-NetROIregion of interesting(multi-task loss)loss Fast RCNNsubmit time: 2015arxiv link Fast RCNNFast RCNN select search 2kregion proposal  CNN 2kregion proposalfeature mapsRoI projection RoI pooling layerfeatures mapregion proposal FCssoftMaxbbox regressionSoftmax Loss() Smooth L1 Loss()(Bounding box regression) ROI pooling layerRoIHxW77HWRoIRoIRoIr, c, h, wr, ch, wRoIhxwRoIHxWh/H x w/WchannelRoISPPnetshwHWH*Wh/H x w/W(max-pooling)  SGDmini-batchNimagesimageR/NROIsimageROIsN mini-batchN=2, R=128 SGDR-CNN softmaxbbox regressor Multi-task LosssoftmaxR-CNNSPPNetSVMFast R-CNNsoftmaxulog lossploss1$$L_{cls}(p, u) = -logp_u$$ softmax$$P_i= \frac{e^{V_i}}{\sum_i^C{e^{V_i}}}$$ Softmax  V  V  V  V $$\begin{align}D = \max(V) \nonumber\\P_i= \frac{e^{V_i-D}}{\sum_i^C{e^{V_i-D}}} \nonumber\end{align}$$logsoftMax $-\log$ loss$L_1$ lossloss $L_{loc}$u $v=(v_x, v_y, v_w, v_h)$u$t^u = (t^u_x, t^u_y, t^u_w, t^u_h)$loss$$L_{loc}(t^{u},v) = \sum_{ i \in {x,y,w,h}} smooth_{L_{1}}(t_i^u - u_i)$$ loss$$L(p,u,t^u,v) = L_{cls}(p,u)+\lambda[u\geq 1] L_{loc}(t^{u},v)$$ u  110u=0RoI$L_{loc}$ Mini-Batch SGDmini-batchN=2images Nimagesmini-batch128image64ROIs25%IOU0.5hard negative miningIOU[0.10.5u=0$[u\geq 1]$ RoI SPPNetROI PoolingMax Pooling10ROI Pooling Poolingregion proposalBatch_Size$$\frac{\partial L }{ \partial x_{i}} = \sum_r \sum_{j} [i = i^*(r,j)]\frac{\partial L }{\partial y_{rj}}$$ $i^*(r, j) = argmax (i)R(r,j)$R(r, j)max pooling $[i = i * (r, j)]$ inputximax pooling,loss rRoIjregionx $y_{rj}$jx RoIfast rcnn]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SPP-Net]]></title>
    <url>%2F2019%2F02%2F13%2FSPP-Net%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[SPP-Netfast RCNN RCNNSPP NetSPP Net SPP-Net Spatial Pyramid Pooling in Deep Convolutional Networks for Visual Recognitionsubmit time: 2015arxiv link spatial pyramid pooling(Bag-of-Words, BoW)SPP-netSPP(bin)RCNN 1croprcnnregion warp2region proposalsAlexNet3regions proposalsVGG1647s SPP-Net select search2kproposal region CNNfeature maps 2kproposalfeature maps(RCNNproposalSPP-net) feature mapFC(SPP-netcrop) proposalsSVM SPP-Net   features mapregion proposalregion proposal4*42*21*121(21)region proposal  ? SPP-Netregion proposalsfeatures mapregion proposalsfeatures mapregion proposal region proposal?SPP-Netfeature mapfeature map(x,y)(x,y)SCNN$$x=\frac{x}{S}+1$$$$x=\frac{x}{S}1$$SZF-5: S = 2*2*2*2 = 16Overleaf-5/7S = 2*3*2 = 12 SPP-NetSPP-netGPU Single-size training:224x224bin sizefeature mapaxaSPP layer$win=\frac{a}{n}$$stride=\frac{a}{n}$ Multi-size training180x180224x224224x224180x1801epoch2epochSPP-Net ROIfeature mapCNNreceptive fieldkernel sizestridepadding , outputsize features map $$W_2 = W_1- K + 2P/S + 1$$ $W_1$KPpaddingSstridefeatures map $$W_1 = (W_2 - 1)*S -2P+K$$ $$r = (m-1) stride+ksize$$mdilate rate = 1dilate rate = 23\35*5dilate rate = 39*9 $$p_i = s_i \cdot p_{i+1} +( (k_i -1)/2 - padding)$$ SPP-Net SPP-Net ROI  feature map feature map  feature map ()  SPPNetR-CNNfeature mapSPPCNNFast R-CNNSPPNet]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RCNN]]></title>
    <url>%2F2019%2F02%2F11%2FRCNN%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[YOLOSSDbounding boxbounding boxR-CNNSPP-NetFast R-CNNFaster R-CNN RCNNRCNN: Region-based Convolutional NetworkSubmitted on 2014 RCNN Selective search Region proposal Region Proposal CNN SVM bounding box region proposal 1951953232 selective search   (2k~3k )   selective search ()()BBOX() RGB,HSV,Lab RCNNregion proposal 227*227proposal proposalcf74096pre-trainingAlexNet CNN  (ILSVRC)(PASCAL)CNN CNNhinton2012image netAlexNet40964096-&gt;1000(fc)10000.014096-&gt;21 0.001batch322096 cf7softMaxcf7SVM svmcnnsoftmaxsvm cnnbounding boxCNNCNNBounding box(IOU0.5region proposal) svmIOU0.7 SVMIoU0.30.3-0.70.7-1.00.30,0.1,,0.5SVMCNN20002000 * 4096svm4096 * N(NNsvmsvm4096w) bounding boxAlexnet pool5bboxground-truth(SVMground-truth,)N${(P^i, G^i)}_{i=1,2,,N}$ProposalGround TruthIoU0.6(groundtruth)=10000l2(design matrix)XXRidge Regression WX WWWRidge Regression and Lasso RegrissionWRegularization $l_2$(Ridge Regression) $l_1$Lasso Regrission  NMSRCNN NMSRCNNIoU RCNN]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC ]]></title>
    <url>%2F2019%2F02%2F07%2FMAC-%E7%A7%81%E4%BA%BA%E8%AE%A2%E5%88%B6%2F</url>
    <content type="text"><![CDATA[gitMacXcode,XcodeOS X:1xcode-select --install 12git config --global user.name &quot;wenhui-zhou&quot;git config --global user.email &quot;765647930@qq.com&quot; ssh-key1ssh-keygen /.ssh/id_rsa.pubGitHubssh1ssh -T git@github.com  Hi WenHui-Zhou! Youve successfully authenticated, but GitHub does not provide shell access. 80http443httpshttpshttphttpshttpsxing Mac Mac /etc/profile /etc/paths ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc /etc/profile/etc/paths3~/.bash_profile~/.bash_profile~/.bashrcbash shell windowshexoMac node.js git hexonpm hexo init,sudo npm install Mac  anacondaitermpythonitermvim ~/.zshrc123456789101112131415161718192021#### Macshift#### mac#### MAC MAC http1. 2. `python -m http.server 80`web3. ipIP `http://ip` 4. ```shellwget -r -np -nH -R index.html http://include/file -r :  -np :  -nH :  -R index.html :  index.html ]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>tip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[-]]></title>
    <url>%2F2019%2F01%2F30%2F%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[(recursion)  1~n  n  n  1 $\leq n \leq15$ 13 12345678322 311 31 21 2 3 dfs() 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;int a[20];//int vis[20]; //void dfs(int pos,int tar,int start)&#123; if(pos == tar+1)&#123; for(int i = 1;i&lt;=tar;i++)&#123; cout&lt;&lt;a[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl; return; &#125; for(int i = start;i&lt;=n;i++)&#123; if(!vis[i])&#123; vis[i] = true; a[pos] = i; dfs(pos+1,tar,i+1); vis[i] = false; &#125; &#125;&#125;int main()&#123; cout &lt;&lt; endl; cin &gt;&gt; n; for(int i = 1;i&lt;= n;i++)&#123; dfs(1,i,1); &#125;&#125; a[20]| i1 state |= 1&lt;&lt;(i-1)^ i0 state ^= 1&lt;&lt;(i-1) 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;bool vis[20];void dfs(int pos,int tar,int start,int state)&#123; if(pos == tar+1)&#123; for(i = 1;i&lt;=n;i++)&#123; if((state&gt;&gt;i)&amp;1) cout &lt;&lt; i&lt;&lt;&quot; &quot;; &#125; cout &lt;&lt;endl; return; &#125; for(int i = start;i&lt;=n;i++)&#123; if(!vis[i])&#123; vis[i] = true; state |= 1&lt;&lt;(i-1); dfs(pos+1,tar,i+1,state); state ^= 1&lt;&lt;(i-1); vis[i] = false; &#125; &#125;&#125;int main()&#123; cout&lt;&lt;endl; cin &gt;&gt; n; for(int i =1;i&lt;= n;i++)&#123; dfs(1,i,start = 1, 0); &#125; return 0;&#125; $2^n$01 000  \n001  1010  2011  3 123456789101112131415#include &lt;iostream&gt;using namespace std;int main()&#123; int n; cout &lt;&lt;endl; cin&gt;&gt; n; for(int state = 1;state&lt; 1&lt;&lt;n;state++)&#123; for(int j = 0;j&lt;n;j++)&#123; if(state&gt;&gt;j&amp;1) cout&lt;&lt;j+1&lt;&lt;&quot; &quot;; &#125; cout &lt;&lt;endl; &#125; return 0;&#125; 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;int n;//ustatevoid dfs(int u,int state)&#123; if(u == n)&#123; for(int i = 0;i&lt;=n;i++)&#123; if(state &gt;&gt; i &amp;1)&#123; cout&lt;&lt;i+1&lt;&lt;&quot; &quot;; &#125; &#125; cout&lt;&lt;endl; return; &#125; dfs(u+1,state); // u dfs(u+1,state|(1&lt;&lt;u)); //u&#125;int main()&#123; cin &gt;&gt;n; dfs(0,0); return 0;&#125;]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RNN,LSTM]]></title>
    <url>%2F2019%2F01%2F29%2F%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CRNN-LSTM%2F</url>
    <content type="text"><![CDATA[RNNRNNDNN/CNNRNN RNN RNNRNNRNNRNN LSTM NetWorkRNNRNNtanhLSTM LSTMLSTMLSTMgatesigmoidsigmoid01LSTM LSTMLSTM$h_{t-1}$$X_t$sigmoid0-1$C_{t-1}$sigmoidtanh$C_t$$C_{t-1}$$C_{t}$sigmoidtanh-11sigmoid $h_t$   LSTMRNNCECoutput$|f_{ij}(x) W_{ij}| = 1,W_{ij}$LSTMRNNCEC]]></content>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[]]></title>
    <url>%2F2019%2F01%2F25%2F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[sketch2ClothGAN Human-parsingDeepLab+SSLGAN DeepLab v2   DCNNCRFS SSL  canny  edge detection using structure forest HEDEdgeHEDvgg pix2pixCGANL1 GAN JSwassersteinearth-mover CGANGAN pix2pixCGANL1U-net,  segysegyGB SVD shaderGPUshaderShader]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AutoMatic Image Colorization ]]></title>
    <url>%2F2019%2F01%2F23%2FAutoMatic-Image-Colorization-%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Let there be Color: Joint End-to-end Learning of Global and Local Image Priors for Automatic Image Colorization with Simutaneous Classification 2016SIGGRAPHLet there be Color:Automatic Image Colorization CNN(global priors)(local image features)(end to end) &emsp; &emsp; &emsp;   LabLab--Lab94%6%  low-level features mid-level features fusion layer colorization network low-level features resize224224*abLlab  1*1*256$$L(y^{color},y^{class}) = ||y^{color} - y^{color,*}||^2_{FRO} - \alpha (y_{l^{class}}^{color} - \log(\sum^{N}_{i = 0} exp(y_i^{class})))$$ MSE Losslossloss$\alpha$0loss $$y_{u,v}^{fusion} = \sigma (b + W [y^{global},y^{mid}_{u,v}]^T)$$ $y^{global}$1*1*256b$\frac{H}{8}*\frac{H}{8}*256$yb$\frac{H}{8}* \frac{H}{8}*512$       PREFERENCE preference1]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[]]></title>
    <url>%2F2019%2F01%2F23%2F%E6%A8%A1%E5%9E%8B%E6%80%A7%E8%83%BD%E8%AF%84%E4%BC%B0%E6%8C%87%E6%A0%87%E6%A6%82%E8%A6%81%2F</url>
    <content type="text"><![CDATA[ AUCAUCarea under thr curveROCxAUC:     TP() FP()  FN() TN() t$$TPR = \frac{TP}{TP+FN}$$$$FPR = \frac{FP}{FP+TN}$$TPRFPRt AUC $$AUC = \int_{t = 0}^{1} y(t) dx(t)$$AUCAUCAUCAUC AUCAUCAUC $$Pricision = \frac{TP}{TP+FP}$$pricision $$Recall = \frac{TP}{TP+FN}$$recall F1 score:$$\frac{2}{F_{1}} = \frac{1}{Precision}+\frac{1}{Recall}$$F1precisionrecall F1 score. mAP:mAPmean average precisionAP APprecisionrecall IoU = 0.5:0.05:0.95mAPmAPIoU0.50.95IoUAPAPmAP BenchMarkSOTA Baselinebenchmarkstate-of-the-artSOTASOTASOTAbenchmark baselinebenchmarkbaseline benchmarkbaseline]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[human head detect summary]]></title>
    <url>%2F2019%2F01%2F23%2Fhuman%20head%20detect%20summary%2F</url>
    <content type="text"><![CDATA[welcome to my blog,enter password to read. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag></tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ ]]></title>
    <url>%2F2019%2F01%2F21%2FC-%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E5%8F%8A%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[ int to string &emsp;string a = to_string(int) string to int&emsp; int a = stoi(string) char to int &emsp; int a = char_b - 48  123456string a = "abcd";string b = "ab";int start = 0;int pos = a.find(b,start); // start0//string::nposif(a.find(b) == string::npos) cout&lt;&lt;"dont exist";  &emsp; string a = astring.substr(startpos,length) vector vector  vector_a.erase(iter_pos),vector_a.erase(iter_begin(),iter_end()) vector nums.sort(nums.begin(),nums.end(),[](int a,int b){return a&gt;b;}) unordered_map: unordered_map$O(1)$ map$O(\log n)$ unordered_map &emsp;unordered_map&lt;char,int&gt; map; unordered_map &emsp;map[&#39;a&#39;] = 1;,map.insert(make_pair(&#39;a&#39;,1)); unordered_map &emsp; if(map.find(&#39;B&#39;) == map.end()){dont exist} &emsp; if(map.count(&#39;B&#39;) == 0){dont exist} unordered_map &emsp;map.erase(map.begin()), &emsp;map.erase(map.begin(),map.end()), &emsp;map.erase(&#39;A&#39;)  int mid = left + (right-left)/2;  int weight[N][M]; C++4M ^ 0^1=11^1=0 lowbitn1lowbit(100100) = 100 -&gt; 123int lowbit(int n)&#123; return (~n + 1) &amp; n; // return (-n)^n; &#125; O(1) STL12while(next_permutation(A.begin(),A.end()))&#123; ... &#125; //falseprev_permutation(A.begin(),A.end()); // vector sprintf() C  int sprintf(char str, const char format, )  str  12sprintf(str, &quot;Pi  = %f&quot;, M_PI); // str = &quot;Pi  = 3.141593&quot;sprintf(str,&quot;%02d:%02d&quot;,h,m); // %02d h20.(3-&gt;03) set setset&lt;vector&lt;int&gt;&gt; res;1234for(auto iter = res.begin();iter!=res.end();iter++) ...res.clear(); //res.empty(); //res.rbegin() == res.end(); vector vector&lt;int&gt; vec(size,0); vec.push_back(val);vec.insert(vec.begin(),val); vec.pop_back();vec.erase(vec.begin()) `vec.erase(vec.begin(), vec.begin()+3);` find(vec.begin(),vec.end(),val) != vec.end() : 123456sort(vec.begin(),vec.end()); bool myfun(int a,int b)&#123;return a&lt;b; // &#125;sort(vec.begin(),vec.end(),myfun); sort(vec.begin(),vec.end(),[](int a,int b)&#123;return a&lt;b;&#125;) lambda 1auto func = [c](int a,int b) &#123; return a &lt; b; &#125;; ca,b string findint pos = str.find(char,int begin = 0,int end = str.size()) //if(pos == string::npos) cant find it else return the index of char string substrstring str = s.substr(begin,num)//beginnum string str = s.substr(begin)//begin]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github ]]></title>
    <url>%2F2019%2F01%2F19%2FGithub-%E5%BB%BA%E7%AB%99%2F</url>
    <content type="text"><![CDATA[githubwindows 1.  node.js: 2009Ryanjavascriptgoogle V8c++I/O git: hexo:hexomakdown 2. Githubregistry Github.github.ioInitialize this repository with a READMEegWenHuiZhou.github.io 3. node.jsgit4. hexo npm install -g hexo-cli&emsp;&emsp;npm (node package manager)node.jsjavascriptnpmnode.jsnode.jsnpm(nmp install jquery.js)&emsp;&emsp;npmnpmnpm config set registry https://registry.npm.taobao.org hexo 123hexo init&lt;blog&gt;cd &lt;blog&gt;npm install hexo _config.ymlsourcethemes hexohexo ghexogeneratehexo shexoserver 5 . hexo  github git bashblog git config --global user.name WenHuiZhougit config --global user.email myemail gitcommitpushgithub 6. SSH  ssh -keygen -t rsa -C &quot;myemail.com&quot;id_rsa  id_rsa.pub ssh-agenteval &quot;$(ssh-agent -s)&quot; SSH keyssh-agentssh-add ~/.ssh/id_rsa 7 .githubssh github settingssh keyid_rsa.pub git bashssh -T git@github.com  hi WenHuiZhou 8 . _config.yml _config.ymldeploy: type:git repository:git@github.com:WenHui-Zhou/WenHuiZhou.github.io.git branch: master repositorygithubdownload 9. hexo hexo new post &quot;blog name&quot;hexosource.md.md hexo s:  hexo d -g: github githubhttps://wenhui-zhou.github.io/ 10.  hexogithub hexo maupassant  PREFERENCE reference1 reference2]]></content>
      <categories>
        <category></category>
      </categories>
      <tags>
        <tag>netStation</tag>
      </tags>
  </entry>
</search>

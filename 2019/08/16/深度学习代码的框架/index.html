<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="cheer up"><meta name="baidu-site-verification" content="9pSIuwCbvi"><meta name="google-site-verification" content="YzcCTjF6VoVlNAtL37_S4vFjzFwYTAFZzD51Il2IGKY"><title>深度学习代码的框架 | WenHuiZhou</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">深度学习代码的框架</h1><a id="logo" href="/.">WenHuiZhou</a><p class="description">perper（打起精神！）</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">深度学习代码的框架</h1><div class="post-meta">Aug 16, 2019<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" href="/2019/08/16/深度学习代码的框架/#vcomment"><span class="valine-comment-count" data-xid="/2019/08/16/深度学习代码的框架/"></span><span> 条评论</span></a><div class="post-content"><p>以pytorch为例，梳理一下深度学习中，数据的读取，神经网络的搭建，NMS，以及各个指标的计算流程。</p>
<a id="more"></a>
<h3 id="main-函数，程序入口，以及代码配置"><a href="#main-函数，程序入口，以及代码配置" class="headerlink" title="main 函数，程序入口，以及代码配置"></a>main 函数，程序入口，以及代码配置</h3><p>通常main函数中，通过实现argparse功能包，从函数的外部接受参数的传入，对数据，网络等进行一些基本的配置。argparse的使用方法：<a href="https://docs.python.org/zh-cn/3/library/argparse.html" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/argparse.html</a></p>
<p>main函数中一些常用的配置项：</p>
<ul>
<li>数据集的格式：coco，csv，pascal voc等等</li>
<li>数据的路径，包括训练集，测试集的路径等等</li>
<li>网络的一些细节配置，如深度，backbone 类型</li>
<li>一些功能的开关设置，如数据的增强等</li>
<li>训练过程中，一些变量的设置，比如epoch的设置，batch_size的设置等等</li>
</ul>
<h3 id="数据读取部分"><a href="#数据读取部分" class="headerlink" title="数据读取部分"></a>数据读取部分</h3><p>数据读取部分的操作包括数据集文件的读取，对图片进行数据的增强，继承dataloader实现数据的批量读取。</p>
<h4 id="数据文件的读取"><a href="#数据文件的读取" class="headerlink" title="数据文件的读取"></a>数据文件的读取</h4><p>这部分读取任务主要包括读取annotation文件，以及class_id文件，这里以csv格式的数据集文件为例。</p>
<p>首先实现一个CSVDataset类，继承至torch.utils.data.Dataset类。该类必须实现<code>__len__</code>,<code>__getitem__</code>两个方法。</p>
<p>在CSVDataset方法的<code>__init__</code>中，进行数据集文件的读取，最终将得到：</p>
<ul>
<li>self.classes</li>
<li>self.image_names : list 包含所有的数据集图片路径</li>
<li>self.image_data: dict[image_name] = [ {x1,y1,x2,y2,class_name},…]</li>
</ul>
<p><code>__getitem__</code>函数中需要实现的方法有根据下标来得到image，以及其对应的标注。最终返回的格式为：</p>
<p><code>sample = {&#39;img&#39;: img, &#39;annot&#39;: annot}</code>。在返回之前，如果有数据增强部分，还需要进行数据的增强。</p>
<h4 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a>数据增强</h4><p>数据增强的方法有很多种，常用的图片的翻转，切割，resize，归一化等等。数据增强利用一张图片，得到它的许多副本，有效的增大数据集。数据增强能够起效果的一个本质因素在于，卷积操作对位移，视角，图片大小，光照等因素具有不变性。数据增强有线下增强和线上增强两种方式，后一种方式在dataloader提取数据的时候，才对数据进行增强。</p>
<p>数据增强的方法通常可以写成一个类，通过pytorch中的<code>transforms.Compose([Augumenter(),Resizer()])</code> 来对所有的增强方法进行整合。</p>
<p><strong>Normalizer</strong></p>
<p>实现一个Normalizer类，覆盖其中的<code>__call__</code>方法，对每张图片做一个正则化。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Normalizer</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.mean = np.array([[[<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>]]])</span><br><span class="line">        self.std = np.array([[[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>]]])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, sample)</span>:</span></span><br><span class="line"></span><br><span class="line">        image, annots = sample[<span class="string">'img'</span>], sample[<span class="string">'annot'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'img'</span>:((image.astype(np.float32)-self.mean)/self.std), <span class="string">'annot'</span>: annots&#125;</span><br></pre></td></tr></table></figure>
<p><strong>argument</strong></p>
<p>实现对图片的翻转，需要注意对标注也要进行处理。</p>
<p><strong>Resizer</strong></p>
<p>该方法意图将图片的大小限制在一定范围以内。因此在缩放的时候，需要找到最大的缩放比例,同时保证图片能够被32整除。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resizer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Convert ndarrays in sample to Tensors."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, sample, min_side=<span class="number">608</span>, max_side=<span class="number">1024</span>)</span>:</span> <span class="comment">#将图片resize到608，1024以下的大小</span></span><br><span class="line">        image, annots = sample[<span class="string">'img'</span>], sample[<span class="string">'annot'</span>]       <span class="comment"># 不能超过这个尺寸（有一边等于这个尺寸）</span></span><br><span class="line"></span><br><span class="line">        rows, cols, cns = image.shape</span><br><span class="line"></span><br><span class="line">        smallest_side = min(rows, cols)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># rescale the image so the smallest side is min_side</span></span><br><span class="line">        scale = min_side / smallest_side</span><br><span class="line"></span><br><span class="line">        <span class="comment"># check if the largest side is now greater than max_side, which can happen</span></span><br><span class="line">        <span class="comment"># when images have a large aspect ratio</span></span><br><span class="line">        largest_side = max(rows, cols)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> largest_side * scale &gt; max_side:</span><br><span class="line">            scale = max_side / largest_side</span><br><span class="line"></span><br><span class="line">        <span class="comment"># resize the image with the computed scale</span></span><br><span class="line">        image = skimage.transform.resize(image, (int(round(rows*scale)), int(round((cols*scale)))))</span><br><span class="line">        rows, cols, cns = image.shape</span><br><span class="line"></span><br><span class="line">        pad_w = <span class="number">32</span> - rows%<span class="number">32</span></span><br><span class="line">        pad_h = <span class="number">32</span> - cols%<span class="number">32</span></span><br><span class="line"></span><br><span class="line">        new_image = np.zeros((rows + pad_w, cols + pad_h, cns)).astype(np.float32)</span><br><span class="line">        new_image[:rows, :cols, :] = image.astype(np.float32) <span class="comment"># 两个边长需要保证被32整除，少掉的的那部分使用0来补全</span></span><br><span class="line"></span><br><span class="line">        annots[:, :<span class="number">4</span>] *= scale</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'img'</span>: torch.from_numpy(new_image), <span class="string">'annot'</span>: torch.from_numpy(annots), <span class="string">'scale'</span>: scale&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数据调用-dataloader"><a href="#数据调用-dataloader" class="headerlink" title="数据调用 dataloader"></a>数据调用 dataloader</h3><p>pytorch通过实现dataloader方法来实现网络训练时，每次iteration的数据的输出。dataloader的逻辑是，每次从dataset中调用<code>__getitem__()</code>获取单个数据，然后组合成batch，在使用<code>collate_fn</code>参数对batch进行一些操作。</p>
<p><code>torch.utils.data.Dataloader</code><strong>中的参数</strong>：</p>
<blockquote>
<p><strong>dataset</strong>(<a href="https://pytorch.org/docs/stable/data.html?highlight=dataloader#torch.utils.data.Dataset" target="_blank" rel="noopener"><em>Dataset</em></a>) – dataset from which to load the data.</p>
<p><strong>batch_size</strong>(<a href="https://docs.python.org/3/library/functions.html#int" target="_blank" rel="noopener"><em>int</em></a>, <em>optional</em>) – how many samples per batch to load (default: 1).</p>
<p><strong>shuffle</strong>(<a href="https://docs.python.org/3/library/functions.html#bool" target="_blank" rel="noopener"><em>bool</em></a>, <em>optional</em>) – set to <code>True</code>to have the data reshuffled at every epoch (default: False).</p>
<p><strong>sampler</strong>(<a href="https://pytorch.org/docs/stable/data.html?highlight=dataloader#torch.utils.data.Sampler" target="_blank" rel="noopener"><em>Sampler</em></a>, <em>optional</em>) – defines the strategy to draw samples from the dataset. If specified, <code>shuffle</code>must be False.</p>
<p><strong>batch_sampler</strong>(<a href="https://pytorch.org/docs/stable/data.html?highlight=dataloader#torch.utils.data.Sampler" target="_blank" rel="noopener"><em>Sampler</em></a>, <em>optional</em>) – like sampler, but returns a batch of indices at a time. Mutually exclusive with batch_size, shuffle, sampler, and drop_last.</p>
<p><strong>num_workers</strong>(<a href="https://docs.python.org/3/library/functions.html#int" target="_blank" rel="noopener"><em>int</em></a>, <em>optional</em>) – how many subprocesses to use for data loading. 0 means that the data will be loaded in the main process. (default: 0)</p>
<p><strong>collate_fn</strong>(<em>callable<strong>, </strong>optional</em>) – merges a list of samples to form a mini-batch.</p>
<p><strong>pin_memory</strong>(<a href="https://docs.python.org/3/library/functions.html#bool" target="_blank" rel="noopener"><em>bool</em></a>, <em>optional</em>) – If <code>True</code>, the data loader will copy tensors into CUDA pinned memory before returning them.</p>
<p><strong>drop_last</strong>(<a href="https://docs.python.org/3/library/functions.html#bool" target="_blank" rel="noopener"><em>bool</em></a>, <em>optional</em>) – set to <code>True</code>to drop the last incomplete batch, if the dataset size is not divisible by the batch size. If <code>False</code>and the size of dataset is not divisible by the batch size, then the last batch will be smaller. (default: False)</p>
<p><strong>timeout</strong>(<em>numeric</em>, <em>optional</em>) – if positive, the timeout value for collecting a batch from workers. Should always be non-negative. (default: 0)</p>
<p><strong>worker_init_fn</strong>(<em>callable</em>, <em>optional</em>) – If not None, this will be called on each worker subprocess with the worker id (an int in <code>[0, num_workers - 1]</code>) as input, after seeding and before data loading. (default: None)</p>
</blockquote>
<p>算法中使用如下参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataloader_train = DataLoader(dataset_train, num_workers=3, collate_fn=collater, batch_sampler=sampler)</span><br></pre></td></tr></table></figure>
<p>其中<code>dataset_train</code>为<code>Dataset</code>类的对象，如上实现数据问价读取的部分。<code>num_workers</code>设置了这个类的线程数。<code>batch_sampler</code> 设置了每次从数据集中返回一个batch的sample的策略。<code>collate_fn</code> 将一系列的样本融合成一个小的mini-batch。</p>
<p><strong>首先是batch_sampler:</strong></p>
<p>继承至采样器类，需要实现其中的<code>__len__</code>方法，<code>__iter__</code>方法。该参数的作用是将数据集做成许多group组成的一个list。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AspectRatioBasedSampler</span><span class="params">(Sampler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data_source, batch_size, drop_last)</span>:</span></span><br><span class="line">        self.data_source = data_source</span><br><span class="line">        self.batch_size = batch_size</span><br><span class="line">        self.drop_last = drop_last</span><br><span class="line">        self.groups = self.group_images()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        random.shuffle(self.groups)</span><br><span class="line">        <span class="keyword">for</span> group <span class="keyword">in</span> self.groups:</span><br><span class="line">            <span class="keyword">yield</span> group</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.drop_last:</span><br><span class="line">            <span class="keyword">return</span> len(self.data_source) // self.batch_size</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (len(self.data_source) + self.batch_size - <span class="number">1</span>) // self.batch_size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">group_images</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># determine the order of the images</span></span><br><span class="line">        order = list(range(len(self.data_source)))</span><br><span class="line">        order.sort(key=<span class="keyword">lambda</span> x: self.data_source.image_aspect_ratio(x))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># divide into groups, one group = one batch</span></span><br><span class="line">        <span class="keyword">return</span> [[order[x % len(order)] <span class="keyword">for</span> x <span class="keyword">in</span> range(i, i + self.batch_size)] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(order), self.batch_size)]</span><br></pre></td></tr></table></figure>
<p>如上，这个方法将数据分别存入group中，然后组成一个groups的list。通过一个<code>__iter__()</code>方法，迭代的方式将数据输出。每次输出一个batch大小的数据。</p>
<p><strong>collate_fn参数：</strong></p>
<p>该参数接受来自batch_sampler的数据，对数据进行进一步的处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">collater</span><span class="params">(data)</span>:</span></span><br><span class="line">    imgs = [s[<span class="string">'img'</span>] <span class="keyword">for</span> s <span class="keyword">in</span> data]</span><br><span class="line">    annots = [s[<span class="string">'annot'</span>] <span class="keyword">for</span> s <span class="keyword">in</span> data]</span><br><span class="line">    scales = [s[<span class="string">'scale'</span>] <span class="keyword">for</span> s <span class="keyword">in</span> data]     </span><br><span class="line">    widths = [int(s.shape[<span class="number">0</span>]) <span class="keyword">for</span> s <span class="keyword">in</span> imgs]</span><br><span class="line">    heights = [int(s.shape[<span class="number">1</span>]) <span class="keyword">for</span> s <span class="keyword">in</span> imgs]</span><br><span class="line">    batch_size = len(imgs)</span><br><span class="line">    max_width = np.array(widths).max()</span><br><span class="line">    max_height = np.array(heights).max()</span><br><span class="line">    padded_imgs = torch.zeros(batch_size, max_width, max_height, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(batch_size):</span><br><span class="line">        img = imgs[i]</span><br><span class="line">        padded_imgs[i, :int(img.shape[<span class="number">0</span>]), :int(img.shape[<span class="number">1</span>]), :] = img</span><br><span class="line">    max_num_annots = max(annot.shape[<span class="number">0</span>] <span class="keyword">for</span> annot <span class="keyword">in</span> annots)</span><br><span class="line">    <span class="keyword">if</span> max_num_annots &gt; <span class="number">0</span>:</span><br><span class="line">        annot_padded = torch.ones((len(annots), max_num_annots, <span class="number">5</span>)) * <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> max_num_annots &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> idx, annot <span class="keyword">in</span> enumerate(annots):</span><br><span class="line">                <span class="comment">#print(annot.shape)</span></span><br><span class="line">                <span class="keyword">if</span> annot.shape[<span class="number">0</span>] &gt; <span class="number">0</span>:</span><br><span class="line">                    annot_padded[idx, :annot.shape[<span class="number">0</span>], :] = annot</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        annot_padded = torch.ones((len(annots), <span class="number">1</span>, <span class="number">5</span>)) * <span class="number">-1</span></span><br><span class="line">    padded_imgs = padded_imgs.permute(<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'img'</span>: padded_imgs, <span class="string">'annot'</span>: annot_padded, <span class="string">'scale'</span>: scales&#125;</span><br></pre></td></tr></table></figure>
<p>上面的操作，将同一个batch中的图片的大小统一同样的大小。annotation的维度也统一到同样大小的维度。然后进行RGB通道的变换之后，放回一个dict。</p>
<p>上面这些步骤就完成了数据的loader，通过for循环从其中取得元素。</p>
<h3 id="retinanet网络结构"><a href="#retinanet网络结构" class="headerlink" title="retinanet网络结构"></a>retinanet网络结构</h3><p>下面从数据流动的角度分析一下retinanet的各个结构的组成。</p>
<p>retinanet的特征提取部分，使用的是resnet，resnet有多种深度的选择，分别有18，34，50，101，152五种深度。常用的网络深度为50，101:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resnet50</span><span class="params">(num_classes, pretrained=False, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""Constructs a ResNet-50 model.</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        pretrained (bool): If True, returns a model pre-trained on ImageNet</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    model = ResNet(num_classes, Bottleneck, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>], **kwargs)</span><br><span class="line">    <span class="keyword">if</span> pretrained:</span><br><span class="line">        model.load_state_dict(model_zoo.load_url(model_urls[<span class="string">'resnet50'</span>], model_dir=<span class="string">'.'</span>), strict=<span class="keyword">False</span>)</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure>
<p>让我们一行一行来看，第一个调用了ResNet()类，创建了一个ResNet对象。ResNet继承至<code>nn.Module</code>,需要实现函数<code>__init__</code>以及<code>forward()</code>两个方法，通常将可学习的参数放到构造函数<code>__init__()</code>中，在<code>forward</code>中实现网络数据的流动，即可实现网络的自动求导机制。</p>
<p><strong>ResNet</strong></p>
<p>resnet首次提出残差的思想，传统的卷积网络或者全连接网络在信息传递的时候或多或少会存在信息丢失，损耗等问题，同时还有导致梯度消失或者梯度爆炸，导致很深的网络无法训练。ResNet通过学习残差的方式，在一定程度上解决了<strong>网络退化和梯度消失</strong>的问题。ResNet通过大量叠加残差块的方式，加深网络的深度的同时，保证了网络的梯度不消失。ResNet有着两种不同的残差单元。分别是basicBlock 和 bottleneck结构。深层次网络使用bottleneck结构，每次经过残差结构之前都对数据进行一次降维，大大降低了网络的参数量。</p>
<p><img src="/images/res_unit.png" alt=""></p>
<p>bottleneck的结构feature经过第一个1x1的卷积层，将特征的维度压缩，对压缩后的特征进行3x3的卷积，然后经过1x1卷积层，将特征的维度放大到原来的大小。</p>
<p>bottleneck的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bottleneck</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    expansion = <span class="number">4</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inplanes, planes, stride=<span class="number">1</span>, downsample=None)</span>:</span></span><br><span class="line">        super(Bottleneck, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(inplanes, planes, kernel_size=<span class="number">1</span>, bias=<span class="keyword">False</span>)</span><br><span class="line">        self.bn1 = nn.BatchNorm2d(planes)</span><br><span class="line">        self.conv2 = nn.Conv2d(planes, planes, kernel_size=<span class="number">3</span>, stride=stride,</span><br><span class="line">                               padding=<span class="number">1</span>, bias=<span class="keyword">False</span>)</span><br><span class="line">        self.bn2 = nn.BatchNorm2d(planes)</span><br><span class="line">        self.conv3 = nn.Conv2d(planes, planes * <span class="number">4</span>, kernel_size=<span class="number">1</span>, bias=<span class="keyword">False</span>)</span><br><span class="line">        self.bn3 = nn.BatchNorm2d(planes * <span class="number">4</span>)</span><br><span class="line">        self.relu = nn.ReLU(inplace=<span class="keyword">True</span>)</span><br><span class="line">        self.downsample = downsample</span><br><span class="line">        self.stride = stride</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        residual = x</span><br><span class="line">        out = self.conv1(x)</span><br><span class="line">        out = self.bn1(out)</span><br><span class="line">        out = self.relu(out)</span><br><span class="line">        </span><br><span class="line">        out = self.conv2(out)</span><br><span class="line">        out = self.bn2(out)</span><br><span class="line">        out = self.relu(out)</span><br><span class="line">        </span><br><span class="line">        out = self.conv3(out)</span><br><span class="line">        out = self.bn3(out)</span><br><span class="line">        <span class="keyword">if</span> self.downsample <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            residual = self.downsample(x)</span><br><span class="line">        out += residual</span><br><span class="line">        out = self.relu(out)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure>
<p>pytorch中常用的搭建网络的函数如下：</p>
<p>Conv2d卷积：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line">nn.Conv2d(in_channels, out_channels, kernel_size, stride=<span class="number">1</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, groups=<span class="number">1</span>, bias=<span class="keyword">True</span>)</span><br><span class="line">参数：</span><br><span class="line">in_channels(int) – 输入信号的通道</span><br><span class="line">out_channels(int) – 卷积产生的通道</span><br><span class="line">kerner_size(int <span class="keyword">or</span> tuple) - 卷积核的尺寸</span><br><span class="line">stride(int <span class="keyword">or</span> tuple, optional) - 卷积步长</span><br><span class="line">padding(int <span class="keyword">or</span> tuple, optional) - 输入的每一条边补充<span class="number">0</span>的层数</span><br><span class="line">dilation(int <span class="keyword">or</span> tuple, optional) – 卷积核元素之间的间距</span><br><span class="line">groups(int, optional) – 从输入通道到输出通道的阻塞连接数</span><br><span class="line">bias(bool, optional) - 如果bias=<span class="keyword">True</span>，添加偏置</span><br><span class="line">输入：</span><br><span class="line">input: (N,C_in,H_in,W_in) </span><br><span class="line">输出：</span><br><span class="line">output: (N,C_out,H_out,W_out)</span><br><span class="line">计算公式：Fout = (Fin + <span class="number">2</span>*padding-kernel)/stride + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>batchNorm2d：</p>
<p>在训练时，该层计算每次输入的均值与方差，并进行移动平均。移动平均默认的动量值为0.1。</p>
<p>在验证时，训练求得的均值/方差将用于标准化验证数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BatchNorm2d(num_features, eps=<span class="number">1e-05</span>, momentum=<span class="number">0.1</span>, affine=<span class="keyword">True</span>)</span><br><span class="line">参数：</span><br><span class="line">num_features： 来自期望输入的特征数，该期望输入的大小为<span class="string">'batch_size x num_features x height x width'</span></span><br><span class="line">eps： 为保证数值稳定性（分母不能趋近或取<span class="number">0</span>）,给分母加上的值。默认为<span class="number">1e-5</span>。</span><br><span class="line">momentum： 动态均值和动态方差所使用的动量。默认为<span class="number">0.1</span>。</span><br><span class="line">affine： 一个布尔值，当设为true，给该层添加可学习的仿射变换参数。</span><br><span class="line">输入：（N, C，H, W) - 输出：（N, C, H, W）</span><br><span class="line">值得至于的是，参数num_feature写channel数即可。</span><br></pre></td></tr></table></figure>
<p>ReLU：修正线性单元函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nn.ReLU(inplace=<span class="keyword">False</span>)</span><br><span class="line">参数：</span><br><span class="line">inplace：表示是否进行覆盖计算，节省内存</span><br><span class="line">不会引起数据维度的变化</span><br></pre></td></tr></table></figure>
<p>MaxPool2d 层</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nn.MaxPool2d(kernel_size, stride=<span class="keyword">None</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, return_indices=<span class="keyword">False</span>, ceil_mode=<span class="keyword">False</span>)</span><br><span class="line">参数：</span><br><span class="line">kernel_size(int <span class="keyword">or</span> tuple) - max pooling的窗口大小</span><br><span class="line">stride(int <span class="keyword">or</span> tuple, optional) - max pooling的窗口移动的步长。默认值是kernel_size</span><br><span class="line">padding(int <span class="keyword">or</span> tuple, optional) - 输入的每一条边补充<span class="number">0</span>的层数</span><br><span class="line">dilation(int <span class="keyword">or</span> tuple, optional) – 一个控制窗口中元素步幅的参数</span><br><span class="line">return_indices - 如果等于<span class="keyword">True</span>，会返回输出最大值的序号，对于上采样操作会有帮助</span><br><span class="line">ceil_mode - 如果等于<span class="keyword">True</span>，计算输出信号大小的时候，会使用向上取整，代替默认的向下取整的操作</span><br><span class="line">输入: (N,C,H_&#123;<span class="keyword">in</span>&#125;,W_in) </span><br><span class="line">输出: (N,C,H_out,W_out)</span><br><span class="line">计算公式：Fout = (Fin + <span class="number">2</span>*padding - kernel)/stride + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>nn.Upsample 上采样操作对channel进行采样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nn.Upsample(size=<span class="keyword">None</span>, scale_factor=<span class="keyword">None</span>, mode=<span class="string">'nearest'</span>, align_corners=<span class="keyword">None</span>)</span><br><span class="line">给定上采样策略mode，上采样的大小：scale_factor</span><br></pre></td></tr></table></figure>
<p>nn.Sequential一个有序的容器，神经网络模块将按照在传入构造器的顺序依次被添加到计算图中执行，同时以神经网络模块为元素的有序字典也可以作为传入参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">downsample = nn.Sequential(</span><br><span class="line">                nn.Conv2d(self.inplanes, planes * block.expansion,</span><br><span class="line">                          kernel_size=<span class="number">1</span>, stride=stride, bias=<span class="keyword">False</span>),</span><br><span class="line">                nn.BatchNorm2d(planes * block.expansion),</span><br><span class="line">            )</span><br></pre></td></tr></table></figure>
<p><strong>网络结构类继承至<code>nn.Module</code>,需要实现函数<code>__init__</code>以及<code>forward()</code>两个方法，通常在<strong>init</strong>中完成网络层的初始化工作，定义各类的网络层。在forward中完成网络层数据的流动。</strong></p>
<p>retinanet金字塔模型的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PyramidFeatures</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, C3_size, C4_size, C5_size, feature_size=<span class="number">256</span>)</span>:</span></span><br><span class="line">        super(PyramidFeatures, self).__init__()</span><br><span class="line">        <span class="comment"># upsample C5 to get P5 from the FPN paper</span></span><br><span class="line">        self.P5_1           = nn.Conv2d(C5_size, feature_size, kernel_size=<span class="number">1</span>, stride=<span class="number">1</span>, padding=<span class="number">0</span>)</span><br><span class="line">        self.P5_upsampled   = nn.Upsample(scale_factor=<span class="number">2</span>, mode=<span class="string">'nearest'</span>)</span><br><span class="line">        self.P5_2           = nn.Conv2d(feature_size, feature_size, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># add P5 elementwise to C4</span></span><br><span class="line">        self.P4_1           = nn.Conv2d(C4_size, feature_size, kernel_size=<span class="number">1</span>, stride=<span class="number">1</span>, padding=<span class="number">0</span>)</span><br><span class="line">        self.P4_upsampled   = nn.Upsample(scale_factor=<span class="number">2</span>, mode=<span class="string">'nearest'</span>)</span><br><span class="line">        self.P4_2           = nn.Conv2d(feature_size, feature_size, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># add P4 elementwise to C3</span></span><br><span class="line">        self.P3_1 = nn.Conv2d(C3_size, feature_size, kernel_size=<span class="number">1</span>, stride=<span class="number">1</span>, padding=<span class="number">0</span>)</span><br><span class="line">        self.P3_2 = nn.Conv2d(feature_size, feature_size, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># "P6 is obtained via a 3x3 stride-2 conv on C5"</span></span><br><span class="line">        self.P6 = nn.Conv2d(C5_size, feature_size, kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># "P7 is computed by applying ReLU followed by a 3x3 stride-2 conv on P6"</span></span><br><span class="line">        self.P7_1 = nn.ReLU()</span><br><span class="line">        self.P7_2 = nn.Conv2d(feature_size, feature_size, kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, inputs)</span>:</span></span><br><span class="line"></span><br><span class="line">        C3, C4, C5 = inputs</span><br><span class="line"></span><br><span class="line">        P5_x = self.P5_1(C5)</span><br><span class="line">        P5_upsampled_x = self.P5_upsampled(P5_x)</span><br><span class="line">        P5_x = self.P5_2(P5_x)</span><br><span class="line">        </span><br><span class="line">        P4_x = self.P4_1(C4)</span><br><span class="line">        P4_x = P5_upsampled_x + P4_x</span><br><span class="line">        P4_upsampled_x = self.P4_upsampled(P4_x)</span><br><span class="line">        P4_x = self.P4_2(P4_x)</span><br><span class="line"></span><br><span class="line">        P3_x = self.P3_1(C3)</span><br><span class="line">        P3_x = P3_x + P4_upsampled_x</span><br><span class="line">        P3_x = self.P3_2(P3_x)</span><br><span class="line"></span><br><span class="line">        P6_x = self.P6(C5)</span><br><span class="line"></span><br><span class="line">        P7_x = self.P7_1(P6_x)</span><br><span class="line">        P7_x = self.P7_2(P7_x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [P3_x, P4_x, P5_x, P6_x, P7_x]</span><br></pre></td></tr></table></figure>
<p>retinanet在金字塔之后，接了一个回归网络以及分类网络，分别对边框位置以及类别进行分类。</p>
<p><strong>回归网络</strong>简单的接了五个卷积层，保持feature的大小不变，每一个channel的维度最终降为num_anchors x 4，即每一个channel需要回归出num_anchors x 4 个坐标点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegressionModel</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_features_in, num_anchors=<span class="number">9</span>, feature_size=<span class="number">256</span>)</span>:</span></span><br><span class="line">        super(RegressionModel, self).__init__()</span><br><span class="line">        </span><br><span class="line">        self.conv1 = nn.Conv2d(num_features_in, feature_size, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.act1 = nn.ReLU()</span><br><span class="line"></span><br><span class="line">        self.conv2 = nn.Conv2d(feature_size, feature_size, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.act2 = nn.ReLU()</span><br><span class="line"></span><br><span class="line">        self.conv3 = nn.Conv2d(feature_size, feature_size, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.act3 = nn.ReLU()</span><br><span class="line"></span><br><span class="line">        self.conv4 = nn.Conv2d(feature_size, feature_size, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.act4 = nn.ReLU()</span><br><span class="line"></span><br><span class="line">        self.output = nn.Conv2d(feature_size, num_anchors*<span class="number">4</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line"></span><br><span class="line">        out = self.conv1(x)</span><br><span class="line">        out = self.act1(out)</span><br><span class="line"></span><br><span class="line">        out = self.conv2(out)</span><br><span class="line">        out = self.act2(out)</span><br><span class="line"></span><br><span class="line">        out = self.conv3(out)</span><br><span class="line">        out = self.act3(out)</span><br><span class="line"></span><br><span class="line">        out = self.conv4(out)</span><br><span class="line">        out = self.act4(out)</span><br><span class="line"></span><br><span class="line">        out = self.output(out)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># out is B x C x W x H, with C = 4*num_anchors</span></span><br><span class="line">        out = out.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out.contiguous().view(out.shape[<span class="number">0</span>], <span class="number">-1</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<p>上诉最后一行值得注意一下view()函数相当于numpy中的reshape函数，但是要求数据必须在内存中是连续存储的。由于permute函数，改变了数据的分布（浅拷贝）。因此在使用view之前，需要执行contiguous函数使得数据内存连续分布。最终out的shape为[batch_size，w x h ，4]。上诉得到的out最终输入criterion中，计算loss。</p>
<p><strong>分类模型</strong>的网络结构和回归模型的结构相同，唯一不同的地方在于最终输出的channel的大小。分类模型输出的channel大小为anchor的数量乘以类别（num_anchor x num_classes）。即每一个框都要预测一个类别信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassificationModel</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_features_in, num_anchors=<span class="number">9</span>, num_classes=<span class="number">80</span>, prior=<span class="number">0.01</span>, feature_size=<span class="number">256</span>)</span>:</span></span><br><span class="line">        super(ClassificationModel, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.num_classes = num_classes</span><br><span class="line">        self.num_anchors = num_anchors</span><br><span class="line">        </span><br><span class="line">        self.conv1 = nn.Conv2d(num_features_in, feature_size, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.act1 = nn.ReLU()</span><br><span class="line"></span><br><span class="line">        self.conv2 = nn.Conv2d(feature_size, feature_size, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.act2 = nn.ReLU()</span><br><span class="line"></span><br><span class="line">        self.conv3 = nn.Conv2d(feature_size, feature_size, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.act3 = nn.ReLU()</span><br><span class="line"></span><br><span class="line">        self.conv4 = nn.Conv2d(feature_size, feature_size, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.act4 = nn.ReLU()</span><br><span class="line"></span><br><span class="line">        self.output = nn.Conv2d(feature_size, num_anchors*num_classes, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.output_act = nn.Sigmoid()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line"></span><br><span class="line">        out = self.conv1(x)</span><br><span class="line">        out = self.act1(out)</span><br><span class="line"></span><br><span class="line">        out = self.conv2(out)</span><br><span class="line">        out = self.act2(out)</span><br><span class="line"></span><br><span class="line">        out = self.conv3(out)</span><br><span class="line">        out = self.act3(out)</span><br><span class="line"></span><br><span class="line">        out = self.conv4(out)</span><br><span class="line">        out = self.act4(out)</span><br><span class="line"></span><br><span class="line">        out = self.output(out)</span><br><span class="line">        out = self.output_act(out)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># out is B x C x W x H, with C = n_classes + n_anchors</span></span><br><span class="line">        out1 = out.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        batch_size, width, height, channels = out1.shape</span><br><span class="line"></span><br><span class="line">        out2 = out1.view(batch_size, width, height, self.num_anchors, self.num_classes)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out2.contiguous().view(x.shape[<span class="number">0</span>], <span class="number">-1</span>, self.num_classes)</span><br></pre></td></tr></table></figure>
<p>最后一行首先将out的维度控制在anchor x num_classes，然后通过一个view将其变为[x.shape[0],W x H x anchor, num_classes]，每一个值表示一个框的类别，然后到criterion中去做预测。</p>
<p>Torch.cat 用法：<a href="https://blog.csdn.net/qq_39709535/article/details/80803003" target="_blank" rel="noopener">https://blog.csdn.net/qq_39709535/article/details/80803003</a></p>
<p>接下来需要生成anchor。</p>
<h3 id="anchor的生成"><a href="#anchor的生成" class="headerlink" title="anchor的生成"></a>anchor的生成</h3><p>anchor的设置上面，对于retinaNet最终的P3，P4，P5，P6，P7均有一个不同的设置。anchor的长宽比和scale的大小分别有三种设置，一共有9种组合。anchor的大小与feature map的大小也是相关的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.ratios = np.array([<span class="number">0.5</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line">self.scales = np.array([<span class="number">2</span>**<span class="number">0</span>,<span class="number">2</span>**(<span class="number">1.0</span>/<span class="number">3.0</span>),<span class="number">2</span>**(<span class="number">2.0</span>/<span class="number">3.0</span>)])</span><br></pre></td></tr></table></figure>
<p>几个常用的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a = np.tile(a,(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment"># a = [[1,2,3,1,2,3,1,2,3]</span></span><br><span class="line">       [<span class="number">1.2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br></pre></td></tr></table></figure>
<p>np.repeat</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a = np.repeat(a,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># a = [1,1,2,2,3,3]</span></span><br><span class="line"><span class="comment"># 与np.tile的区别是，他是一个元素一个元素的增加后进行排序的。tile则是一起增加。</span></span><br></pre></td></tr></table></figure>
<p>生成anchor的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Anchors</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pyramid_levels=None, strides=None, sizes=None, ratios=None, scales=None)</span>:</span></span><br><span class="line">        super(Anchors, self).__init__()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> pyramid_levels <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            self.pyramid_levels = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">        <span class="keyword">if</span> strides <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            self.strides = [<span class="number">2</span> ** x <span class="keyword">for</span> x <span class="keyword">in</span> self.pyramid_levels]</span><br><span class="line">        <span class="keyword">if</span> sizes <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            self.sizes = [<span class="number">2</span> ** (x + <span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> self.pyramid_levels]</span><br><span class="line">        <span class="keyword">if</span> ratios <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            self.ratios = np.array([<span class="number">0.5</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">if</span> scales <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            self.scales = np.array([<span class="number">2</span> ** <span class="number">0</span>, <span class="number">2</span> ** (<span class="number">1.0</span> / <span class="number">3.0</span>), <span class="number">2</span> ** (<span class="number">2.0</span> / <span class="number">3.0</span>)])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, image)</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># image = [2,3,640,832]</span></span><br><span class="line">        image_shape = image.shape[<span class="number">2</span>:]</span><br><span class="line">        image_shape = np.array(image_shape)</span><br><span class="line">        image_shapes = [(image_shape + <span class="number">2</span> ** x - <span class="number">1</span>) // (<span class="number">2</span> ** x) <span class="keyword">for</span> x <span class="keyword">in</span> self.pyramid_levels]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># compute anchors over all pyramid levels</span></span><br><span class="line">        all_anchors = np.zeros((<span class="number">0</span>, <span class="number">4</span>)).astype(np.float32)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> idx, p <span class="keyword">in</span> enumerate(self.pyramid_levels):</span><br><span class="line">            anchors         = generate_anchors(base_size=self.sizes[idx], ratios=self.ratios, scales=self.scales)</span><br><span class="line">            shifted_anchors = shift(image_shapes[idx], self.strides[idx], anchors)</span><br><span class="line">            all_anchors     = np.append(all_anchors, shifted_anchors, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        all_anchors = np.expand_dims(all_anchors, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> torch.from_numpy(all_anchors.astype(np.float32)).cuda()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_anchors</span><span class="params">(base_size=<span class="number">16</span>, ratios=None, scales=None)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Generate anchor (reference) windows by enumerating aspect ratios X</span></span><br><span class="line"><span class="string">    scales w.r.t. a reference window.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ratios <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        ratios = np.array([<span class="number">0.5</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> scales <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        scales = np.array([<span class="number">2</span> ** <span class="number">0</span>, <span class="number">2</span> ** (<span class="number">1.0</span> / <span class="number">3.0</span>), <span class="number">2</span> ** (<span class="number">2.0</span> / <span class="number">3.0</span>)])</span><br><span class="line"></span><br><span class="line">    num_anchors = len(ratios) * len(scales) <span class="comment"># 9个点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># initialize output anchors</span></span><br><span class="line">    anchors = np.zeros((num_anchors, <span class="number">4</span>)) <span class="comment"># 每一个位置上都有9个点，每个点都有四个坐标值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># scale base_size,feature 的大小与scale相乘，得到每一层anchor的大小</span></span><br><span class="line">    anchors[:, <span class="number">2</span>:] = base_size * np.tile(scales, (<span class="number">2</span>, len(ratios))).T</span><br><span class="line"></span><br><span class="line">    <span class="comment"># compute areas of anchors</span></span><br><span class="line">    areas = anchors[:, <span class="number">2</span>] * anchors[:, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># correct for ratios 构造长宽比</span></span><br><span class="line">    anchors[:, <span class="number">2</span>] = np.sqrt(areas / np.repeat(ratios, len(scales)))</span><br><span class="line">    anchors[:, <span class="number">3</span>] = anchors[:, <span class="number">2</span>] * np.repeat(ratios, len(scales))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># transform from (x_ctr, y_ctr, w, h) -&gt; (x1, y1, x2, y2)</span></span><br><span class="line">    anchors[:, <span class="number">0</span>::<span class="number">2</span>] -= np.tile(anchors[:, <span class="number">2</span>] * <span class="number">0.5</span>, (<span class="number">2</span>, <span class="number">1</span>)).T</span><br><span class="line">    anchors[:, <span class="number">1</span>::<span class="number">2</span>] -= np.tile(anchors[:, <span class="number">3</span>] * <span class="number">0.5</span>, (<span class="number">2</span>, <span class="number">1</span>)).T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> anchors</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shift</span><span class="params">(shape, stride, anchors)</span>:</span></span><br><span class="line">    shift_x = (np.arange(<span class="number">0</span>, shape[<span class="number">1</span>]) + <span class="number">0.5</span>) * stride</span><br><span class="line">    shift_y = (np.arange(<span class="number">0</span>, shape[<span class="number">0</span>]) + <span class="number">0.5</span>) * stride</span><br><span class="line"></span><br><span class="line">    shift_x, shift_y = np.meshgrid(shift_x, shift_y)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># shifts = [shape[0]*shape[1],4]</span></span><br><span class="line">    shifts = np.vstack((</span><br><span class="line">        shift_x.ravel(), shift_y.ravel(),</span><br><span class="line">        shift_x.ravel(), shift_y.ravel()</span><br><span class="line">    )).transpose()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># add A anchors (1, A, 4) to</span></span><br><span class="line">    <span class="comment"># cell K shifts (K, 1, 4) to get</span></span><br><span class="line">    <span class="comment"># shift anchors (K, A, 4)</span></span><br><span class="line">    <span class="comment"># reshape to (K*A, 4) shifted anchors</span></span><br><span class="line">    A = anchors.shape[<span class="number">0</span>]</span><br><span class="line">    K = shifts.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 下面这一行进行了广播赋值，每一行都赋予维度不同的行进行广播，</span></span><br><span class="line">    <span class="comment"># 最终形成[1,A,4] + [k,1,4] = [k,A,4],其中k = shape[0]*shape[1]</span></span><br><span class="line">    <span class="comment"># 也就是说每一个像素位置都将产生9个anchor，每个anchor有四个坐标。 shape的大小则是由计算产生的</span></span><br><span class="line">    <span class="comment"># 每张图片在每个level处的大小在__init__处进行初始化</span></span><br><span class="line">    all_anchors = (anchors.reshape((<span class="number">1</span>, A, <span class="number">4</span>)) + \</span><br><span class="line">                   shifts.reshape((<span class="number">1</span>, K, <span class="number">4</span>)).transpose((<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>)))</span><br><span class="line">    all_anchors = all_anchors.reshape((K * A, <span class="number">4</span>))</span><br><span class="line">    <span class="keyword">return</span> all_anchors</span><br></pre></td></tr></table></figure>
<p>每一行进行分析就是先设置每一层feature map的level，stride，sizes，ratios，scales的值。然后在forward里面<strong>generate_anchor()，对每一个level的feature生成符合要求的size的anchor</strong>，长宽比组合后共9种anchor。具体的设置可看代码。</p>
<p>然后进入shift()函数，shift()函数的作用是将anchor散布到每一个位置上。流程大概是，一张图片进来，分别计算出这种图片在每一层level上的size大小，然后根据每一层的anchor的大小，每一个像素点位置取9个anchor，然后返回一个$[shape[0]<em>shape[1]</em>9,4]$ 大小的矩阵。</p>
<p>几个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">np.meshgrid(x,y)<span class="comment"># 将x中元素与y中元素一一对应起来组合成坐标的形式。</span></span><br><span class="line">np.vstack((x,y))<span class="comment"># 将x，y中元素按照垂直方向叠加</span></span><br><span class="line"><span class="comment">#ravel()</span></span><br><span class="line">a = [[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">a.ravel() <span class="comment"># 将多维数组拉平，不存生新的副本 a = [2,2,1,1]</span></span><br><span class="line">a.flatten() <span class="comment"># 作用与上面函数相同，将返回一个数据副本</span></span><br><span class="line">np.squeeze([[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>]]) <span class="comment"># 对维度为1的数据进行压缩，得到[1,2,3]</span></span><br><span class="line">a = a.reshape(<span class="number">-1</span>) <span class="comment"># 同样能够得到1维的数据</span></span><br><span class="line">a.transpose() <span class="comment"># 不指定参数表示对矩阵进行转置</span></span><br></pre></td></tr></table></figure>
<p>经过上面的过程，在for循环部分，将5层的anchor全部装入一个list中，anchor生成完毕。</p>
<p><strong>torch.cat函数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">torch.cat((a,b),<span class="number">0</span>) <span class="comment"># 垂直方向 [[1,2,3],[3,4,5]]</span></span><br><span class="line">torch.cat((a,b),<span class="number">1</span>) <span class="comment"># 水平方向 [[1,2,3,4,5,6]]</span></span><br></pre></td></tr></table></figure>
<h3 id="focalLoss部分"><a href="#focalLoss部分" class="headerlink" title="focalLoss部分"></a>focalLoss部分</h3><p>focalLoss紧接着上面的一部分。现在回过头来梳理一下网络中数据流动到的位置：</p>
<p>将图片输入ResNet中，通过一个多层金字塔结构，输出5个不同深度feature map（P3，P4，P5，P6，P7），依次将这些层输入到regression网络和classification网络中，每一层都将得到$[batch,w<em>h,4]$的输出和$[batch,w</em>h*anchors,class_nums]$的输出，然后将所有结果cat到一起（水平拼接），即所有level上的anchor 的预测框会被cat到regression_anchor 和classification_anchor中。接下来要做的是判断这些anchor的好坏。根据我们的先验知识，我们产生了一部分anchor的设置，我们将网络产生的anchor和我们预生成的anchor输入focalLoss中，对anchor进行过滤，计算产生的loss。</p>
<p>下面介绍focalLoss：</p>
<p>focalLoss部分按batch为单位，每次输入一个batch的数据，然后进行loss的计算。首先计算预设置的anchor与当前图片GT的IoU。（重叠部分 / 相并部分）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_iou</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    area = (b[:, <span class="number">2</span>] - b[:, <span class="number">0</span>]) * (b[:, <span class="number">3</span>] - b[:, <span class="number">1</span>])</span><br><span class="line">    iw = torch.min(torch.unsqueeze(a[:, <span class="number">2</span>], dim=<span class="number">1</span>), b[:, <span class="number">2</span>]) -\</span><br><span class="line">    torch.max(torch.unsqueeze(a[:, <span class="number">0</span>], <span class="number">1</span>), b[:, <span class="number">0</span>])</span><br><span class="line">    ih = torch.min(torch.unsqueeze(a[:, <span class="number">3</span>], dim=<span class="number">1</span>), b[:, <span class="number">3</span>]) -\</span><br><span class="line">    torch.max(torch.unsqueeze(a[:, <span class="number">1</span>], <span class="number">1</span>), b[:, <span class="number">1</span>])</span><br><span class="line">    iw = torch.clamp(iw, min=<span class="number">0</span>)</span><br><span class="line">    ih = torch.clamp(ih, min=<span class="number">0</span>)</span><br><span class="line">    ua = torch.unsqueeze((a[:, <span class="number">2</span>] - a[:, <span class="number">0</span>]) * (a[:, <span class="number">3</span>] - a[:, <span class="number">1</span>]), dim=<span class="number">1</span>) + area - iw * ih</span><br><span class="line">    ua = torch.clamp(ua, min=<span class="number">1e-8</span>)</span><br><span class="line">    intersection = iw * ih</span><br><span class="line">    IoU = intersection / ua</span><br><span class="line">    <span class="keyword">return</span> IoU</span><br></pre></td></tr></table></figure>
<p>focalLoss主要对每一个anchor进入classification的分类结果，focalLoss的原理如下：</p>
<p><img src="/images/focal-loss.png" alt=""></p>
<p>整个网络的loss其实由两部分组成，一部分是分类loss，一部分是回归loss。分类loss即focal loss，回归部分的loss为边框回归的loss。实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FocalLoss</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="comment">#def __init__(self):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, classifications, regressions, anchors, annotations)</span>:</span></span><br><span class="line">        alpha = <span class="number">0.25</span></span><br><span class="line">        gamma = <span class="number">2.0</span></span><br><span class="line">        batch_size = classifications.shape[<span class="number">0</span>]</span><br><span class="line">        classification_losses = []</span><br><span class="line">        regression_losses = []</span><br><span class="line"></span><br><span class="line">        anchor = anchors[<span class="number">0</span>, :, :]</span><br><span class="line"></span><br><span class="line">        anchor_widths  = anchor[:, <span class="number">2</span>] - anchor[:, <span class="number">0</span>]</span><br><span class="line">        anchor_heights = anchor[:, <span class="number">3</span>] - anchor[:, <span class="number">1</span>]</span><br><span class="line">        anchor_ctr_x   = anchor[:, <span class="number">0</span>] + <span class="number">0.5</span> * anchor_widths</span><br><span class="line">        anchor_ctr_y   = anchor[:, <span class="number">1</span>] + <span class="number">0.5</span> * anchor_heights</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(batch_size):</span><br><span class="line"></span><br><span class="line">            classification = classifications[j, :, :]</span><br><span class="line">            regression = regressions[j, :, :]</span><br><span class="line"></span><br><span class="line">            bbox_annotation = annotations[j, :, :]</span><br><span class="line">            bbox_annotation = bbox_annotation[bbox_annotation[:, <span class="number">4</span>] != <span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> bbox_annotation.shape[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                regression_losses.append(torch.tensor(<span class="number">0</span>).float().cuda())</span><br><span class="line">                classification_losses.append(torch.tensor(<span class="number">0</span>).float().cuda())</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            classification = torch.clamp(classification, <span class="number">1e-4</span>, <span class="number">1.0</span> - <span class="number">1e-4</span>)</span><br><span class="line"></span><br><span class="line">            IoU = calc_iou(anchors[<span class="number">0</span>, :, :], bbox_annotation[:, :<span class="number">4</span>]) <span class="comment"># num_anchors x num_annotations</span></span><br><span class="line"></span><br><span class="line">            IoU_max, IoU_argmax = torch.max(IoU, dim=<span class="number">1</span>) <span class="comment"># num_anchors x 1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#import pdb</span></span><br><span class="line">            <span class="comment">#pdb.set_trace()</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># compute the loss for classification</span></span><br><span class="line">            <span class="comment"># target 的维度为类别的个数</span></span><br><span class="line">            targets = torch.ones(classification.shape) * <span class="number">-1</span></span><br><span class="line">            targets = targets.cuda()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># lt : less than 如果IoU_max的面积小于0.4，那么就认为没有匹配上</span></span><br><span class="line">            targets[torch.lt(IoU_max, <span class="number">0.4</span>), :] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            positive_indices = torch.ge(IoU_max, <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">            num_positive_anchors = positive_indices.sum()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># IoU_argmax记录着当前的anchor与哪一个GT比较匹配</span></span><br><span class="line">            <span class="comment"># 下面这个赋值语句就是给对应的anchor选择一个GT</span></span><br><span class="line">            <span class="comment"># 第一个参数选择候选的anchor，第二个参数将候选anchor的坐标值都取到</span></span><br><span class="line">            assigned_annotations = bbox_annotation[IoU_argmax, :]</span><br><span class="line"></span><br><span class="line">            targets[positive_indices, :] = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 下面一句表明对每个满足IoU条件的anchor，赋予一个类别。形成一个one hot编码（原先target的维度长度等于类别的个数）</span></span><br><span class="line">            targets[positive_indices, assigned_annotations[positive_indices, <span class="number">4</span>].long()] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            alpha_factor = torch.ones(targets.shape).cuda() * alpha</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            alpha_factor = torch.where(torch.eq(targets, <span class="number">1.</span>), alpha_factor, <span class="number">1.</span> - alpha_factor)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 对focal weight进行统一的计算，然后赋值</span></span><br><span class="line">            focal_weight = torch.where(torch.eq(targets, <span class="number">1.</span>), <span class="number">1.</span> - classification, classification)</span><br><span class="line">            focal_weight = alpha_factor * torch.pow(focal_weight, gamma)</span><br><span class="line">            <span class="comment">#      当y=1,即只有targets=1参与计算              当y=0，即只有targets=0参与</span></span><br><span class="line">            bce = -(targets * torch.log(classification) + (<span class="number">1.0</span> - targets) * torch.log(<span class="number">1.0</span> - classification))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># cls_loss = focal_weight * torch.pow(bce, gamma)</span></span><br><span class="line">            cls_loss = focal_weight * bce</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 注意对target的处理，当IoU在【0.4，0.5】之间时target=-1，不提供loss，其他情况均赋予一个cls_loss</span></span><br><span class="line">            cls_loss = torch.where(torch.ne(targets, <span class="number">-1.0</span>), cls_loss, torch.zeros(cls_loss.shape).cuda())</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 计算所有的loss在正例中的平均值</span></span><br><span class="line">            classification_losses.append(cls_loss.sum()/torch.clamp(num_positive_anchors.float(), min=<span class="number">1.0</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># compute the loss for regression</span></span><br><span class="line">            <span class="comment">#只有预测为正例的部分参与边框的回归，下面一部分为回归loss。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> positive_indices.sum() &gt; <span class="number">0</span>:</span><br><span class="line">                assigned_annotations = assigned_annotations[positive_indices, :]</span><br><span class="line"></span><br><span class="line">                anchor_widths_pi = anchor_widths[positive_indices]</span><br><span class="line">                anchor_heights_pi = anchor_heights[positive_indices]</span><br><span class="line">                anchor_ctr_x_pi = anchor_ctr_x[positive_indices]</span><br><span class="line">                anchor_ctr_y_pi = anchor_ctr_y[positive_indices]</span><br><span class="line"></span><br><span class="line">                gt_widths  = assigned_annotations[:, <span class="number">2</span>] - assigned_annotations[:, <span class="number">0</span>]</span><br><span class="line">                gt_heights = assigned_annotations[:, <span class="number">3</span>] - assigned_annotations[:, <span class="number">1</span>]</span><br><span class="line">                gt_ctr_x   = assigned_annotations[:, <span class="number">0</span>] + <span class="number">0.5</span> * gt_widths</span><br><span class="line">                gt_ctr_y   = assigned_annotations[:, <span class="number">1</span>] + <span class="number">0.5</span> * gt_heights</span><br><span class="line"></span><br><span class="line">                <span class="comment"># clip widths to 1</span></span><br><span class="line">                gt_widths  = torch.clamp(gt_widths, min=<span class="number">1</span>)</span><br><span class="line">                gt_heights = torch.clamp(gt_heights, min=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                targets_dx = (gt_ctr_x - anchor_ctr_x_pi) / anchor_widths_pi</span><br><span class="line">                targets_dy = (gt_ctr_y - anchor_ctr_y_pi) / anchor_heights_pi</span><br><span class="line">                targets_dw = torch.log(gt_widths / anchor_widths_pi)</span><br><span class="line">                targets_dh = torch.log(gt_heights / anchor_heights_pi)</span><br><span class="line"></span><br><span class="line">                targets = torch.stack((targets_dx, targets_dy, targets_dw, targets_dh))</span><br><span class="line">                targets = targets.t()</span><br><span class="line"></span><br><span class="line">                targets = targets/torch.Tensor([[<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.2</span>]]).cuda()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                negative_indices = <span class="number">1</span> - positive_indices</span><br><span class="line"></span><br><span class="line">                regression_diff = torch.abs(targets - regression[positive_indices, :])</span><br><span class="line"></span><br><span class="line">                regression_loss = torch.where(</span><br><span class="line">                    torch.le(regression_diff, <span class="number">1.0</span> / <span class="number">9.0</span>),</span><br><span class="line">                    <span class="number">0.5</span> * <span class="number">9.0</span> * torch.pow(regression_diff, <span class="number">2</span>),</span><br><span class="line">                    regression_diff - <span class="number">0.5</span> / <span class="number">9.0</span></span><br><span class="line">                )</span><br><span class="line">                regression_losses.append(regression_loss.mean())</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                regression_losses.append(torch.tensor(<span class="number">0</span>).float().cuda())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> torch.stack(classification_losses).mean(dim=<span class="number">0</span>, keepdim=<span class="keyword">True</span>), torch.stack(regression_losses).mean(dim=<span class="number">0</span>, keepdim=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<p>边框回归部分学习一个边框的平移以及缩放关系：</p>
<p><img src="/images/box-regress.png" alt=""></p>
<p>最终将得到的分类loss以及regression loss的平均值整合成一个stack，返回下一步。</p>
<p>几个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">torch.cat(a,b) <span class="comment">#水平方向将a与b进行拼接</span></span><br><span class="line">torch.clamp(a,min_val,max_val) <span class="comment"># 将a中的值控制在min_val与max_val之间，小于取min_val，大于取max_val</span></span><br><span class="line">max_val, max_index = torch.max(a,dim = <span class="number">1</span>) <span class="comment"># 返回每一列最大值以及每一列的最大值的索引</span></span><br><span class="line">torch.lt(a,<span class="number">0.4</span>) <span class="comment"># 返回a中值小于0.4的元素的下标，ge均类似</span></span><br><span class="line">torch.where(condition,true_val,false_val) <span class="comment"># 如果满足条件者该位置为true_val,否则为false_val,其中参数的维度均相同（比如都为三维）</span></span><br></pre></td></tr></table></figure>
<h3 id="训练阶段"><a href="#训练阶段" class="headerlink" title="训练阶段"></a>训练阶段</h3><p>训练部分有几个需要完成的工作：</p>
<ol>
<li>初始化网络，设置优化器等等</li>
<li>将数据从dataloader中取出来</li>
<li>将数据输入网络中，得到网络的loss值</li>
<li>对loss进行反向传播，一些操作如learning rate的降低，梯度的裁剪可以在其中完成</li>
<li>打印出每个batch训练的结果</li>
<li>当训练次数到达一定的epoch时，对网络进行evaluate</li>
<li>保存mAP较高的网络</li>
</ol>
<p>下面通过代码来解读：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将训练过程迁移到gpu上</span></span><br><span class="line"> use_gpu = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">if</span> use_gpu:</span><br><span class="line">	retinanet = retinanet.cuda()</span><br><span class="line">retinanet = torch.nn.DataParallel(retinanet).cuda()</span><br><span class="line">retinanet.training = <span class="keyword">True</span></span><br><span class="line"> <span class="comment"># 设置优化器为adam</span></span><br><span class="line">optimizer = optim.Adam(retinanet.parameters(), lr=<span class="number">1e-5</span>)</span><br><span class="line"> <span class="comment"># ；learning rate的缩减器</span></span><br><span class="line">scheduler = optim.lr_scheduler.ReduceLROnPlateau(optimizer, patience=<span class="number">3</span>, verbose=<span class="keyword">True</span>)</span><br><span class="line">loss_hist = collections.deque(maxlen=<span class="number">500</span>) <span class="comment"># 实现了两端的快速添加删除</span></span><br><span class="line">retinanet.train()</span><br><span class="line">retinanet.module.freeze_bn()</span><br><span class="line">print(<span class="string">'Num training images: &#123;&#125;'</span>.format(len(dataset_train)))</span><br><span class="line"><span class="comment"># 从dataloader中取数据</span></span><br><span class="line"> <span class="keyword">for</span> epoch_num <span class="keyword">in</span> range(parser.epochs):</span><br><span class="line">	retinanet.train()</span><br><span class="line">	retinanet.module.freeze_bn()</span><br><span class="line">	epoch_loss = []</span><br><span class="line">	<span class="keyword">for</span> iter_num, data <span class="keyword">in</span> enumerate(dataloader_train):</span><br><span class="line">		<span class="keyword">try</span>:</span><br><span class="line">       <span class="comment"># 清空梯度，由于pytorch在每次backward的时候，</span></span><br><span class="line">       <span class="comment"># 会进行梯度的累积，这样的做法方便训练RNN模型</span></span><br><span class="line">       <span class="comment"># 但是在训练普通模型的时候，需要将累积的梯度清空。</span></span><br><span class="line">       <span class="comment"># 清空后做backward梯度方向有利于梯度的整体下降</span></span><br><span class="line">			optimizer.zero_grad()</span><br><span class="line">       <span class="comment"># 将数据传入网络中，得到loss</span></span><br><span class="line">			classification_loss, regression_loss = retinanet([data[<span class="string">'img'</span>].cuda().float(), data[<span class="string">'annot'</span>]])</span><br><span class="line">			classification_loss = classification_loss.mean()</span><br><span class="line">			regression_loss = regression_loss.mean()</span><br><span class="line">			loss = classification_loss + regression_loss</span><br><span class="line">			<span class="keyword">if</span> bool(loss == <span class="number">0</span>):</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">       <span class="comment"># 误差的反向传播</span></span><br><span class="line">			loss.backward()</span><br><span class="line">       <span class="comment"># 梯度裁剪函数,第二个参数表明允许最大的梯度为0.1</span></span><br><span class="line">			torch.nn.utils.clip_grad_norm_(retinanet.parameters(), <span class="number">0.1</span>)</span><br><span class="line">			optimizer.step()</span><br><span class="line">			loss_hist.append(float(loss))</span><br><span class="line">			epoch_loss.append(float(loss))</span><br><span class="line">			print(<span class="string">'Epoch: &#123;&#125; | Iteration: &#123;&#125; | Classification loss: &#123;:1.5f&#125; | Regression loss: &#123;:1.5f&#125; | Running loss: &#123;:1.5f&#125;'</span>.format(epoch_num, iter_num, float(classification_loss), float(regression_loss), np.mean(loss_hist)))</span><br><span class="line">			<span class="keyword">del</span> classification_loss</span><br><span class="line">			<span class="keyword">del</span> regression_loss</span><br><span class="line">		<span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">			print(e)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">	<span class="keyword">if</span> parser.dataset == <span class="string">'coco'</span>:</span><br><span class="line">		print(<span class="string">'Evaluating dataset'</span>)</span><br><span class="line">     <span class="comment"># 验证集验证模型的有效性</span></span><br><span class="line">		coco_eval.evaluate_coco(dataset_val, retinanet)</span><br><span class="line">	<span class="keyword">elif</span> parser.dataset == <span class="string">'csv'</span> <span class="keyword">and</span> parser.csv_val <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">		print(<span class="string">'Evaluating dataset'</span>)</span><br><span class="line">		mAP = csv_eval.evaluate(dataset_val, retinanet)</span><br><span class="line">	scheduler.step(np.mean(epoch_loss))</span><br><span class="line">   <span class="comment"># 保存训练好的模型</span></span><br><span class="line">	torch.save(retinanet.module, <span class="string">'&#123;&#125;_retinanet_&#123;&#125;.pt'</span>.format(parser.dataset, epoch_num))</span><br><span class="line"> retinanet.eval()</span><br><span class="line">torch.save(retinanet, <span class="string">'model_final.pt'</span>.format(epoch_num))</span><br></pre></td></tr></table></figure>
<p>需要注意的点：</p>
<p>在网络进行训练或验证时，通常先进行一次：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model.train()</span><br><span class="line"><span class="comment"># or evaluate</span></span><br><span class="line">model.eval()</span><br></pre></td></tr></table></figure>
<p>这样的目的是模型在train和eval的时候，需要执行的操作是不一样的。例如batchNorm和Dropout在eval的时候是不需要执行的。因此需要提前对网络进行设置。</p>
<h3 id="eval-验证"><a href="#eval-验证" class="headerlink" title="eval 验证"></a>eval 验证</h3><p>eval作为验证网络的性能，被安排在网络执行的最后，在每个batch结束，或者达到设定的epoch的时候，对网络进行测试。并以此为依据，是否对网络进行存储。</p>
<p>eval部分常用的指标是mAP，该指标通过计算recall以及precision的值来得到最终的结果。首先得到网络的eval的结果，然后从标注数据中得到anno的结果，进行mAP的计算。</p>
<p>得到网络的结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_detections</span><span class="params">(dataset, retinanet, score_threshold=<span class="number">0.05</span>, max_detections=<span class="number">100</span>, save_path=None)</span>:</span></span><br><span class="line">    <span class="string">""" Get the detections from the retinanet using the generator.</span></span><br><span class="line"><span class="string">    The result is a list of lists such that the size is:</span></span><br><span class="line"><span class="string">        all_detections[num_images][num_classes] = detections[num_detections, 4 + num_classes]</span></span><br><span class="line"><span class="string">    # Arguments</span></span><br><span class="line"><span class="string">        dataset         : The generator used to run images through the retinanet.</span></span><br><span class="line"><span class="string">        retinanet           : The retinanet to run on the images.</span></span><br><span class="line"><span class="string">        score_threshold : The score confidence threshold to use.</span></span><br><span class="line"><span class="string">        max_detections  : The maximum number of detections to use per image.</span></span><br><span class="line"><span class="string">        save_path       : The path to save the images with visualized detections to.</span></span><br><span class="line"><span class="string">    # Returns</span></span><br><span class="line"><span class="string">        A list of lists containing the detections for each image in the generator.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    all_detections = [[<span class="keyword">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(dataset.num_classes())] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(dataset))]</span><br><span class="line">    retinanet.eval()</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(dataset)):</span><br><span class="line">            data = dataset[index]</span><br><span class="line">            scale = data[<span class="string">'scale'</span>]</span><br><span class="line">            <span class="comment"># run network</span></span><br><span class="line">            scores, labels, boxes = retinanet(data[<span class="string">'img'</span>].permute(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>).cuda().float().unsqueeze(dim=<span class="number">0</span>))</span><br><span class="line">            scores = scores.cpu().numpy()</span><br><span class="line">            labels = labels.cpu().numpy()</span><br><span class="line">            boxes  = boxes.cpu().numpy()</span><br><span class="line">            <span class="comment"># correct boxes for image scale</span></span><br><span class="line">            boxes /= scale</span><br><span class="line">            <span class="comment"># select indices which have a score above the threshold</span></span><br><span class="line">            indices = np.where(scores &gt; score_threshold)[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> indices.shape[<span class="number">0</span>] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># select those scores</span></span><br><span class="line">                scores = scores[indices]</span><br><span class="line">                <span class="comment"># find the order with which to sort the scores</span></span><br><span class="line">                <span class="comment"># 得到score从大到小的下标，然后选择其中的max_detections那么多个</span></span><br><span class="line">                scores_sort = np.argsort(-scores)[:max_detections]</span><br><span class="line">                <span class="comment"># select detections score从大到小</span></span><br><span class="line">                image_boxes      = boxes[indices[scores_sort], :]</span><br><span class="line">                image_scores     = scores[scores_sort]</span><br><span class="line">                image_labels     = labels[indices[scores_sort]]</span><br><span class="line">                image_detections = np.concatenate([image_boxes, np.expand_dims(image_scores, axis=<span class="number">1</span>), np.expand_dims(image_labels, axis=<span class="number">1</span>)], axis=<span class="number">1</span>)</span><br><span class="line">                <span class="comment"># copy detections to all_detections</span></span><br><span class="line">                <span class="keyword">for</span> label <span class="keyword">in</span> range(dataset.num_classes()):</span><br><span class="line">                    <span class="comment"># 每一张图片均表示成一个index，对所有的label都遍历一边，每个label保存若干个anchor,没有的话则不保存</span></span><br><span class="line">                    all_detections[index][label] = image_detections[image_detections[:, <span class="number">-1</span>] == label, :<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># copy detections to all_detections</span></span><br><span class="line">                <span class="keyword">for</span> label <span class="keyword">in</span> range(dataset.num_classes()):</span><br><span class="line">                    all_detections[index][label] = np.zeros((<span class="number">0</span>, <span class="number">5</span>))</span><br><span class="line">            print(<span class="string">'&#123;&#125;/&#123;&#125;'</span>.format(index + <span class="number">1</span>, len(dataset)), end=<span class="string">'\r'</span>)</span><br><span class="line">    <span class="keyword">return</span> all_detections</span><br></pre></td></tr></table></figure>
<p>从标注文件中读取图片的标注信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_annotations</span><span class="params">(generator)</span>:</span></span><br><span class="line">    <span class="string">""" Get the ground truth annotations from the generator.</span></span><br><span class="line"><span class="string">    The result is a list of lists such that the size is:</span></span><br><span class="line"><span class="string">        all_detections[num_images][num_classes] = annotations[num_detections, 5]</span></span><br><span class="line"><span class="string">    # Arguments</span></span><br><span class="line"><span class="string">        generator : The generator used to retrieve ground truth annotations.</span></span><br><span class="line"><span class="string">    # Returns</span></span><br><span class="line"><span class="string">        A list of lists containing the annotations for each image in the generator.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    all_annotations = [[<span class="keyword">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(generator.num_classes())] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(generator))]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(generator)):</span><br><span class="line">        <span class="comment"># load the annotations</span></span><br><span class="line">        annotations = generator.load_annotations(i)</span><br><span class="line">        <span class="comment"># copy detections to all_annotations</span></span><br><span class="line">        <span class="keyword">for</span> label <span class="keyword">in</span> range(generator.num_classes()):</span><br><span class="line">            all_annotations[i][label] = annotations[annotations[:, <span class="number">4</span>] == label, :<span class="number">4</span>].copy()</span><br><span class="line">        print(<span class="string">'&#123;&#125;/&#123;&#125;'</span>.format(i + <span class="number">1</span>, len(generator)), end=<span class="string">'\r'</span>)</span><br><span class="line">    <span class="keyword">return</span> all_annotations</span><br></pre></td></tr></table></figure>
<p>得到标注数据之后，开始计算mAP指标，mAP指标由recall（判断正确的占所有正确类别的百分比），precision（判断正确的占预测结果中认为正确的百分比）。通过对这两个指数的积分来计算最终的mAP结果。</p>
<p>recall = TP/(TP + FN) 即真正预测对的，占所有正类的比例</p>
<p>precision = TP/(TP + FN) 即真正预测对的，占预测结果为正的比例</p>
<p>TP,FP,TN,FN这几个指标第一个字母表示预测是不是对的，第二个字母表示，预测的内容是什么（正类或者负类）。关于mAP的计算可以看： <a href="https://perper.site/2019/03/22/手撕mAP/" target="_blank" rel="noopener">这里</a></p>
<p>下面代码计算mAP的内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_overlap</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    a: (N, 4) ndarray of float</span></span><br><span class="line"><span class="string">    b: (K, 4) ndarray of float</span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    overlaps: (N, K) ndarray of overlap between boxes and query_boxes</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    area = (b[:, <span class="number">2</span>] - b[:, <span class="number">0</span>]) * (b[:, <span class="number">3</span>] - b[:, <span class="number">1</span>])</span><br><span class="line">    iw = np.minimum(np.expand_dims(a[:, <span class="number">2</span>], axis=<span class="number">1</span>), b[:, <span class="number">2</span>]) - np.maximum(np.expand_dims(a[:, <span class="number">0</span>], <span class="number">1</span>), b[:, <span class="number">0</span>])</span><br><span class="line">    ih = np.minimum(np.expand_dims(a[:, <span class="number">3</span>], axis=<span class="number">1</span>), b[:, <span class="number">3</span>]) - np.maximum(np.expand_dims(a[:, <span class="number">1</span>], <span class="number">1</span>), b[:, <span class="number">1</span>])</span><br><span class="line">    iw = np.maximum(iw, <span class="number">0</span>)</span><br><span class="line">    ih = np.maximum(ih, <span class="number">0</span>)</span><br><span class="line">    ua = np.expand_dims((a[:, <span class="number">2</span>] - a[:, <span class="number">0</span>]) * (a[:, <span class="number">3</span>] - a[:, <span class="number">1</span>]), axis=<span class="number">1</span>) + area - iw * ih</span><br><span class="line">    ua = np.maximum(ua, np.finfo(float).eps)</span><br><span class="line">    intersection = iw * ih</span><br><span class="line">    <span class="keyword">return</span> intersection / ua</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_compute_ap</span><span class="params">(recall, precision)</span>:</span></span><br><span class="line">    <span class="string">""" Compute the average precision, given the recall and precision curves.</span></span><br><span class="line"><span class="string">    Code originally from https://github.com/rbgirshick/py-faster-rcnn.</span></span><br><span class="line"><span class="string">    # Arguments</span></span><br><span class="line"><span class="string">        recall:    The recall curve (list).</span></span><br><span class="line"><span class="string">        precision: The precision curve (list).</span></span><br><span class="line"><span class="string">    # Returns</span></span><br><span class="line"><span class="string">        The average precision as computed in py-faster-rcnn.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># correct AP calculation</span></span><br><span class="line">    <span class="comment"># first append sentinel values at the end</span></span><br><span class="line">    mrec = np.concatenate(([<span class="number">0.</span>], recall, [<span class="number">1.</span>]))</span><br><span class="line">    mpre = np.concatenate(([<span class="number">0.</span>], precision, [<span class="number">0.</span>]))</span><br><span class="line">    <span class="comment"># compute the precision envelope</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(mpre.size - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        mpre[i - <span class="number">1</span>] = np.maximum(mpre[i - <span class="number">1</span>], mpre[i])</span><br><span class="line">    <span class="comment"># to calculate area under PR curve, look for points</span></span><br><span class="line">    <span class="comment"># where X axis (recall) changes value</span></span><br><span class="line">    i = np.where(mrec[<span class="number">1</span>:] != mrec[:<span class="number">-1</span>])[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># and sum (\Delta recall) * prec</span></span><br><span class="line">    ap = np.sum((mrec[i + <span class="number">1</span>] - mrec[i]) * mpre[i + <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> ap</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    generator,</span></span></span><br><span class="line"><span class="function"><span class="params">    retinanet,</span></span></span><br><span class="line"><span class="function"><span class="params">    iou_threshold=<span class="number">0.5</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    score_threshold=<span class="number">0.05</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    max_detections=<span class="number">100</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    save_path=None</span></span></span><br><span class="line"><span class="function"><span class="params">)</span>:</span></span><br><span class="line">    <span class="string">""" Evaluate a given dataset using a given retinanet.</span></span><br><span class="line"><span class="string">    # Arguments</span></span><br><span class="line"><span class="string">        generator       : The generator that represents the dataset to evaluate.</span></span><br><span class="line"><span class="string">        retinanet           : The retinanet to evaluate.</span></span><br><span class="line"><span class="string">        iou_threshold   : The threshold used to consider when a detection is positive or negative.</span></span><br><span class="line"><span class="string">        score_threshold : The score confidence threshold to use for detections.</span></span><br><span class="line"><span class="string">        max_detections  : The maximum number of detections to use per image.</span></span><br><span class="line"><span class="string">        save_path       : The path to save images with visualized detections to.</span></span><br><span class="line"><span class="string">    # Returns</span></span><br><span class="line"><span class="string">        A dict mapping class names to mAP scores.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># gather all detections and annotations</span></span><br><span class="line">    all_detections     = _get_detections(generator, retinanet, score_threshold=score_threshold, max_detections=max_detections, save_path=save_path)</span><br><span class="line">    all_annotations    = _get_annotations(generator)</span><br><span class="line">    average_precisions = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> label <span class="keyword">in</span> range(generator.num_classes()):</span><br><span class="line">        false_positives = np.zeros((<span class="number">0</span>,))</span><br><span class="line">        true_positives  = np.zeros((<span class="number">0</span>,))</span><br><span class="line">        scores          = np.zeros((<span class="number">0</span>,))</span><br><span class="line">        num_annotations = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(generator)):</span><br><span class="line">            detections           = all_detections[i][label]</span><br><span class="line">            annotations          = all_annotations[i][label]</span><br><span class="line">            num_annotations     += annotations.shape[<span class="number">0</span>]</span><br><span class="line">            detected_annotations = []</span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> detections:</span><br><span class="line">                scores = np.append(scores, d[<span class="number">4</span>])</span><br><span class="line">                <span class="keyword">if</span> annotations.shape[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 表示当前图片没有标注，因此你的标注结果都是错误的</span></span><br><span class="line">                    false_positives = np.append(false_positives, <span class="number">1</span>)</span><br><span class="line">                    true_positives  = np.append(true_positives, <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                overlaps            = compute_overlap(np.expand_dims(d, axis=<span class="number">0</span>), annotations)</span><br><span class="line">                assigned_annotation = np.argmax(overlaps, axis=<span class="number">1</span>) <span class="comment"># 对每个框找出覆盖最多的一个标注,返回标注所在的下标</span></span><br><span class="line">                max_overlap         = overlaps[<span class="number">0</span>, assigned_annotation]</span><br><span class="line">                <span class="keyword">if</span> max_overlap &gt;= iou_threshold <span class="keyword">and</span> assigned_annotation <span class="keyword">not</span> <span class="keyword">in</span> detected_annotations:</span><br><span class="line">                    false_positives = np.append(false_positives, <span class="number">0</span>)</span><br><span class="line">                    true_positives  = np.append(true_positives, <span class="number">1</span>)</span><br><span class="line">                    detected_annotations.append(assigned_annotation)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    false_positives = np.append(false_positives, <span class="number">1</span>)</span><br><span class="line">                    true_positives  = np.append(true_positives, <span class="number">0</span>)</span><br><span class="line">        <span class="comment"># no annotations -&gt; AP for this class is 0 (is this correct?)</span></span><br><span class="line">        <span class="keyword">if</span> num_annotations == <span class="number">0</span>:</span><br><span class="line">            average_precisions[label] = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># sort by score</span></span><br><span class="line">        indices         = np.argsort(-scores)</span><br><span class="line">        false_positives = false_positives[indices]</span><br><span class="line">        true_positives  = true_positives[indices]</span><br><span class="line">        <span class="comment"># compute false positives and true positives</span></span><br><span class="line">        <span class="comment"># 得到一个累加的数组的结果</span></span><br><span class="line">        false_positives = np.cumsum(false_positives)</span><br><span class="line">        true_positives  = np.cumsum(true_positives)</span><br><span class="line">        <span class="comment"># compute recall and precision</span></span><br><span class="line">        recall    = true_positives / num_annotations</span><br><span class="line">        precision = true_positives / np.maximum(true_positives + false_positives, np.finfo(np.float64).eps)</span><br><span class="line">        <span class="comment"># compute average precision</span></span><br><span class="line">        average_precision  = _compute_ap(recall, precision)</span><br><span class="line">        average_precisions[label] = average_precision, num_annotations</span><br><span class="line">    print(<span class="string">'\nmAP:'</span>)</span><br><span class="line">    <span class="keyword">for</span> label <span class="keyword">in</span> range(generator.num_classes()):</span><br><span class="line">        label_name = generator.label_to_name(label)</span><br><span class="line">        print(<span class="string">'&#123;&#125;: &#123;&#125;'</span>.format(label_name, average_precisions[label][<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">return</span> average_precisions</span><br></pre></td></tr></table></figure>
<p>几个函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.argsort(scores) <span class="comment"># 根据从小到大返回元素的下标，小的在前</span></span><br><span class="line">np.argmax(overlaps,axis = <span class="number">1</span>) <span class="comment"># 找出每一列的最大值，返回他的下标</span></span><br><span class="line">np.cumsum(nums) <span class="comment"># 返回一个数组，数组中内容从头开始累加到当前位置</span></span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过上面几个流程我们大致梳理了一下一个网络的搭建，数据的传递，loss的计算，以及最后的验证的过程。</p>
<p>总结一下：</p>
<ol>
<li>构造dataloader，在这里头完成数据的读取，增强等工作</li>
<li>完成网络的搭建</li>
<li>完成网络的训练</li>
<li>完成验证集的测试工作</li>
</ol>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>WenHui Zhou</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/08/16/深度学习代码的框架/">https://wenhui-zhou.github.io/2019/08/16/深度学习代码的框架/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>| 本博客所有文章除特别声明外，均采用 <a href="&quot;http://creativecommons.org/licenses/by-nc-sa/3.0/cn/&quot;" rel="&quot;external" nofollow&quot;="" target="&quot;_blank&quot;">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！ </li></ul></div><br><div class="tags"><a href="/tags/深度学习/">深度学习</a></div><div class="post-nav"><a class="pre" href="/2019/08/22/堆排序，python实现/">堆排序，python实现</a><a class="next" href="/2019/07/24/normalization/">normalization</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'civq9nKD49NpRALooR9Llqmf-gzGzoHsz',
  appKey:'JggO9HaSi1Lfx17nt16oDfsI',
  placeholder:'Shall we talk',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/3D重建/">3D重建</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NLP/">NLP</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tensorflow/">Tensorflow</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/effective-cpp/">effective cpp</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/super-resolution/">super resolution</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tool/">tool</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/xigua/">xigua</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/建站/">建站</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/手撕系列/">手撕系列</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/推荐系统/">推荐系统</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/模型评价/">模型评价</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/比赛/">比赛</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法扫盲/">算法扫盲</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程/">编程</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文复现/">论文复现</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文阅读/">论文阅读</a><span class="category-list-count">22</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/论文阅读/3D重建/">3D重建</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/项目/">项目</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/项目总结/">项目总结</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/项目总结/论文阅读/">论文阅读</a><span class="category-list-count">3</span></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/c/" style="font-size: 15px;">c++</a> <a href="/tags/深度学习/" style="font-size: 15px;">深度学习</a> <a href="/tags/leetcode/" style="font-size: 15px;">leetcode</a> <a href="/tags/3D重建/" style="font-size: 15px;">3D重建</a> <a href="/tags/项目总结/" style="font-size: 15px;">项目总结</a> <a href="/tags/论文阅读/" style="font-size: 15px;">论文阅读</a> <a href="/tags/tool/" style="font-size: 15px;">tool</a> <a href="/tags/netStation/" style="font-size: 15px;">netStation</a> <a href="/tags/SR/" style="font-size: 15px;">SR</a> <a href="/tags/dialog/" style="font-size: 15px;">dialog</a> <a href="/tags/interview/" style="font-size: 15px;">interview</a> <a href="/tags/tip/" style="font-size: 15px;">tip</a> <a href="/tags/Tensorflow/" style="font-size: 15px;">Tensorflow</a> <a href="/tags/learning-cpp/" style="font-size: 15px;">learning cpp</a> <a href="/tags/—-leetcode/" style="font-size: 15px;">— leetcode</a> <a href="/tags/tips/" style="font-size: 15px;">tips</a> <a href="/tags/职业规划/" style="font-size: 15px;">职业规划</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/超分辨率/" style="font-size: 15px;">超分辨率</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/12/02/NLP实践-文本分类任务/">NLP实践 文本分类任务</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/02/图像的去噪/">图像的去噪</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/01/NLP模型finetune-GPT到Bert（三）/">NLP模型finetune:GPT到Bert（三）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/29/NLP之transformer（二）/">NLP之transformer（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/29/NLP之Word2Vec（一）/">NLP之Word2Vec（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/26/effective-cpp-九-杂项讨论/">effective cpp(九)杂项讨论</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/25/effective-cpp-八-定制new和delete/">effective cpp(八)定制new和delete</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/19/effective-cpp-七-模板与范型编程/">effective cpp(七) 模板与范型编程</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/16/effective-cpp-六-继承与面向对象设计/">effective cpp(六) 继承与面向对象设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/10/effective-cpp-五-实现/">effective cpp(五) 实现</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/WenHui-Zhou" title="GITHUB" target="_blank">GITHUB</a><ul></ul><a href="http://www.google.com/" title="GOOGLE" target="_blank">GOOGLE</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">WenHuiZhou.</a> 访问人数:<span id="busuanzi_value_site_uv"></span> 
访问量:<span id="busuanzi_value_site_pv"></span></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> </div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
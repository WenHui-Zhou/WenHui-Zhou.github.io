<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="cheer up"><meta name="baidu-site-verification" content="9pSIuwCbvi"><meta name="google-site-verification" content="YzcCTjF6VoVlNAtL37_S4vFjzFwYTAFZzD51Il2IGKY"><title>effective cpp(五) 实现 | WenHuiZhou</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">effective cpp(五) 实现</h1><a id="logo" href="/.">WenHuiZhou</a><p class="description">perper（打起精神！）</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">effective cpp(五) 实现</h1><div class="post-meta">Nov 10, 2019<span> | </span><span class="category"><a href="/categories/effective-cpp/">effective cpp</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" href="/2019/11/10/effective-cpp-五-实现/#vcomment"><span class="valine-comment-count" data-xid="/2019/11/10/effective-cpp-五-实现/"></span><span> 条评论</span></a><div class="post-content"><p>2019/11/10，effective cpp第五章 实现</p>
<p>cpp在实现上存在着很多高效率，代码优化的细节。</p>
<ul>
<li>26 条款：经可能延后变量定义式的出现时间</li>
<li>27 条款：尽量少做转型动作</li>
<li>28 条款：避免返回handles指向对象内部成分</li>
<li>29 条款：为异常安全而努力是值得的</li>
<li>30 条款：透彻了解inlining 的里里外外</li>
<li>31 条款：将文件间的编译依存关系降至最低</li>
</ul>
<a id="more"></a>
<h3 id="26-条款：经可能延后变量定义式的出现时间"><a href="#26-条款：经可能延后变量定义式的出现时间" class="headerlink" title="26 条款：经可能延后变量定义式的出现时间"></a>26 条款：经可能延后变量定义式的出现时间</h3><p>我们定义一个变量需要承担它的构造成本以及析构成本，如果我们在程序中，由于一些判断条件未能使用到这些变量，那么将造成大量的时间浪费，于是我们应当尽量的延后变量的定义。</p>
<p>第二个优化的地方在于在定义变量的时候，通过调用构造函数来初始化变量，而不是通过赋值的方式。（通过赋值的方式将会浪费一次系统默认的赋值时间）</p>
<p>第三个优化的地方，如果我们需要在一个循环中使用变量的话，<strong>我们应该在循环的内部定义变量</strong>，除非析构与构造的成本比较高，且你的代码对效率高度敏感。</p>
<p><strong>总结</strong></p>
<ul>
<li>尽可能延后变量定义式的出现，这样做可以增加程序的清晰度，并改善程序的效率。</li>
</ul>
<h3 id="27-条款：尽量少做转型动作"><a href="#27-条款：尽量少做转型动作" class="headerlink" title="27 条款：尽量少做转型动作"></a>27 条款：尽量少做转型动作</h3><p>首先是结论：<strong>优良的C++代码很少使用转型</strong></p>
<p>C++的设计目标之一就是保证类型错误绝不可能发生，尽量保证任何转型动作尽可能少的发生。转型动作破坏了类型系统，导致一些很隐晦的错误。C++提供的转型变换如下：</p>
<ul>
<li><p><code>const_cast&lt;T&gt; (expression)</code>，通常用于对象的常量性移除，将常量去除</p>
</li>
<li><p><code>dynamic_cast&lt;T&gt;(expression)</code>，主要用于执行“安全向下转型”，用来决定某对象是否归属继承体系中的某个类型。可能耗费比较大的运行成本。</p>
</li>
<li><code>reinterpret_cast&lt;T&gt;(expression)</code>，执行低级转型，例如将point to int 转成int。</li>
<li><code>static_cast&lt;T&gt;(expression)</code>，用来强迫执行隐式转型，将int转成double等等。</li>
</ul>
<p>旧式的转型：</p>
<ul>
<li><code>(T)expression</code></li>
<li><code>T(expression)</code></li>
</ul>
<p>旧式的两种写法功能相同，建议使新式的转型方法，因为他们在代码上容易辨认，且各个转型动作目标比较窄，容易排查错误,例如只有const_cast方法才能实现对象的常量移除。</p>
<p>关于<code>dynamic_cast</code>方法，例如我有有些时候，希望在子类函数调用的时候先调用父类的函数，会写出下面的代码（错误的）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">special</span>:</span> <span class="keyword">public</span> window&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;window&gt;(*<span class="keyword">this</span>).onResize();</span><br><span class="line">  	...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上诉代码将this转为window的指针，但是他调用的并不是当前对象上的函数，<strong>转型动作将产生一个this对象的base class的成分的一个副本</strong>。因此window上的onsize操作只是在一个副本上执行操作的，并不会改变this对象的内容。解决的方法是直接调用父类的onsize方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">special</span>:</span> <span class="keyword">public</span> window&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    window::onResize();</span><br><span class="line">  	...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>dynamic_cast</code>的场景通常说，我们手上只有一个base class的指针，但是想希望通过它来执行子类的一些操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;tr1::<span class="built_in">shared_ptr</span>&lt;window&gt;&gt; vpw;</span><br><span class="line">vpw winptr;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">for</span>(vpw::iterator iter=winptr.begin();iter!=winptr.end();++iter)&#123;</span><br><span class="line">    <span class="keyword">if</span>(special* psw=<span class="keyword">dynamic_cast</span>&lt;special*&gt;(iter-&gt;get()))</span><br><span class="line">      psw-&gt;blink();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码效率比较低，而且令人担心，因此最后直接用子类的容器存储指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;tr1::<span class="built_in">shared_ptr</span>&lt;special&gt;&gt; vpsw;</span><br><span class="line">vpsw winptr;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(vpsw::iterator iter = winptr.begin();iter!=winptr.end();++iter)&#123;</span><br><span class="line">  (*iter)-&gt;blink();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是上面的代码童谣失去了指向所有可能子类的可能，<strong>一个可行的解决方案就是为在base class提供一个缺省实现的blink函数声明。或者是直接用上述方式写出子类</strong></p>
<p>不论是哪一种写法：使用类型安全容器，或将virtual函数往继承体系上方移动，都是一个替代dynamic_cast 的可行方案。</p>
<p>绝对需要避免的一种写法是连串使用多个dynamic_cast，这种代码将又大又慢，同时十分的不安全。</p>
<p><strong>总结</strong></p>
<ul>
<li>如果可以，尽可能避免转型，特别在注重效率的代码中避免使用<code>dynamic_cast</code></li>
<li>如果转型是必要的，试着将它隐藏呀某个函数背后，供客户调用</li>
<li>宁可使用C++新式的转型，因为容易辨认，同时便于排查错误。</li>
</ul>
<h3 id="28-条款：避免返回handles指向对象内部成分"><a href="#28-条款：避免返回handles指向对象内部成分" class="headerlink" title="28 条款：避免返回handles指向对象内部成分"></a>28 条款：避免返回handles指向对象内部成分</h3><p><strong>handles指的是诸如reference，指针，迭代器这种用来取得某个对象的变量，我们应当避免直接返回指向对象内部数据或函数的handle出现。</strong></p>
<p>如下，我们打算实现一个矩阵类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">point</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    point(<span class="keyword">int</span> x,<span class="keyword">int</span> y);</span><br><span class="line">  ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义角</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RectData</span>&#123;</span></span><br><span class="line">  point ulhc;</span><br><span class="line">  point lrhc;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义矩阵</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>&#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    tr1::<span class="built_in">shared_ptr</span>&lt;RectData&gt; pData;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">point&amp; <span class="title">upper</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> pData-&gt;ulhc;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>upper函数取得矩阵左上角的点，返回一个引用，这个引用指向了矩阵内部的点，就会引发一个矛盾，我们使用一个const函数，但是返回的值是private数据，且可以被修改。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Rectangle <span class="title">rec</span><span class="params">(coord1,coord2)</span></span>;</span><br><span class="line">rec.upper().setX(<span class="number">50</span>); <span class="comment">//被修改</span></span><br></pre></td></tr></table></figure>
<p>从从上面我们可以得出两条结论，</p>
<ul>
<li>第一条，成员变量的封装性只能等于返回其reference的级别，即引用的级别决定了封装性。</li>
<li>第二条，如果const成员函数传出一个reference，后者所指的数据与对象自身有关联，而他又被存储与对象之外，那么这个函数的调用者可以修改那笔数据。</li>
</ul>
<p>一个好的解决办法就是在函数调用的时候，将返回值的内容设置成const：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> pData-&gt;ulhc;&#125;</span><br></pre></td></tr></table></figure>
<p>但是即使如此，如果直接返回代表对象内部数据的handle的话，有可能这个handle的生存周期比对象本身的生存周期要长，那么将导致空悬指针的发生（dangling handles）。</p>
<p>因此：<strong>尽量避免将对象内部的handles传出去。</strong></p>
<p><strong>总结</strong></p>
<ul>
<li>避免返回handles指向对象内部，遵守这个条款可以增加封装性，使得const更加像一个const，并避免虚调handles的发生。</li>
</ul>
<h3 id="29-条款：为异常安全而努力是值得的"><a href="#29-条款：为异常安全而努力是值得的" class="headerlink" title="29 条款：为异常安全而努力是值得的"></a>29 条款：为异常安全而努力是值得的</h3><p>对于一个异常安全性的函数来说，他通常有两个条件：</p>
<ul>
<li><strong>不泄漏任何资源</strong></li>
<li><strong>不允许数据败坏</strong>：即出现类似空指针，指向已经销毁的对象这种情况</li>
</ul>
<p>第一种情况可以通过资源管理类来完美的解决，下面专门来解决第二种情况</p>
<p><strong>异常安全函数</strong>提供以下三种程度的保证：</p>
<ul>
<li><strong>基本承诺：</strong>如果异常被抛出，程序内的任何事物仍然保持在有效状态下</li>
<li><strong>强烈承诺：</strong>如果异常被抛出，程序状态不改变，如果函数成功就完全成功，如果函数失败，就恢复到调用函数之前的状态。</li>
<li><strong>不抛掷保证：</strong>承诺不抛出异常，他们总能完成承诺的功能，例如一些内置类型等。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>上面的函数带有指定的空白异常，也就是说上述函数抛出异常的话，将会产生很严重的后果，但是该函数并不能提供任何异常安全的保证，异常安全的保护正完全由实现来决定。</p>
<p>对于异常安全来说，保证不抛出异常基本难以实现。基本上能够实现强烈承诺或基本承诺就可以满足需求了。</p>
<p>实现强烈承诺，即出现异常情况对象的状态不发生改变，有一个策略称为：<strong>copy and swap</strong>，即为打算修改的对象提供一份副本，并在那个副本上做一切必要的修改，如果出现异常，则原对象未发生改变，如果正常则将副本和原对象进行交换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> pretty::changeBackground(istream&amp; imgSrc)&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">  <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;    <span class="comment">// 获得mutex的副本</span></span><br><span class="line">  tr1::<span class="built_in">shared_ptr</span>&lt;PMImpl&gt; pNew(<span class="keyword">new</span> PMImpl(*pImpl)); </span><br><span class="line">  pNew-&gt;bgImage.reset(<span class="keyword">new</span> Image(imgSrc));</span><br><span class="line">  ++pNew-&gt;imageChanges;</span><br><span class="line">  swap(pImpl,pNew);  <span class="comment">// 释放mutex</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看出来，对函数的异常保证将花费大量的资源，因此如果强烈保证不能满足的情况下，你就应该转向基本满足的情况。</p>
<p>对于一个对象来说，它的异常保证的级别取决于最差的一个异常保证函数。</p>
<p><strong>总结</strong></p>
<ul>
<li>异常安全函数即使发生异常也不会泄露资源或允许任何数据结构败坏，这样的函数区分为三种可能的保证：基本型，强烈型，不抛异常型</li>
<li>强烈保证往往能够以copy and swap实现出来</li>
<li>函数提供的异常安全保证，通常最高值等于其所调用的各个函数的异常安全保证种最弱的</li>
</ul>
<h3 id="30-条款：透彻了解inlining-的里里外外"><a href="#30-条款：透彻了解inlining-的里里外外" class="headerlink" title="30 条款：透彻了解inlining 的里里外外"></a>30 条款：透彻了解inlining 的里里外外</h3><p>inline函数，使用起来像函数，调用他们又不用蒙受额外的函数调用所导致的开销，编译器的最优化机制通常被设计成用来浓缩那些<strong>不含函数调用</strong>的代码，因此inline函数也会得到编译器在当前语境下的最优化处理。</p>
<p>但是过度使用inline同样会导致很多问题，首先是使得程序的目标码过大，导致一些效率上的损失。</p>
<p><strong>总之，如果inline函数的本体很小，编译器对函数本体所产出的代码可能比函数调用所产出的代码要小，这种情况将函数inlining确实可以导致较小的目标码和较高的指令高速缓存装置的击中率。</strong></p>
<p><strong>inline函数的做法</strong>：隐喻的做法是将函数定义在class内，自动就完成了inline的操作。明确声明的做法则是在函数前面加上inline关键字。</p>
<p><strong>inline函数通常一定被放置于头文件内，因为大多数的生成环境在编译过程中进行inline，需要知道函数本体长什么样子。</strong></p>
<p>模版类templates也通常被置于头文件内，因为它一旦被使用，编译器为了将它具体化，需要知道它长什么样子。但是templates与inline没有直接的联系，如果你觉得该templates内的函数都比较简单，可以进行inline的话，才会去定义为inline。</p>
<p><strong>inline是一个申请，编译器可以拒绝</strong></p>
<p>也就是说，一个函数最终实现方式是否是inline，取决于编译器是否同意该函数满足inline的条件。</p>
<p>例如大部分过于复杂（含循环，递归等）的函数，virtual声明的函数，通常都会被定义为outline函数。</p>
<p>有些编译器有意愿inlining某个函数，但是也可能为函数生成一个函数本体。<strong>例如程序要取得某个inline函数的地址，编译器通常必须为此函数生成一个outline函数本体。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;...&#125; <span class="comment">//假设编译器有意愿inline对f的调用</span></span><br><span class="line"><span class="keyword">void</span> (*f)()  = f;</span><br><span class="line">f(); <span class="comment">// 调用inline</span></span><br><span class="line">pf(); <span class="comment">// 调用outline的本体</span></span><br></pre></td></tr></table></figure>
<p>有时候，编译器会为析构函数和构造函数生成一个函数的副本，这样他们就可以获得指针指向那些需要指针的函数，但是这样一来，导致了析构函数和构造函数的赋值过程。</p>
<p>实际上析构函数，构造函数往往是inline糟糕的候选人，因为C++在创建对象的时候，将构造对象，析构对象，异常处理等一些操作隐藏在析构函数和构造函数内部，因此函数内部存在着很多的对象。但是对这些对象的副本往往会造成很大的资源消耗。</p>
<p><strong>因此，是否将构造函数和析构函数inline化，是一个慎重的考虑。</strong></p>
<p><strong>inline函数修改后必须重新编译</strong></p>
<p>此外，inline函数还存在一个问题。当我们对inline函数进行修改的时候，原来函数的本体因为已经编译进程序的内部了，无法通过函数的链接步骤实现修改，而是需要对整个程序进行重新编译。</p>
<p><strong>总结</strong></p>
<ul>
<li>将大多数inlining限制在小型、被频繁调用的函数身上，这可使得日后的调试过程和二进制升级更加容易，也可使潜在的代码膨胀问题最小化，使得程序速度提升最大化。</li>
<li>不要滥用inline，不用只因为function templates出现在头文件中就将他们声明为inline，因为很多时候，这些函数不符合inline标准，编译器还是会为他们生成outline版本</li>
</ul>
<h3 id="31-条款：将文件间的编译依存关系降至最低"><a href="#31-条款：将文件间的编译依存关系降至最低" class="headerlink" title="31 条款：将文件间的编译依存关系降至最低"></a>31 条款：将文件间的编译依存关系降至最低</h3><p>文件之间的依存关系越是复杂将会导致函数之间的耦合度越高，对修改代码带来不便。</p>
<p>例如你仅仅对class进行轻微的修改，但是这将导致所有用到这个文件的程序都需要进行重新编译，这一连串的编译依存关系将导致难以形容的灾难。</p>
<p>例如下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"data.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"address.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,<span class="keyword">const</span> Date&amp; birthday);</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">birthday</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> thename;</span><br><span class="line">    Data theData;</span><br><span class="line">    address add;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的类别的私有变量中，string，Data需要用到其他的头文件来创建（实现细则），这些头文件任意一个被修改后都将导致Person class重新编译。</p>
<p>针对这种形式，我们可以这样做：</p>
<p><strong>把person分割为两个classes，一个只提供接口，另一个负责实现该接口。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>;</span>   <span class="comment">// 类的前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,<span class="keyword">const</span> Date&amp; birthday);</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">birthday</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    str1::<span class="built_in">shared_ptr</span>&lt;PersonImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类PersonImpl为person类的实现，这样的话，修改Data类就不需要对Person函数进行重新编译，将person与其他类进行分离。</p>
<p>这个分离的关键在于：<strong>使用声明的依存性</strong>来代替<strong>定义的依存性</strong>，尽量让头文件自我满足，万一无法做到，那么让它和其他文件内的声明式相依（而不是定义式）。</p>
<p>下面一些准则都是这个原则下完成的：</p>
<ul>
<li>如果使用object references 或objects pointers可以完成任务，就不要使用object，即使用声明式来代替定义式。</li>
<li><p>尽量以class声明式代替class定义式。</p>
</li>
<li><p><strong>为声明式和定义式提供不同的头文件</strong>，为一个文件提供函数的声明，而不是而代替提供class的定义式，这样可将文件见的编译依存关系去掉。因此我们需要定义两个文件，一个是声明式，另一个是定义式。</p>
</li>
</ul>
<p>上面这个实现使得代码编，让Person变成一个handle class。</p>
<p><strong>抽象基类</strong></p>
<p>通过制作抽象类的方式，也可以实现这种操作。通过定义抽象类函数接口，创建不同类型的的派生类对象。</p>
<p>handle classes 和interface class解除了接口和实现之间的耦合关系，从而减低了文件间的编译依存关系。但是也在某种程度上使得每个对象超额付出若干的时间以及空间的成本。</p>
<p><strong>总结</strong></p>
<ul>
<li>支持<strong>编译依存最小化</strong>的一般构想是：相依与声明式，不要相依于定义式，基于此的构想的两个手段是 handle classes，interface classes。</li>
<li>程序库头文件应该以完全且仅有的声明式的形式存在，这种做法不论是否涉及templates都适用。</li>
</ul>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>WenHui Zhou</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/11/10/effective-cpp-五-实现/">https://wenhui-zhou.github.io/2019/11/10/effective-cpp-五-实现/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>| 本博客所有文章除特别声明外，均采用 <a href="&quot;http://creativecommons.org/licenses/by-nc-sa/3.0/cn/&quot;" rel="&quot;external" nofollow&quot;="" target="&quot;_blank&quot;">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！ </li></ul></div><br><div class="tags"></div><div class="post-nav"><a class="pre" href="/2019/11/16/effective-cpp-六-继承与面向对象设计/">effective cpp(六) 继承与面向对象设计</a><a class="next" href="/2019/11/09/effective-cpp-四-设计与声明/">effective cpp(四) 设计与声明</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'civq9nKD49NpRALooR9Llqmf-gzGzoHsz',
  appKey:'JggO9HaSi1Lfx17nt16oDfsI',
  placeholder:'Shall we talk',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/3D重建/">3D重建</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NLP/">NLP</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tensorflow/">Tensorflow</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/effective-cpp/">effective cpp</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/super-resolution/">super resolution</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tool/">tool</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/xigua/">xigua</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/建站/">建站</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/手撕系列/">手撕系列</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/推荐系统/">推荐系统</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/模型评价/">模型评价</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/比赛/">比赛</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法扫盲/">算法扫盲</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程/">编程</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文复现/">论文复现</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文阅读/">论文阅读</a><span class="category-list-count">22</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/论文阅读/3D重建/">3D重建</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/项目/">项目</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/项目总结/">项目总结</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/项目总结/论文阅读/">论文阅读</a><span class="category-list-count">3</span></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/tool/" style="font-size: 15px;">tool</a> <a href="/tags/dialog/" style="font-size: 15px;">dialog</a> <a href="/tags/leetcode/" style="font-size: 15px;">leetcode</a> <a href="/tags/c/" style="font-size: 15px;">c++</a> <a href="/tags/项目总结/" style="font-size: 15px;">项目总结</a> <a href="/tags/3D重建/" style="font-size: 15px;">3D重建</a> <a href="/tags/论文阅读/" style="font-size: 15px;">论文阅读</a> <a href="/tags/netStation/" style="font-size: 15px;">netStation</a> <a href="/tags/SR/" style="font-size: 15px;">SR</a> <a href="/tags/interview/" style="font-size: 15px;">interview</a> <a href="/tags/深度学习/" style="font-size: 15px;">深度学习</a> <a href="/tags/tip/" style="font-size: 15px;">tip</a> <a href="/tags/Tensorflow/" style="font-size: 15px;">Tensorflow</a> <a href="/tags/NLP/" style="font-size: 15px;">NLP</a> <a href="/tags/learning-cpp/" style="font-size: 15px;">learning cpp</a> <a href="/tags/职业规划/" style="font-size: 15px;">职业规划</a> <a href="/tags/tips/" style="font-size: 15px;">tips</a> <a href="/tags/—-leetcode/" style="font-size: 15px;">— leetcode</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/超分辨率/" style="font-size: 15px;">超分辨率</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/12/29/GPT/">GPT</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/29/finetune-诗句生成/">finetune-诗句生成</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/19/bert的一些思考/">bert的一些思考</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/09/pytorch-重点回顾/">pytorch 重点回顾</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/05/NLP实践-基于注意力机制的文本匹配/">NLP实践 基于注意力机制的文本匹配</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/02/NLP实践-文本分类任务/">NLP实践 文本分类任务</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/02/图像的去噪/">图像的去噪</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/01/NLP模型finetune-GPT到Bert（三）/">NLP模型finetune:GPT到Bert（三）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/29/NLP之transformer（二）/">NLP之transformer（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/29/NLP之Word2Vec（一）/">NLP之Word2Vec（一）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/WenHui-Zhou" title="GITHUB" target="_blank">GITHUB</a><ul></ul><a href="http://www.google.com/" title="GOOGLE" target="_blank">GOOGLE</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">WenHuiZhou.</a> 访问人数:<span id="busuanzi_value_site_uv"></span> 
访问量:<span id="busuanzi_value_site_pv"></span></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> </div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="cheer up"><meta name="baidu-site-verification" content="9pSIuwCbvi"><meta name="google-site-verification" content="YzcCTjF6VoVlNAtL37_S4vFjzFwYTAFZzD51Il2IGKY"><title>effective cpp(三) 资源管理 | WenHuiZhou</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">effective cpp(三) 资源管理</h1><a id="logo" href="/.">WenHuiZhou</a><p class="description">perper（打起精神！）</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">effective cpp(三) 资源管理</h1><div class="post-meta">Nov 5, 2019<span> | </span><span class="category"><a href="/categories/effective-cpp/">effective cpp</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" href="/2019/11/05/effective-cpp-三-资源管理/#vcomment"><span class="valine-comment-count" data-xid="/2019/11/05/effective-cpp-三-资源管理/"></span><span> 条评论</span></a><div class="post-content"><p>2019/11/05 effective cpp 第三章</p>
<p>CPP程序运行中，将会动态申请内存、文件描述器、互斥锁等一些重要的资源，必须及时归还系统。</p>
<ul>
<li>13 条款：以对象管理资源</li>
<li>14 条款：</li>
</ul>
<a id="more"></a>
<h3 id="13-条款：以对象管理资源"><a href="#13-条款：以对象管理资源" class="headerlink" title="13 条款：以对象管理资源"></a>13 条款：以对象管理资源</h3><p>若一个基类通过一个工厂函数，得到若干个子类的地址指针，在使用完这些子类之后，需要将他们回收，下面写一个回收的函数对他们进行回收：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Invest* ptr = create();</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述的代码可以完美的运行，但是在一些特定的情况下，如果程序在delete之前中途退出了，这将导致分配的资源无法得到释放。一个比较可靠的做法是：</p>
<p><strong>把资源放进对象内，当需要销毁资源的时候，使用C++的析构函数自动调用机制，确保资源的释放。</strong></p>
<p><strong>auto_ptr</strong></p>
<p>许多资源被动态分配到heap内，被用于函数内。它们应该在控制流离开那个函数的时候被释放，auto_ptr智能指针就是为此设计的一个<strong>类指针对象</strong>，由析构函数对其所指对象调用delete。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">auto_ptr</span>&lt;invest&gt; Ptr(create());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述的做法体现了两条回收资源的设计：</p>
<ul>
<li><strong>获得资源后，立即放入管理对象内：</strong>资源对象创建的最佳时期就是资源获取的时机。最好的方式是获取资源的同一个语句内使用它初始化某个管理对象</li>
<li><strong>管理对象运用析构函数确保资源被释放：</strong>不论控制流如何离开区块，一旦对象被销毁，析构函数自动销毁所获得的资源。</li>
</ul>
<p>auto_ptr对象离开它的有效范围之后，就将自动销毁分配的资源。但是有一个缺陷，它不允许多个auto_ptr指向同一块区域，这样会造成一个对象被多次的删除。为了防止这个问题，auto_ptr中有一个特性，如果通过拷贝函数复制他们，之前的指针将会变成null，复制后的指针得到资源的唯一拥有权。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>&lt;invest&gt; ptr1(create());</span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;invest&gt; ptr2(ptr1);  <span class="comment">// 此时ptr1变成null</span></span><br></pre></td></tr></table></figure>
<p>auto_ptr的替代方案使用<code>tr1::shared_ptr</code>，这个对象类将持续追踪共有多少指针指向某个资源，但是在环形引用时无法打破。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; </span><br><span class="line"> tr1::<span class="built_in">shared_ptr</span>&lt;invest&gt; ptr(create());</span><br><span class="line"> tr1::<span class="built_in">shared_ptr</span>&lt;invest&gt; ptr1(ptr); <span class="comment">// ptr，ptr1指向同一个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述例子告诉我们，当我们手动释放资源的时候，容易发生错误，罐装式的资源管理类如auto_ptr, shared_ptr可以比较好的准守这条规则。</p>
<p><strong>总结</strong></p>
<ul>
<li>防止资源浪费，使用RAII对象，在他们的构造函数中获得资源，在析构函数中释放资源。</li>
<li>使用RAII中的tr1::shared_ptr，auto_ptr是两个比较好的选择，shared_ptr具有比较正常的copy。</li>
</ul>
<h3 id="14-条款：在资源管理类中小心copying行为"><a href="#14-条款：在资源管理类中小心copying行为" class="headerlink" title="14 条款：在资源管理类中小心copying行为"></a>14 条款：在资源管理类中小心copying行为</h3><p>通常使用auto_ptr,shared_ptr作为资源管理类，但是有些资源并非在heap-based，不实用使用上述的两种资源管理类，因此需要建立自己的资源管理类。</p>
<p>自己定义的资源管理类通常在构造函数的部分申请得到资源，在析构函数中释放资源，这种类型的资源包括了互斥锁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>：</span><br><span class="line">    explicit Lock(Mutex* pm):mutexPtr(pm)&#123;  // 在初始化资源类的时候，初始化资源</span><br><span class="line">      lock(mutexPtr);</span><br><span class="line">  &#125;</span><br><span class="line">  ~Lock()&#123;unlock(mutexPtr);&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">   Mutex* mutexPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，对于资源管理类来说，如果对象被复制，我们需要处理对象的复制问题。可以让它继承UnCopyable对象，禁止对象的复制。或者使用shared_ptr的方法，<strong>使用引用计数法</strong>，使用shared_ptr来定义指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;Mutex&gt; mutexPtr;</span><br></pre></td></tr></table></figure>
<p>这时候就可以不用定义虚析构函数了，当指针被回收的时候，资源就会被回收。</p>
<p><strong>转移底层的资源拥有权</strong></p>
<p>使用类似于auto_ptr的做法，copy的时候，保证资源的唯一性。</p>
<p><strong>总结</strong></p>
<ul>
<li>复制RAII对象（资源管理对象）需要一并复制它所管理的资源，资源的copying行为决定了RAII对象的copying行为。</li>
<li>普遍常见的RAII copying行为通常为：抑制copying，使用引用计数法，转移底层资源的拥有权。</li>
</ul>
<h3 id="15-条款：在资源管理类中提供对原始资源的访问"><a href="#15-条款：在资源管理类中提供对原始资源的访问" class="headerlink" title="15 条款：在资源管理类中提供对原始资源的访问"></a>15 条款：在资源管理类中提供对原始资源的访问</h3><p>资源管理类通常是我们设计来保证资源的正常申请和销毁的，但是有些情况是，我们调用一些函数的时候需要直接访问内部的资源（例如一些指针类）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1::<span class="built_in">shared_ptr</span>&lt;Invest&gt; pInt(create()); <span class="comment">// pInt是一个资源类对象</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daysHeld</span><span class="params">(<span class="keyword">const</span> Invest* pi)</span></span>; <span class="comment">// pi是一个invest* 对象</span></span><br></pre></td></tr></table></figure>
<p>当我们要调用daysHeld()函数的时候，传入的参数如果为pInt的话会发生错误，因为pInt是一个资源类对象，因此我们需要从这个资源类对象中取出其中的指针资源。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daysHeld(pInt.get());</span><br></pre></td></tr></table></figure>
<p>shared_ptr,auto_ptr继承了原是指针中的<code>-&gt;,*</code>操作，并且可以通过get函数得到资源的直接访问。</p>
<p>当我们选择自己实现资源管理类的时候，我们也需要实现一个get函数，实现显示的函数变换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Font</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    explicit Font(Fhandle fh):f(fh)&#123;&#125;</span><br><span class="line">    ~Font()&#123;release(fh);&#125;</span><br><span class="line">    <span class="function">FHandle <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> fh;&#125; <span class="comment">// 实现直接获取资源的函数</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    FHandle fh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过实现<code>operator FHandle() const {return fh;}</code>函数可以实现隐式的变换，但是这样容易造成错误的发生，因此建议使用显式的变换（get的方式）。</p>
<p><strong>总结</strong></p>
<ul>
<li>API中往往要求访问原始资源，所以每一个RAII类中应该要实现一个直接获取志愿的方法（get方法）。</li>
<li>对原始资源的访问可能是显式变换或者隐式的变换，一般而言显式变换比较安全。</li>
</ul>
<h3 id="16-条款：成对使用new和delete时要采取相同形式"><a href="#16-条款：成对使用new和delete时要采取相同形式" class="headerlink" title="16 条款：成对使用new和delete时要采取相同形式"></a>16 条款：成对使用new和delete时要采取相同形式</h3><p>new在被使用的时候，可以申请单个内存（<code>new int</code>）或多个内存（<code>new int[10]</code>），delete再回收内存的时候，也有回收单一内存和连续内存的区别，需要注意的是，new和delete行为必须一致（单一内存和多内存的一致。）</p>
<p><strong>总结</strong></p>
<ul>
<li>new中使用[]必须在delete中也使用[]（连续内存），new中不使用[]，delete中也不能使用[]（单一）。</li>
</ul>
<p>下面补充一下CPP中new和delete的用法：</p>
<p><strong>new的使用</strong></p>
<p>new负责C++中的动态内存分配，动态内存位于heap上。在不使用这段内存的时候，程序需要负责将这段内存回收掉。</p>
<p>new指令初始化内存，返回内存分配的初始地址：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pointer-variable = <span class="keyword">new</span> data-type;</span><br><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br></pre></td></tr></table></figure>
<p>可以<strong>使用括号的方式初始化对象</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p><strong>使用中括号[]的方式分配一整块内存空间：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>传统的申请内存的方式为<code>int a[10];</code> 这个空间由编译器申请，在使用结束之后也由编译器进行回收。但是自己申请的内存会一直存在，直到自己delete处理掉。</p>
<p><strong>delete的使用</strong></p>
<p>使用delete对new申请的数组进行清空：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p; <span class="comment">// 删除单个元素</span></span><br><span class="line"><span class="keyword">delete</span>[] p; <span class="comment">// 删除整段空间</span></span><br></pre></td></tr></table></figure>
<h3 id="17-条款：以独立语句将newed对象置入智能指针"><a href="#17-条款：以独立语句将newed对象置入智能指针" class="headerlink" title="17 条款：以独立语句将newed对象置入智能指针"></a>17 条款：以独立语句将newed对象置入智能指针</h3><p>可以使用智能指针的方式来管理new申请的内存：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str1::<span class="built_in">shared_ptr</span>&lt;Widget&gt; pw(<span class="keyword">new</span> Widget);</span><br></pre></td></tr></table></figure>
<p>存在一种情况，当我们使用资源管理类来管理内存的时候，可能会出现内存泄漏。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process(str1::<span class="built_in">shared_ptr</span>&lt;Wdiget&gt;(<span class="keyword">new</span> Widget),priority());</span><br></pre></td></tr></table></figure>
<p>上面代码可能的执行顺序是(顺序不一定)：</p>
<ol>
<li>new widget</li>
<li>priority</li>
<li>Shared_ptr构造函数</li>
</ol>
<p>如果第二步抛出异常，那么造成内存泄漏，因此：<strong>newed对象应当写一个单独的语句</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1::<span class="built_in">shared_ptr</span>&lt;Widget&gt; pw(<span class="keyword">new</span> Widget);</span><br><span class="line">process(pw,priority());</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ul>
<li>以单独的语句将newed对象存储在智能指针内，确保资源不会泄露。</li>
</ul>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>WenHui Zhou</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/11/05/effective-cpp-三-资源管理/">https://wenhui-zhou.github.io/2019/11/05/effective-cpp-三-资源管理/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>| 本博客所有文章除特别声明外，均采用 <a href="&quot;http://creativecommons.org/licenses/by-nc-sa/3.0/cn/&quot;" rel="&quot;external" nofollow&quot;="" target="&quot;_blank&quot;">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！ </li></ul></div><br><div class="tags"></div><div class="post-nav"><a class="pre" href="/2019/11/06/推荐系统之评分预测（三）/">推荐系统之评分预测（三）</a><a class="next" href="/2019/11/05/推荐系统之用户标签数据-二/">推荐系统之用户标签数据(二)</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'civq9nKD49NpRALooR9Llqmf-gzGzoHsz',
  appKey:'JggO9HaSi1Lfx17nt16oDfsI',
  placeholder:'Shall we talk',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/3D重建/">3D重建</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tensorflow/">Tensorflow</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/effective-cpp/">effective cpp</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/super-resolution/">super resolution</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tool/">tool</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/xigua/">xigua</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/建站/">建站</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/手撕系列/">手撕系列</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/推荐系统/">推荐系统</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/模型评价/">模型评价</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/比赛/">比赛</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法扫盲/">算法扫盲</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程/">编程</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文复现/">论文复现</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文阅读/">论文阅读</a><span class="category-list-count">22</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/论文阅读/3D重建/">3D重建</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/项目/">项目</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/项目总结/">项目总结</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/项目总结/论文阅读/">论文阅读</a><span class="category-list-count">3</span></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/SR/" style="font-size: 15px;">SR</a> <a href="/tags/深度学习/" style="font-size: 15px;">深度学习</a> <a href="/tags/项目总结/" style="font-size: 15px;">项目总结</a> <a href="/tags/c/" style="font-size: 15px;">c++</a> <a href="/tags/leetcode/" style="font-size: 15px;">leetcode</a> <a href="/tags/3D重建/" style="font-size: 15px;">3D重建</a> <a href="/tags/论文阅读/" style="font-size: 15px;">论文阅读</a> <a href="/tags/netStation/" style="font-size: 15px;">netStation</a> <a href="/tags/tool/" style="font-size: 15px;">tool</a> <a href="/tags/dialog/" style="font-size: 15px;">dialog</a> <a href="/tags/interview/" style="font-size: 15px;">interview</a> <a href="/tags/tip/" style="font-size: 15px;">tip</a> <a href="/tags/Tensorflow/" style="font-size: 15px;">Tensorflow</a> <a href="/tags/learning-cpp/" style="font-size: 15px;">learning cpp</a> <a href="/tags/职业规划/" style="font-size: 15px;">职业规划</a> <a href="/tags/—-leetcode/" style="font-size: 15px;">— leetcode</a> <a href="/tags/tips/" style="font-size: 15px;">tips</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/超分辨率/" style="font-size: 15px;">超分辨率</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/11/09/effective-cpp-四-设计与声明/">effective cpp(四) 设计与声明</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/06/EncNet结合上下文的语义分割/">EncNet结合上下文的语义分割</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/06/推荐系统之评分预测（三）/">推荐系统之评分预测（三）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/05/effective-cpp-三-资源管理/">effective cpp(三) 资源管理</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/05/推荐系统之用户标签数据-二/">推荐系统之用户标签数据(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/02/effective-cpp-二-构造、析构、赋值运算/">effective cpp (二) 构造、析构、赋值运算</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/02/推荐系统之协同过滤（一）/">推荐系统之协同过滤（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/31/effective-cpp-（一）-让自己习惯cpp/">effective cpp(一) 让自己习惯cpp</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/31/FastFCN-大工不巧/">FastFCN: 大工不巧</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/10/30/关于职业生涯规划以及时间安排的一些思考/">关于职业生涯规划以及时间安排的一些思考</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/WenHui-Zhou" title="GITHUB" target="_blank">GITHUB</a><ul></ul><a href="http://www.google.com/" title="GOOGLE" target="_blank">GOOGLE</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">WenHuiZhou.</a> 访问人数:<span id="busuanzi_value_site_uv"></span> 
访问量:<span id="busuanzi_value_site_pv"></span></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> </div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
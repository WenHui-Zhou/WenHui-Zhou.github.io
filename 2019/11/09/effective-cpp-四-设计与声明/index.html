<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="cheer up"><meta name="baidu-site-verification" content="9pSIuwCbvi"><meta name="google-site-verification" content="YzcCTjF6VoVlNAtL37_S4vFjzFwYTAFZzD51Il2IGKY"><title>effective cpp(四) 设计与声明 | WenHuiZhou</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">effective cpp(四) 设计与声明</h1><a id="logo" href="/.">WenHuiZhou</a><p class="description">perper（打起精神！）</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">effective cpp(四) 设计与声明</h1><div class="post-meta">Nov 9, 2019<span> | </span><span class="category"><a href="/categories/effective-cpp/">effective cpp</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" href="/2019/11/09/effective-cpp-四-设计与声明/#vcomment"><span class="valine-comment-count" data-xid="/2019/11/09/effective-cpp-四-设计与声明/"></span><span> 条评论</span></a><div class="post-content"><p>2019/11/09 effective cpp 第四章</p>
<p>良好的cpp接口的设计以及声明是可以令软件作出其最正确的事，包括正确，高效性、封装性、维护性、延展性、以及协议一致性。</p>
<ul>
<li>18 条款：让接口容易被正确使用，不易被误用</li>
<li>19 条款：设计class犹如设计type</li>
<li>20 条款：宁以 pass-by-reference-to-const 替换 pass-by-value</li>
<li>21 条款：必须放回对象时，别妄想返回其reference</li>
<li>22 条款：将成员变量声明为private</li>
<li>23 条款：宁以non-member、non-friend替换member函数</li>
<li>24 条款：若所有参数皆需类型转换，请为此采用non-member函数</li>
<li>25 条款：考虑写出一个不抛异常的swap函数</li>
</ul>
<a id="more"></a>
<h3 id="18-条款：让接口容易被正确使用，不易被误用"><a href="#18-条款：让接口容易被正确使用，不易被误用" class="headerlink" title="18 条款：让接口容易被正确使用，不易被误用"></a>18 条款：让接口容易被正确使用，不易被误用</h3><p>接口开发的目标在于：<strong>让接口容易被正确使用，不易被误用</strong></p>
<p>但是由于有时候会遇到用户传入的参数和接口能够接受的参数不同，可能会导致错误，这个时候最后通过 <strong>类型系统的方式来预防</strong>，通过导入新的类别来限制数据类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Date(<span class="keyword">const</span> Month&amp; m,<span class="keyword">const</span> Day&amp; d,<span class="keyword">const</span> Year&amp; y)&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Month(<span class="number">3</span>),Day(<span class="number">30</span>),year(<span class="number">1995</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<p>对数据的限制部分在每一个数据类型的函数内部。明智地选择合适的新类型，能够有效的防止接口被误用。</p>
<p>另一个预防客户错误的方式是限制类型内可做什么事情，不能做什么事情，常见的限制加上const，阻止用户自定义类型错误。</p>
<p>另一个准则为除非有好的理由，否则应该尽量令你的types的行为和内置的type的行为一致。例如STL中的所有类均有一个size方法，表示长度。</p>
<p>如果在接口内部有资源的申请，申请的资源必须在最后得到销毁。因此最好的方法就是将函数的返回值设置为shared_ptr：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str1:：<span class="built_in">shared_ptr</span>&lt;invest&gt; create();</span><br></pre></td></tr></table></figure>
<p>此外，shared_ptr还允许绑定一个对象释放函数，当对象释放的时候，shared_ptr调用这个函数来释放对象。定义方式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str1::<span class="built_in">shared_ptr</span>&lt;invest&gt; pInt(ptr,deleteMethod);</span><br></pre></td></tr></table></figure>
<p><code>str1::shared_ptr</code>会自动调用每个使用它的指针专属的删除器，避免跨DLL文件delete导致运行期的错误。<strong>shared_ptr会调用指针的专属删除器</strong>。</p>
<p>shared_ptr在效率和空间上是用指针的两倍大，使用辅助动态内存，比原始指针要大。</p>
<p><strong>总结</strong></p>
<ul>
<li>设计不容易出错的接口</li>
<li>保证接口之间的一致性</li>
<li>阻止误用，建立新类型的方式限制类型上的操作，消除客户资源管理的任务</li>
<li>Tr1::shared_ptr支持定制删除器，防范DLL问题</li>
</ul>
<h3 id="19-条款：设计class犹如设计type"><a href="#19-条款：设计class犹如设计type" class="headerlink" title="19 条款：设计class犹如设计type"></a>19 条款：设计class犹如设计type</h3><p>当你定义了一个新的class，也就定义了一个type，设计好的type有自然的语法和直观的语义，有一下的设计规范：</p>
<ul>
<li>新type的对象应该如何创建和销毁</li>
<li>对象初始化和对象的赋值该有什么样的差别</li>
<li>新type对象如果被传值（passed by value）该在copy函数中写实现方法</li>
<li>对type的合法值进行约束</li>
<li>新的type是否需要配合继承图系</li>
<li>新type需要什么样的类型转换</li>
<li>什么样的操作符和函数对新type是合理的</li>
<li>什么样的标准函数需要驳回</li>
<li>谁该去用新type成员</li>
<li>什么是新type的未声明接口</li>
<li>type的一般化程度</li>
<li>你真的需要一个新type吗</li>
</ul>
<p><strong>总结</strong></p>
<p>设计一个class的时候，需要充分考虑上面的问题，具体所指可以参考书本84页。</p>
<h3 id="20-条款：宁以-pass-by-reference-to-const-替换-pass-by-value"><a href="#20-条款：宁以-pass-by-reference-to-const-替换-pass-by-value" class="headerlink" title="20 条款：宁以 pass-by-reference-to-const 替换 pass-by-value"></a>20 条款：宁以 pass-by-reference-to-const 替换 pass-by-value</h3><p>C++默认以传值的方式给函数传递参数，这一过程函数参数的初值都是调用对象的构造函数来实现，当离开这个函数的时候，通过析构函数来回收这些资源，因此传值的方式将会耗费大量的资源和时间。</p>
<p>一个很好的优化方法就是使用const 引用的方式，这种方式没有任何的构造函数被调用。之所以使用const，是为了保证传入的参数对象不会被改变。</p>
<p>此外如果直接传值，对于参数类型为父类的情况，传入子类对象，会造成子类特化功能被切割，参数的行为与父类相同，但是如果使用传引用的方式，这种现象不会发生。</p>
<p>说到这里，我们会好奇，引用到底是个什么东西呢，其实际上运用是通过指针的方式来实现的，传递引用等同于传递指针，<strong>对于内置类型来说，传值方式会比传指针的方式更加高效。</strong> 对于int，float这些类型，直接通过传值的方式更加的高效。</p>
<p><strong>总结</strong></p>
<ul>
<li>尽量以传const引用的方式替换传值的方式，前者通常比较高效，避免对象切割问题</li>
<li>对于内置类型以及STL迭代器，函数对象来说，直接传值比较高效</li>
</ul>
<h3 id="21-条款：必须放回对象时，别妄想返回其reference"><a href="#21-条款：必须放回对象时，别妄想返回其reference" class="headerlink" title="21 条款：必须放回对象时，别妄想返回其reference"></a>21 条款：必须放回对象时，别妄想返回其reference</h3><p>当我们尝试消灭所有的传值行为的时候，我们可能会对函数的返回值下手，这种做法是不可取的。</p>
<p>所谓的引用，即表明它所指代的对象一定要存在，在函数中我们有两种方式创建对象：</p>
<p><strong>创建对象在stack内存上</strong></p>
<p>stack内存存放函数的参数，局部变量值，由编译器自动释放：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Ration&amp; <span class="keyword">operator</span>*(<span class="keyword">const</span> Ration&amp; lhs,<span class="keyword">const</span> Ration&amp; rhs)&#123;</span><br><span class="line">  <span class="function">Ration <span class="title">result</span><span class="params">(lhs.n*rhs.n)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上买代码返回了一个局部变量的引用，但是由于出了这个函数，局部变量就会被销毁，因此这个reference将毫无意义。</p>
<p><strong>创建对象在heap内存上</strong></p>
<p>用户自己分配，自己销毁的资源都会分配在heap内存上，有new-delete对来管理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Ration&amp; <span class="keyword">operator</span>*(<span class="keyword">const</span> Ration&amp; lhs,<span class="keyword">const</span> Ration&amp; rhs)&#123;</span><br><span class="line">  Ration* result = <span class="keyword">new</span> Ration(lhs.n*rhs.n);</span><br><span class="line">  <span class="keyword">return</span> *result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面返回的引用是有意义的，但是当我们使用完这个 内存之后，由谁去销毁呢，在一些很复杂的操作里面，程序员往往无法保证资源的完全回收。</p>
<p><strong>使用static变量</strong></p>
<p>在函数内部定义static变量，该变量的生命周期是整个程序的生命周期，static变量，全局变量他们的值都是存放在同一块区域，由程序结束后统一回收。</p>
<p>但这又引发了另一个问题，你想要比较两个数相乘后与另外两个数相乘的大小，但是结果存放在static当中，程序只会保存一份static的结果，因此永远无法比较。</p>
<p>因此，<strong>如果函数要求返回一个对象，那么我们就承担返回值所产生的构造和析构成本</strong>，不要试图去放回引用。</p>
<p><strong>总结</strong></p>
<p>不要返回一个指针或引用指向一个local对象，或指向heap-allocated对象，或指向static对象，而是直接返回该对象（传值）。</p>
<h3 id="22-条款：将成员变量声明为private"><a href="#22-条款：将成员变量声明为private" class="headerlink" title="22 条款：将成员变量声明为private"></a>22 条款：将成员变量声明为private</h3><p>为保证成员便来那个的约束性，对用户隐藏变量，使得类中的约束条件总会收到维护。如果将一个变量声明为public，破坏了封装性，在我们修改该变量的时候，我们无法预知这个变量所涉及的一切，可能会对程序造成极大的破坏。因此保护类的封装性。protected类型与public相似，其实只有来那个两种访问权限：<strong>private（提供封装）和其他（不提供封装）</strong></p>
<p><strong>总结</strong></p>
<ul>
<li>切记将成员变量声明为private，这可赋予客户访问数据一致性，细微划分访问控制，允许约束条件获得保护，并 提供class作者充分的实现弹性。</li>
</ul>
<h3 id="23-条款：宁以non-member、non-friend替换member函数"><a href="#23-条款：宁以non-member、non-friend替换member函数" class="headerlink" title="23 条款：宁以non-member、non-friend替换member函数"></a>23 条款：宁以non-member、non-friend替换member函数</h3><p>这个条款的核心在于：<strong>越少的操作直接接触到数据，对类的封装性，代码的维护越好</strong>。因此如果一些操作可以由非成员函数来完成的话，就不要去写那个成员函数的版本。</p>
<p>越少的函数接触到数据，我们在改变数据的时候，就可以有越大的灵活度修改这个数据。</p>
<p>有几种方式可以去实现非类内函数来完成这个操作：</p>
<ul>
<li>例如我们指提供了一个完成基础操作的类，我们可以选择另一个类中的函数，传入这个对象，来实现你想要的操作，而不用为基础类添加成员</li>
<li>C++的一个常用的做法是，将non-member函数与类写在同一个命名空间中，命名空间可以跨越多个源码文件。将所有便利函数放在多个头文件内，但同属于一个命名空间，以为着用户可以轻松扩展这一组便利函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件webbrowser.h</span></span><br><span class="line"><span class="keyword">namespace</span> webbrowserStuff&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">webbrowser</span>&#123;</span>...&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头文件webbrowserbook.h</span></span><br><span class="line"><span class="keyword">namespace</span> webbrowserbook&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 头文件webbrowsercookies.h</span></span><br><span class="line"><span class="keyword">namespace</span> webbrowsercookies&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过include需要的头文件的方式来管理标准程序库，使得那一小部分系统形成编译相依的关系。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//web.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> wweb&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">web</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">get_name</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        web(<span class="built_in">string</span> n):name(n)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">say_hi</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//web.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"web.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::wweb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> web::say_hi() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hihi"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<ul>
<li>宁可用non-member函数替代member函数，这可增加类的封装性，包裹性，机能扩充性。</li>
<li>non-member的函数通常与class定义在同一个命名空间内</li>
</ul>
<h3 id="24-条款：若所有参数皆需类型转换，请为此采用non-member函数"><a href="#24-条款：若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="24 条款：若所有参数皆需类型转换，请为此采用non-member函数"></a>24 条款：若所有参数皆需类型转换，请为此采用non-member函数</h3><p>当我们传入参数都需要进行类型转换的时候，如果将类函数写成如下情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ration</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">const</span> Ration <span class="keyword">operator</span>* (<span class="keyword">const</span> Ration&amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Ration <span class="title">oneE</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">Ration result = oneE*<span class="number">2</span>; <span class="comment">// C++将2转换成Ration类型</span></span><br><span class="line">Ration result = <span class="number">2</span>*oneE; <span class="comment">// 编译错误，因为this不可以作为类型转换的变量</span></span><br></pre></td></tr></table></figure>
<p>只有当参数可位列于参数列中内，这个参数才允许隐式转换，因此一个比较好的方法就是非类内函数去实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Ration <span class="keyword">operator</span>*(<span class="keyword">const</span> Ration&amp; lhs,<span class="keyword">const</span> Ration&amp; rhs)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>能够避免使用友元的情况就一定要避免使用它。</p>
<p><strong>总结</strong></p>
<p>如果需要为某个函数的所有参数进行类型的转换，那么这个函数必须是个non-member。</p>
<h3 id="25-条款：考虑写出一个不抛异常的swap函数"><a href="#25-条款：考虑写出一个不抛异常的swap函数" class="headerlink" title="25 条款：考虑写出一个不抛异常的swap函数"></a>25 条款：考虑写出一个不抛异常的swap函数</h3><p>swap函数的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">namspace <span class="built_in">std</span>&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a,T&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要支持copying，swap就会完成交换。但是上面这种方法需要不断的构造，析构。于是我们选择特性化swap，<strong>通过置换指针的方式就可以达到置换的效果</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">widget</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span></span>&#123;</span><br><span class="line">      <span class="keyword">using</span> <span class="built_in">std</span>::swap;  <span class="comment">//令std内的swap函数可见</span></span><br><span class="line">      swap(pInt,other.pInt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;&gt;  <span class="comment">//告诉编译器，这是个全特化的版本</span></span><br><span class="line">  <span class="keyword">void</span> swap&lt;Widget&gt;(Widget&amp; a,Widget&amp; b)</span><br><span class="line">  &#123;</span><br><span class="line">    a.swap(b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此优化copy：</p>
<ul>
<li>提供一个public swap成员函数，让它高效置换你的类型的两个对象值，且不能抛出异常。（置换基本类型）。</li>
<li>在class或template所在命名空间中提供一个non-member swap函数，并令他调用上述的swap成员函数。</li>
<li>如果你正编写一个class，为你的class特化std::swap，并调用你的swap。</li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li><p>当std::swap对你的类型效率不高的时候，提供一个swap成员函数，并确保不抛出异常</p>
</li>
<li><p>提供一个member swap函数，也应该提供一个non-member swap用来调用前者，对于classes也请特化std::swap。</p>
</li>
<li>调用 swap时应该针对std::swap使用using声明式，然后调用swap并且不带任何命名空间资格修饰。</li>
<li>为“用户定义类型”进行std::template全特化是好的但是千万不要尝试在std内部加上对std而言全新的东西。</li>
</ul>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>WenHui Zhou</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/11/09/effective-cpp-四-设计与声明/">https://wenhui-zhou.github.io/2019/11/09/effective-cpp-四-设计与声明/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>| 本博客所有文章除特别声明外，均采用 <a href="&quot;http://creativecommons.org/licenses/by-nc-sa/3.0/cn/&quot;" rel="&quot;external" nofollow&quot;="" target="&quot;_blank&quot;">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！ </li></ul></div><br><div class="tags"></div><div class="post-nav"><a class="pre" href="/2019/11/10/effective-cpp-五-实现/">effective cpp(五) 实现</a><a class="next" href="/2019/11/06/EncNet结合上下文的语义分割/">EncNet结合上下文的语义分割</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'civq9nKD49NpRALooR9Llqmf-gzGzoHsz',
  appKey:'JggO9HaSi1Lfx17nt16oDfsI',
  placeholder:'Shall we talk',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/3D重建/">3D重建</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NLP/">NLP</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tensorflow/">Tensorflow</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/effective-cpp/">effective cpp</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/super-resolution/">super resolution</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tool/">tool</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/webSearch/">webSearch</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/xigua/">xigua</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/动画/">动画</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/建站/">建站</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/手撕系列/">手撕系列</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/推荐系统/">推荐系统</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/机器学习/">机器学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/模型评价/">模型评价</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/比赛/">比赛</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/深度学习/">深度学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/深度学习总结/">深度学习总结</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法扫盲/">算法扫盲</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/统计学习方法/">统计学习方法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程/">编程</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文复现/">论文复现</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文阅读/">论文阅读</a><span class="category-list-count">23</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/论文阅读/3D重建/">3D重建</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/面试准备/">面试准备</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/项目/">项目</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/项目总结/">项目总结</a><span class="category-list-count">6</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/项目总结/论文阅读/">论文阅读</a><span class="category-list-count">3</span></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/SR/" style="font-size: 15px;">SR</a> <a href="/tags/深度学习/" style="font-size: 15px;">深度学习</a> <a href="/tags/c/" style="font-size: 15px;">c++</a> <a href="/tags/项目总结/" style="font-size: 15px;">项目总结</a> <a href="/tags/leetcode/" style="font-size: 15px;">leetcode</a> <a href="/tags/3D重建/" style="font-size: 15px;">3D重建</a> <a href="/tags/netStation/" style="font-size: 15px;">netStation</a> <a href="/tags/论文阅读/" style="font-size: 15px;">论文阅读</a> <a href="/tags/tool/" style="font-size: 15px;">tool</a> <a href="/tags/interview/" style="font-size: 15px;">interview</a> <a href="/tags/dialog/" style="font-size: 15px;">dialog</a> <a href="/tags/tip/" style="font-size: 15px;">tip</a> <a href="/tags/Tensorflow/" style="font-size: 15px;">Tensorflow</a> <a href="/tags/NLP/" style="font-size: 15px;">NLP</a> <a href="/tags/learning-cpp/" style="font-size: 15px;">learning cpp</a> <a href="/tags/—-leetcode/" style="font-size: 15px;">— leetcode</a> <a href="/tags/职业规划/" style="font-size: 15px;">职业规划</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/tips/" style="font-size: 15px;">tips</a> <a href="/tags/超分辨率/" style="font-size: 15px;">超分辨率</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/12/19/github指令/">github指令</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/28/C-STL-library/">C++ STL library</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/18/海量地震数据超分辨率恢复及三维可视化/">海量地震数据超分辨率恢复及三维可视化的细枝末节</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/20/跟着面试打补丁/">跟着面试打补丁</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/17/地震数据超分辨率实验部分/">地震数据超分辨率实验部分</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/15/RDSNet细枝末节/">RDSNet细枝末节</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/14/ms-一个结束，一个开始/">ms:一个结束，一个开始</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/06/面试试题准备/">面试试题准备</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/04/手势识别/">手势识别</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/27/常见的目标检测网络/">常见的目标检测网络</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/WenHui-Zhou" title="GITHUB" target="_blank">GITHUB</a><ul></ul><a href="http://www.google.com/" title="GOOGLE" target="_blank">GOOGLE</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">WenHuiZhou.</a> 访问人数:<span id="busuanzi_value_site_uv"></span> 
访问量:<span id="busuanzi_value_site_pv"></span></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> </div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
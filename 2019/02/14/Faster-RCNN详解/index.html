<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="cheer up"><meta name="baidu-site-verification" content="9pSIuwCbvi"><meta name="google-site-verification" content="YzcCTjF6VoVlNAtL37_S4vFjzFwYTAFZzD51Il2IGKY"><title>Faster RCNN详解 | WenHuiZhou</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Faster RCNN详解</h1><a id="logo" href="/.">WenHuiZhou</a><p class="description">perper（打起精神！）</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Faster RCNN详解</h1><div class="post-meta">Feb 14, 2019<span> | </span><span class="category"><a href="/categories/论文阅读/">论文阅读</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><a class="disqus-comment-count" href="/2019/02/14/Faster-RCNN详解/#vcomment"><span class="valine-comment-count" data-xid="/2019/02/14/Faster-RCNN详解/"></span><span> 条评论</span></a><div class="post-content"><h3 id="Faster-RCNN详解"><a href="#Faster-RCNN详解" class="headerlink" title="Faster RCNN详解"></a>Faster RCNN详解</h3><p>Faster RCNN 是在Fast RCNN的基础上，进一步改进，解决select search 算法选择候选框速度太慢的问题。</p>
<blockquote>
<p>Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks<br>submit time: 2016<br><a href="https://arxiv.org/pdf/1506.01497.pdf" target="_blank" rel="noopener">arxiv link</a> </p>
</blockquote>
<p>fast R-CNN和faster R-CNN之间的区别在于我们不使用特殊区域提议方法来创建region  proposal。而是训练一个<strong>region proposal network（RPN）</strong>，<strong>该网络将features map 作为输入并输出region proposals。然后将这些proposal输入Fast R-CNN中的RoI池化层</strong>。以下是fast RCNN与Faster RCNN的网络结构对比图。<br><img src="/images/fasternet/structure.png" alt="structure"><br><strong>Faster RCNN 关键步骤：</strong></p>
<ul>
<li>Conv layers。作为一种CNN网络目标检测方法，Faster RCNN首先使用一组基础的conv+relu+pooling层<strong>提取image的feature maps</strong>。该feature maps被共享用于后续RPN层和全连接层。</li>
<li>Region Proposal Networks。<strong>RPN网络用于生成region proposals</strong>。该层通过softmax判断anchors属于foreground或者background，<strong>再利用bounding box regression修正anchors获得精确的proposals</strong>。</li>
<li>Roi Pooling。该层收集输入的feature maps和proposals，综合这些信息后<strong>提取proposal feature maps</strong>，送入后续全连接层判定目标类别。</li>
<li>Classification。利用proposal feature maps计算proposal的类别，同时再次bounding box regression获得检测框最终的精确位置。</li>
</ul>
<p>Faster RCNN 网络是用于目标检测的一种比较流行的框架。它主要由以下四个部分组成</p>
<ul>
<li>分别是conv layer 输入为原始图片，用于提取图片的feature map</li>
<li>RPN网络，输入为features map，用于生成region proposal，该层为features map 上每个像素生成若干个anchors（9个），随后通过softmax 判断每个anchor是属于foreground（目标）或者background（背景），再利用bounding box regression修正anchors获得精确的proposal位置。</li>
<li>RoI pooling，该层输入为proposal位置信息和features map，通过proposal的位置信息在features map 上提取region features map候选区，然后通过pooling产生一个固定长度的特征，送入全连接层进行目标判别。</li>
<li>classification，利用proposal feature maps计算proposal的类别，同时再次进行一次bounding box regression，对proposal位置进行精修，随后将结果输出。</li>
</ul>
<p>总结一套介绍网络框架的先后顺序的方法。</p>
<font color="red"> 可以先大后小，按照先后顺序从前到后，按功能性介绍一件事情，每件事情的功能介绍的时候，说清楚输入，工作流程附带其具体功能，输出。</font>

<p><strong>Faster RCNN 详细网络结构如图：</strong><br><img src="/images/fasternet/fasterrcnn_structure.jpg" alt="fasterrcnn_structure"></p>
<p>将一副任意大小PxQ的图像，首先缩放至固定大小MxN，然后将MxN图像送入网络；而卷积层 Conv layers中包含了<strong>13个conv层+13个relu层+4个pooling层</strong>；<strong>RPN网络</strong>首先经过3x3卷积，再分别生成foreground anchors与bounding box regression偏移量，然后计算出proposals；而<strong>Roi Pooling层则利用proposals以及feature maps，提取proposal feature</strong>送入后续全连接和softmax网络作classification。</p>
<h4 id="conv-layer"><a href="#conv-layer" class="headerlink" title="conv layer"></a>conv layer</h4><p><img src="/images/fasternet/vgg.jpg" alt="vgg"></p>
<p>Conv layers部分共有13个conv层，13个relu层，4个pooling层。</p>
<ul>
<li>所有的conv层都是： kernel_size=3 ， pad=1 ，stride=1，因此conv层不改变原图大小</li>
<li>所有的pooling层都是： kernel_size=2 ，pad=0 ， stride=2，pooling 层将原图缩小为原来的一半</li>
<li>经过Conv layer后，一个MxN大小的矩阵将变为(M/16)x(N/16)</li>
</ul>
<h4 id="Region-Proposal-Networks-RPN"><a href="#Region-Proposal-Networks-RPN" class="headerlink" title="Region Proposal Networks(RPN)"></a>Region Proposal Networks(RPN)</h4><p>Faster RCNN 层在fast RCNN 的基础上，对提取候选框进行优化。</p>
<p><img src="/images/fasternet/RPN.jpg" alt="RPN"></p>
<p>RPN网络分为2条线，上面一条通过<strong>softmax分类anchors获得foreground和background</strong>（检测目标是foreground），<strong>下面一条用于计算anchors的bounding box regression偏移量</strong>，以获得精确的proposal。而最后的Proposal层则负责综合foreground anchors和bounding box regression偏移量获取proposals，同时剔除太小和超出边界的proposals。其实整个网络到了Proposal Layer这里，就完成了相当于目标定位的功能。</p>
<h5 id="anchors"><a href="#anchors" class="headerlink" title="anchors"></a>anchors</h5><p>anchor为由一个中心点，周围生成了9个矩形，矩形长宽比由三个尺寸<code>1:1,1:2;2:1</code>三种，如下图，基本覆盖了各种尺寸和形状，引入检测中常用到的多尺度方法。<br><img src="/images/fasternet/anchor.jpg" alt="anchor"><br>Faster RCNN遍历Conv layers计算获得的feature maps，<strong>为feature map上每一个点都配备这9种anchors作为初始的检测框</strong>。这样做获得检测框很不准确，之后将会在RPN层，以及最后进行2次的bounding box regression修正检测框位置。<br><img src="/images/fasternet/convmap.jpg" alt="convmap"><br>如上图，对于每一个点的k个anchor来说，从conv layer提取出得特征具有256维，对于每一个anchor，需要分foreground与background，因此共有2k个score，对于每一个anchor共有$(x_1,y_1,x_2,y_2)$四个坐标值。因此共有4k个coordinates。在训练阶段，程序将会从这些anchor中挑选出一些合适的anchor进行训练。<br><strong>因此RPN最终就是在<font color="red">原图尺度上</font>，对每一个像素设置9个尺度的候选anchor。然后用cnn去判断哪些Anchor是里面有目标的foreground anchor，哪些是没目标的backgroud。所以，仅仅是个二分类而已！</strong><br>那么Anchor一共有多少个？原图800x600，VGG下采样16倍，feature map每个点设置9个Anchor，所以：<br>$$<br>ceil(800/16) \times ceil(600/16) \times 9=50\times38 \times9=17100<br>$$<br>其中ceil()表示向上取整，是因为VGG输出的feature map size= 50*38。</p>
<p><img src="/images/fasternet/generateAnchor.jpg" alt="generateAnchor"></p>
<h4 id="softmax判定foreground与background"><a href="#softmax判定foreground与background" class="headerlink" title="softmax判定foreground与background"></a>softmax判定foreground与background</h4><p>RPN网络中利用anchors和softmax初步提取出foreground anchors作为候选区域。<br><img src="/images/fasternet/softmax.jpg" alt="softmax"><br>features map 首先做一个1*1的卷积，这个卷积的作用是生成一个$W*H*(9*2)$大小的矩阵。该矩阵用于存储上面提到的foreground与background信息（2*k score）。将该特征后接softmax分类获得foreground anchors，也就相当于初步提取了检测目标候选区域box（一般认为目标在foreground anchors中）。前后两个reshape 操作目的为便于程序实现。<br>clc layer输出预测区域共k个，每个有的2个参数，即预测为前景的概率和背景的概率，损失用softmax loss（cross entropy loss）。监督信息是Y=0,1，表示这个区域是否为groundtruth。确定groundtruth时，我们需要确定k个区域中的各个区域是不是有效的，是前景还是背景。<br>K个区域分配标签规则：</p>
<ul>
<li>与某个ground truth(GT)的IoU最大的区域的分配正标签</li>
<li>与任意GT的IoU大于0.7的区域分配正标签</li>
<li>与所有GT的IoU都小于0.3的区域分配负标签</li>
</ul>
<h4 id="bounding-box-regression原理"><a href="#bounding-box-regression原理" class="headerlink" title="bounding box regression原理"></a>bounding box regression原理</h4><p>对于窗口一般使用四维向量  (x, y, w, h) 表示，分别表示窗口的中心点坐标和宽高。对于图 11，红色的框A代表原始的Foreground Anchors，绿色的框G代表目标的GT，我们的目标是寻找一种关系，使得输入原始的anchor A经过映射得到一个跟真实窗口G更接近的回归窗口G’，即：<br><img src="/images/fasternet/bbox.jpg" alt="bbox"></p>
<p>给定：$anchor A=(A_{x}, A_{y}, A_{w}, A_{h}) 和 GT=[G_{x}, G_{y}, G_{w}, G_{h}]$<br>寻找一种变换F，使得：$F(A_{x}, A_{y}, A_{w}, A_{h})=(G_{x}^{‘}, G_{y}^{‘}, G_{w}^{‘}, G_{h}^{‘})，$其中$(G_{x}^{‘}, G_{y}^{‘}, G_{w}^{‘}, G_{h}^{‘})≈(G_{x}, G_{y}, G_{w}, G_{h})$<br>那么经过何种变换F才能从图10中的anchor A变为G’呢？ 比较简单的思路就是先做平移，然后进行缩放，边框回归与RCNN中边框回归相同。<a href="https://blog.csdn.net/u014433413/article/details/78194855" target="_blank" rel="noopener">bounding box 原理参考链接</a><br>RPN中所涉及的边框回归首先经过一个1*1的卷积层，输出一个$W*H*(9*4)$的矩阵，用于存储box的坐标信息（4k coordinate）<br><img src="/images/fasternet/rpnbbox.jpg" alt="rpnbbox"></p>
<font color="red">RPN值得注意的地方: </font><br>- RPN在原图的尺度上选择anchor的大小<br>- anchor的数目是feature map上每个像素选择9个长宽比不同的矩形<br>- soft Max层用于判断anchor是否为前景（含有目标）<br>- bounding box regression 预测的输出是anchor的偏移变换<br>- proposal层，结合前景的anchor（背景anchor被忽略）与anchor偏移变换，对anchor位置进行调整，计算出proposal的精确位置。<br>- bounding  box 本质上是学习一个W权重矩阵，即那个1*1的网络的参数（输出为4K regreason,对应anchor的（x，y,w,h）四个偏移），利用W参数乘以 CNN pool5层输出的features map，通过最小二乘，得到anchor的偏移。<br>- 为什么bounding box regression不直接预测坐标呢？ 因为坐标间的关系不是简单的一维关系，难以优化。当anchor 与 ground truth比较接近时，他们之间的位置关系（偏移）就可以用一维关系来近似。<br>- proposal层输出的proposal坐标是在原图的尺度上的proposal坐标。<br><br>#### proposal layer<br>RPN 最后一层为proposal layer，用于前景anchors，以及anchor对应的边框回归微调参数$[d_{x}(A),d_{y}(A),d_{w}(A),d_{h}(A)]$和im_info=[M, N, scale_factor]（传入Faster RCNN前首先reshape到固定MxN，im_info则保存了此次缩放的所有信息）来计算产生的proposal位置，<strong>此时输出的proposal坐标为原图尺度上的proposal坐标</strong>。<br><br><strong>Proposal Layer forward（caffe layer的前传函数）按照以下顺序依次处理：</strong><br><br>- <strong>生成anchors</strong>：利用$[d_{x}(A),d_{y}(A),d_{w}(A),d_{h}(A)]$对所有的anchors做bbox regression回归（这里的anchors生成和训练时完全一致）<br>- 按照输入的foreground softmax scores<strong>由大到小排序anchors</strong>，<strong>提取前pre_nms_topN(e.g. 6000)个anchors，</strong>即提取修正位置后的foreground anchors。<br>- <strong>限定超出图像边界的foreground anchors为图像边界</strong>（防止后续roi pooling时proposal超出图像边界）<br>- <strong>剔除非常小（width&lt;threshold or height&lt;threshold）的foreground anchors</strong><br>- <strong>进行nonmaximum suppression</strong><br>- <strong>再次按照nms后的foreground softmax scores由大到小排序fg anchors，提取前post_nms_topN(e.g. 300)结果作为proposal = [x1, y1, x2, y2]输出。</strong><br>输出的proposal=[x1, y1, x2, y2]，由于在第三步中将anchors映射回原图判断是否超出边界，所以<strong>这里输出的proposal是对应MxN输入图像尺度的</strong>。<br>RPN网络结构主要步骤如下：<br><strong>生成anchors -&gt; softmax分类器提取前景 anchors -&gt; bbox reg回归前景 anchors -&gt; Proposal Layer生成proposals</strong><br><br>#### RoI pooling layer<br>RoI Pooling layer负责收集proposal，并计算出proposal feature maps，送入后续网络。Rol pooling层有2个输入：<br>- 原始的feature maps<br>- RPN输出的proposal boxes（大小各不相同）<br><br><strong>RoI Pooling layer forward过程：</strong><br><br>- 由于proposal是对应$ M\times N$ 尺度的，所以首先使用spatial_scale参数将其映射回 $(M/16)\times(N/16) $大小的feature map尺度；<br>- 再将每个proposal对应的feature map区域水平分为 $\text{pooled_w}\times \text{pooled_h} $的网格；<br>- 对网格的每一份都进行max pooling处理。<br><br>经过上述处理后，即使大小不同的proposal输出结果都是 $\text{pooled_w}\times \text{pooled_h}$ 固定大小，实现了固定长度输出。<br><br>#### Classification<br><br>Classification部分利用已经获得的proposal feature maps，通过full connect层与softmax计算每个proposal具体属于那个类别（如人，车，电视等），输出cls_prob概率向量；同时再次利用bounding box regression获得每个proposal的位置偏移量bbox_pred，用于回归更加精确的目标检测框。<br><img src="/images/fasternet/classfication.jpg" alt="classfication"><br>从PoI Pooling获取到7x7=49大小的proposal feature maps后，送入后续网络，可以看到做了如下2件事：<br>- 通过全连接和softmax对proposals进行分类<br>- 再次对proposals进行bounding box regression，获取更高精度的rect box<br><br>#### Faster R-CNN训练<br>Faster R-CNN的训练，是在已经训练好的model（如VGG_CNN_M_1024，VGG，ZF）的基础上继续进行训练。实际中训练过程分为6个步骤：<br><br>- 在已经训练好的model上，训练RPN网络<br>- 利用步骤1中训练好的RPN网络<br>- 第一次训练Fast RCNN网络<br>- 第二训练RPN网络<br>- 再次利用步骤4中训练好的RPN网络<br>- 第二次训练Fast RCNN网络<br>可以看到训练过程类似于一种“迭代”的过程，不过只循环了2次。至于只循环了2次的原因是应为作者提到：”A similar alternating training can be run for more iterations, but we have observed negligible improvements”，即循环更多次没有提升了。<br><br><img src="/images/fasternet/train.jpg" alt="train"><br><br>#### RPN 训练<br><br>与检测网络类似的是，依然使用Conv Layers提取feature maps。整个网络使用的Loss如下：<br>$$<br>L({p_i},{t_i})=\frac{1}{N_{cls}}\sum_{i} L_{cls}(p_i,p_i^*)+\lambda \frac{1}{N_{reg}}\sum_{i} p_i^* L_{reg} (t_i,t_i^*)<br>$$<br><br>上述公式中 i 表示anchors index，$ p_{i}$ 表示foreground softmax probability，$p_{i}^{*}$代表对应的GT predict概率（即当第i个anchor与GT间IoU&gt;0.7，认为是该anchor是foreground，$p_{i}^{*}=1$；反之IoU&lt;0.3时，认为是该anchor是background，$ p_{i}^{*}=0 $；至于那些0.3&lt;IoU&lt;0.7的anchor则不参与训练）；t代表predict bounding box，$ t^{*} $ 代表对应foreground anchor对应的GT box。可以看到，整个Loss分为2部分：<br><br>- cls loss，即rpn_cls_loss层计算的softmax loss，用于分类anchors为forground与background的网络训练<br>- reg loss，即rpn_loss_bbox层计算的soomth L1 loss，用于bounding box regression网络训练。注意在该loss中乘了 $p_{i}^{*}$ ，相当于只关心foreground anchors的回归（其实在回归中也完全没必要去关心background）。<br><br><font color="red">Smooth L1 loss 相比于L2 loss对离群点更加不敏感，更加鲁棒。当预测值与目标相差很大时，L2 loss的梯度是x-t，容易产生梯度爆炸，而L1的梯度为常数，使用L1 loss 可以防止梯度爆炸。 </font>

<p>关于softMax loss 和 边框回归loss与fast RCNN 相同。<a href="http://perper.site/2019/02/14/Fast-RCNN%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">链接</a></p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>WenHui Zhou</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/02/14/Faster-RCNN详解/">https://wenhui-zhou.github.io/2019/02/14/Faster-RCNN详解/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>| 本博客所有文章除特别声明外，均采用 <a href="&quot;http://creativecommons.org/licenses/by-nc-sa/3.0/cn/&quot;" rel="&quot;external" nofollow&quot;="" target="&quot;_blank&quot;">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！ </li></ul></div><br><div class="tags"><a href="/tags/深度学习/">深度学习</a></div><div class="post-nav"><a class="pre" href="/2019/02/19/深度学习中常用的技术（面试考点）/">深度学习中常用的技术（面试考点）</a><a class="next" href="/2019/02/14/Fast-RCNN详解/">Fast RCNN详解</a></div><div id="vcomment"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'civq9nKD49NpRALooR9Llqmf-gzGzoHsz',
  appKey:'JggO9HaSi1Lfx17nt16oDfsI',
  placeholder:'Shall we talk',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10'
})</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/3D重建/">3D重建</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/NLP/">NLP</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tensorflow/">Tensorflow</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/effective-cpp/">effective cpp</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/super-resolution/">super resolution</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tool/">tool</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/xigua/">xigua</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/建站/">建站</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/手撕系列/">手撕系列</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/推荐系统/">推荐系统</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/模型评价/">模型评价</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/比赛/">比赛</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法扫盲/">算法扫盲</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程/">编程</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文复现/">论文复现</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/论文阅读/">论文阅读</a><span class="category-list-count">22</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/论文阅读/3D重建/">3D重建</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/项目/">项目</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/项目总结/">项目总结</a><span class="category-list-count">5</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/项目总结/论文阅读/">论文阅读</a><span class="category-list-count">3</span></li></ul></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/SR/" style="font-size: 15px;">SR</a> <a href="/tags/dialog/" style="font-size: 15px;">dialog</a> <a href="/tags/项目总结/" style="font-size: 15px;">项目总结</a> <a href="/tags/3D重建/" style="font-size: 15px;">3D重建</a> <a href="/tags/c/" style="font-size: 15px;">c++</a> <a href="/tags/leetcode/" style="font-size: 15px;">leetcode</a> <a href="/tags/论文阅读/" style="font-size: 15px;">论文阅读</a> <a href="/tags/netStation/" style="font-size: 15px;">netStation</a> <a href="/tags/tool/" style="font-size: 15px;">tool</a> <a href="/tags/interview/" style="font-size: 15px;">interview</a> <a href="/tags/深度学习/" style="font-size: 15px;">深度学习</a> <a href="/tags/tip/" style="font-size: 15px;">tip</a> <a href="/tags/Tensorflow/" style="font-size: 15px;">Tensorflow</a> <a href="/tags/NLP/" style="font-size: 15px;">NLP</a> <a href="/tags/learning-cpp/" style="font-size: 15px;">learning cpp</a> <a href="/tags/tips/" style="font-size: 15px;">tips</a> <a href="/tags/职业规划/" style="font-size: 15px;">职业规划</a> <a href="/tags/—-leetcode/" style="font-size: 15px;">— leetcode</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/超分辨率/" style="font-size: 15px;">超分辨率</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/01/01/2019！2020！/">2019！2020！</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/29/GPT/">GPT</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/29/finetune-诗句生成/">finetune-诗句生成</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/19/bert的一些思考/">bert的一些思考</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/09/pytorch-重点回顾/">pytorch 重点回顾</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/05/NLP实践-基于注意力机制的文本匹配/">NLP实践 基于注意力机制的文本匹配</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/02/NLP实践-文本分类任务/">NLP实践 文本分类任务</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/02/图像的去噪/">图像的去噪</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/01/NLP模型finetune-GPT到Bert（三）/">NLP模型finetune:GPT到Bert（三）</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/29/NLP之transformer（二）/">NLP之transformer（二）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://github.com/WenHui-Zhou" title="GITHUB" target="_blank">GITHUB</a><ul></ul><a href="http://www.google.com/" title="GOOGLE" target="_blank">GOOGLE</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">WenHuiZhou.</a> 访问人数:<span id="busuanzi_value_site_uv"></span> 
访问量:<span id="busuanzi_value_site_pv"></span></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> </div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.2/jquery.fancybox.min.css"><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
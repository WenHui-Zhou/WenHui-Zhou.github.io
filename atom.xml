<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WenHuiZhou</title>
  
  <subtitle>perper（打起精神！）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wenhui-zhou.github.io/"/>
  <updated>2019-10-27T11:37:27.081Z</updated>
  <id>https://wenhui-zhou.github.io/</id>
  
  <author>
    <name>WenHuiZhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cpp STL方法介绍</title>
    <link href="https://wenhui-zhou.github.io/2019/10/27/cpp-STL%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
    <id>https://wenhui-zhou.github.io/2019/10/27/cpp-STL方法介绍/</id>
    <published>2019-10-27T11:34:48.000Z</published>
    <updated>2019-10-27T11:37:27.081Z</updated>
    
    <content type="html"><![CDATA[<p>这篇post主要目的是对cpp提供的Standard Template Library标准模板库中一些重要的方法进行学习，记录，以便今后学习。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇post主要目的是对cpp提供的Standard Template Library标准模板库中一些重要的方法进行学习，记录，以便今后学习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="learning cpp" scheme="https://wenhui-zhou.github.io/tags/learning-cpp/"/>
    
  </entry>
  
  <entry>
    <title>cpp语法快速回顾</title>
    <link href="https://wenhui-zhou.github.io/2019/10/25/cpp%E8%AF%AD%E6%B3%95%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE/"/>
    <id>https://wenhui-zhou.github.io/2019/10/25/cpp语法快速回顾/</id>
    <published>2019-10-24T16:57:12.000Z</published>
    <updated>2019-10-27T12:16:26.319Z</updated>
    
    <content type="html"><![CDATA[<p>cpp的一些基本的语法的回顾，主要是一些比较小规模的语法特性的记录。</p><p>​    <a id="more"></a></p><p><strong>第一个可执行的cpp代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>cpp程序编译执行过程</strong></p><ul><li>编译：将源代码翻译成机器语言，生成目标文件<ul><li>预处理：拷贝#include 文件代码，#define 宏定义的替换 ，处理条件编译指令 （#ifndef #ifdef #endif）等，输出.i文件。</li><li>编译优化：进行cpp词法语法分析，确定所有指令是否符合规则，后翻译成汇编代码文件.s。</li><li>汇编：将汇编代码翻译成目标机器代码.o文件。</li></ul></li><li>链接：由于目标文件调用了其他源文件，因此这一步需要将有关的源文件链接起来，生成.exe。</li></ul><p><strong>#define宏定义</strong></p><p>宏定义用一个字符串代替一串字符串，在cpp编译的预处理阶段，将字符串的位置替换成原来的长字符串，这种设计方式的好处是1）修改代码方面。2）对一些很短的代码，如果写成一个函数，将花费大量的系统调用时间，因此宏定义可以提升代码效率，但是目标代码空间就会变大。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi 3.14 <span class="comment">//对象宏，定义变量</span></span></span><br><span class="line"><span class="comment">// 函数宏，这种方式直接将字符串展开，需要注意代码运算优先级的问题</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(A,B) ((A) &lt; (B) ?(A):(B))</span></span><br></pre></td></tr></table></figure><p><strong>条件编译</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NULL</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>#与##运算符</strong></p><p><strong>#</strong>起到将指令变成字符串的作用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACRO(x) #x</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;MACRO(HOW ARE)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// "HOW ARE"</span></span><br></pre></td></tr></table></figure><p><strong>##</strong>起到链接前后内容的作用，将参数连在一起。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACFUNS(x,y) x##y</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ACFUNS(<span class="string">"aa"</span>,<span class="string">"bb"</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// aabb</span></span><br></pre></td></tr></table></figure><p><strong>typedef申明</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="keyword">wchar_t</span>;</span><br></pre></td></tr></table></figure><p>使用wchar_t来表示short int 这种类型，起了一个新名字。</p><p><strong>enum枚举类</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> color&#123;red,blue,black&#125; c; <span class="comment">//值为0，1，2</span></span><br><span class="line">c = blue; <span class="comment">//等于为c赋值为1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><strong>声明与定义</strong></p><p>cpp语言支持分离时编译，允许将程序分割成多个模块，声明与定义分离（.h / .cpp）,静态库(lib)包含声明以及方法，动态库(.lib,dll)仅包含声明，dll中为方法。</p><p>声明的作用是在编译器链接代码的阶段，告诉程序该变量的存在。可以在多个文件中，多次声明，使用关键字：</p><p><code>extern int a;</code>声明了一个变量a。定义的过程只能有一次。</p><p><code>extern</code>关键字常用在多个文件同时使用同一个变量或者函数的时候。</p><p><strong>变量的初始值</strong></p><p>当一个变量是全局变量，系统会默认初始值为0。当变量是局部变量，系统不会赋初始值。</p><p><strong>定义常量</strong></p><p>常量不可以修改它的值，两种方式定义常量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDTH 10</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HEIGHT = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p><strong>修饰符类型</strong></p><p>修饰符用于改变基本数据类型char，int，double的含义。可以使用的修饰符有： <code>signed,unsigned,long short</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* <span class="keyword">restrict</span> restar = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">制定只有restar这个指针可以指向这一块内存，其他指针都不能访问</span><br></pre></td></tr></table></figure><p><strong>存储类</strong></p><p>auto 关键字声明变量根据初始化值自动推断<strong>变量</strong>的类型，声明函数返回的<strong>占位符</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">auto</span> s = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><p><strong>static</strong>告诉编译器在程序声明周期内保持局部变量的存在，在编译阶段进行赋值，其他阶段不会进行初始化操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        func();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出为5，4，3，2，1.... 其中static i只会被初始化一次</span></span><br></pre></td></tr></table></figure><p><strong>thread_local</strong>关键字声明的变量仅仅可以在其上创建的线程上访问，仅仅可以用来声明变量。</p><p><code>thread_local int x;</code></p><p><strong>位运算符</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">00111100</span></span><br><span class="line">B = <span class="number">00001101</span></span><br><span class="line">A&amp;B = <span class="number">00001100</span></span><br><span class="line">A|B = <span class="number">00111101</span></span><br><span class="line">A^B = <span class="number">00110001</span></span><br><span class="line">~A = <span class="number">11000011</span></span><br><span class="line">A &lt;&lt;= <span class="number">1</span>; <span class="comment">//A = 01111000</span></span><br><span class="line">A &gt;&gt;= <span class="number">1</span>; <span class="comment">//A = 00011110</span></span><br><span class="line"><span class="keyword">sizeof</span>(A); <span class="comment">//返回A的大小</span></span><br><span class="line">b = &amp;A; <span class="comment">// 取地址</span></span><br><span class="line">c = *b; <span class="comment">// 取出b中的值</span></span><br></pre></td></tr></table></figure><p><strong>函数定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传参数方式可以分为传值，传指针，传地址三种</span></span><br></pre></td></tr></table></figure><p><strong>lambda表达式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameter)-&gt; <span class="keyword">return</span>-type&#123;body&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> funa = [s](<span class="keyword">int</span> a,<span class="keyword">int</span> b)-&gt; <span class="keyword">int</span>&#123;<span class="keyword">return</span> a+b+s;&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; funa(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><strong>数学运算</strong></p><p>数学运算的方法在<cmath>头文件中。</cmath></p><p><strong>随机数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">j = rand()</span><br></pre></td></tr></table></figure><p><strong>数组</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">10</span>,<span class="number">10</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>字符串</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c风格字符串</span></span><br><span class="line"><span class="keyword">char</span> gre[] = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;gre;</span><br><span class="line"><span class="built_in">strcpy</span>(str1,str2); <span class="comment">// str2给str1赋值</span></span><br><span class="line"><span class="built_in">strcat</span>(str1,str2); <span class="comment">// str1+str2</span></span><br><span class="line"><span class="built_in">strcmp</span>(s1,s2);<span class="comment">//比较s1，s2</span></span><br><span class="line"><span class="built_in">strchr</span>(s1,ch); <span class="comment">// 返回指针，指针位置为ch第一次出现的位置</span></span><br><span class="line"><span class="built_in">strstr</span>(s1,s2);<span class="comment">// 放回指针，指向第一次出现s2的位置</span></span><br></pre></td></tr></table></figure><p><strong>string 字符串操作</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> a = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">string</span> b = <span class="string">"el"</span>;</span><br><span class="line">a.find_first_of(b); <span class="comment">// 等于a.find(b);</span></span><br><span class="line">a.find_last_of(b);</span><br><span class="line">s.size();</span><br><span class="line"><span class="keyword">if</span>(a.find(b) == <span class="built_in">string</span>::npos)&#123;</span><br><span class="line">    <span class="keyword">return</span> “dont exists”;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>指针</strong></p><p>cpp中每个变量都有一个内存位置，这个内存位置可以通过<code>&amp;</code> 取址符来得到，他表示内存中的一个地址。</p><p>指针是一个变量，它的值就是地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line"><span class="keyword">int</span> var = <span class="number">10</span>;</span><br><span class="line">ip = &amp;var;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ip; <span class="comment">//取去ip中的值</span></span><br><span class="line"><span class="keyword">int</span> *ptr[<span class="number">10</span>]; <span class="comment">//指针数组，数组中存指针</span></span><br><span class="line"><span class="comment">//指针可以允许加减，数组和指针很类似，一个定义在数组开头的指针用法和数组相同</span></span><br><span class="line"><span class="keyword">int</span> var[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">int</span> *ip = var;</span><br><span class="line">ip++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ip[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p><strong>引用</strong></p><p>引用变量是为变量起了一个别名，引用在创建的时候必须初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; r = a;</span><br><span class="line"><span class="comment">//传参数的时候可以使用引用，不用传值，快。</span></span><br><span class="line"><span class="comment">// 函数返回类型为引用类型的时候，操作和其他类型的一样，返回一个引用，就可以对这个引用进行赋值的过一些操作了。</span></span><br></pre></td></tr></table></figure><p><strong>结构体</strong></p><p>cpp中定义数据类型使用结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span> <span class="title">b1</span>;</span></span><br><span class="line"><span class="comment">//使用typedef定义别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Book</span>&#123;</span></span><br><span class="line">      <span class="keyword">int</span> count;</span><br><span class="line">      <span class="built_in">string</span> name;</span><br><span class="line">&#125;Book;</span><br><span class="line">Book b1,b2;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b1.name;</span><br><span class="line"><span class="comment">//指针调用</span></span><br><span class="line">Book *ptr = &amp;b1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ptr-&gt;name;</span><br></pre></td></tr></table></figure><p><strong>类</strong></p><p>类是cpp的核心，通常被用与用户定制自己的数据以及方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">int</span> width;</span><br><span class="line">      <span class="keyword">int</span> height;</span><br><span class="line">      Box(); <span class="comment">//构造函数，函数进行定义，初始化的入口</span></span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">get_area</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width*height;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Box b1; <span class="comment">//定义了一个Box的类型变量</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; b1.width;</span><br><span class="line">Box* ptr = &amp;b1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ptr-&gt;get_area();</span><br></pre></td></tr></table></figure><p><strong>拷贝构造函数</strong></p><p>利用已经存在的类对象，对新类进行初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box b2 = b1;</span><br></pre></td></tr></table></figure><p><strong>友元函数</strong></p><p>友元函数设计的思路是说，一个非A类内的函数，希望获得完整的A类内成员的访问权限，这时候需要在A类对该函数进行一下注册，用friend最为前缀（适用于多人协作的项目）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> mon;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">detial</span><span class="params">(A a1)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">detail</span><span class="params">(A a1)</span></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; a1.val; <span class="comment">//允许访问私有变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>this 指针</strong></p><p>成员函数均有一个隐含的this指针参数，用于指向对象。</p><p><strong>类内静态成员变量，静态函数</strong></p><p>类中允许定义static变量，该变量在所有类的对象中是共享的，该变量属于类，不属于对象，不可以在类的构造函数中初始化static变量，而是通过<code>A::变量 =  init</code>的方式进行初始化。</p><p>static声明的函数，与任何对象都没有关系，该函数与类同在，只能访问静态成员变量，与其他静态成员函数。</p><p><strong>继承</strong></p><p>我理解继承是这种大型工程中非常有灵性的一种设计，通过底层写一些通用的模版类，底下的继承类就有很好的一致性，以及少写了很多重复性的工作，此外通过子类中定制自己的成员，呈现一种放散式的结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">book</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> page = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">string</span> name = <span class="string">"island"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">detail</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt; <span class="keyword">this</span>.page &lt;&lt; <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">finance</span>:</span> <span class="keyword">public</span> book&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">    finance(<span class="keyword">int</span> pro);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">detail</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">finance::finance(<span class="keyword">int</span> pro):book()&#123;</span><br><span class="line">  <span class="keyword">this</span>.profit = pro;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> finance::detail()&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>.page &lt;&lt; <span class="keyword">this</span>.name &lt;&lt; <span class="keyword">this</span>.pro;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体来说，<strong>继承不会继承积累的构造函数，友元函数，重载运算符。</strong>从设计的角度上看，友元这一类函数会破坏类的封装性，子类不接受友元是很正确的决定，而构造函数有专门的作用，因此，不继承构造函数也是可以理解的。</p><p><strong>基类构造函数</strong></p><p>所谓的基类构造函数，构造的时候，需要对父类进行初始化，很容易理解。初始化的方式就是通过构造函数表来初始化，在构造函数定义的时候使用，成员变量也允许那时候初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">finance::finance(<span class="keyword">int</span> profit,<span class="keyword">int</span> page,<span class="built_in">string</span> name):Book(page,name),profit(profit)&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>重载运算符</strong></p><p>我认为这一步的设计思路是是我们设计的类和基础类型的变量能够使用一些类似于<strong>+，-，x，/</strong>这种方便的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">   Box <span class="keyword">operator</span>+(Box b)&#123;</span><br><span class="line">     Box box;</span><br><span class="line">     box.width = <span class="keyword">this</span>.width + b.width;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Box b1,b2;</span><br><span class="line">b = b1 + b2;</span><br></pre></td></tr></table></figure><p><strong>重载函数</strong></p><p>重载函数指的是同一个函数，但是随着输入的参数不同，调用的具体函数也是不同的。这样的设计思路在于，是一个函数用起来更加灵活，例如对于不同级别的类别都需要登入操作，但是入口不同。就可以利用重载的思路来实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">log</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> user = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> vip = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">int</span> user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">int</span> user,<span class="keyword">int</span> vip)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多态</strong></p><p>多态的设计思路，有这样一种情况，当子类与父类中同时有某个方法。我们可以用父类的指针来存放所有的子类的地址。但是每个子类调用一个工友的方法，各自应该有各自的方案。例如大家办护照都去公安局，但是每个人有不同的办理方案，这种情况就是多态。</p><p>要实现多态的话，在需要实现多态的函数前加上<strong>virtual</strong>关键字，告诉编译器，在编译的时候不要链接该函数，而是得到调用函数的时候，看变量的类型来确定用什么函数。这个叫<strong>做动态链接</strong>。</p><p>静态链接则是写死了，每次用父类的对象调用的都是父类的方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shape</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> width = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">    shape(<span class="keyword">int</span> w,<span class="keyword">int</span> h):width(w),height(h);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"shape"</span> ；</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">triangle</span>:</span><span class="keyword">public</span> shape&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    triangle(<span class="keyword">int</span> a,<span class="keyword">int</span> b):shape(a,b)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"triangle area"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> a*b / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rectangle</span>:</span><span class="keyword">public</span> shape&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    rectangle(<span class="keyword">int</span> a,<span class="keyword">int</span> b):shape(a,b)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"rectangle area"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> a*b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shape* sh;</span><br><span class="line"><span class="function">rectangle <span class="title">rec</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">triangle <span class="title">tri</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="comment">// 正方形面积</span></span><br><span class="line">sh = &amp;rec;</span><br><span class="line">sh-&gt;area();</span><br><span class="line"><span class="comment">// 三角形面积</span></span><br><span class="line">sh = $tri;</span><br><span class="line">sh-&gt;area();</span><br></pre></td></tr></table></figure><p><strong>虚基类virtual</strong></p><p>虚基类提出的设计思路是说，如果一个类同时继承两个类，而这两个类又同时继承自同一个父类，因此在子类这就会出现最高父类的两个拷贝。因此多继承很多时候会产生很多二义性的问题，因此在设计函数的时候要尽可能避免。出现这种情况可以用virtual进行虚继承。<code>class B : virtual public A{...}</code>。</p><p><strong>抽象类</strong></p><p>设计抽象类的设计思想是说，面向对象的系统可能会使用一个抽象基类为所有的外部应用程序提供一个适当的、通用的、标准化的接口。因此会在基类设计一个<strong>virtual</strong>抽象类，规定一下子类的接口参数的格式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shape</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    shape(<span class="keyword">int</span> a,<span class="keyword">int</span> b):width(a),weight(b)&#123;&#125;</span><br><span class="line">  <span class="comment">// 提供纯虚函数接口，子类必须覆盖</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">get_area</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rectangle</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    rectangle(<span class="keyword">int</span> a,<span class="keyword">int</span> b):shape(a,b)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_area</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.width*<span class="keyword">this</span>.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>文件的读写</strong></p><p>文件的读写定义在两个库函数中，<strong>ifstream,ofstream</strong>，写入过程使用&lt;&lt;，读出过程使用&gt;&gt;。</p><p><strong>异常处理</strong></p><p>cpp中提供了<code>try,catch,throw</code>用来保护代码，抛出错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//保护代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(ExceptionName e1)&#123;</span><br><span class="line">  <span class="comment">//catch 内容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(ExceptionName e2)&#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//catch 模块</span></span><br><span class="line"><span class="keyword">if</span>(error)&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">"error message"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>cpp动态内存</strong></p><p>栈：在函数内部声明的所有变量都将用栈来存储</p><p>堆：这部分内存程序未使用，在程序运行时可动态分配内存。</p><p>cpp允许使用<strong>new</strong>给变量分配堆内内存，返回动态内存的起始位置，同时可以使用<strong>delete</strong>将这部分内存删除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>* ptr = <span class="keyword">new</span> <span class="keyword">double</span>;</span><br><span class="line">*ptr = <span class="number">12.32</span>;</span><br><span class="line"><span class="comment">//数组申请空间</span></span><br><span class="line"><span class="keyword">int</span> * ptr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="keyword">delete</span>[] ptr;</span><br><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line"><span class="keyword">int</span> ** ptr = <span class="keyword">new</span> <span class="keyword">int</span> *[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  ptr[i] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">Box* ptr = <span class="keyword">new</span> Box[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">delete</span> [] ptr;</span><br></pre></td></tr></table></figure><p><strong>命名空间</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> first_space&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">     ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">first_space::func();</span><br></pre></td></tr></table></figure><p><strong>cpp模板</strong></p><p>模板指<strong>函数模板</strong>和<strong>类模板</strong>，是一种参数化类型机制，在泛型编程（泛型允许程序员使用<strong>未指定</strong>类型的变量，在<strong>实例化</strong>时作为参数指明这些类型）中十分的重要。常用的cpp模版例如<strong>vector</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 用T表示一种类型的变量</span></span><br><span class="line"><span class="function">T <span class="title">Max_val</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a &gt; b ? a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">Max_val(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">Max_val(<span class="number">1.2</span>,<span class="number">3.4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">stack</span>&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt; elems;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp; val)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">stack</span>&lt;T&gt;:</span>:push(T <span class="keyword">const</span>&amp; val)&#123;</span><br><span class="line">  elems.push(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; int_stack;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; str_stack;</span><br></pre></td></tr></table></figure><p><strong>const&amp;</strong></p><p>在一些库函数，模板类的函数中进场发现这种传参数，传指数的方法,这种方法用引用减少数值传递过程中需要消耗的时间。返回值是const&amp;是个引用，如果是const的话，程序还需要另外开辟空间。同时这样使用可以函数返回值还可以作为左值，因此建议今后写代码带上引用。</p><p><strong>void*</strong></p><p><code>void *</code>是一种指针类型，常用在<code>函数参数、函数返回值</code>中需要兼容不同指针类型的地方。它类似于指针类型中的原始基类，所有的指针可以对它赋值，它也可以转化为任何指针类型，但是是否合理需要看函数的原始定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* c;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> * ptr = &amp;a;</span><br><span class="line">c = ptr;</span><br><span class="line"><span class="keyword">int</span> * d = (<span class="keyword">int</span> *) c;</span><br></pre></td></tr></table></figure><p><strong>cpp多进程/线程</strong></p><ul><li>进程：程序需要并发执行</li><li>线程：一个进程中含多个线程，线程负责同一段程序中的并发</li></ul><p>使用 POSIX 编写多线程 C++ 程序。POSIX支持linux上的并行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 线程的运行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">say_hello</span><span class="params">(<span class="keyword">void</span>* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello Runoob！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义线程的 id 变量，多个变量使用数组</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tids[NUM_THREADS];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//参数依次是：创建的线程id，线程参数，调用的函数，传入的函数参数</span></span><br><span class="line">        <span class="keyword">int</span> ret = pthread_create(&amp;tids[i], <span class="literal">NULL</span>, say_hello, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="built_in">cout</span> &lt;&lt; <span class="string">"pthread_create error: error_code="</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等各个线程退出后，进程才结束，否则进程强制结束了，线程可能还没反应过来；</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>cpp中的STL（standard template library）</strong></p><p>STL库中包含了许多模板类，实现了很多容器，算法以及迭代器等等。</p><ul><li>算法algorithm：这些算法类大多是作用在容器上<ul><li><code>sort(begin_adress,end_adress)</code>，用于数组的排序</li></ul></li><li>容器：如vector，map，set等等</li><li>迭代器</li><li>Functors：算子，类似于sort的时候用算法自定义排序的方式，作为参数传入</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cpp的一些基本的语法的回顾，主要是一些比较小规模的语法特性的记录。&lt;/p&gt;
&lt;p&gt;​
    
    </summary>
    
    
      <category term="learning cpp" scheme="https://wenhui-zhou.github.io/tags/learning-cpp/"/>
    
  </entry>
  
  <entry>
    <title>DeepLab 总结</title>
    <link href="https://wenhui-zhou.github.io/2019/10/22/DeepLab-%E6%80%BB%E7%BB%93/"/>
    <id>https://wenhui-zhou.github.io/2019/10/22/DeepLab-总结/</id>
    <published>2019-10-22T02:15:32.000Z</published>
    <updated>2019-10-25T10:46:48.770Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="项目总结" scheme="https://wenhui-zhou.github.io/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>cpp工程文件的总结</title>
    <link href="https://wenhui-zhou.github.io/2019/10/21/cpp%E5%B7%A5%E7%A8%8B%E6%96%87%E4%BB%B6%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>https://wenhui-zhou.github.io/2019/10/21/cpp工程文件的总结/</id>
    <published>2019-10-21T15:52:15.000Z</published>
    <updated>2019-10-26T02:58:03.860Z</updated>
    
    <content type="html"><![CDATA[<p>cpp学习的第一轮，首先从以前的盲区开始杀进去，解决的第一个问题是</p><blockquote><p>人们说cpp工程文件，说的都是什么。</p></blockquote><a id="more"></a><p>打开vs，创建一个控制台的应用。（CLion用cmakeList链接文件，感觉可以学习一下）这时候会产生很多中间系统文件以及文件夹。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cpp学习的第一轮，首先从以前的盲区开始杀进去，解决的第一个问题是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;人们说cpp工程文件，说的都是什么。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="learning cpp" scheme="https://wenhui-zhou.github.io/tags/learning-cpp/"/>
    
  </entry>
  
  <entry>
    <title>文献阅读：基于RealSense和模型库的人体建模方法</title>
    <link href="https://wenhui-zhou.github.io/2019/10/18/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB%EF%BC%9A%E5%9F%BA%E4%BA%8ERealSense%E5%92%8C%E6%A8%A1%E5%9E%8B%E5%BA%93%E7%9A%84%E4%BA%BA%E4%BD%93%E5%BB%BA%E6%A8%A1%E6%96%B9%E6%B3%95/"/>
    <id>https://wenhui-zhou.github.io/2019/10/18/文献阅读：基于RealSense和模型库的人体建模方法/</id>
    <published>2019-10-18T08:55:32.000Z</published>
    <updated>2019-10-25T09:40:05.651Z</updated>
    
    <content type="html"><![CDATA[<p>这篇论文是张远师兄的毕业论文，主要的思路是通过深度模型预测类别，进而补全模型深度信息，然后通过学习模型参数，最终实现对人体的建模以及测量。</p><a id="more"></a><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>人体建模经历了 1. 基于回归分析的人体建模 2. 基于三维扫描人体建模 3. 基于数据库人体建模。人体建模的精度越来越高，对场景的约束越来越低。</p><p>本文通过基于RGBD信息与模型数据库的人体建模技术，提升人体建模的精度。主要的工作有：</p><ol><li><p>提出一种基于RGB数据的<strong>人体深度类别</strong>预测方法</p></li><li><p>提出一种基于深度类别信息的人体<strong>深度数据补全</strong>与优化方法</p></li><li>提出一种<strong>基于RGBD数据</strong>和<strong>模型参数</strong>的人体建模方法</li></ol><h3 id="基于RGB预测人体深度类别"><a href="#基于RGB预测人体深度类别" class="headerlink" title="基于RGB预测人体深度类别"></a>基于RGB预测人体深度类别</h3><p>基于RGB数据来预测人体的深度信息，本文提出了两阶段的网络结构，用于RGB图像中的人体深度类别预测。该部分主要分为两部分：</p><ul><li>预测图像中的人体分割</li><li><p>预测人体分割对应的深度信息</p><p>针对人体不变的局部特征和多变的全局特征，作者采用多尺度信息融合的方式提取特征，采用跳跃层结构，使用Stacked hourglass network作为基本网络，使用交叉熵作为损失函数，分别应用与人体部件分割以及深度类别的预测上。</p></li></ul><p>针对这两个问题，作者使用Varol et al.(CVPR 2017) 提到的方法对人体进行分割以及预测人体的深度类别信息。该网络深度信息预测结果不好，作者通过扩充网络，将网络修改成二阶段的网络，获取原始数据多尺度的结果之后得到一个较好的恢复结果。</p><p><img src="/images/3D/deep_predict.png" style="zoom:50%;"></p><p>左图第二行是分割信息，有图中间一列是Varol的结果，最后一列是本文结果。</p><h3 id="基于深度类别信息的人体深度数据补全与优化"><a href="#基于深度类别信息的人体深度数据补全与优化" class="headerlink" title="基于深度类别信息的人体深度数据补全与优化"></a>基于深度类别信息的人体深度数据补全与优化</h3><p>对RGB图像进行标定，作者使用realsense内部的标定算法实现标定。接下来对深度数据进行恢复，主要有两种方案，一种是基于滤波器的方法，另一种则是基于图像修复重建的方案。第一种方案难以修复比较大的空洞，第二种方案引入图像修复技术，通常会假设人体深度数据与RGB数据呈现局部线性关系，作者认为由于人的衣服颜色相同，因此不适用于这两种方案。</p><p>作者使用快速行进法（Telea 2004）(FMM)进行空洞的补全，该方法的思路是从已知的像素点和位置的像素点的边界开始计算，逐渐扩展到所有位置的像素点，求解出深度图。作者首先对其RGBD图像之后，对目标图像I上的任意一点深度，采用对周边点的一阶泰勒展开来得到。使用RGB图像上的梯度来替换深度图对应位置上的梯度，最终得到目标图像上的深度计算公式：<br>$$<br>I(p)=I(q)+\nabla I_{p}(q)(p-q)<br>$$<br>使用RGB图像上的梯度来替换深度图对应位置上的梯度，最终得到目标图像上的深度计算公式：<br>$$<br>I(p)=\frac{\sum w(p, q)\left[I(q)+s \cdot \nabla C_{p}(q)(p-q)\right]}{\sum w(p, q)}<br>$$<br>通过快速行进法，使用RGB梯度代替目标图像的梯度的方式，作者命名为GradientFMM，梯度的快速行进法。</p><p>在图像滤波上，作者使用了<strong>引导滤波</strong>的方法，对整张深度图像进行滤波。</p><h3 id="基于RGBD数据和模型参数的人体建模与测量"><a href="#基于RGBD数据和模型参数的人体建模与测量" class="headerlink" title="基于RGBD数据和模型参数的人体建模与测量"></a>基于RGBD数据和模型参数的人体建模与测量</h3><p>作者基于数据库学习出一种人体模型的参数表示方式，能够很好的表示出人体姿势的变化，从而使一个标准的人体形变后和点云数据相互拟合。随后建立一个融合点云数据和人体参数的能量优化模型，得到配准的人体三维模型。</p><p>能量函数（Bouaziz et al 2014）提出一种 能量函数泛式来解决配准问题，他包含数据匹配和参数先验能量。<br>$$<br>E = E_{match} + E_{prior}<br>$$<br>作者研究，对于刚体形变或非刚体形变本质上都是期望最大化算法。EM算法本上是一个非凸优化问题。因此上诉配准问题不一定能收敛到最优解。</p><p>作者使用SCAPE数据集，里头包含1517个男性和1531个女性在不同姿势下的模型，对于每一个人人体模型，都包含12500个顶点和25000个三角面片。对于人体的三维变形，本质上就是对人体网格的三角面片进行变形。 作者通过计算标准模型到每一块面片的参数变换的Q，R，S矩阵，得到整个数据集所有的变换矩阵。因此可以通过不用的姿势，体型参数，可以得到一组Q，R，S然后从标准的模型中，得到目标的模型。</p><p>随后利用能量函数（数据匹配能量以及人体先验能量函数）来无限的拟合人体参数模型和采集到的深度数据之间的距离，得到一个较为真实的人体模型。项目到此结束。</p><h3 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h3><p>做鱼类RGBD数据的三维重建工作，我觉得我的工作可能集中在深度数据的恢复，水下场景的去噪算法，光线折射的还原，空洞的补全这些部分上。对于最后和标准的三维模型去拟合这一部分的工作我可能没办法完成了。</p><p>然后使用到cpp，绘制部分的工作可以用恢复了一部分的深度数据来完成。</p><p>那么近期的工作就十分的清楚了，关注人体的恢复实验，找到一些深度学习的算法，恢复出人体，然后针对鱼进行优化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇论文是张远师兄的毕业论文，主要的思路是通过深度模型预测类别，进而补全模型深度信息，然后通过学习模型参数，最终实现对人体的建模以及测量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="3D重建" scheme="https://wenhui-zhou.github.io/tags/3D%E9%87%8D%E5%BB%BA/"/>
    
  </entry>
  
</feed>

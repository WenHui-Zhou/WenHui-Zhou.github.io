<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WenHuiZhou</title>
  
  <subtitle>perper（打起精神！）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wenhui-zhou.github.io/"/>
  <updated>2019-12-24T08:37:40.791Z</updated>
  <id>https://wenhui-zhou.github.io/</id>
  
  <author>
    <name>WenHuiZhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>bert的一些思考</title>
    <link href="https://wenhui-zhou.github.io/2019/12/19/bert%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>https://wenhui-zhou.github.io/2019/12/19/bert的一些思考/</id>
    <published>2019-12-19T07:00:31.000Z</published>
    <updated>2019-12-24T08:37:40.791Z</updated>
    
    <content type="html"><![CDATA[<p>观其大致，能够比较好的融会贯通，理解整个任务。这是这篇post的主要目的。</p><a id="more"></a><p>Bert的应用模式</p><p>bert在应用到具体的任务上时，通常采用两阶段策略：</p><ul><li>第一阶段利用通用语言模型任务，采用自监督的学习方法，选择某个具体的特征抽取器，来学习预训练模型</li><li>第二个阶段，根据手头具体的监督学习任务，采取特征集成或finetune的应用模型，</li></ul><p>总之，加载预训练模型，然后为不同的任务定制第二阶段的定制网络</p><p><strong>特征集成任务</strong></p><p>ELMO方法是典型的特征集成方式，把当前要判断的输入句子，走一遍ELMO预训练好的的双层双向LSTM网络，然后把每个输入单词对应位置的高层LSTM激活embedding（或者输入单词对应位置的若干层embedding进行加权求和），作为下游任务单词对应的输入。</p><p>这是一种典型的应用预训练模型的方法，更侧重于单词的上下文特征表达方面。</p><p><strong>finetune模式</strong></p><p>GPT和bert采用finetune应用模式，在获得了预训练模型以及对应的网络结构（Transformer）后，第二个阶段仍然采用与预训练过程相同的网络结构，拿出手头任务的部分训练数据，直接在这个网络上进行模型训练，以针对性地修正预训练阶段获得的网络参数，一般这个阶段被称为Fine-tuning。</p><p><strong>搜索引擎的未来就是QA和阅读理解</strong>：搜索引擎通过理解文本，对于用户提出的问题直接给出答案。</p><p><strong>Bert生成式任务</strong></p><p>例如将bert用在生成式摘要任务中。从技术角度上来讲，生成式任务符合典型的encoder-decoder框架。encoder部分好解决，只需要用预训练好的Bert模型初始化encoder部分的transformer即可。另一方面是decoder端。大量的实验证明直接将bert的预训练参数用来初始化decoder的部分效果都不好。主要原因是bert预训练的时候使用的是双向的语言模型，而一般的decoder任务是从左到右依次生成的，无法利用bert在预训练阶段学到的上下文信息。这也是bert在做生成类任务时遇到的最大问题。</p><p><strong>如何用bert</strong></p><p>简而言之，使用bert的核心在于使用transformer作为特征提取器，用bert预训练模型初始化transformer参数，然后再用当前的任务去finetune。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;观其大致，能够比较好的融会贯通，理解整个任务。这是这篇post的主要目的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="NLP" scheme="https://wenhui-zhou.github.io/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>pytorch 重点回顾</title>
    <link href="https://wenhui-zhou.github.io/2019/12/09/pytorch-%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE/"/>
    <id>https://wenhui-zhou.github.io/2019/12/09/pytorch-重点回顾/</id>
    <published>2019-12-09T07:57:45.000Z</published>
    <updated>2019-12-18T02:17:08.305Z</updated>
    
    <content type="html"><![CDATA[<p>pytorch 在日常实践中的一些常用的函数，工作流。</p><a id="more"></a><h3 id="pytorch-简介"><a href="#pytorch-简介" class="headerlink" title="pytorch 简介"></a>pytorch 简介</h3><p>pytorch是一个基于torch的python开源库。前身torch是一个有大量机器学习算法支持的科学计算框架，以及与numpy类似的张量操作库。通过pytorch的反向求导技术，可以实现动态的修改神经网络，实现速度快是一大特点。</p><p>缺点是全面性不如TensorFlow，移动端的部署性能有待提升。</p><h3 id="张量tensors"><a href="#张量tensors" class="headerlink" title="张量tensors"></a>张量tensors</h3><p>张量在神经网络中大量的应用，支持pytorch的反向求导，可以和numpy库互换，GPU计算，是pytorch中的<strong>砖块</strong>的角色。</p><p><strong>创建张量</strong></p><p>在深度学习中，<code>torch.float</code>类型使用比较多，常见的，当我们使用tensor申请参数的时候，常用的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 申请一个未初始化的矩阵</span></span><br><span class="line">x = torch.empty(<span class="number">3</span>,<span class="number">3</span>) <span class="comment"># 大小为3x3的一个矩阵，数字可以无限加，每一个数值表示一个矩阵</span></span><br><span class="line"><span class="comment"># 随机初始化，感觉这个会用的比较多一点</span></span><br><span class="line">x = torch.rand(<span class="number">24</span>,<span class="number">24</span>,<span class="number">3</span>，dtype = torch.float) <span class="comment"># 大小为24x24x3，dtype = float</span></span><br><span class="line">x = torch.zeros(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>) <span class="comment">#维度为3x3x3</span></span><br><span class="line"><span class="comment"># 直接使用数据来构造</span></span><br><span class="line">x = torch.tensor([<span class="number">5.1</span>,<span class="number">1</span>]) </span><br><span class="line"><span class="comment"># 使用已经存在的数据来构造</span></span><br><span class="line">x = x.new_ones(<span class="number">5</span>,<span class="number">4</span>,dtype=  torch.double)</span><br><span class="line">x = torch.randn_like(x,dtype = torch.float) <span class="comment"># 维度与之前的x相同</span></span><br><span class="line">x.size() <span class="comment"># 返回一个tuple，表示tensor的维度</span></span><br></pre></td></tr></table></figure><p><strong>张量操作</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#加法</span></span><br><span class="line">z =  x + y</span><br><span class="line"><span class="comment">#减法</span></span><br><span class="line">z = x - y</span><br><span class="line"><span class="comment"># 获得float的输出（而不是tensor）</span></span><br><span class="line">x.item()</span><br><span class="line"><span class="comment"># 改变tensor的形状</span></span><br><span class="line">x.view(<span class="number">16</span>) <span class="comment"># 变成1*16的向量</span></span><br><span class="line">x.view(<span class="number">-1</span>,<span class="number">4</span>)<span class="comment"># 4x4的向量</span></span><br><span class="line">x.view(<span class="number">-1</span>,<span class="number">2</span>,<span class="number">2</span>)<span class="comment"># 2x2x2的向量</span></span><br><span class="line"><span class="comment"># tensor支持所有的numpy切片操作</span></span><br><span class="line">x[:<span class="number">10</span>]</span><br><span class="line"><span class="comment"># cat拼接向量</span></span><br><span class="line">torch.cat((x,y),dim = <span class="number">0</span>) <span class="comment"># y轴方向</span></span><br><span class="line">torch.cat((x,y),dim = <span class="number">1</span>) <span class="comment"># x轴方向</span></span><br><span class="line"><span class="comment"># chunk，向量拆分</span></span><br><span class="line">x.chunk(chunks = <span class="number">3</span>,dim = <span class="number">0</span>) <span class="comment"># y方向，等分成三份，第三份可能会少一点</span></span><br><span class="line">x.chunk(chunks = <span class="number">3</span>,dim = <span class="number">1</span>) <span class="comment"># x方向</span></span><br><span class="line"><span class="comment"># 截断</span></span><br><span class="line">x.clamp(<span class="number">0.3</span>,<span class="number">0.7</span>) <span class="comment"># 数值限制在这个范围</span></span><br><span class="line">x.sort(dim = <span class="number">0</span>) <span class="comment"># 沿着x方向排序，返回下标</span></span><br><span class="line">x.flatten() <span class="comment"># 将向量展成一列</span></span><br><span class="line"><span class="comment"># 选择前topK</span></span><br><span class="line">x.topk(<span class="number">2</span>,dim=<span class="number">0</span>) <span class="comment"># 返回 值以及下标</span></span><br><span class="line">x.numel()<span class="comment">#返回所有元素</span></span><br><span class="line">torch.stack((x,y), dim = <span class="number">0</span>/<span class="number">1</span>) <span class="comment"># 保留维度，然后将向量组合在一起</span></span><br><span class="line">x.permute(<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>) <span class="comment"># 调整每一维度向量的先后</span></span><br><span class="line">x.squeeze(dim = <span class="number">1</span>) <span class="comment"># 维度为1的坍缩</span></span><br><span class="line">x.unsqueeze(dim = <span class="number">0</span>) <span class="comment"># 增加一个维度为1的</span></span><br><span class="line">x.cuda() <span class="comment"># 放回在GPU上的拷贝</span></span><br><span class="line">torch.where(x&gt;<span class="number">0</span>,x,y) <span class="comment"># x&gt;0 返回x，否则返回y</span></span><br><span class="line">x.round() <span class="comment"># 取整</span></span><br><span class="line">x.contiguous() <span class="comment"># 转成连续存储模式 </span></span><br><span class="line">x.numpy() <span class="comment"># 返回numpy格式</span></span><br><span class="line">x = torch.from_numpy(a) <span class="comment"># numpy转成tensor</span></span><br></pre></td></tr></table></figure><h3 id="pytorch自动微分"><a href="#pytorch自动微分" class="headerlink" title="pytorch自动微分"></a>pytorch自动微分</h3><p>autograd包是pytorch所有神经网络的核心，autograd为tensor上所有的操作提供自动微分。当我们在定义一个tensor的时候，将<code>requires_grad</code>设置成true，pytorch将会开始跟踪该tensor的所有操作。<code>backward()</code>将会自动计算所有的梯度。</p><p>要停止计算梯度可以使用detach()，或者使用<code>with torch.no_grad()</code>包起来。每个张量都有一个grad_fn的属性，这个属性保存着一个Function的引用，保存计算过程的完整信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = torch.ones(<span class="number">2</span>,<span class="number">2</span>,requires_grad = <span class="keyword">True</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">x = tensor([[1,1],</span></span><br><span class="line"><span class="string">             [1,1]],requires_grad = True)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">y = x + <span class="number">2</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">y = tensor([[3,3],[3,3]],grad_fn = &lt;AddBackward0&gt;)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="搭建神经网络"><a href="#搭建神经网络" class="headerlink" title="搭建神经网络"></a>搭建神经网络</h3><p>神经网络可以通过torch.nn来构建。一个nn.Module包含层以及一个正向传播的方法,<code>forward()</code>。一个典型的神经网络训练过程包括以下几点：</p><ol><li>定义一个包含可训练参数的神经网络</li><li>迭代整个输入</li><li>通过神经网络处理输入</li><li>计算loss</li><li>反向传播梯度到神经网络的参数</li><li>更新网络的参数，使用一些优化器等</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">      super(net,self).__init__()</span><br><span class="line">      <span class="comment"># 定义一些层</span></span><br><span class="line">      .</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">      <span class="comment"># x 为输入，下面是定义网络正向传播的过程</span></span><br><span class="line">      .</span><br><span class="line">nets = net()</span><br><span class="line">print(nets) <span class="comment"># 输出net的结构信息</span></span><br><span class="line">net.parameters() <span class="comment"># 得到net中的所有的参数</span></span><br><span class="line"></span><br><span class="line">net.zero_grad() <span class="comment"># 将所有参数梯度缓存置零</span></span><br><span class="line"></span><br><span class="line">output = nets(input)</span><br><span class="line">target = torch.rand(<span class="number">10</span>)</span><br><span class="line">target = target.view(<span class="number">1</span>,<span class="number">-1</span>)</span><br><span class="line">criterion = nn.MSELoss() <span class="comment"># 定义loss</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数更新规则</span></span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line">optimizer = optim.SGD(net.parameters(),lr = <span class="number">0.01</span>)</span><br><span class="line">optimizer.zero_grad()</span><br><span class="line">output = nets(input)</span><br><span class="line">loss = criterion(output,target)</span><br><span class="line">loss.backward()</span><br><span class="line">optimizer.step()</span><br></pre></td></tr></table></figure><p><strong>处理数据</strong></p><ul><li>处理图像时，我们可以使用pillow，opencv这些库</li><li>处理语音时，我们可以使用scipy，librosa</li><li>处理文本，可以使用python的基础数据加载模块，或者使用NTLK，SpaCy这些库</li></ul><p><strong>GPU数据处理</strong></p><p>如何将数据转移到GPU上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">device = torch.device(<span class="string">'cuda:0,1,2,3'</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">'cpu'</span>)</span><br><span class="line">net.to(device)</span><br><span class="line"><span class="comment"># 输入，输出也有传输到gpu上</span></span><br><span class="line">inputs,labels = inputs.to(device),labels.to(devices)</span><br></pre></td></tr></table></figure><p>pytorch默认使用一个GPU，我们可以通过<code>DataParallel()</code>来设定模型在GPU上跑。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line">model = DataParallel(model)</span><br></pre></td></tr></table></figure><p>尽管我们的模型只获得一个输入，执行一个线性操作，然后输出。数据并行操作自动拆分了你的数据，将任务单发到多个GPU上。当每一个模型都完成自己的任务，DataParallel收集这些结果，然后返回到输出中。（代码形式是线性的，但是程序执行的时候是并行的）</p><p>代码见github链接。</p><p><strong>数据类</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset,DataLoader</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">own_dataset</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,data)</span>:</span></span><br><span class="line">    self.data = data</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self,index)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.data[index]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(self.data)</span><br><span class="line">data_loader = DataLoader(own_dataset,batch_size = <span class="number">4</span>,num_works = <span class="number">2</span>,shuffle = <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>继承Dataset需要实现其中的<code>__getitem__()</code>，<code>__len__()</code>方法。</p><p>继而实现dataLoader类，作为一个迭代器，每次向model中喂数据，batch_size这些参数都在这里设置。</p><p>如何将自己的数据转化成DataLoader的类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.utils.data <span class="keyword">as</span> Data</span><br><span class="line">x = torch.rand(<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">y = torch.rand(<span class="number">10</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 转换成dataset</span></span><br><span class="line">datas = Data.TensorDataset(x ,y)</span><br><span class="line">lloader = DataLoader(datas,batch_size=<span class="number">4</span>,shuffle=<span class="keyword">True</span>)</span><br><span class="line"><span class="keyword">for</span> data_x,data_y <span class="keyword">in</span> lloader:</span><br><span class="line">    print(data_x,data_y)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p><strong>python</strong></p><h3 id="pytorch-迁移学习"><a href="#pytorch-迁移学习" class="headerlink" title="pytorch 迁移学习"></a>pytorch 迁移学习</h3><p>事实上，很少人从头开始训练一个完整的网络。通常的做法是在一个很大的数据集上进行预训练，得到网络的初始化参数，或者固定这些参数，去优化下游任务。</p><p><strong>保存、加载模型</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># save 参数</span></span><br><span class="line">torch.save(model.state_dict(),<span class="string">'my_resnet.pth'</span>)</span><br><span class="line">resnet = ResNet()</span><br><span class="line">resnet.load_state_dict(torch.load(<span class="string">'my_resnet.pth'</span>))</span><br><span class="line"><span class="comment"># save 模型结构</span></span><br><span class="line">torch.save(model,<span class="string">'my_resnet.pth'</span>)</span><br><span class="line">resnet = torch.load(<span class="string">'my_resnet.pth'</span>)</span><br><span class="line"><span class="comment"># 保存checkpoint</span></span><br><span class="line">torch.save(&#123;</span><br><span class="line">  <span class="string">'epoch'</span>:epoch,</span><br><span class="line">  <span class="string">'model_state_dict'</span>:model.state_dict(),</span><br><span class="line">  <span class="string">'optimizer_state_dict'</span>:optimizer.state_dict(),</span><br><span class="line">  <span class="string">'loss'</span>:loss,</span><br><span class="line">  .</span><br><span class="line">&#125;, PATH)</span><br><span class="line"></span><br><span class="line"><span class="comment"># DataParallel模型的保存使用：</span></span><br><span class="line">torch.save(model.module.state_dict(),PATH)</span><br></pre></td></tr></table></figure><p><strong>加载部分预训练参数</strong></p><p>有些场景我们基于一个基础网络做的，因此我们需要为主干网络进行初始化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pretrain = model_zoo.load_url(model_urls[<span class="string">'resnet152'</span>])</span><br><span class="line">model_dict = model.state_dict()</span><br><span class="line">pretrain = &#123;k:v <span class="keyword">for</span> k,v <span class="keyword">in</span> pretrain.items() <span class="keyword">if</span> k <span class="keyword">in</span> model_dict&#125;</span><br><span class="line">model_dict.update(pretrain)</span><br><span class="line">model.load_state_dict(model_dict)</span><br></pre></td></tr></table></figure><h3 id="当一个batch中，句子不等长的时候"><a href="#当一个batch中，句子不等长的时候" class="headerlink" title="当一个batch中，句子不等长的时候"></a>当一个batch中，句子不等长的时候</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn.utils.rnn <span class="keyword">as</span> rnn_utils</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torch.utils.data <span class="keyword">as</span> data</span><br><span class="line">train  = [tensor([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]),tensor([<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]),tensor([<span class="number">6</span>,<span class="number">6</span>])]</span><br><span class="line"><span class="comment"># 将train 变量的长度补全后面补上0，使得其长度一致</span></span><br><span class="line">x = rnn_utils.pad_sequence(train, batch_first=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># 由于直接用上面的变长变量，会增加很多工作，因此我们需要pack，将向量的长度减小</span></span><br><span class="line"><span class="comment"># 其中第二个参数为每一个序列，实际的长度</span></span><br><span class="line"><span class="comment"># 返回值为：data=tensor([1., 3., 6., 1., 3., 6., 1., 3., 1., 3., 1., 3., 1., 1.]),</span></span><br><span class="line"><span class="comment">#          batch_sizes=tensor([3, 3, 2, 2, 2, 1, 1]))</span></span><br><span class="line">x = rnn_utils.pack_padded_sequence(x,[<span class="number">7</span>,<span class="number">5</span>,<span class="number">2</span>],batch_first = <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面函数为上面函数的逆函数，恢复填充0之后的tensor</span></span><br><span class="line">x = rnn_utils.pad_packed_sequence(x,batch_first = <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p><strong>pytorch库的大致功能</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn <span class="comment"># 包含的大量的网络层nn.Linear() 等等</span></span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset,DataLoader <span class="comment"># 包含了数据读取的方式</span></span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F <span class="comment"># 包含了激活函数等</span></span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim <span class="comment"># 包含了优化器</span></span><br><span class="line"><span class="keyword">import</span> torch.nn.utils.rnn <span class="keyword">as</span> rnn <span class="comment"># rnn中的一些方法</span></span><br></pre></td></tr></table></figure><h3 id="机器翻译模型"><a href="#机器翻译模型" class="headerlink" title="机器翻译模型"></a>机器翻译模型</h3><p>将词转化成可以输入网络的格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="comment"># 首先经过一系列的分词，去除不正确的词</span></span><br><span class="line"><span class="comment"># 建立词向量表，用随机值初始化</span></span><br><span class="line">embed = nn.embedding(n_vocabulary,embedding_size) <span class="comment">#字典的字数，每个词向量的长度</span></span><br><span class="line"><span class="comment"># embedding是一个二维的矩阵，y轴方向为每个单词，x轴为词向量的具体表示</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">word2vec</span><span class="params">(input_seq)</span>:</span></span><br><span class="line">  <span class="comment"># input_seq是一个batch，含有多个句子，但是句子的长度不一致，</span></span><br><span class="line">  <span class="comment"># 因此需要将句子的长度补充到一致的水平</span></span><br><span class="line">  <span class="comment"># 可以使用nn.utils.rnn.pad_sequence(x,batch_first = True)</span></span><br><span class="line">  words = nn.utils.rnn.pad_sequence(x,batch_first = <span class="keyword">True</span>)</span><br><span class="line">  <span class="comment"># 输入的数据每次喂给模型的为batch中句子的第n列词，因此需要把维度改为seq*batch</span></span><br><span class="line">  words = word.T</span><br><span class="line">  embed_word = embed(words) <span class="comment"># 将词替换成词向量</span></span><br><span class="line">  <span class="comment"># 下一步送入模型之前，对填充变量进行压缩</span></span><br><span class="line">  x = rnn_utils.pack_padded_sequence(x,lengths = [<span class="number">7</span>,<span class="number">5</span>,<span class="number">2</span>],batch_first = <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>上述过程就得到了输入数据的格式。通常机器翻译模型由encoder和decoder的机构组成。</p><p><img src="/images/nlp/seq1.png" style="zoom:50%;"></p><p>Encoder将句子编码成一个语义向量，decoder一个一个产生目标单词，根据之前的单词，产生之后的单词：</p><p><img src="/images/nlp/seq2.png" style="zoom:50%;"></p><p>具体如何选择encoder和decoder有非常多的选择（LSTM，GRU）等等。</p><p><strong>下面实现encoder部分:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搭建encoder模型</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">encoder的输入input_seq大小为【最大句子长度*batch-size】</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EncoderRNN</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,hidden_size,embedding,n_layers=<span class="number">1</span>,dropout=<span class="number">0</span>)</span>:</span></span><br><span class="line">        super(EncoderRNN,self).__init__()</span><br><span class="line">        self.n_layers = n_layers</span><br><span class="line">        self.hidden_size = hidden_size</span><br><span class="line">        self.embedding = embedding</span><br><span class="line">        self.gru = nn.GRU(hidden_size,hidden_size,n_layers,droput=(<span class="number">0</span> <span class="keyword">if</span></span><br><span class="line">                          n_layers==<span class="number">1</span> <span class="keyword">else</span> dropout),bidirectional=<span class="keyword">True</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,input_seq,input_lengths,hidden=None)</span>:</span></span><br><span class="line">        embedded = self.embedding(input_seq) <span class="comment"># 转化成词向量</span></span><br><span class="line">        packed = nn.utils.rnn.pack_paded_sequence(embedding,input_lengths)<span class="comment"># 压缩</span></span><br><span class="line">        <span class="comment"># 整体的一个output，和最后一层的hidden输出</span></span><br><span class="line">        outputs,hidden = self.gru(packed,hidden)</span><br><span class="line">        <span class="comment"># 将tensor填充到维度一致，还返回一个每个句子的长度</span></span><br><span class="line">        outputs,_ = nn.utils.rnn.pad_packed_sequence(outputs) </span><br><span class="line">        <span class="comment"># 将正反两向的值相加</span></span><br><span class="line">        outputs = outputs[:,:,:self.hidden_size] + output[:,:,:self.hidden_size] </span><br><span class="line">        <span class="keyword">return</span> outputs,hidden</span><br></pre></td></tr></table></figure><p><strong>GRU的使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gru = torch.nn.GRU(input_size,hidden_size,n_layers)</span><br><span class="line"><span class="comment"># 这里的input_size就是词向量的维度，hidden_size就是RNN隐藏层的维度，这两个一般相同就可以</span></span><br><span class="line"><span class="comment"># n_layers是GRU的层数</span></span><br><span class="line"><span class="comment"># GRU实现自身迭代，不需要时间步数</span></span><br><span class="line"><span class="comment"># GRU的输入是经过pack后的向量</span></span><br><span class="line"><span class="comment"># GRU的输出有两个，分别为整体的输出和最后一层的hidden</span></span><br></pre></td></tr></table></figure><p>注意力机制的应用：</p><p><img src="/images/nlp/seq3.png" style="zoom:67%;"></p><p>上面$h_s$表示GRU向上的所有输出，用来分类。$h_t$表示GRU向右的输出，是隐藏状态值。</p><p>由上面分析，最终权重将会有三种计算方式：</p><ul><li><p>第一个是直接将输出和隐藏状态的输出相乘，linear层的输出作为权重。</p></li><li><p>第二种方式是加入一个linear层，输入为output。linear的输出再乘以hidden。</p></li><li>第三种首先hidden转化为output的shape，然后将hidden和output串在一起，经过一个linear层，之后用tanh激活函数，最后用hidden_shape的value乘以tanh的输出，得到最后权重</li></ul><p>但是这个还没完，最后还要经过一个softmax，才能得到最终的权重，然后乘以output，作为decoder的输入。</p><p><strong>下面是attention第三种公式的实现部分</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">atten</span><span class="params">(nn.Moudle)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,hidden_size)</span>:</span></span><br><span class="line">        super(atten,self).__init__()</span><br><span class="line">        self.fc = linear(hidden_size*<span class="number">2</span>,hidden_size)</span><br><span class="line">        self.v = nn.Parameter(torch.FloatTensor(hidden_size))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,hidden,encoder_output)</span>:</span></span><br><span class="line">        x = torch.cat((hidden.expand(encoder_output.size(<span class="number">0</span>),<span class="number">-1</span>,<span class="number">-1</span>),</span><br><span class="line">                       encoder_output),<span class="number">2</span>)</span><br><span class="line">        x = self.fc(x) <span class="comment"># shape = [hidden_size,hidden]</span></span><br><span class="line">        x = F.tanh(x)</span><br><span class="line">        x = torch.sum(self.v * x,dim = <span class="number">2</span>)</span><br><span class="line">        x = F.softmax(x.T,dim = <span class="number">1</span>).unsqueze(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>最后的输出转置之后，经过一个softmax转换成概率之后，输出。</p><p>decoder接受encoder部分的hidden-state，即句子的深层特征。然后输入全是<code>&lt;SOS&gt;</code>，即句子的结束符。所以首先decoder需要进行word2vec，然后接受encoder的中间层的输出，最后得到decoder的output（可能会有全连接层），然后输出结果和target计算一个loss。</p><p>下面实现以下decoder的部分，包括输入的形成以及decoder最后的输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># decoder 部分</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">decoder</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,embedding,hidden_size,n_layers = <span class="number">1</span>,dropout=<span class="number">0.1</span>)</span>:</span></span><br><span class="line">        super(decoder,self).__init__()</span><br><span class="line">        self.hidden_size = hidden_size <span class="comment"># encoder,decoder都会用到</span></span><br><span class="line">        self.n_layers = n_layers</span><br><span class="line">        self.dropout = dropout</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 定义decoder的层</span></span><br><span class="line">        self.embedding = embedding</span><br><span class="line">        self.embedding_dropout = nn.Dropout(dropout)</span><br><span class="line">        self.gru = nn.GRU(hidden_size,hidden_size,n_layers,dropout)</span><br><span class="line">        self.fc1 = nn.Linear(hidden_size*<span class="number">2</span>,hidden_size)</span><br><span class="line">        self.fc2 = nn.Linear(hidden_size,hidden_size)</span><br><span class="line">        self.attn = atten(hidden_size)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,inputs,last_hidden,encoder_output)</span>:</span></span><br><span class="line">        embedd = self.embedding(inputs)</span><br><span class="line">        embedd = self.embedding_dropout(embedd)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 进入GRU网络</span></span><br><span class="line">        rnn_output,hidden = self.gru(embedd,last_hidden)</span><br><span class="line">        <span class="comment"># 然后rnn_output作为是一个输出结合连个输出的attention，去做分类的工作</span></span><br><span class="line">        attention = self.attn(rnn_output,encoder_output)</span><br><span class="line">        x = torch.cat((rnn_output,attention),<span class="number">1</span>)</span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = torch.tanh(x)</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        x = F.softmax(x,dim = <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> output,hidden <span class="comment"># 返回输出和最终隐藏状态（每一个词的长度都是词向量的长度）</span></span><br></pre></td></tr></table></figure><p>下面调用encoder和decoder，使得整个网络连贯起来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">encoder_outputs, encoder_hidden = encoder(input_variable, lengths)</span><br><span class="line">attens = atten(encoder_hidden,encoder_output)</span><br><span class="line">encoder_outputs = encoder_outputs*attens</span><br><span class="line">decoder_output,decoder_hidden = decoder(inputs,encoder_outputs,encoder_hidden)</span><br></pre></td></tr></table></figure><p><strong>定义损失函数：</strong></p><p>由于我们处理的是批量填充序列，因此在计算损失时我们不能简单地考虑张量的所有元素。我们定义<code>maskNLLLoss</code>可以根据解码器的输出张量、 描述目标张量填充的<code>binary mask</code>张量来计算损失。该损失函数计算与<code>mask tensor</code>中的1对应的元素的平均负对数似然。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maskNLLLoss</span><span class="params">(inp, target, mask)</span>:</span></span><br><span class="line">    nTotal = mask.sum()</span><br><span class="line">    crossEntropy = -torch.log(torch.gather(inp, <span class="number">1</span>, target.view(<span class="number">-1</span>, <span class="number">1</span>)).squeeze(<span class="number">1</span>))</span><br><span class="line">    loss = crossEntropy.masked_select(mask).mean()</span><br><span class="line">    loss = loss.to(device)</span><br><span class="line">    <span class="keyword">return</span> loss, nTotal.item()</span><br></pre></td></tr></table></figure><p>本文github地址：<a href="https://github.com/WenHui-Zhou/NLP_pratice/blob/master/pytorh_review.ipynb" target="_blank" rel="noopener">https://github.com/WenHui-Zhou/NLP_pratice/blob/master/pytorh_review.ipynb</a></p><h3 id="inference"><a href="#inference" class="headerlink" title="inference"></a>inference</h3><ul><li><a href="https://www.cnblogs.com/duye/p/10590146.html" target="_blank" rel="noopener">https://www.cnblogs.com/duye/p/10590146.html</a></li><li><a href="https://plmsmile.github.io/2017/10/12/Attention-based-NMT/" target="_blank" rel="noopener">https://plmsmile.github.io/2017/10/12/Attention-based-NMT/</a></li><li><a href="http://www.nlpuser.com/pytorch/2018/11/04/Attention-In-TextClassification/" target="_blank" rel="noopener">http://www.nlpuser.com/pytorch/2018/11/04/Attention-In-TextClassification/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;pytorch 在日常实践中的一些常用的函数，工作流。&lt;/p&gt;
    
    </summary>
    
      <category term="NLP" scheme="https://wenhui-zhou.github.io/categories/NLP/"/>
    
    
  </entry>
  
  <entry>
    <title>NLP实践 基于注意力机制的文本匹配</title>
    <link href="https://wenhui-zhou.github.io/2019/12/05/NLP%E5%AE%9E%E8%B7%B5-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6%E7%9A%84%E6%96%87%E6%9C%AC%E5%8C%B9%E9%85%8D/"/>
    <id>https://wenhui-zhou.github.io/2019/12/05/NLP实践-基于注意力机制的文本匹配/</id>
    <published>2019-12-05T07:52:00.000Z</published>
    <updated>2019-12-19T02:05:30.545Z</updated>
    
    <content type="html"><![CDATA[<p>文本匹配是一个宽泛的任务，只要是研究两端样本之间的关系，都可以将这个问题看成文本匹配的问题。常见的任务场景有：</p><ul><li>相似度计算，复述识别</li><li>问答系统</li><li>对话系统</li><li>自然语言推理、文本蕴含识别</li><li>信息检索中的匹配</li><li>机器阅读理解</li></ul><a id="more"></a><h3 id="通用baseline"><a href="#通用baseline" class="headerlink" title="通用baseline"></a>通用baseline</h3><p>对于这种匹配问题，直接上一个SiameseCNN模型，即孪生模型将textA，textB输入两个模型中，如果是计算两个文本的相似性，可以直接采用cosine，L1距离，欧式距离等得到两个文本之间的相似性。</p><p><img src="../images/nlp/text11.png" style="zoom:53%;"></p><p>匹配问题可能还会涉及到问答关系，文本蕴含关系等等，因此我们可以通过两个子模型生成了textA，textB的向量来构造出更加适合的feature，如A-B，A*B等等。然后用额外的模型（如MLP）来学习文本之间的映射关系。</p><p><strong>孪生模型</strong></p><p>孪生模型的含义指的是神经网络连体，通过权值共享的方式，组成一个完整的网络：</p><p><img src="../images/nlp/text12.jpg" style="zoom:50%;"></p><p>Network1与Network2有着相同的网络和相同的权重。他的作用是衡量两个输入的相似性。具体的应用有QA问答系统，手写体识别等等。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>相似度计算<ul><li>判断两个文本是否表达相同的含义，构成复述关系</li><li>有些数据集给出相似度等级，有些数据集则给出0/1标签</li></ul></li><li>问答匹配<ul><li>问答问题可以视为是一个分类问题，但是通常情况下，但是实际场景是从若干候选中找出正确的答案，相关数据集是通过一个匹配正例和若干负例组成的，往往建模成rank问题</li><li>学习方法上，不仅可以使用分类方法来做（pointwise-learning），还可以使用pairwise-learning（同问题的一对正负样本作为一对正负样本），listwise-learning（同问题的全部样本序列作为一个样本）。</li></ul></li><li>对话匹配<ul><li>对话系统是问答系统的升级，主要的不同有：对话匹配引入了历史轮，因此回答需要参考历史</li><li>对话匹配的回复空间比问答系统要大很多，甚至存在一些万能回复。</li></ul></li><li>自然语言推理、文本蕴含识别<ul><li>如果一直句子A，能够推导出句子B为正，则A蕴含B，若推导出B为假，则说明，A与B相互矛盾，如无法推导出B为真为假那么A与B独立。</li><li>可以将这个问题看成是一个3-way classification的问题</li></ul></li><li>信息检索匹配<ul><li>query-title匹配、query-document匹配等信息检索场景下的文本匹配问题。不过，信息检索场景下，一般先通过检索方法召回相关项，再对相关项进行rerank。对这类问题来说，<strong>更重要的是ranking</strong>，而不是非黑即白或单纯的selection</li></ul></li><li>机器阅读理解<ul><li>在文本中找到答案片段</li></ul></li></ul><h3 id="学习方法"><a href="#学习方法" class="headerlink" title="学习方法"></a>学习方法</h3><p>基于表示的文本匹配方法（simaese结构）与基于交互的匹配方法（花式attention交互）纷争数年，最终文本匹配问题还是被BERT方法给终结了。</p><p><strong>基于表示的孪生结构</strong></p><p>这种结构有两个改进方向，一种是使用更加强大的encoder，第二种为使用更加花哨的相似度计算函数。基于这两个方向的工作也很多</p><p><strong>基于交互attention结构</strong></p><p>首先通过attention为代表的结构来对两段文本进行不同粒度（词，短语级别）的交互，然后将各个粒度的匹配结果通过一种结构聚合起来，作为一个超级特征向量得到最终的匹配关系。</p><p>然后这种结构往往在某个场景中有很好的性能，换一个场景性能可能就会变差（因为设计出来的结构迎合了某个特定数据集的数据分布）。</p><h3 id="attention机制"><a href="#attention机制" class="headerlink" title="attention机制"></a>attention机制</h3><p>attention是一个用于提升RNN在encoder-decoder中性能的机制，在机器翻译，语音识别，图像标注中得到广泛的应用。attention为句子中的每个词赋予了不同权重，使得神经网络学习变得更加的灵活（soft），同时可以反应在翻译，识别过程中的一种对齐关系。</p><p><strong>attention帮助模型对输入的x的每个部分赋予不同的权重，抽取出更加关键的信息，使得模型做出更加准确的判断，同时不会产生过大的计算和存储的开销。</strong></p><p>attention模型以经典的Bahdanau attention 为例：</p><p><img src="../images/nlp/attention1.jpg" style="zoom:87%;"></p><p>经典的attention结构主要由三个部分：</p><ul><li>source function：度量环境向量与当前输入向量的相似性，找到当前环境下应该focus那些信息</li></ul><p>$$<br>\begin{equation}<br>e_{i j}=a\left(c, y_{i}\right)=v_{a}^{T} \tanh \left(W_{a} <em> c+U_{a} </em> y_{i}\right)<br>\end{equation}<br>$$</p><ul><li>alignment function：计算attention weight，通常使用softmax进行归一化</li></ul><p>$$<br>\begin{equation}<br>\alpha_{i j}=\frac{\exp \left(e_{i j}\right)}{\sum_{k=1}^{T_{x}} \exp \left(e_{i k}\right)}<br>\end{equation}<br>$$</p><ul><li>generate context vector function: 利用attention weight对输出赋予新的权重。</li></ul><p>$$<br>\begin{equation}<br>z_{i}=\sum_{i} \alpha_{i j} * y_{i}<br>\end{equation}<br>$$</p><p>attention机制通常和seq2seq一起介绍：</p><p><img src="../images/nlp/attention2.jpg" style="zoom:87%;"></p><p>脱离seq2seq结构，使用下面的方式计算attention：</p><p><img src="../images/nlp/attention3.jpg" style="zoom:67%;"></p><p>首先计算key和query的相似性，得出权重。然后通过sotfmax进行归一化得到结构之后与value相乘，得到最后的attention value。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>数据集：<a href="https://nlp.stanford.edu/projets/snli/" target="_blank" rel="noopener">https://nlp.stanford.edu/projets/snli/</a></p><p>SNLI1.0包含570，000的人工手写英文句子对。<br>针对 <code>推理前提</code>(premise)与<code>推理假设</code>(hypothesis)之间是否存在逻辑关系，人工标注了以下三种标签：</p><ul><li><a href="https://en.wikipedia.org/wiki/Entailment_(linguistics" target="_blank" rel="noopener"><strong>entailment</strong></a>) 蕴含、推理 p⇒h</li><li><a href="https://en.wikipedia.org/wiki/Contradiction" target="_blank" rel="noopener"><strong>contradiction</strong></a> 矛盾、对立 p⊥h</li><li><strong>neutral</strong> 中立、无关 p⇎h</li></ul><p>明天要做的事：</p><ol><li>把数据集的文件整理好</li><li>然后把网络结构搭建起来</li><li>整理一下思路</li><li>跑代码，完成蕴含关系的实验</li><li>把照片找出来</li></ol><h3 id="inference"><a href="#inference" class="headerlink" title="inference"></a>inference</h3><p><a href="https://www.jiqizhixin.com/articles/2019-10-18-14" target="_blank" rel="noopener">https://www.jiqizhixin.com/articles/2019-10-18-14</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文本匹配是一个宽泛的任务，只要是研究两端样本之间的关系，都可以将这个问题看成文本匹配的问题。常见的任务场景有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相似度计算，复述识别&lt;/li&gt;
&lt;li&gt;问答系统&lt;/li&gt;
&lt;li&gt;对话系统&lt;/li&gt;
&lt;li&gt;自然语言推理、文本蕴含识别&lt;/li&gt;
&lt;li&gt;信息检索中的匹配&lt;/li&gt;
&lt;li&gt;机器阅读理解&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="NLP" scheme="https://wenhui-zhou.github.io/categories/NLP/"/>
    
    
  </entry>
  
  <entry>
    <title>NLP实践 文本分类任务</title>
    <link href="https://wenhui-zhou.github.io/2019/12/02/NLP%E5%AE%9E%E8%B7%B5-%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/"/>
    <id>https://wenhui-zhou.github.io/2019/12/02/NLP实践-文本分类任务/</id>
    <published>2019-12-02T06:21:37.000Z</published>
    <updated>2019-12-04T16:47:30.708Z</updated>
    
    <content type="html"><![CDATA[<p>文本分类是NLP中的一个很经典的问题，通过这个问题可以熟悉NLP在处理这类问题的一个大致的思路，达到快速入门的目的。</p><a id="more"></a><blockquote><p>nlp中token，tokenize，tokenizer</p><p>token：令牌，表示关键字，变量名，标点，括号等标记符号</p><p>tokenize：令牌化，解析标记，将一个句子中关键字等令牌解析出来</p><p>tokenizer：令牌解析器，具有解析的功能的类</p></blockquote><h3 id="任务简介"><a href="#任务简介" class="headerlink" title="任务简介"></a>任务简介</h3><p>文本分类的数据集，数据格式如下：<br>$$<br>X = {(x^1 , y^1 ),(x^2,y^2) · · · , (x^N , y^N )}<br>$$<br>其中$ x_i $表示一组文本，$ y_i $可以为一组标签如词性，也可以是一个标签，即文本的类别。本文的最终目标就是希望达到：<br>$$<br>f(x_i) \to y_i<br>$$<br>下面来深入解决这个问题。 </p><h3 id="向量化"><a href="#向量化" class="headerlink" title="向量化"></a>向量化</h3><p>在机器学习算法中，样本实例一般是以连续变量或离散变量的形式存在的。因此我们在分类之前，需要将文字转化为特征向量。</p><p><strong>词袋模型</strong></p><p>一种简单的方法就是认为文本是由字，词组成的无序，多重集合，不考虑语法和词序。这就是在自然语言处理中常用的词袋模型。磁带模型可以看车以词为基本单位的向量空间模型。</p><p><strong>N元特征</strong></p><p>在实际场景中词序是十分重要的，可能影响句子含义的表达。因此我们需要在特征中保留单词的词序。 </p><p>N 元特征(N-gram 特征),顾名思义,就是由 N 个字或词组成的字符串,单元可以 是字或词。这里N是大于等于1的任意整数。如果N 为2,就叫做二元特征,如果N为 3,就叫做三元特征以此类推。</p><p>以中文句子“机器学习算法”为例,以字为基本单位的二元特征集合为:{机器,器 学,学习,习算,算法}。集合中每一项都是由二个相邻的字组成的的子串,长度为 2。</p><p> 有了 N 元特征集合,就可以利用词袋模型将文本表示为向量形式。随着 N 的增加, 可以抽取的特征就会越多,特征空间也会呈指数增加。这些高阶的特征出现的频率也会相对较低,对分类不但没有太多帮助,还会直接影响着后续处理的效率与复杂度。<strong>因此在一般的文本分类任务中,N 取 3 就足够了,并且同时也使用一元和二元特征,防止出现过拟合。</strong></p><h3 id="特征分类"><a href="#特征分类" class="headerlink" title="特征分类"></a>特征分类</h3><p>经过特征的抽取之后，一个模型就可以认为是k维特征空间上的一个点，需接下来就要寻找一些超平面来对空间进行划分，也就是对文本进行分类。</p><p><strong>二分类问题</strong></p><p>$$ \hat y =sign((f(z))) = sign(\theta^Tz+\theta_0) $$</p><p>sign为符号函数，取判别函数f(z)的正负号，为方便，简写判别函数为 </p><p>$$ f(z) ＝ \theta^Tz+\theta_0 = \sum_{i=1}^{k}\theta_iz_i + \theta_0 = \sum_{i=0}^{k} = \hat \theta^T \hat z $$ </p><p>其中$z_0=1$,$\hat\theta,\hat z$分别称为增广权重向量和增光特征向量。 $$ \hat z = \left( \begin{array} {ccc} 1  z_1 . . z_k \end{array} \right) = \left( \begin{array}{ccc} 1   z   \<br>\end{array} \right) $$</p><p>$$ \hat \theta = \left( \begin{array} {ccc} \theta_0  \theta_1 . . \theta_k \end{array} \right) = \left( \begin{array}{ccc} \theta_0   \theta   \<br>\end{array} \right) $$</p><p>后面的分类器描述中,我们都采用简化的表示方法,并直接用 $θ , z$ 来表示增广权重向量和增广特征向量</p><p><strong>多分类问题</strong></p><p> 对于 C 类分类问题,需要定义 C 个判别函数。但是这种表示一般适用于类别 y 为离散变量的情况。在自然语言处理的很多学习任务,类别 y 可以是更复杂的结构,比如多标签、层次化以及结构化等形式。为了更好的描述这些情况，可采用如下形式： $$ \hat y = \mathop{argmax}_yf(\phi(x,y),\theta)$$ 这里$\phi(x,y)$是包含了样本x和类别y混合信息的特征向量，$\theta=[\theta_1;\theta_2…;\theta_C]$，$\phi(x,y)$ 为特征表示，$f(\phi,\theta)$为模型，一般在文本分类中为线性模型（由于我们可以构建足够复杂的特征表示，在高维空间中总是线性可分的），argmax 为解码过程，即寻求y解的过程，对于分类问题，看得分取高分即可。机器学习要学的参数是$\theta$。<a href="https://perper.site/2019/12/02/NLP%E5%AE%9E%E8%B7%B5-%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1/" target="_blank" rel="noopener"></a></p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p>数据集：<a href="https://www.kaggle.com/c/sentiment-analysis-on-movie-reviews" target="_blank" rel="noopener">https://www.kaggle.com/c/sentiment-analysis-on-movie-reviews</a></p><p>数据集由train.tsv和test.tsv组成，tsv即数列的分隔符是tab，数据的格式如下：</p><p><img src="/images/nlp/text1.png" style="zoom:45%;"></p><p>每一行由短语id，句子id，句子，类型四列组成。句子类型分为五类：</p><ul><li>0 - negative</li><li>1 - somewhat negative</li><li>2 - neutral</li><li>3 - somewhat positive</li><li>4 - positive</li></ul><p><strong>数据处理</strong></p><p><code>nltk</code>：一个专门处理英文文本的库</p><p><code>beautifulsoup</code>：构建，解析分析树</p><p>nlp数据预处理的流程：</p><ul><li>bs4等工具去除标签，或手工的方式，去除数据中不需要的内容</li><li>拼写错误检查，通常使用 pyenchant工具包</li><li>词干提取（stemming），词形还原（lemmatization），这两种方法都是要找到词的原始形式。即对于一些复数，过去式等英文的还原。stemming方法更加激进一些，还原后的词不一定是原词的词干，通常使用nltk工具包</li></ul><p>下面是具体的实现，在拿到原始的数据之后，我们需要对数据进行一些处理，处理的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面这个函数用来去除html标签</span></span><br><span class="line"><span class="comment"># 去除非文本内容</span></span><br><span class="line"><span class="comment"># tokenize句子，即分词</span></span><br><span class="line"><span class="comment"># lemmatize句子，即词性还原</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_sentences</span><span class="params">(df)</span>:</span></span><br><span class="line">    reviews = []</span><br><span class="line">    <span class="keyword">for</span> sent <span class="keyword">in</span> tqdm(df[<span class="string">'Phrase'</span>]):</span><br><span class="line">        review_text = BeautifulSoup(sent).get_text() <span class="comment"># 去除html</span></span><br><span class="line">        review_text = re.sub(<span class="string">'[^a-zA-Z]'</span>,<span class="string">' '</span>,review_text) <span class="comment"># 去除非文本部分</span></span><br><span class="line">        <span class="comment"># tokenize the sentences</span></span><br><span class="line">        words = word_tokenize(review_text.lower()) <span class="comment"># 令牌化</span></span><br><span class="line">        lemma_words = [lemmatizer.lemmatize(i) <span class="keyword">for</span> i <span class="keyword">in</span> words] <span class="comment"># 词形恢复</span></span><br><span class="line">        reviews.append(lemma_words)</span><br><span class="line">    <span class="keyword">return</span> reviews</span><br><span class="line"><span class="comment"># clear the data</span></span><br><span class="line">train_sentences = clean_sentences(train)</span><br><span class="line">test_sentences = clean_sentences(test)</span><br><span class="line">print(len(train_sentences))</span><br><span class="line">print(len(test_sentences))</span><br></pre></td></tr></table></figure><p>上述代码对这个数据集进行统一的处理，将文本中的html部分去掉，非文字部分去掉。将单词还原到原始的拼写方式上，最终将得到一个每个句子都转变为一行单词组成的list中。</p><p>标注数据为5个类别，通过keras.utils中的to_categorical方法将target转变为one-hot的形式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将标注转变为one-hot格式</span></span><br><span class="line">target = train.Sentiment.values</span><br><span class="line">y_target = to_categorical(target)</span><br><span class="line">num_classes = y_target.shape[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>使用sklearn对训练集进行划分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># split the data into train and val</span></span><br><span class="line">x_train,x_val,y_train,y_val = train_test_split(train_sentences,y_target,test_size = <span class="number">0.2</span>,stratify=y_target)</span><br></pre></td></tr></table></figure><p>划分完训练集和测试集只有，训练集中不同单词的个数可能减少了，我们希望得到一个当前训练集的一个词汇全集，并且记录一下最长的句子的长度。得到词汇全集是为了之后做token以及句子的序列化将会使用到。记录句子的最大长度是为了对句子长度进行对齐的时候们将会使用到。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 去除重复出现的词，unique_words里头是一个单词的全集</span></span><br><span class="line">unique_words = set()</span><br><span class="line">len_max = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> sent <span class="keyword">in</span> tqdm(x_train):</span><br><span class="line">    unique_words.update(sent)</span><br><span class="line">    <span class="keyword">if</span>(len_max &lt; len(sent)):</span><br><span class="line">        len_max = len(sent)</span><br><span class="line">print(len(list(unique_words)))</span><br><span class="line">print(len_max)</span><br></pre></td></tr></table></figure><p>下面利用keras的方法，对句子进行重新的token，这里的目的和最开始做token的目的不同，这里是为了得到句子的序列表示，得到序列表示以及词汇表之后，就可以使用embedding层，对句子进行word2vec变换了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对句子再次进行tokenizer操作</span></span><br><span class="line">tokenizer = Tokenizer(num_words = len(list(unique_words)))</span><br><span class="line">tokenizer.fit_on_texts(list(x_train)) <span class="comment"># 用数据初始化tokenizer</span></span><br><span class="line"><span class="comment"># tokenizer.word_count 返回一个字典，字典的key为词，val为出现的个数</span></span><br><span class="line"><span class="comment"># tokenizer.word_index 对词集合中每一个词编号,key为词，val为编号</span></span><br><span class="line"><span class="comment"># 将句子中的词替换成词的编号</span></span><br><span class="line">x_train = tokenizer.texts_to_sequences(x_train)</span><br><span class="line">x_val = tokenizer.texts_to_sequences(x_val)</span><br><span class="line">x_test = tokenizer.texts_to_sequences(test_sentences)</span><br><span class="line"><span class="comment"># 由于每个句子的长度不一样长，因此需要对齐，通过pad在短的句子开头补上0</span></span><br><span class="line">x_train = sequence.pad_sequences(x_train,maxlen=len_max)</span><br><span class="line">x_val = sequence.pad_sequences(x_val,maxlen=len_max)</span><br><span class="line">x_test = sequence.pad_sequences(x_test,maxlen=len_max)</span><br></pre></td></tr></table></figure><p>最终得到长度一致的一个句子序列化结果，上述代码即完成了所有的数据处理的操作。</p><h3 id="网络搭建"><a href="#网络搭建" class="headerlink" title="网络搭建"></a>网络搭建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置early stop</span></span><br><span class="line">early_stopping = EarlyStopping(min_delta=<span class="number">0.001</span>,mode =<span class="string">'max'</span>,monitor=<span class="string">'val_acc'</span>,patience = <span class="number">2</span>)</span><br><span class="line">callback = [early_stopping]</span><br><span class="line"><span class="comment"># keras搭建模型</span></span><br><span class="line">model = Sequential()</span><br><span class="line"><span class="comment"># embedding(input_dim(词汇表长度),output_dim(输出的vector的长度)，input_length(输入句子的长度))</span></span><br><span class="line"><span class="comment"># 等于输入了词汇表，句子的sequences，然后去学习word2vec的参数，得到表示句子的vector，长度通常设置成128或300</span></span><br><span class="line">model.add(Embedding(len(list(unique_words)),<span class="number">300</span>,input_length=len_max))<span class="comment"># embedding 起到word2vec的作用</span></span><br><span class="line"><span class="comment"># LSTM return_sequences=true表示输出全序列的输出，False只输出最后一个LSTM的输出</span></span><br><span class="line">model.add(LSTM(<span class="number">128</span>,dropout=<span class="number">0.5</span>,recurrent_dropout=<span class="number">0.5</span>,return_sequences=<span class="keyword">True</span>))</span><br><span class="line">model.add(LSTM(<span class="number">64</span>,dropout=<span class="number">0.5</span>,recurrent_dropout=<span class="number">0.5</span>,return_sequences=<span class="keyword">False</span>))</span><br><span class="line">model.add(Dense(<span class="number">100</span>,activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(Dropout(<span class="number">0.5</span>))</span><br><span class="line">model.add(Dense(num_classes,activation = <span class="string">'softmax'</span>))</span><br><span class="line">model.compile(loss = <span class="string">'categorical_crossentropy'</span>,optimizer=Adam(lr = <span class="number">0.005</span>),metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure><p>模型结果如下：</p><p><img src="/images/nlp/text2.png" style="zoom:43%;"></p><p>embedding 层用于skip-gram方法得到词向量，最后一层softmax，使用交叉熵计算误差。</p><p>下面开始模型的训练过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 往模型中加入数据</span></span><br><span class="line">history = model.fit(x_train,y_train,validation_data,(x_val,y_val),epochs=<span class="number">6</span>,batch_size = <span class="number">256</span>,verbose=<span class="number">1</span>,callbacks=callback)</span><br></pre></td></tr></table></figure><p>包含了验证集的验证：</p><p><img src="/images/nlp/text3.png" style="zoom:50%;"></p><p>绘制训练结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">epoch_count = range(<span class="number">1</span>,len(history.history[<span class="string">'loss'</span>]) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(epoch_count,history.history[<span class="string">'loss'</span>],<span class="string">'r--'</span>)</span><br><span class="line">plt.plot(epoch_count,history.history[<span class="string">'val_loss'</span>],<span class="string">'b--'</span>)</span><br><span class="line">plt.legend([<span class="string">'Training loss'</span>,<span class="string">'validation loss'</span>])</span><br><span class="line">plt.xlabel(<span class="string">'epoch'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'loss'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>生成测试集的预测结果，代码结束：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># submission</span></span><br><span class="line">y_pred = model.predict_classes(x_test)</span><br><span class="line">sub_file = pd.read_csv(os.path.join(root,<span class="string">'sampleSubmission.csv'</span>),sep=<span class="string">','</span>)</span><br><span class="line">sub_file.Sentiment = y_pred</span><br><span class="line">sub_file.to_csv(<span class="string">'submission.csv'</span>,index = <span class="keyword">False</span>)</span><br></pre></td></tr></table></figure><h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><p>看完代码最后来总结一些模型的结构：</p><p><img src="/images/nlp/text2.png" style="zoom:43%;"></p><p>通过数据的预处理部分，将文本中句子整理成一个【句子个数，句子最大长度】的一个矩阵，每一个位置上为一个单词。如果句子长度不够长的话，就在句子的前面用0来填充。</p><p>随后将每个句子，每个词进行word2vec，即embedding处理。<code>keras.layers.embedding</code>层完成词嵌入的工作。本质是一个全连接层，embedding是一个【总词汇数量，每个词编码长度】的一个权重矩阵，每一行表示一个词的向量，embeding层训练好词向量之后，将这些词向量赋予给句子中的词</p><p><img src="/images/nlp/text4.png" style="zoom:50%;"></p><p>每一个句子将得到一个【句子最大长度，词向量长度】的矩阵。</p><p><strong>RNN</strong></p><p>LSTM类似于cv领域的CNN，值得好好琢磨一下（虽然现在transform更加的流行）</p><p>传统的RNN如下：</p><p><img src="/images/nlp/text5.jpg" style="zoom:70%;"></p><p>可以看出隐层间的信息传递，$\hat{h}$与h以及x有关，每一个RNN输出的y仅与$\hat{h}$有关，通过softmax进行分类，通过训练网络得出W的参数。RNN与DNN相同，当网络比较深的时候，同样面临梯度消失的问题，当两个词相距比较远的时候，前一个词难以影响到后面的词（但是有时候这种长连接的词能够决定句子的含义）。</p><p><strong>LSTM</strong></p><p><img src="/images/nlp/text6.jpg" alt=""></p><p>LSTM包含三个数据的输入，C的输入为简单的相乘与相加，因此能够保留较长序列的信息。LSTM之间传递的h信息，有一份来自前一层的信息以及当前LSTM的输入信息。LSTM中间分层三个部分，分别为遗忘门，记忆门，选择输出门。</p><p><strong>GRU</strong></p><p>Gate Recurrent Unit是循环神经网络的一种，和LSTM相似，用来解决长期记忆和反向传播中梯度等问题而提出来的。GRU和LSTM的表现类似，但是GRU的计算复杂度比较小。</p><p><img src="/images/nlp/text7.png" style="zoom:25%;"></p><p>即：</p><p><img src="/images/nlp/text8.jpg" style="zoom:55%;"></p><p><img src="/images/nlp/text10.jpg" style="zoom:45%;"></p><p><img src="/images/nlp/text9.jpg" style="zoom:55%;"></p><p>GRU用一个1-z的方式，用同一个门代替了遗忘门和记忆门的工作，在使用的时候，GRU参数较小，能够使得算法复杂度下降。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>nlp和cv问题在处理上比起来，一个很大的不同在于数据预处理部分有比较多的工作需要完成。这些工作包括了文本数据的清洗，单词的划分tokenize，对每个句子生成word2vec，然后下面才搭建模型，和cv部分就比较类似了。</p><p>我觉得从上面的代码里头可以总结从一份代码，这份代码专门处理文本数据的预处理问题。</p><p>本文的代码地址：<a href="https://github.com/WenHui-Zhou/NLP_pratice/tree/master/text_classification" target="_blank" rel="noopener">https://github.com/WenHui-Zhou/NLP_pratice/tree/master/text_classification</a></p><h3 id="inference"><a href="#inference" class="headerlink" title="inference"></a>inference</h3><p><a href="https://www.kaggle.com/chiranjeevbit/movie-review-prediction" target="_blank" rel="noopener">https://www.kaggle.com/chiranjeevbit/movie-review-prediction</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文本分类是NLP中的一个很经典的问题，通过这个问题可以熟悉NLP在处理这类问题的一个大致的思路，达到快速入门的目的。&lt;/p&gt;
    
    </summary>
    
      <category term="NLP" scheme="https://wenhui-zhou.github.io/categories/NLP/"/>
    
    
  </entry>
  
  <entry>
    <title>图像的去噪</title>
    <link href="https://wenhui-zhou.github.io/2019/12/02/%E5%9B%BE%E5%83%8F%E7%9A%84%E5%8E%BB%E5%99%AA/"/>
    <id>https://wenhui-zhou.github.io/2019/12/02/图像的去噪/</id>
    <published>2019-12-02T02:42:52.000Z</published>
    <updated>2019-12-05T02:35:43.739Z</updated>
    
    <content type="html"><![CDATA[<p>噪声在图像上通常表现为引起较强视觉效果的孤立像素点或像素块。通常噪声信号与要研究的对象不相关，以无用的信息的形式出现，下面的任务就是将噪声部分消去，使其对图像的影响最小。</p><a id="more"></a><h3 id="噪声概述"><a href="#噪声概述" class="headerlink" title="噪声概述"></a>噪声概述</h3><p><strong>噪声的来源</strong></p><p>（1）图像获取过程中</p><p>两种常用类型的图像传感器CCD和CMOS采集图像过程中，由于<strong>受传感器材料属性、工作环境、电子元器件和电路结构</strong>等影响，会引入各种噪声，如<strong>电阻引起的热噪声</strong>、场效应管的<strong>沟道热噪声、光子噪声、暗电流噪声、光响应非均匀性噪声</strong>。</p><p>（2）图像信号传输过程中</p><p>由于传输介质和记录设备等的不完善，<strong>数字图像在其传输记录过程中往往会受到多种噪声的污染</strong>。另外，在图像处理的某些环节当输入的对象并不如预想时也会在结果图像中引入噪声。</p><p><strong>噪声类型</strong></p><p>图像中常见的噪声基本上有四种：</p><ul><li>高斯噪声</li><li>泊松噪声</li><li>乘性噪声</li><li>椒盐噪声（真没写错）</li></ul><p>噪声的图像由原图，一直到椒盐噪声，从上到下：</p><p><img src="../images/3D/noise1.jpeg" style="zoom:60%;"></p><p><img src="../images/3D/noise2.jpeg" style="zoom:60%;"></p><p><img src="../images/3D/noise3.jpeg" style="zoom:60%;"></p><p><img src="../images/3D/noise4.jpeg" style="zoom:60%;"></p><p><img src="../images/3D/noise5.jpeg" style="zoom:60%;"></p><h3 id="传统去噪方法"><a href="#传统去噪方法" class="headerlink" title="传统去噪方法"></a>传统去噪方法</h3><p>传统的去噪算法分为<strong>空间域法</strong>和<strong>变换域法</strong>：</p><ul><li><p><strong>空间域去噪方法的思想就是在原图像上对图像灰度值进行处理</strong>，通常采取“平均”或“平滑”的方法，将突变的噪声分量分散到周围像素中去，使图像变得较为平滑，降低噪声的影响。常用的空间域去噪方法有：均值去噪法，中值去噪法，高斯去噪法、维纳滤波去噪法等。</p></li><li><p><strong>变换域去噪方法的思想是将原图像进行相关的变换</strong>，将图像信息变换到变换域中,再通过一定的方法来对图像信息进行处理，之后再通过反变换恢复图像信息，以达到图像去噪的目的。常用的变换域去噪方法有：傅里叶变换去噪方法，小波变换去噪方法等。</p></li></ul><p><strong>常用去噪算法</strong></p><ul><li>均值滤波去噪</li><li>中值滤波去噪</li><li>高斯滤波去噪</li><li>傅里叶变换去噪</li></ul><p>下面介绍深度学习在图像去噪上的一篇最新的论文：Noise2Noise: Learning Image Restoration without Clean Data ICML 2018</p><h3 id="Noise2Noise-Learning-Image-Restoration-without-Clean-Data"><a href="#Noise2Noise-Learning-Image-Restoration-without-Clean-Data" class="headerlink" title="Noise2Noise: Learning Image Restoration without Clean Data"></a>Noise2Noise: Learning Image Restoration without Clean Data</h3><p><strong>概述</strong></p><p>这篇文章的主要亮点在于训练网络的时候不需要提供清晰的图像，。作者将另一个不清晰的图像作为GT进行网络的训练，最终也能够得到较好的结果。</p><p><strong>理论依据</strong></p><p>先看一种简单的情况，假设我们对某个物理量（如房间的温度）多次测量，得到一系列不可靠的测量值（y1,y2,…)一种估计真实值的通用方法是找到一个数z，使其与这些测量值有最小的平均偏差，即优化下面损失函数：<br>$$<br>argminz𝔼y{L(z,y)}\arg\min_z \mathbb{E}_y{L(z,y)}<br>$$<br>对于L2 损失$L(z,y)=(z-y)^2$ ，该损失函数的最优解在测量值的算数平均值(期望)处取到：<br>$$<br>z=\mathbb{E}_y{y}<br>$$<br>对于L1,损失$L(z,y)=|z-y|$，该损失函数的最优解在测量值的中值处取到：<br>$$<br>z=median{y}<br>$$<br>对于L0损失 ,$L(z,y)=|z-y|_0$ ，该损失函数的最优解近似在测量值的众数处取到：<br>$$<br>z=mode{y}<br>$$<br>从统计学角度，这些通用的损失函数都可以解释为似然函数的负对数，而对这些损失函数的优化过程可以看做为最大似然估计。<br>训练神经网络回归器是这种点估计过程的推广。已知一系列输入-目标对$(x_i,y_i)$，典型的网络训练形式是优化下列目标函数：<br>$$<br>\arg\min_\theta\mathbb{E}_{(x,y)}{L(f_θ(x),y)}<br>$$<br>通过调节参数theta，使得x与y之间的误差最小。事实上，使用上面的Loss，结果和GT不是一一对应的关系，而是一个多值映射的关系，网络学习到所有的输出结果的平均值。</p><p>这意味着对于L2 loss来说，我们在目标图像上加上一个均值为0的随机噪声，例如高斯噪声，泊松噪声等，根据上面的方程，在目标上加上一个均值为0的噪声对方程的结果没有影响（均值为0的噪声期望为0），因此：<strong>可以通过含有噪声的图像最为训练数据，GT为在目标上加上均值为0而生成的噪声数据，这样训练的结果和直接使用干净的GT的结果理论上来说是相同的，实验结果表情，精度仅仅相差了一点点</strong>。</p><p><strong>应用场景</strong></p><p>看这个文章的时候我一直很疑惑，实验假定了存在一个含有随机噪声的图像，以及一张和它对应的，在干净的图像上加上均值为0的某个噪声分布的图像作为label，在这个基础上进行训练，得到的训练结果和clear图像的训练结果十分相似。疑惑的点在于，我认为这种假设现实生活中是难以满足的，事实上，作者在做实验的时候，也是在GT上加了均值为0的噪声来做实验的。</p><p>但是也有一些人说这个方法可能可以用在一些特定的领域，例如医疗MRT图像，难以获得清晰的图像版本，但是可以通过多次观测得到多个含噪声的医疗MRT图像，利用这些成对的含噪声的图像进行去噪处理。但是从实验角度出发，噪声的分布并不满足均值为0，因为效果可能还是不好。</p><p><strong>实验</strong></p><p>作者分别做了Guassian Noise，possion noise，monte Carlo rendering，MRT图像上的实验。实验结果表明，在加上均值为0的噪声后，同样能够得到去噪后的结果。</p><h3 id="inference"><a href="#inference" class="headerlink" title="inference"></a>inference</h3><ul><li>传统去噪算法： <a href="https://www.voidking.com/dev-gp-image-denoise/" target="_blank" rel="noopener">https://www.voidking.com/dev-gp-image-denoise/</a></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;噪声在图像上通常表现为引起较强视觉效果的孤立像素点或像素块。通常噪声信号与要研究的对象不相关，以无用的信息的形式出现，下面的任务就是将噪声部分消去，使其对图像的影响最小。&lt;/p&gt;
    
    </summary>
    
      <category term="3D重建" scheme="https://wenhui-zhou.github.io/categories/3D%E9%87%8D%E5%BB%BA/"/>
    
    
  </entry>
  
</feed>

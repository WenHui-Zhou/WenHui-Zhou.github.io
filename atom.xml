<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WenHuiZhou</title>
  
  <subtitle>perper（打起精神！）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wenhui-zhou.github.io/"/>
  <updated>2019-11-26T14:18:34.220Z</updated>
  <id>https://wenhui-zhou.github.io/</id>
  
  <author>
    <name>WenHuiZhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>effective cpp(九)杂项讨论</title>
    <link href="https://wenhui-zhou.github.io/2019/11/26/effective-cpp-%E4%B9%9D-%E6%9D%82%E9%A1%B9%E8%AE%A8%E8%AE%BA/"/>
    <id>https://wenhui-zhou.github.io/2019/11/26/effective-cpp-九-杂项讨论/</id>
    <published>2019-11-26T13:34:29.000Z</published>
    <updated>2019-11-26T14:18:34.220Z</updated>
    
    <content type="html"><![CDATA[<p>2019/11/26 effective cpp 第九章 杂项讨论</p><p>这是这本书的最后一章，今晚应该就能够阅读完！在开始阅读之前，我想感慨一下，最后的几章难度太大，一知半解的看下来，我想原因是相关张章节的实践不多导致的，因此日后有需要要回来重新阅读它们，时间很快大概花了一个月的空闲时间来阅读这本书，收获满满！</p><p>这一章主要说了三个问题：编译器的警告要重视；C++标准库的一个总览；boost一个泛用性C++库的总览。</p><ul><li>53 条款：不要轻视编译器的警告</li></ul><a id="more"></a><h3 id="53-条款：不要轻视编译器的警告"><a href="#53-条款：不要轻视编译器的警告" class="headerlink" title="53 条款：不要轻视编译器的警告"></a>53 条款：不要轻视编译器的警告</h3><p>编译器作者在触发一个warning的时候，他比你更加明白将来会发生什么严重的错误，因此我们需要在对待编译器警告的时候更加的小心。</p><p>当出现一个编译器warning的时候，我们应该需要知道它的意图以及真正的意义。</p><p><strong>总结</strong></p><ul><li>严肃对待编译器发出的警告，争取无警告荣誉</li><li>不要过度依赖编译器的报警功能，因为不同的编译器对待事情的反应是不同的</li></ul><h3 id="54-条款：让自己熟悉包括TR1在内的标准程序库"><a href="#54-条款：让自己熟悉包括TR1在内的标准程序库" class="headerlink" title="54 条款：让自己熟悉包括TR1在内的标准程序库"></a>54 条款：让自己熟悉包括TR1在内的标准程序库</h3><p>C++standard定义了C++语言及其标准程序库的规范，里头包含以下：</p><ul><li>STL 标准模板库</li><li>Iostream</li><li>国际化支持</li><li>数值处理</li><li>C89标准程序库</li><li>异常阶层体系</li></ul><p>此外C++的新特性被记录在TR1的文档内，在下一次更新将会加入到标准库中。</p><p><strong>总结</strong></p><ul><li>C++标准库的主要机能由STL，iostreams，locates组成。并包含C99标准程序库。</li><li>TR1添加了智能指针，一般化函数指针，hash-based容器，正则表达式以及另外10个组件的支持</li><li>TR1自身只是一份规范。</li></ul><h3 id="55-条款：让自己熟悉Boost"><a href="#55-条款：让自己熟悉Boost" class="headerlink" title="55 条款：让自己熟悉Boost"></a>55 条款：让自己熟悉Boost</h3><p>如果你在找一个高质量，源码开放，平台独立，编译器独立的程序库，那么Boost是一个很好地选择。他的网址是：<a href="">http://boost.org</a>。</p><p><strong>总结</strong></p><ul><li>Boost是一个社群，也是一个网站，致力于免费，源码开放，同僚复审的C++程序库开发。Boost在C++标准化过程中扮演深居影响力的角色。</li><li>Boost提供许多TR1组件实现品，以及其他许多程序库。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019/11/26 effective cpp 第九章 杂项讨论&lt;/p&gt;
&lt;p&gt;这是这本书的最后一章，今晚应该就能够阅读完！在开始阅读之前，我想感慨一下，最后的几章难度太大，一知半解的看下来，我想原因是相关张章节的实践不多导致的，因此日后有需要要回来重新阅读它们，时间很快大概花了一个月的空闲时间来阅读这本书，收获满满！&lt;/p&gt;
&lt;p&gt;这一章主要说了三个问题：编译器的警告要重视；C++标准库的一个总览；boost一个泛用性C++库的总览。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;53 条款：不要轻视编译器的警告&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="effective cpp" scheme="https://wenhui-zhou.github.io/categories/effective-cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>effective cpp(八)定制new和delete</title>
    <link href="https://wenhui-zhou.github.io/2019/11/25/effective-cpp-%E5%85%AB-%E5%AE%9A%E5%88%B6new%E5%92%8Cdelete/"/>
    <id>https://wenhui-zhou.github.io/2019/11/25/effective-cpp-八-定制new和delete/</id>
    <published>2019-11-25T13:40:42.000Z</published>
    <updated>2019-11-26T13:31:52.371Z</updated>
    
    <content type="html"><![CDATA[<p>2019/11/25 effective cpp 第8章 定制new和delete</p><p>C++在内存管理，垃圾回收机制上常常受到人们的讨论。下面这一章将讨论C++的内存管理例程。</p><ul><li>49 条款：了解new-handler的行为</li><li>50 条款：了解new和delete的合理替换时机</li><li>51 条款：编写new和delete时需固守常规</li><li>52 条款：写了placement new也要写placement delete</li></ul><a id="more"></a><h3 id="49-条款：了解new-handler的行为"><a href="#49-条款：了解new-handler的行为" class="headerlink" title="49 条款：了解new-handler的行为"></a>49 条款：了解new-handler的行为</h3><p>当operator new无法满足某一内存分配的需求时，它将会抛出异常。当operator new发生异常，它会先调用一个客户指定的错误处理函数，即new-handler函数。为了指定这个用以处理内存不足的函数，客户必须调用set_new_handler，那是声明与<code>&lt;new&gt;</code>的一个标准程序库函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出来new_handler是一个typedef。定义出一个指向函数的指针，该函数没有返回任何东西，set_new_handler则是接受一个指针，返回一个指针，并且不允许抛出任何的异常。</p><p>Set_new_handler的使用方式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outOfMem</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"unable doing something"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">abort</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::set_new_handler(outOfMem);</span><br><span class="line">  <span class="keyword">int</span>* pBig = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">12323232333333</span>];</span><br><span class="line">  <span class="comment">// 当new无法分配这么多空间的时候，将会去调用outOfMem报错。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现new-handler的时候，有几点注意：</p><ul><li><strong>让更多的内存可被使用</strong>，一个做法是程序开始执行的时候就分配了一大块内存，当调用handler的时候，释放给程序使用</li><li><strong>安装另一个new-handler</strong>，如果目前这个new-handler无法处理这个异常，它可以通过调用其他的handler来分配内存。</li><li><p><strong>卸除new-handler</strong>，就是讲null指针传给set_new_handler，一旦没有安装任何new-handler，operator new会在内存分配不成功时抛出异常。</p></li><li><p><strong>跑出bad_alloc异常，</strong>这样的异常不会被operator new捕获，因此会被传播到内存索求处。</p></li><li><strong>不返回</strong>，通常调用abort，exit来中断程序。</li></ul><p><strong>总结</strong></p><ul><li>set_new_handler允许客户指定一个函数，在内存分配无法获得满足时被调用</li><li>Nothrow new是一个颇为局限的工具，因为它只适用于内存分配，后续的构造函数调用还是可能抛出异常。</li></ul><h3 id="50-条款：了解new和delete的合理替换时机"><a href="#50-条款：了解new和delete的合理替换时机" class="headerlink" title="50 条款：了解new和delete的合理替换时机"></a>50 条款：了解new和delete的合理替换时机</h3><p>通常我们选择替换new和delete会出于几个原因：</p><ul><li>用于检测运用上的错误</li><li>为了强化效能</li><li>为了收集使用上的统计数据</li></ul><p>此外，在了解何时可在 <strong>全局性</strong>或 <strong>class专属的</strong>基础上合理替换缺省的new和delete：</p><ul><li>为了检测运用上的错误</li><li>为了手机动态分配内存之使用统计信息</li><li>为了增加分配和归还的速度</li><li>为了降低缺省内存管理器带来的空间额外开销</li><li>为了弥补缺省分配器中的非最佳齐位</li><li>为了将相关对象成簇集中</li><li>为了获得非传统的行为</li></ul><p><strong>总结</strong></p><p>有许多理由需要写个自定义的new和delete，包括改善效能，对heap运用错误进行调试，收集heap使用信息。</p><h3 id="51-条款：编写new和delete时需固守常规"><a href="#51-条款：编写new和delete时需固守常规" class="headerlink" title="51 条款：编写new和delete时需固守常规"></a>51 条款：编写new和delete时需固守常规</h3><p>让我们从实现operator new开始，实现一致性operator new必须返回正确的值，内存不足的时候必须调用new-handling函数，必须有对付零内存需求的准备，还需避免不慎掩盖正常形式的new。</p><p>operator new其实比较单纯，如果能够申请到空间，就返回正确的值，如果申请不到空间就返回一个bad-alloc。但是他也有不单纯的一面，因为operator不止一次的申请内存，如果new-handling有能力做一些操作释放内存出来，因此只有在new-handling返回null的时候才会抛出错误。</p><p>如果你打算控制operator new[]的行为，你唯一要做的事情就是分配一块未加工的内存。因为你无法知道array中将会保存什么东西。</p><p>对于operator delete来说，我们要确保的是 <strong>删除null指针永远安全</strong>。</p><p><strong>总结</strong></p><ul><li>operator new应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存的需求，就调用new-handler。它应该也有能力处理0byte申请。class 专属版本则应该处理 <strong>比正确大小更大的错误。</strong></li><li>operator delete应该受到null指针时不做任何事，class专属版本则还应该处理 <strong>比正确大小更大的申请。</strong></li></ul><h3 id="52-条款：写了placement-new也要写placement-delete"><a href="#52-条款：写了placement-new也要写placement-delete" class="headerlink" title="52 条款：写了placement new也要写placement delete"></a>52 条款：写了placement new也要写placement delete</h3><p>placement new和placement delete应当也成对的出现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">widget* pw = <span class="keyword">new</span> widget;</span><br></pre></td></tr></table></figure><p>当我们通过上面的代码的时候，实际上做了两件事情，第一件是new，第二件是调用了widget的default构造函数。如果在第二种情况下发生了异常，new成功执行。这种情况下我们要去释放new所申请的空间，但是我们手上并没有申请得到的指针，因此释放内存的重任就交给了C++。</p><p>如果当前面对的是拥有正常签名的new和delete函数，那么系统在运行期间就会主动去调用相应的delete函数。</p><p>但是如果我们使用的new是我们修改过的，带有附加参数的new，这时候我们需要制定一个与之对应的delete函数。</p><p>此外，由于成员函数名称将会覆盖其外围作用域的相同名称，你必须小心避免掉这种覆盖。一个简单的做法就是建立一个base class，内含所有正常形式的new和delete，凡是想以自定形式扩充标准形式的客户，可利用继承机制及using声明式来取得标准形式。</p><p><strong>总结</strong></p><ul><li>当你写一个placement operator new。请确定也写出对应了placement operator delete函数，如果没有这样做的话，你的程序可能会发生隐微而断续的内存泄漏。</li><li>当你声明placement new和placement delete，请确定不要无意识地掩盖了他们的正常版本。</li></ul><p>一知半解。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019/11/25 effective cpp 第8章 定制new和delete&lt;/p&gt;
&lt;p&gt;C++在内存管理，垃圾回收机制上常常受到人们的讨论。下面这一章将讨论C++的内存管理例程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;49 条款：了解new-handler的行为&lt;/li&gt;
&lt;li&gt;50 条款：了解new和delete的合理替换时机&lt;/li&gt;
&lt;li&gt;51 条款：编写new和delete时需固守常规&lt;/li&gt;
&lt;li&gt;52 条款：写了placement new也要写placement delete&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="effective cpp" scheme="https://wenhui-zhou.github.io/categories/effective-cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>effective cpp(七) 模板与范型编程</title>
    <link href="https://wenhui-zhou.github.io/2019/11/19/effective-cpp-%E4%B8%83-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E8%8C%83%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    <id>https://wenhui-zhou.github.io/2019/11/19/effective-cpp-七-模板与范型编程/</id>
    <published>2019-11-19T05:58:47.000Z</published>
    <updated>2019-11-25T13:39:12.086Z</updated>
    
    <content type="html"><![CDATA[<p>2019/11/19 effective cpp 第七章 模板与范型编程</p><p>C++ template最初是为了让我们建立类型安全的容器，如vector，list，map等等，后来随着越来越多的人用上模板之后，人们发现，template这种代码与其处理对象类型分离，彼此独立的风格很好，于是人们道出了模板元编程，template的作用越来越大。</p><p>本章主要解决在使用template上遇到的一些可以避免，优化的问题。</p><ul><li>41 条款：了解隐式接口和编译期多态</li><li>42 条款：了解typename的双重含义</li><li>43 条款：学习处理模板化基类内的名称</li><li>44 条款：将与参数无关的代码抽离template</li><li>45 条款：运用成员函数模板接受所有兼容类型</li><li>46 条款：需要类型转换时请为模板定义非成员函数</li><li>47 条款：请使用traits classes表现类型信息</li><li>48 条款：认识template元编程</li></ul><!--moew--><h3 id="41-条款：了解隐式接口和编译期多态"><a href="#41-条款：了解隐式接口和编译期多态" class="headerlink" title="41 条款：了解隐式接口和编译期多态"></a>41 条款：了解隐式接口和编译期多态</h3><p>面向对象编程总是以显式的接口和运行期多态来解决问题，它具有两个特点：</p><ul><li>必须在子类总的各种方法，且他的代码在源码中是明确可见的。</li><li>由于widget的某些成员函数是virtual，w对于那些函数的调用将表现出运行期间的多态，根据运行期间w的动态类型来决定调用哪一个函数。</li></ul><p>在template的泛型编程中，我们将函数转变为函数模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doProcessing</span><span class="params">(T&amp; w)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (w.size() &gt; <span class="number">10</span> &amp;&amp; w!= someWidget)&#123;</span><br><span class="line">    <span class="function">T <span class="title">temp</span><span class="params">(w)</span></span>;</span><br><span class="line">    temp.normalize();</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码，我们可以认为T这种类型应该具有size(),normalize()这些函数，允许进行大小的比较。但是实际上，对于模板类来说，他不一定必须要具备这些，这就是和显示接口的一个重大的不同。</p><p><strong>对于显式接口来说</strong>，<strong>他由函数的签名式构成，即包含函数的名称，参数类型，返回类型。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">widget</span>&#123;</span></span><br><span class="line">  widget();</span><br><span class="line">  <span class="keyword">virtual</span> ~widget();</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">normalize</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对于隐式接口来说，他并不是基于函数签名式，而是由有效表达式组成的，如上的第一份代码。</strong></p><p>由于操作符允许重载，因此在实现上述接口的时候，类型T不必要满足支持size成员函数，operation成员函数等。对于size()可由他的父类来提供。对于operator&gt;来说，只要存在一个隐式转换就能够进行类型的转换，将操作符两边的对象转换为同一种对象即可。</p><p><strong>总结</strong></p><ul><li>classes和templates都支持接口和多态</li><li>对class而言，接口式显式的，以函数签名为中心，多态则是通过virtual函数发生于运行期。</li><li>对template参数而言，接口式隐式的，基于有效表达式。多态则是通过template具现化和函数重载解析与编译期的。</li></ul><h3 id="42-条款：了解typename的双重含义"><a href="#42-条款：了解typename的双重含义" class="headerlink" title="42 条款：了解typename的双重含义"></a>42 条款：了解typename的双重含义</h3><p><strong>在template的声明式中，class和typename没有不同。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">widget</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">widget</span>;</span></span><br></pre></td></tr></table></figure><p>当我们在声明参数的时候，上面的两种表达方式完全相同。</p><p>在template中，我们存在着两种类型的变量。</p><p><strong>从属名称：</strong>template内部出现名称依赖于某个template参数。如果存在嵌套的话，则称为嵌套从属名称，如C::iterator，类型C的从属名称。</p><p><strong>非从属名称：</strong>对于类似于int那种名称，不依赖于template。</p><p>对于从属名称来说，typename有时候表示为一种类型，而有时候则是一个成员白能量，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span></span>&#123;</span><br><span class="line">  C::const_iterator*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当上式C::const_iterator表示一个变量的时候，上面变成一个乘法的表达式，如果他是一个类型的话，那就表示声明了一个local的指针。</strong></p><p>C++是如何区分这种情况的呢，<strong>C++在默认的情况下，处理从属关系的时候优先认为这是一个变量，而不是一个类型，除非你告诉编译器。</strong></p><p>显式告诉编译器这是个类型的方式是通过typename来实现的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span></span>&#123;</span><br><span class="line">  <span class="keyword">typename</span> C::<span class="function">cosnt_iterator <span class="title">iter</span><span class="params">(container.begin())</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>typename只被用来确定嵌套从属类型的名称，在其他地方不要去使用它。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> C&amp; container,         <span class="comment">// 一定不要使用typename</span></span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">typename</span> C::iterator iter)</span></span>;  <span class="comment">// 一定要使用typename</span></span><br></pre></td></tr></table></figure><p>此外，在typename在一个特殊的例子中是不允许使用的，就是 <strong>base class list 以及mem init list即父类列表，以及成员初始化的初始化列表中不允许使用。</strong></p><p>当我们在使用嵌套类型的时候，有时候类型名非常的长，我们希望通过typedef来给他重命名，可以将typedef typename一起连用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;iterT&gt;::value_type value_type;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li>声明template参数时，前缀关键字class和typename可互换。</li><li>请使用关键字typename标识嵌套从属类型的名称，但不得在base class lists或mem init list以他作为base class修饰符。</li></ul><h3 id="43-条款：学习处理模板化基类内的名称"><a href="#43-条款：学习处理模板化基类内的名称" class="headerlink" title="43 条款：学习处理模板化基类内的名称"></a>43 条款：学习处理模板化基类内的名称</h3><p>template的继承和显式的继承有些不同之处：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loggin</span>:</span><span class="keyword">public</span> MsgSender&lt;company&gt;&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMSG</span><span class="params">(<span class="keyword">const</span> MsgSender&lt;Company&gt;)</span></span>&#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">      sendClear(info);  <span class="comment">// 调用父类中的sendClear函数</span></span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码如果实在class的继承中，一定是成立的，但是template继承中则会出错，因为在继承<code>MsgSender&lt;company&gt;</code>的时候，编译器并不知道这是个什么样的class，也就自然不知道这个class中是否有一个sendClear函数了，因此上面的调用将会出错。</p><p>解决方法：</p><ol><li><strong>在base class函数调用动作之前加上this-&gt;</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loggin</span>:</span><span class="keyword">public</span> MsgSender&lt;company&gt;&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMSG</span><span class="params">(<span class="keyword">const</span> MsgSender&lt;Company&gt;)</span></span>&#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">      <span class="keyword">this</span>-&gt;sendClear(info);  <span class="comment">// 调用父类中的sendClear函数</span></span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>使用using声明式，是的父类的方法能够在子类中可见</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loggin</span>:</span><span class="keyword">public</span> MsgSender&lt;company&gt;&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMSG</span><span class="params">(<span class="keyword">const</span> MsgSender&lt;Company&gt;)</span></span>&#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">      <span class="keyword">using</span> MsgSender&lt;company&gt;::sendClear;</span><br><span class="line">      sendClear(info);  <span class="comment">// 调用父类中的sendClear函数</span></span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>明确指出函数在base class内</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loggin</span>:</span><span class="keyword">public</span> MsgSender&lt;company&gt;&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMSG</span><span class="params">(<span class="keyword">const</span> MsgSender&lt;Company&gt;)</span></span>&#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">      MsgSender::sendClear(info);  <span class="comment">// 调用父类中的sendClear函数</span></span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在template继承的时候，子类对父类的方法一无所知，因此我们需要通过this，或者明确指出父类方法的方式得到函数的声明。</p><p><strong>总结</strong></p><ul><li>可在derived class templates内通过<code>this-&gt;</code>指涉base class template内的成员名称，或由一个明白写出的base class资格的修饰符，使用using 或直接由类调用。</li></ul><h3 id="44-条款：将与参数无关的代码抽离template"><a href="#44-条款：将与参数无关的代码抽离template" class="headerlink" title="44 条款：将与参数无关的代码抽离template"></a>44 条款：将与参数无关的代码抽离template</h3><p>template是一个节约时间与避免代码重复的一个方法。但是有时候我们可能会导致代码膨胀。</p><p>一些指针，vector，list等等，位于父类函数中，将会造成代码的膨胀。</p><p><strong>总结</strong></p><ul><li>template生成多个class和多个参数，所以任何template代码都不该与某个造成膨胀的template参数产生相依的关系。</li><li>因非类型末班参数而造成的代码膨胀，往往可以消除，做法是用函数参数或class成员变量替代template参数</li><li>因类型参数而造成的代码膨胀往往可以降低，做法是让带有完全相同的二进制表述的具现类型共享实现码。</li></ul><h3 id="45-条款：运用成员函数模板接受所有兼容类型"><a href="#45-条款：运用成员函数模板接受所有兼容类型" class="headerlink" title="45 条款：运用成员函数模板接受所有兼容类型"></a>45 条款：运用成员函数模板接受所有兼容类型</h3><p>智能指针是行为上像是一个指针的对象，它提供了指针的所有机能，在STL容器中，我们总是使用智能指针。此外指针的另一很好的优点在于支持<strong>隐式转换</strong>，即子类指针可以隐式的转换为父类指针。但是这种关系在template类模板中是不存在的。</p><p><strong>用具有base-derived关系的对象去具现化某个template的时候，产生出来的的具现体并不具有base-derived的关系。</strong></p><p>一个可行的方法就是实现一个template构造函数，即构造模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    SmartPtr(<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; other);  <span class="comment">// 将一个具现化的u转型为t</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这一构造函数根据对象u创建对象t，而u和t的类型是同一个template的不同具现体，我们称这个函数为泛化copy构造函数。需要注意的是，<strong>上面的前提是说，一个U可以被转型为T。</strong></p><p>我们同样可以在构造函数中完成我们想要达到的转化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    SmartPtr(<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; other)</span><br><span class="line">      :heldPtr(other.get())&#123;...&#125;  <span class="comment">//  使用u的指针去初始化t变量的指针</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    T* heldPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样的，上述的做法是在 <strong>U指针可以隐式转换为T*的基础上才成立的。</strong></p><p>泛化copy构造函数与普通的copy构造函数之间不存在冲突，因此具现化后的类，依旧会为这个类实现一个copy构造函数。</p><p><strong>总结</strong></p><ul><li>请使用member function templates成员函数模板，生成可接受所有兼容类型的函数。（即上面的u-&gt;t）。</li><li>如果你声明member templates用于泛化copy构造或泛化assignment操作，你还是需要声明正常的copy构造函数和copy assignment操作符，因为编译器默认生成的函数不会因为生成泛化copy构造函数受到影响。</li></ul><h3 id="46-条款：需要类型转换时请为模板定义非成员函数"><a href="#46-条款：需要类型转换时请为模板定义非成员函数" class="headerlink" title="46 条款：需要类型转换时请为模板定义非成员函数"></a>46 条款：需要类型转换时请为模板定义非成员函数</h3><p>当我们在使用template来定义非成员函数，同时这个成员函数的参数需要隐式的转换的话，我们可能会遇到问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs,<span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure><p>当我们调用上面代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rational&lt;<span class="keyword">int</span>&gt; result = onehalf*<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>将会出现编译错误，因为template类型<code>Rational&lt;T&gt;</code>在具现化的时候需要确定T的类型，当遇到2的时候，C++无法推断出T为int，因此无法通过编译。</p><p>此路不通，我们曲线救国，通过将<code>Rational&lt;T&gt;</code>申请为class Rational的friend函数的方式来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">friend</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> rational&amp; lhs,<span class="keyword">const</span>&amp; rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过友元的方式来制定一个具体的函数，从而避免template进行参数的推导。</p><p>但是上面方法同样会引发一个问题，就是我们通过友元的方式，使得我们可以通过友元来确定函数，但是仅仅是个声明，没有函数的实现，一个最直接的方法就是我们直接将函数的本体定义在Rational乘法里头。</p><p><strong>总结</strong></p><ul><li>当我们需要编写一个class template，而他所提供的与此template相关的函数支持所有参数隐式类型转换时，请将那些函数定义为class template内部的friend函数。</li></ul><h3 id="47-条款：请使用traits-classes表现类型信息"><a href="#47-条款：请使用traits-classes表现类型信息" class="headerlink" title="47 条款：请使用traits classes表现类型信息"></a>47 条款：请使用traits classes表现类型信息</h3><p>在一些状况下，我们需要知道一个类的某些信息。<strong>traits构件</strong>就是做这件事情的，他是一种技术，也是C++程序员所遵守的一种协议。我们将trait放入一个template中去：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TT&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>;</span></span><br></pre></td></tr></table></figure><p>接下来我们确认一个traits中应该包含哪些信息：</p><ul><li>确认若干你希望将来可取得的类型的相关信息，例如对于迭代器，我们希望将来可取的他的分类。</li><li>为该信息选择一个名称</li><li>提供一个template与一组特化版本，内含你希望看到的相关信息</li></ul><p>接下来是如何使用traits：</p><ul><li>建立一个重载函数或函数模板，彼此的差异在于各自的trait参数；</li><li>建立一个控制函数或函数模板，用于调用上述的函数，并传递trait信息。</li></ul><p><strong>总结</strong></p><ul><li>traits class使得类型相关信息在编译期可用，它以template和templates特化完成实现。</li><li>整合重载技术后，trait class有可能在编译期对类型执行if … else 操作。</li></ul><h3 id="48-条款：认识template元编程"><a href="#48-条款：认识template元编程" class="headerlink" title="48 条款：认识template元编程"></a>48 条款：认识template元编程</h3><p>template metaprogramming元编程是编写template-based c++程序并执行与编译期的过程。</p><p><strong>总结</strong></p><ul><li>元编程可将工作由运行期移往编译期，因而得以实现早期错误侦测和更高的执行效率</li><li>TMP可被用来生成 <strong>基于政策选择组合</strong>的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。</li></ul><p>it is a little difficult for me,but never mind !</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2019/11/19 effective cpp 第七章 模板与范型编程&lt;/p&gt;
&lt;p&gt;C++ template最初是为了让我们建立类型安全的容器，如vector，list，map等等，后来随着越来越多的人用上模板之后，人们发现，template这种代码与其处理对象类型分离
      
    
    </summary>
    
      <category term="effective cpp" scheme="https://wenhui-zhou.github.io/categories/effective-cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>effective cpp(六) 继承与面向对象设计</title>
    <link href="https://wenhui-zhou.github.io/2019/11/16/effective-cpp-%E5%85%AD-%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/"/>
    <id>https://wenhui-zhou.github.io/2019/11/16/effective-cpp-六-继承与面向对象设计/</id>
    <published>2019-11-16T08:40:17.000Z</published>
    <updated>2019-11-19T10:14:53.249Z</updated>
    
    <content type="html"><![CDATA[<p>2019/11/16 effective cpp 第六章 继承与面向对象设计</p><p>面向对象编程成为一个风靡一时的重要特性，关于C++在面向对象上的一些特性，将在本章进行详细的介绍。</p><ul><li>32 条款：确定你的public继承塑膜出is-a关系</li><li>33 条款：避免遮掩继承而来的名称</li><li>34 条款：区分接口继承和实现继承</li><li>35 条款：考虑virtual函数与外的其他选择</li><li>36 条款：绝不重新定义继承而来的non-virtual函数</li><li>37 条款：绝不重新定义继承而来的缺省参数值</li><li>38 条款：通过符合塑模出has-a或“根据某物实现出”</li><li>39 条款：明智而审慎地使用private继承</li><li>40 条款：明智而审慎地使用多重继承</li></ul><a id="more"></a><h3 id="32-条款：确定你的public继承塑膜出is-a关系"><a href="#32-条款：确定你的public继承塑膜出is-a关系" class="headerlink" title="32 条款：确定你的public继承塑膜出is-a关系"></a>32 条款：确定你的public继承塑膜出is-a关系</h3><p>作者通过一个例子表明立场，说明一个<strong>戒慎恐惧</strong>的东西，将会使人们记得异常牢固。接下来他说我们应该用同样的心态记住下面的话：</p><p><strong>public继承意味着是一种is-a关系</strong>，即子类通过public的方式继承父类，那么子类在任何场合都可以直接转变为父类。</p><p>即D以public的方式继承自B，意味着B比D表现出更一般化的概念，D比B则表现出更加的特殊化。B可以使用的地方D一定可以使用，D可以使用的地方B不一定可以使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span>:</span><span class="keyword">public</span> Person&#123;...&#125;;</span><br></pre></td></tr></table></figure><p>上诉的代码表明是一个学生一定是一个人。任何函数希望得到一个person参数的时候，通常也愿意接受一个student对象。即给父类参数传递一个子类对象作为参数，是符合继承的观点，合法的。</p><p><strong>总结</strong></p><ul><li>public继承意味着“is-a”的关系。适用于base classes身上的每一件事情一定也适用于derived class 身上，因为每一个derived classes 对象也都是一个base classes对象。</li></ul><h3 id="33-条款：避免遮掩继承而来的名称"><a href="#33-条款：避免遮掩继承而来的名称" class="headerlink" title="33 条款：避免遮掩继承而来的名称"></a>33 条款：避免遮掩继承而来的名称</h3><p>这个内容与作用域相关，指的是在不同的作用域之中，变量的遮掩。编译器从local领域从发，向外一步步直到找到变量。</p><p>当我们在谈论继承的时候，当位于一个derived class成员函数的内指涉base class内的某物，编译器可以找出所指涉的东西，因为derived classes继承了声明与base class内的所有东西。<strong>子类的作用域嵌套在base class作用域内，子类对象可以调用父类的成员。</strong></p><p>例如下面例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">boid <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述例子中混合了public，private名称，以及一组成员变量和成员函数名称，包含了pure virtual，virtual，non-virtual三种，假设mf4函数实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Derived::mf4()&#123;</span><br><span class="line">  ...</span><br><span class="line">    mf2();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 当编译器遇到mf2的时候，必须估算他所指涉的东西，编译器的做法是查找各个作用域，看看有没有mf2的声明式，首先是local，然后是外围作用域，base的作用域，最外层的global作用域。</p><p>下面我们考虑一个重载带来的问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们重载了mf1和mf3函数，base class中的mf1和mf3都被子类的函数所代替，但是此时对于父类中的重载函数将会发生错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line">d.mf1(); <span class="comment">//正常调用</span></span><br><span class="line">d.mf1(x); <span class="comment">// 含参数的那个函数也被mf1函数所覆盖，因此调用出现问题</span></span><br><span class="line">d.mf3(); <span class="comment">// 正常调用</span></span><br><span class="line">d.mf3(x); <span class="comment">// 出错</span></span><br></pre></td></tr></table></figure><p>为了解决上面出现的遮掩行为造成的错误，我们可以使用using声明式来达到目的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line">  <span class="keyword">using</span> Base::mf1;</span><br><span class="line">  <span class="keyword">using</span> Base::mf3;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用using机制使得继承可以得到完美的实现。子类中调用d.mf3(x)将会到父类中寻找d.mf3(x)函数进行调用。</p><p><strong>这意味着你继承base class并加上重载函数，而你又希望重新定义或覆盖其中的一部分，那么你必须为那些原本会遮掩的每个名称引入一个using声明式，否则某些你希望的名称将会被遮掩。</strong></p><p>另一种情况是，当我们只希望继承父类重载的多个函数中的一个函数的时候，我们使用转交函数的方式，在子类函数中调用父类的函数，使其成为inline：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">private</span> Base&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>&#123;  <span class="comment">// 转交函数，只实现了一个版本，有参数的那个版本在子类中未继承</span></span><br><span class="line">      Base::mf1();  <span class="comment">// 使其成为inline</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li>子类内的名称会遮掩base classes内的名称，在public继承下从来没有人希望如此</li><li>为了让遮掩的名称重见天日，可以使用using 声明式或转交函数。</li></ul><h3 id="34-条款：区分接口继承和实现继承"><a href="#34-条款：区分接口继承和实现继承" class="headerlink" title="34 条款：区分接口继承和实现继承"></a>34 条款：区分接口继承和实现继承</h3><p>在类的继承中，可以通过三种方式进行继承：</p><ul><li>继承一个接口（pure virtual）</li><li>继承接口以及接口的部分实现，子类选择覆盖这些实现（impure virtual）</li><li>继承接口以及接口的部分实现，子类不覆盖这些实现（non-virtual）</li></ul><p><strong>成员函数的接口总是会被继承</strong></p><p>pure virtual函数最突出的特性，他们必须被任何继承了他们的具象class重新声明，而且他们在抽象class中通常没有定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shape</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>声明一个pure virtual函数的目的是为了让derived classes只继承函数接口。</strong></p><p>对于shape::draw函数来说，这样是十分合理的，因为每个shape对象都应该有一个draw函数，同时由于shape子类形状各异，因此父类无法提供一个缺省（通用的）实现方式。</p><p>但是令人意外的是：<strong>我们可以为纯虚pure virtual函数提供一份实现代码，但是调用他的唯一途径就是明确指出class的名称。</strong>但是pure virtual依然无法创建对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shape* ps = <span class="keyword">new</span> shape;</span><br><span class="line">shape* ps1 = <span class="keyword">new</span> Rectangle;</span><br><span class="line">ps1-&gt;draw();  <span class="comment">// Rectangle的draw函数</span></span><br><span class="line">ps1-&gt;shape::draw(); <span class="comment">// 调用了父类的draw函数</span></span><br></pre></td></tr></table></figure><p><strong>声明非纯impure virtual函数的目的，就是让derived classes继承该函数的接口和缺省实现。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shape</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示每个class都必须支持一个“当遇到错误时可调用”的函数，但每个class可自由处理错误。如果不愿意自己处理错误的话，也可以使用父类的缺省实现。</p><p>但是这就会出现一个问题，当我们继承了一个韩非纯函数的父类的时候，我们可能会忘记实现自己的版本，此时编译器就会为了安排默认的版本，而引发错误，下面这种做法就是为了解决这个问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(cosnt sAirport&amp; destination)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">defaultFly</span><span class="params">(cosnt Ariport&amp; destination)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Airplane::defaultFly(<span class="keyword">const</span> Airport&amp; destination)&#123;</span><br><span class="line">  <span class="comment">//fly函数中的实现部分改到这里来写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述操作将fly函数又impure设置成pure函数，意味着子类必须有自己实现的版本，在缺省的实现部分转移到defaultFly当中去，如果子类不实现fly函数则会报错，如果希望用缺省方式的话，则调用defaultFly函数。</p><p>但是上面这种做法将会导致代码的重复这种情况。</p><p>另一种做法是将默认的实现部分转移到纯虚函数的实现中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(cosnt Airport&amp; destination)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Airplane::fly(cosnt Airport&amp; destination)&#123;</span><br><span class="line">  <span class="comment">//缺省行为，将飞机飞至指定的目的地</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span>:</span><span class="keyword">public</span> Airplane&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>&#123;</span><br><span class="line">      Airplane::fly(destination); <span class="comment">// 使用缺省的方式实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br><span class="line"><span class="comment">// 如果你要自己实现fly这个函数的话，可以自己写相应的方法</span></span><br></pre></td></tr></table></figure><p>这种方式避免了再去定义一个defaultFly函数。现在的fly函数被切割成两个部分，其声明部分表现的是接口，其定义部分表现出缺省行为。</p><p><strong>声明non-virtual函数的目的就是为了令derived classes继承函数的接口及一份强制性的实现。</strong></p><p>由于non-virtual函数代表的意义是不变性凌驾于特异性之上，我们绝对不要在子类中重新定义父类中的non-virtual函数。</p><p><strong>总结</strong></p><ul><li>接口继承和实现继承不同。在public继承之下，derived classes总是继承base class的接口。</li><li>pure virtual函数只具体指定接口继承。</li><li>非纯的函数具体制定接口继承及缺省实现继承。</li><li>non-virtual函数具体指定接口继承以及强制性实现继承。</li></ul><h3 id="35-条款：考虑virtual函数与外的其他选择"><a href="#35-条款：考虑virtual函数与外的其他选择" class="headerlink" title="35 条款：考虑virtual函数与外的其他选择"></a>35 条款：考虑virtual函数与外的其他选择</h3><p>我们可以使用一些其他的方式来代替virtual的使用</p><p><strong>template method模式</strong></p><p>这种模式为将虚函数修改为public的non-virtual函数，然后其具体的实现通过定义一个private的virtual函数来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">      ... <span class="comment">// 调用前准备</span></span><br><span class="line">      <span class="keyword">int</span> retval = dohealthValue();</span><br><span class="line">      ... <span class="comment">// 调用后处理</span></span><br><span class="line">      <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">dohealthValue</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 上面的设计令用户通过public non-virtual成员函数佳节调用private virtual函数的模式（NVI non-virtual interface），把non-virtual函数作为一个外覆器，在调用前后都可以进行一些处理，这是这种方法的一个优点，但是缺点是我们需要定义很多private virtual函数。</p><p><strong>籍由Function Pointers实现strategy模式</strong></p><p>利用传入一个函数指针的方式，进行实际的操作。</p><p>函数指针的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">defaultHealth</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"><span class="comment">//函数指针如下</span></span><br><span class="line">return_types (*func_pointer)( data_types arg1, data_types arg2, ..);</span><br><span class="line"><span class="keyword">int</span> (*defaultHealth)(<span class="keyword">const</span> GameCharacter&amp;);</span><br><span class="line"><span class="comment">//使用上面的定义之后，就可以用指针defaultHealth来调用函数了</span></span><br></pre></td></tr></table></figure><p>上述这种方法提供了某种弹性，在调用不同的类型的时候，传入不同计算方法的函数的指针，得到不同的计算方式。当我们使用了类外的方法的时候，我们可能会陷入一个陷阱中，就是这个函数只能访问类的public部分，如果我们想进一步的话，就只能降低函数的封装级别了。</p><p><strong>籍由tr1::function完成strategy模式</strong></p><p><strong>C++ Technical Report 1 （TR1</strong>）是ISO/IEC TR 19768, C++ Library Extensions（函式库扩充）的一般名称。TR1是一份文件，内容提出了对C++标准函式库的追加项目。这些追加项目包括了正则表达式、智能指针、哈希表、随机数生成器等。</p><p><strong>function 是一种通用、多态的函数封装</strong>。<strong>std::function 的实例可以对任何可以调用的目标进行存储、复制、和调用操作，这些目标包括函数、lambda 表达式、绑定表达式、以及其它函数对象等</strong>。（c++11起的版本可用）<br>　　function（和bind一样）可以实现类似函数指针的功能，却比函数指针更加灵活（体现在占位符上面），尤其是在很多成员调用同一个函数（仅仅是参数类型不同）的时候比较方便。</p><p><strong>C++中的函数签名(function signature)</strong>：包含了一个函数的信息，包括函数名、参数类型、参数个数、顺序以及它所在的类和命名空间。</p><p>function对象只要签名式满足要求，那么这个对象就可以存储任何可调用物。下面我们使用function来替代上面的函数指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::str1::function&lt;<span class="keyword">int</span> (<span class="keyword">const</span> GameCharacter&amp;)&gt; healthCalFunc;</span><br><span class="line">    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc):healthFunc(hfc)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> healthFunc(*<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面代码可以看出来，我们只要传入一下接受一个const reference参数的任意函数都可以，我们可以使用函数，函数对象，成员函数等等。</p><p><strong>古典的strategy模式</strong></p><p>传统的strategy做法将一个健康的计算函数做成一个分离的继承体系中的virtual成员函数。</p><p><strong>替代方案</strong></p><p>本条条款的核心就是可以通过一下几种方式来找到virtual的替代方案：</p><ul><li>使用non-virtual interface手法，那是template method设计模式的一种特殊形式，它以public non-virtual成员函数包裹较低访问性的virtual函数。</li><li>将virtual函数替换为函数指针成员变量，这是strategy设计模式的一种分解形式。</li><li>以tr1::function成员变量替换virtual函数，因而允许使用任何可调用物来搭配一个兼容于需求的签名式。</li><li>将继承体系内的virtual函数替换为另一个继承体系内的virtual函数，这是strategy设计模式的传统实现方法。</li></ul><p><strong>总结</strong></p><ul><li><p>virtual 函数的替代方案包含NVI，以及strategy设计模式的多种形式，NVI手法是一个特殊形式的template method模式。</p></li><li><p>将机能从成员函数一道class外部函数，带来一个缺点，非成员函数无法访问class的non-public成员。</p></li><li>tr1::function对象行为就像一般函数指针，这样的对象可接纳与给定目标签名式兼容的所有可调物。</li></ul><h3 id="36-条款：绝不重新定义继承而来的non-virtual函数"><a href="#36-条款：绝不重新定义继承而来的non-virtual函数" class="headerlink" title="36 条款：绝不重新定义继承而来的non-virtual函数"></a>36 条款：绝不重新定义继承而来的non-virtual函数</h3><p>在一个类中，我们定义了non-virtual函数，意味着我们遵循设计原则，认为这个函数的不变性要大于特异性，因此我们不可以在子类中对这个函数进行覆盖。否则，将同一个元素赋值给父类和子类，将导致不同的行为，这是我们不希望看到的。</p><p><strong>总结</strong></p><ul><li>绝对不要重新定义继承而来的non-virtual函数</li></ul><h3 id="37-条款：绝不重新定义继承而来的缺省参数值"><a href="#37-条款：绝不重新定义继承而来的缺省参数值" class="headerlink" title="37 条款：绝不重新定义继承而来的缺省参数值"></a>37 条款：绝不重新定义继承而来的缺省参数值</h3><p>当我们继承一个父类的时候，如果父类中的virtual函数带有缺省值，我们选择不去重写这个缺省值。原因是：</p><p><strong>virtual函数系动态绑定，而缺省参数值确实静态绑定。</strong>因此缺省的参数值在定义的时候就会被确定，缺省值就是定义这个函数的类给赋予的。如下面代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> shapecolor&#123;red,green,blue&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(shapecolor color = red)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rectangle</span>:</span><span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(shapecolor color = green)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> rectangle::draw(Shape::shapecolor color) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"---"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; color;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"---"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shape *ps = <span class="keyword">new</span> rectangle();</span><br><span class="line">rectangle* rec = <span class="keyword">new</span> rectangle();</span><br><span class="line">ps-&gt;draw();  <span class="comment">// 使用静态绑定的shape中的缺省值</span></span><br><span class="line">rec-&gt;draw(); <span class="comment">// 使用静态绑定的rectangle中的缺省值</span></span><br></pre></td></tr></table></figure><p>上述代码就可以看出矛盾，同一个对象却有不同的表现，导致缺省值的不同。上述代码的一个解决方案就是使用NVI方式，用non-virtual去调用virtual函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> shapecolor&#123;red,green,blue&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(shapecolor color = red)</span></span>&#123;</span><br><span class="line">        doDraw(color);  </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(shapecolor color)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rectangle</span>:</span><span class="keyword">public</span> shape&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(shapecolor color)</span> <span class="keyword">const</span></span>;  <span class="comment">// 这里不需要指定缺省的参数值</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>由于non-virtual函数是不会被子类覆盖。这个设计保证了参数值一定是一致的。</p><p><strong>总结</strong></p><ul><li>绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定的，而virtual函数（你唯一需要覆盖的东西）是动态绑定的。</li></ul><p>###38 条款：通过符合塑模出has-a或“根据某物实现出”</p><p>has-a表现出来的是一种复合关系（composition），当某种类型的对象内含它种类型的对象，便是这种关系。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    Address ad; <span class="comment">// 其他类型的生成对象</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">  PhoneNumber num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，还有另一种关系，成为 <strong>is-implemented-in-terms-of</strong> 关系，例如我们实现一个set，直觉上我们可以继承标准库中的set，但是为了资源等考虑，我们打算另辟蹊径。我们可能就会考虑到list的实现，但是我们不能直接继承list，因为list与set不是is-a的关系。但是我们可以在函数中多次使用list结构来构造一个set，<strong>这就是根据某物实现出</strong>的这种关系。</p><p><strong>总结</strong></p><ul><li>复合的意义和public继承完全不同</li><li>在应用域，复合意味着is-a关系。在实现域，复合意味着根据某物来实现。</li></ul><h3 id="39-条款：明智而审慎地使用private继承"><a href="#39-条款：明智而审慎地使用private继承" class="headerlink" title="39 条款：明智而审慎地使用private继承"></a>39 条款：明智而审慎地使用private继承</h3><p>private继承不是一个is-a继承，而是一种子类实现需要使用父类的某些函数性质的 “implemented-in-terms-of”的关系。</p><p>对于private的选择，我们通常会考虑：<strong>当一个意欲成为derived class者想要访问一个意欲成为base class者的protected成分，或者成为重新定义一个或多个virtual函数。</strong>如果满足这个条件的话，我们会考虑使用private继承，但是很多情况下，我们使用复合，将private继承的类作为一个成员变量的方式，能够提供能多的灵活性。</p><p><strong>即：我们可以使用复合的方式来代替private的继承，保证更大的灵活性。</strong></p><p>但是如果我们追求一种更加激进的空间优化，我们会选择使用private继承来代替复合。</p><p>如果我们使用的类满足不带数据成员，没有virtual等条件，满足空白基类最优化EBO的情况下，我们应该优先考虑private继承，但是这种情况基本很少见。</p><p><strong>总结</strong></p><ul><li>private继承意味着 <strong>根据某物实现出</strong>的关系，它通常比复合的级别要低，当时当子类需要访问protected base class的成员，或需要重新定义继承而来的cirtual函数时，是合理的。</li><li>和复合不同，private继承可以造成empty base最优化，这对于严格要求“对象尺寸最小化”的程序开发者而言是很重要的。</li></ul><h3 id="40-条款：明智而审慎地使用多重继承"><a href="#40-条款：明智而审慎地使用多重继承" class="headerlink" title="40 条款：明智而审慎地使用多重继承"></a>40 条款：明智而审慎地使用多重继承</h3><p>当我们设计到多重继承的时候，在子类的使用上将会面临起义的一个问题，共同父类中相同的函数，必须通过类名的方式进行调用。</p><p>对于钻石形的继承关系，我们使用virtual来继承，使得每一个子类都有一份供自己使用的父类成员变量。但是使用virtual将会导致C++编译器在处理这类继承时，生成体积较大的对象，访问速度也比较慢，virtual继承付出的代价更加的明显，规则复杂不够直观。</p><p><strong>忠告</strong></p><ul><li><p>非必须使用virtual bases的时候不要使用它，大部分情况使用non-virtual继承</p></li><li><p>如果必须使用virtual base继承，那么尽量避免在其中放置数据，使得类小一点，以及不会出现难以察觉的赋值问题。</p></li></ul><p>但是有些时候，双重继承也有其合理的用途，保留使用多重继承的看法。如果能用单一继承代替多重继承的话，单一继承是一个非常好的选择。</p><p><strong>总结</strong></p><ul><li>多重继承比单一继承复杂，他可能导致起义性，以及对virtual继承的需要</li><li>virtual继承会增加大小，速度，初始化复杂度等成本，如果virtual base classes不带任何的数据，将会是多重继承最具有使用价值的情况。</li><li>多重继承的确有正当用途，其中一个情节涉及public继承某个interface class和private继承某个协助实现的class的两相组合。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019/11/16 effective cpp 第六章 继承与面向对象设计&lt;/p&gt;
&lt;p&gt;面向对象编程成为一个风靡一时的重要特性，关于C++在面向对象上的一些特性，将在本章进行详细的介绍。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;32 条款：确定你的public继承塑膜出is-a关系&lt;/li&gt;
&lt;li&gt;33 条款：避免遮掩继承而来的名称&lt;/li&gt;
&lt;li&gt;34 条款：区分接口继承和实现继承&lt;/li&gt;
&lt;li&gt;35 条款：考虑virtual函数与外的其他选择&lt;/li&gt;
&lt;li&gt;36 条款：绝不重新定义继承而来的non-virtual函数&lt;/li&gt;
&lt;li&gt;37 条款：绝不重新定义继承而来的缺省参数值&lt;/li&gt;
&lt;li&gt;38 条款：通过符合塑模出has-a或“根据某物实现出”&lt;/li&gt;
&lt;li&gt;39 条款：明智而审慎地使用private继承&lt;/li&gt;
&lt;li&gt;40 条款：明智而审慎地使用多重继承&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="effective cpp" scheme="https://wenhui-zhou.github.io/categories/effective-cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>effective cpp(五) 实现</title>
    <link href="https://wenhui-zhou.github.io/2019/11/10/effective-cpp-%E4%BA%94-%E5%AE%9E%E7%8E%B0/"/>
    <id>https://wenhui-zhou.github.io/2019/11/10/effective-cpp-五-实现/</id>
    <published>2019-11-10T11:26:50.000Z</published>
    <updated>2019-11-16T08:42:36.806Z</updated>
    
    <content type="html"><![CDATA[<p>2019/11/10，effective cpp第五章 实现</p><p>cpp在实现上存在着很多高效率，代码优化的细节。</p><ul><li>26 条款：经可能延后变量定义式的出现时间</li><li>27 条款：尽量少做转型动作</li><li>28 条款：避免返回handles指向对象内部成分</li><li>29 条款：为异常安全而努力是值得的</li><li>30 条款：透彻了解inlining 的里里外外</li><li>31 条款：将文件间的编译依存关系降至最低</li></ul><a id="more"></a><h3 id="26-条款：经可能延后变量定义式的出现时间"><a href="#26-条款：经可能延后变量定义式的出现时间" class="headerlink" title="26 条款：经可能延后变量定义式的出现时间"></a>26 条款：经可能延后变量定义式的出现时间</h3><p>我们定义一个变量需要承担它的构造成本以及析构成本，如果我们在程序中，由于一些判断条件未能使用到这些变量，那么将造成大量的时间浪费，于是我们应当尽量的延后变量的定义。</p><p>第二个优化的地方在于在定义变量的时候，通过调用构造函数来初始化变量，而不是通过赋值的方式。（通过赋值的方式将会浪费一次系统默认的赋值时间）</p><p>第三个优化的地方，如果我们需要在一个循环中使用变量的话，<strong>我们应该在循环的内部定义变量</strong>，除非析构与构造的成本比较高，且你的代码对效率高度敏感。</p><p><strong>总结</strong></p><ul><li>尽可能延后变量定义式的出现，这样做可以增加程序的清晰度，并改善程序的效率。</li></ul><h3 id="27-条款：尽量少做转型动作"><a href="#27-条款：尽量少做转型动作" class="headerlink" title="27 条款：尽量少做转型动作"></a>27 条款：尽量少做转型动作</h3><p>首先是结论：<strong>优良的C++代码很少使用转型</strong></p><p>C++的设计目标之一就是保证类型错误绝不可能发生，尽量保证任何转型动作尽可能少的发生。转型动作破坏了类型系统，导致一些很隐晦的错误。C++提供的转型变换如下：</p><ul><li><p><code>const_cast&lt;T&gt; (expression)</code>，通常用于对象的常量性移除，将常量去除</p></li><li><p><code>dynamic_cast&lt;T&gt;(expression)</code>，主要用于执行“安全向下转型”，用来决定某对象是否归属继承体系中的某个类型。可能耗费比较大的运行成本。</p></li><li><code>reinterpret_cast&lt;T&gt;(expression)</code>，执行低级转型，例如将point to int 转成int。</li><li><code>static_cast&lt;T&gt;(expression)</code>，用来强迫执行隐式转型，将int转成double等等。</li></ul><p>旧式的转型：</p><ul><li><code>(T)expression</code></li><li><code>T(expression)</code></li></ul><p>旧式的两种写法功能相同，建议使新式的转型方法，因为他们在代码上容易辨认，且各个转型动作目标比较窄，容易排查错误,例如只有const_cast方法才能实现对象的常量移除。</p><p>关于<code>dynamic_cast</code>方法，例如我有有些时候，希望在子类函数调用的时候先调用父类的函数，会写出下面的代码（错误的）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">special</span>:</span> <span class="keyword">public</span> window&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;window&gt;(*<span class="keyword">this</span>).onResize();</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上诉代码将this转为window的指针，但是他调用的并不是当前对象上的函数，<strong>转型动作将产生一个this对象的base class的成分的一个副本</strong>。因此window上的onsize操作只是在一个副本上执行操作的，并不会改变this对象的内容。解决的方法是直接调用父类的onsize方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">special</span>:</span> <span class="keyword">public</span> window&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    window::onResize();</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>dynamic_cast</code>的场景通常说，我们手上只有一个base class的指针，但是想希望通过它来执行子类的一些操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;tr1::<span class="built_in">shared_ptr</span>&lt;window&gt;&gt; vpw;</span><br><span class="line">vpw winptr;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">for</span>(vpw::iterator iter=winptr.begin();iter!=winptr.end();++iter)&#123;</span><br><span class="line">    <span class="keyword">if</span>(special* psw=<span class="keyword">dynamic_cast</span>&lt;special*&gt;(iter-&gt;get()))</span><br><span class="line">      psw-&gt;blink();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面代码效率比较低，而且令人担心，因此最后直接用子类的容器存储指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;tr1::<span class="built_in">shared_ptr</span>&lt;special&gt;&gt; vpsw;</span><br><span class="line">vpsw winptr;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(vpsw::iterator iter = winptr.begin();iter!=winptr.end();++iter)&#123;</span><br><span class="line">  (*iter)-&gt;blink();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上面的代码童谣失去了指向所有可能子类的可能，<strong>一个可行的解决方案就是为在base class提供一个缺省实现的blink函数声明。或者是直接用上述方式写出子类</strong></p><p>不论是哪一种写法：使用类型安全容器，或将virtual函数往继承体系上方移动，都是一个替代dynamic_cast 的可行方案。</p><p>绝对需要避免的一种写法是连串使用多个dynamic_cast，这种代码将又大又慢，同时十分的不安全。</p><p><strong>总结</strong></p><ul><li>如果可以，尽可能避免转型，特别在注重效率的代码中避免使用<code>dynamic_cast</code></li><li>如果转型是必要的，试着将它隐藏呀某个函数背后，供客户调用</li><li>宁可使用C++新式的转型，因为容易辨认，同时便于排查错误。</li></ul><h3 id="28-条款：避免返回handles指向对象内部成分"><a href="#28-条款：避免返回handles指向对象内部成分" class="headerlink" title="28 条款：避免返回handles指向对象内部成分"></a>28 条款：避免返回handles指向对象内部成分</h3><p><strong>handles指的是诸如reference，指针，迭代器这种用来取得某个对象的变量，我们应当避免直接返回指向对象内部数据或函数的handle出现。</strong></p><p>如下，我们打算实现一个矩阵类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">point</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    point(<span class="keyword">int</span> x,<span class="keyword">int</span> y);</span><br><span class="line">  ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义角</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RectData</span>&#123;</span></span><br><span class="line">  point ulhc;</span><br><span class="line">  point lrhc;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义矩阵</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>&#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    tr1::<span class="built_in">shared_ptr</span>&lt;RectData&gt; pData;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">point&amp; <span class="title">upper</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> pData-&gt;ulhc;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>upper函数取得矩阵左上角的点，返回一个引用，这个引用指向了矩阵内部的点，就会引发一个矛盾，我们使用一个const函数，但是返回的值是private数据，且可以被修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Rectangle <span class="title">rec</span><span class="params">(coord1,coord2)</span></span>;</span><br><span class="line">rec.upper().setX(<span class="number">50</span>); <span class="comment">//被修改</span></span><br></pre></td></tr></table></figure><p>从从上面我们可以得出两条结论，</p><ul><li>第一条，成员变量的封装性只能等于返回其reference的级别，即引用的级别决定了封装性。</li><li>第二条，如果const成员函数传出一个reference，后者所指的数据与对象自身有关联，而他又被存储与对象之外，那么这个函数的调用者可以修改那笔数据。</li></ul><p>一个好的解决办法就是在函数调用的时候，将返回值的内容设置成const：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> pData-&gt;ulhc;&#125;</span><br></pre></td></tr></table></figure><p>但是即使如此，如果直接返回代表对象内部数据的handle的话，有可能这个handle的生存周期比对象本身的生存周期要长，那么将导致空悬指针的发生（dangling handles）。</p><p>因此：<strong>尽量避免将对象内部的handles传出去。</strong></p><p><strong>总结</strong></p><ul><li>避免返回handles指向对象内部，遵守这个条款可以增加封装性，使得const更加像一个const，并避免虚调handles的发生。</li></ul><h3 id="29-条款：为异常安全而努力是值得的"><a href="#29-条款：为异常安全而努力是值得的" class="headerlink" title="29 条款：为异常安全而努力是值得的"></a>29 条款：为异常安全而努力是值得的</h3><p>对于一个异常安全性的函数来说，他通常有两个条件：</p><ul><li><strong>不泄漏任何资源</strong></li><li><strong>不允许数据败坏</strong>：即出现类似空指针，指向已经销毁的对象这种情况</li></ul><p>第一种情况可以通过资源管理类来完美的解决，下面专门来解决第二种情况</p><p><strong>异常安全函数</strong>提供以下三种程度的保证：</p><ul><li><strong>基本承诺：</strong>如果异常被抛出，程序内的任何事物仍然保持在有效状态下</li><li><strong>强烈承诺：</strong>如果异常被抛出，程序状态不改变，如果函数成功就完全成功，如果函数失败，就恢复到调用函数之前的状态。</li><li><strong>不抛掷保证：</strong>承诺不抛出异常，他们总能完成承诺的功能，例如一些内置类型等。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>上面的函数带有指定的空白异常，也就是说上述函数抛出异常的话，将会产生很严重的后果，但是该函数并不能提供任何异常安全的保证，异常安全的保护正完全由实现来决定。</p><p>对于异常安全来说，保证不抛出异常基本难以实现。基本上能够实现强烈承诺或基本承诺就可以满足需求了。</p><p>实现强烈承诺，即出现异常情况对象的状态不发生改变，有一个策略称为：<strong>copy and swap</strong>，即为打算修改的对象提供一份副本，并在那个副本上做一切必要的修改，如果出现异常，则原对象未发生改变，如果正常则将副本和原对象进行交换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> pretty::changeBackground(istream&amp; imgSrc)&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">  <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;    <span class="comment">// 获得mutex的副本</span></span><br><span class="line">  tr1::<span class="built_in">shared_ptr</span>&lt;PMImpl&gt; pNew(<span class="keyword">new</span> PMImpl(*pImpl)); </span><br><span class="line">  pNew-&gt;bgImage.reset(<span class="keyword">new</span> Image(imgSrc));</span><br><span class="line">  ++pNew-&gt;imageChanges;</span><br><span class="line">  swap(pImpl,pNew);  <span class="comment">// 释放mutex</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出来，对函数的异常保证将花费大量的资源，因此如果强烈保证不能满足的情况下，你就应该转向基本满足的情况。</p><p>对于一个对象来说，它的异常保证的级别取决于最差的一个异常保证函数。</p><p><strong>总结</strong></p><ul><li>异常安全函数即使发生异常也不会泄露资源或允许任何数据结构败坏，这样的函数区分为三种可能的保证：基本型，强烈型，不抛异常型</li><li>强烈保证往往能够以copy and swap实现出来</li><li>函数提供的异常安全保证，通常最高值等于其所调用的各个函数的异常安全保证种最弱的</li></ul><h3 id="30-条款：透彻了解inlining-的里里外外"><a href="#30-条款：透彻了解inlining-的里里外外" class="headerlink" title="30 条款：透彻了解inlining 的里里外外"></a>30 条款：透彻了解inlining 的里里外外</h3><p>inline函数，使用起来像函数，调用他们又不用蒙受额外的函数调用所导致的开销，编译器的最优化机制通常被设计成用来浓缩那些<strong>不含函数调用</strong>的代码，因此inline函数也会得到编译器在当前语境下的最优化处理。</p><p>但是过度使用inline同样会导致很多问题，首先是使得程序的目标码过大，导致一些效率上的损失。</p><p><strong>总之，如果inline函数的本体很小，编译器对函数本体所产出的代码可能比函数调用所产出的代码要小，这种情况将函数inlining确实可以导致较小的目标码和较高的指令高速缓存装置的击中率。</strong></p><p><strong>inline函数的做法</strong>：隐喻的做法是将函数定义在class内，自动就完成了inline的操作。明确声明的做法则是在函数前面加上inline关键字。</p><p><strong>inline函数通常一定被放置于头文件内，因为大多数的生成环境在编译过程中进行inline，需要知道函数本体长什么样子。</strong></p><p>模版类templates也通常被置于头文件内，因为它一旦被使用，编译器为了将它具体化，需要知道它长什么样子。但是templates与inline没有直接的联系，如果你觉得该templates内的函数都比较简单，可以进行inline的话，才会去定义为inline。</p><p><strong>inline是一个申请，编译器可以拒绝</strong></p><p>也就是说，一个函数最终实现方式是否是inline，取决于编译器是否同意该函数满足inline的条件。</p><p>例如大部分过于复杂（含循环，递归等）的函数，virtual声明的函数，通常都会被定义为outline函数。</p><p>有些编译器有意愿inlining某个函数，但是也可能为函数生成一个函数本体。<strong>例如程序要取得某个inline函数的地址，编译器通常必须为此函数生成一个outline函数本体。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;...&#125; <span class="comment">//假设编译器有意愿inline对f的调用</span></span><br><span class="line"><span class="keyword">void</span> (*f)()  = f;</span><br><span class="line">f(); <span class="comment">// 调用inline</span></span><br><span class="line">pf(); <span class="comment">// 调用outline的本体</span></span><br></pre></td></tr></table></figure><p>有时候，编译器会为析构函数和构造函数生成一个函数的副本，这样他们就可以获得指针指向那些需要指针的函数，但是这样一来，导致了析构函数和构造函数的赋值过程。</p><p>实际上析构函数，构造函数往往是inline糟糕的候选人，因为C++在创建对象的时候，将构造对象，析构对象，异常处理等一些操作隐藏在析构函数和构造函数内部，因此函数内部存在着很多的对象。但是对这些对象的副本往往会造成很大的资源消耗。</p><p><strong>因此，是否将构造函数和析构函数inline化，是一个慎重的考虑。</strong></p><p><strong>inline函数修改后必须重新编译</strong></p><p>此外，inline函数还存在一个问题。当我们对inline函数进行修改的时候，原来函数的本体因为已经编译进程序的内部了，无法通过函数的链接步骤实现修改，而是需要对整个程序进行重新编译。</p><p><strong>总结</strong></p><ul><li>将大多数inlining限制在小型、被频繁调用的函数身上，这可使得日后的调试过程和二进制升级更加容易，也可使潜在的代码膨胀问题最小化，使得程序速度提升最大化。</li><li>不要滥用inline，不用只因为function templates出现在头文件中就将他们声明为inline，因为很多时候，这些函数不符合inline标准，编译器还是会为他们生成outline版本</li></ul><h3 id="31-条款：将文件间的编译依存关系降至最低"><a href="#31-条款：将文件间的编译依存关系降至最低" class="headerlink" title="31 条款：将文件间的编译依存关系降至最低"></a>31 条款：将文件间的编译依存关系降至最低</h3><p>文件之间的依存关系越是复杂将会导致函数之间的耦合度越高，对修改代码带来不便。</p><p>例如你仅仅对class进行轻微的修改，但是这将导致所有用到这个文件的程序都需要进行重新编译，这一连串的编译依存关系将导致难以形容的灾难。</p><p>例如下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"data.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"address.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,<span class="keyword">const</span> Date&amp; birthday);</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">birthday</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> thename;</span><br><span class="line">    Data theData;</span><br><span class="line">    address add;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的类别的私有变量中，string，Data需要用到其他的头文件来创建（实现细则），这些头文件任意一个被修改后都将导致Person class重新编译。</p><p>针对这种形式，我们可以这样做：</p><p><strong>把person分割为两个classes，一个只提供接口，另一个负责实现该接口。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>;</span>   <span class="comment">// 类的前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,<span class="keyword">const</span> Date&amp; birthday);</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">birthday</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    str1::<span class="built_in">shared_ptr</span>&lt;PersonImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类PersonImpl为person类的实现，这样的话，修改Data类就不需要对Person函数进行重新编译，将person与其他类进行分离。</p><p>这个分离的关键在于：<strong>使用声明的依存性</strong>来代替<strong>定义的依存性</strong>，尽量让头文件自我满足，万一无法做到，那么让它和其他文件内的声明式相依（而不是定义式）。</p><p>下面一些准则都是这个原则下完成的：</p><ul><li>如果使用object references 或objects pointers可以完成任务，就不要使用object，即使用声明式来代替定义式。</li><li><p>尽量以class声明式代替class定义式。</p></li><li><p><strong>为声明式和定义式提供不同的头文件</strong>，为一个文件提供函数的声明，而不是而代替提供class的定义式，这样可将文件见的编译依存关系去掉。因此我们需要定义两个文件，一个是声明式，另一个是定义式。</p></li></ul><p>上面这个实现使得代码编，让Person变成一个handle class。</p><p><strong>抽象基类</strong></p><p>通过制作抽象类的方式，也可以实现这种操作。通过定义抽象类函数接口，创建不同类型的的派生类对象。</p><p>handle classes 和interface class解除了接口和实现之间的耦合关系，从而减低了文件间的编译依存关系。但是也在某种程度上使得每个对象超额付出若干的时间以及空间的成本。</p><p><strong>总结</strong></p><ul><li>支持<strong>编译依存最小化</strong>的一般构想是：相依与声明式，不要相依于定义式，基于此的构想的两个手段是 handle classes，interface classes。</li><li>程序库头文件应该以完全且仅有的声明式的形式存在，这种做法不论是否涉及templates都适用。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019/11/10，effective cpp第五章 实现&lt;/p&gt;
&lt;p&gt;cpp在实现上存在着很多高效率，代码优化的细节。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;26 条款：经可能延后变量定义式的出现时间&lt;/li&gt;
&lt;li&gt;27 条款：尽量少做转型动作&lt;/li&gt;
&lt;li&gt;28 条款：避免返回handles指向对象内部成分&lt;/li&gt;
&lt;li&gt;29 条款：为异常安全而努力是值得的&lt;/li&gt;
&lt;li&gt;30 条款：透彻了解inlining 的里里外外&lt;/li&gt;
&lt;li&gt;31 条款：将文件间的编译依存关系降至最低&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="effective cpp" scheme="https://wenhui-zhou.github.io/categories/effective-cpp/"/>
    
    
  </entry>
  
</feed>

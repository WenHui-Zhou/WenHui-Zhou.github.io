<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WenHuiZhou</title>
  
  <subtitle>perper（打起精神！）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wenhui-zhou.github.io/"/>
  <updated>2019-09-04T04:14:32.421Z</updated>
  <id>https://wenhui-zhou.github.io/</id>
  
  <author>
    <name>WenHuiZhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>超分辨率论文摘要阅读</title>
    <link href="https://wenhui-zhou.github.io/2019/09/03/%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87%E8%AE%BA%E6%96%87%E6%91%98%E8%A6%81%E9%98%85%E8%AF%BB/"/>
    <id>https://wenhui-zhou.github.io/2019/09/03/超分辨率论文摘要阅读/</id>
    <published>2019-09-03T07:40:23.000Z</published>
    <updated>2019-09-04T04:14:32.421Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客的主要目的为了记录阅读的超分辨率论文的摘要部分，了解超分辨率领域的研究前沿进度。</p><a id="more"></a><h3 id="值得注意的网页"><a href="#值得注意的网页" class="headerlink" title="值得注意的网页"></a>值得注意的网页</h3><ol><li>github上关于超分辨率领域的SOAT论文的整理：<a href="https://github.com/YapengTian/Single-Image-Super-Resolution" target="_blank" rel="noopener">https://github.com/YapengTian/Single-Image-Super-Resolution</a></li><li>知乎上关于超分辨率一些大牛的主页： <a href="https://www.zhihu.com/search?type=content&amp;q=超分辨率" target="_blank" rel="noopener">https://www.zhihu.com/search?type=content&amp;q=%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87</a></li></ol><h3 id="论文阅读"><a href="#论文阅读" class="headerlink" title="论文阅读"></a>论文阅读</h3><h4 id="Xuaner-Zhang-Qifeng-Chen-Ren-Ng-and-Vladlen-Koltun-Zoom-to-Learn-Learn-to-Zoom-CVPR-2019-Paper"><a href="#Xuaner-Zhang-Qifeng-Chen-Ren-Ng-and-Vladlen-Koltun-Zoom-to-Learn-Learn-to-Zoom-CVPR-2019-Paper" class="headerlink" title="Xuaner Zhang, Qifeng Chen, Ren Ng, and Vladlen Koltun. Zoom to Learn, Learn to Zoom, CVPR 2019. [Paper]"></a>Xuaner Zhang, Qifeng Chen, Ren Ng, and Vladlen Koltun. Zoom to Learn, Learn to Zoom, CVPR 2019. <a href="http://vladlen.info/papers/zoom.pdf" target="_blank" rel="noopener">[Paper]</a></h4><p>作者将超分辨率方法应用在数字变焦中，他认为真实的图片能够比生成的图片更能保留数据的细节，网络的性能也将更好。那些在制作的数据集上训练的模型，通常在实际场景下性能不好，因此本文使用单反去直接制作数据集。高分辨率使用长焦距拍摄，低分辨率使用短焦距拍摄。</p><p>由于使用单反采集的数据高低配置无法完全对齐，因此作者提出了CoBi loss function，完美的解决了这个问题。这就是本文的主要insight。</p><h3 id="Image-Super-Resolution-Using-Very-Deep-Residual-Channel-Attention-Networks"><a href="#Image-Super-Resolution-Using-Very-Deep-Residual-Channel-Attention-Networks" class="headerlink" title="Image Super-Resolution Using Very Deep Residual Channel Attention Networks"></a>Image Super-Resolution Using Very Deep Residual Channel Attention Networks</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博客的主要目的为了记录阅读的超分辨率论文的摘要部分，了解超分辨率领域的研究前沿进度。&lt;/p&gt;
    
    </summary>
    
      <category term="论文阅读" scheme="https://wenhui-zhou.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="超分辨率" scheme="https://wenhui-zhou.github.io/tags/%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>电阻率成像数据分析</title>
    <link href="https://wenhui-zhou.github.io/2019/08/30/%E7%94%B5%E9%98%BB%E7%8E%87%E6%88%90%E5%83%8F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    <id>https://wenhui-zhou.github.io/2019/08/30/电阻率成像数据分析/</id>
    <published>2019-08-30T01:52:41.000Z</published>
    <updated>2019-08-30T16:05:00.588Z</updated>
    
    <content type="html"><![CDATA[<p><strong>电阻率成像(ERI)</strong> 是一种地球物理技术，用于通过在表面或在一个或多个钻孔中的电极进行的电阻率测量来对底层亚表面结构进行成像。</p><a id="more"></a><h3 id="电阻率数据的采集"><a href="#电阻率数据的采集" class="headerlink" title="电阻率数据的采集"></a>电阻率数据的采集</h3><p>方位电阻率成像测井是在双侧向测井基础上发展起来的，在主电极或屏蔽电极中部沿圆周剖分成12个长方形小电极（见图），每个电极的定向方位成30°辐射，12个方位电极电位彼此相等。</p><p><img src="../images/SR/bettery.png" alt=""></p><p>电流的大小反映了该方向内地层电阻率的变化。测量每个方位电极的供电电流和环状监督电极M 3 （M 4 ）相对铠装电缆钢丝外皮的电位，可计算该方向地层的视电阻率。</p><p> 地层中不同的岩石（泥岩、砂岩、石灰岩）、流体其电阻率是不同的，通过测量<strong>井壁</strong> 各点的电阻率值，然后将电阻率值的相对高低用灰度或色度图表示出来。井壁可以表示成一张黑白/彩色图像。</p><p>颜色映射如下：</p><p><img src="../images/SR/color-map.png" width="400" align="middle"> </p><p> 得到的电阻率成像图像如下：</p><p><img src="../images/SR/162.jpg" alt="162"></p><h3 id="电阻率数据的分析"><a href="#电阻率数据的分析" class="headerlink" title="电阻率数据的分析"></a>电阻率数据的分析</h3><p>微电极测井使用的电极紧贴井壁，电阻数据是测井井周一圈的数据，因此同一个水平面上数据的空间位置十分的接近。数据在空间关系上有一定的相关性。</p><p><img src="../images/SR/fmi1.jpg" alt=""></p><p><img src="../images/SR/fmi.png" alt=""></p><p>上图中的绿线是地层的分层线。对电阻率的分析过程是将电阻率数据传入一个专业软件中，将会自动生成一些简单的分层线，然后采用人工标注的方式，对电阻率数据标注进行完善。最终得到完善的电阻率标注图。</p><p>对超分辨率问题来说，有什么内在的约束？</p><p>得到新数据时，需要明白测量的精度（2.5mm），井口的大小这些数据。</p><p>反演的概念：通过一些观察到的局部信息，反推相关过程发生的原因以及机制。根据结果或信息反推事件发生的过程称为反演，而对事件发生过程的预测则称为正演。例如根据地表上探测到的部分数据，来推测地表以下的地质结构。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;电阻率成像(ERI)&lt;/strong&gt; 是一种地球物理技术，用于通过在表面或在一个或多个钻孔中的电极进行的电阻率测量来对底层亚表面结构进行成像。&lt;/p&gt;
    
    </summary>
    
      <category term="super resolution" scheme="https://wenhui-zhou.github.io/categories/super-resolution/"/>
    
    
  </entry>
  
  <entry>
    <title>并查集，python示例</title>
    <link href="https://wenhui-zhou.github.io/2019/08/27/%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%8Cpython%E7%A4%BA%E4%BE%8B/"/>
    <id>https://wenhui-zhou.github.io/2019/08/27/并查集，python示例/</id>
    <published>2019-08-27T12:09:07.000Z</published>
    <updated>2019-08-27T13:43:59.021Z</updated>
    
    <content type="html"><![CDATA[<p>并查集是一种数据结构，在合并不相交的集合，用来判断一个图中是否有环这种问题时，具有很高的性能。</p><a id="more"></a><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>并查集的主要操作就是为一个集合中的元素找到一个代表（根节点）。并查集的基本操作是合并两个集合，当拿到两个节点，第一步需要找到各自节点的根，然后选择一个节点作为新的代表，那么就完成了两个集合的合并。</p><h3 id="并查集实现"><a href="#并查集实现" class="headerlink" title="并查集实现"></a>并查集实现</h3><p>并查集可以使用一个数组来表示，数组表示图上的节点，下标表示节点的编号，数组的值表示该下标的父节点是哪一个。例如A[0] = 1 表示节点0的父节点是节点1.</p><p>并查集的实现过程主要分为两步，一步是实现节点的根的查找，另一步是实现两个集合的合并，这里包含了节点的路径压缩。</p><p>下面实现find_root算法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">joint = <span class="number">10</span></span><br><span class="line">parent = [<span class="number">-1</span>]*<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_root</span><span class="params">(parent,x)</span>:</span></span><br><span class="line">  x_root = x</span><br><span class="line">  <span class="keyword">while</span> parent[x_root] != <span class="number">-1</span>:</span><br><span class="line">    x_root = parent[x_root]</span><br><span class="line">  <span class="keyword">return</span> x_root</span><br></pre></td></tr></table></figure><p>上面代码说明当x不是根节点时，循环继续往上找，当x时根节点时则返回。</p><p>下面是union的算法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union_joint</span><span class="params">(parent,x,y)</span>:</span></span><br><span class="line">  x = find_root(parent,x)</span><br><span class="line">  y = find_root(parent,y)</span><br><span class="line">  <span class="keyword">if</span> x == y:</span><br><span class="line">    print(<span class="string">'circle'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    parent[x] = y</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>上诉代码如果返回的结果是0的话则说明存在一个环，否则不存在环。</p><p>存在一种极端的情况，即每次union合成的集合它形成了一个很长的链，每次寻找一个节点的根需要遍历一下整个节点，复杂度太高，下面在union中引入路径压缩的思想，即引入另一个数组rank，表明当前节点的位置，当进行union的时候，rank小的数连接到rank大的树底下，当两个rank相同的时候，可以随意连接，但是连接之后作为父节点的rank需要加1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rank = [<span class="number">0</span>]*joint</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(parent,x,y,rank)</span>:</span></span><br><span class="line">  x = find_root(parent,x)</span><br><span class="line">  y = find_root(parent,y)</span><br><span class="line">  <span class="keyword">if</span> x == y:</span><br><span class="line">    print(<span class="string">'circle'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> rank[x] &gt; rank[y]:</span><br><span class="line">      parent[y] = x</span><br><span class="line">    <span class="keyword">elif</span> rank[x] &lt; rank[y]:</span><br><span class="line">      parent[x] = y</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      parent[x] = y</span><br><span class="line">      rank[y] += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在判断一个图是否存在环的时候，依次遍历图的所有边，如果union返回的结果是0的话，表明有环。</p><p>下面是一道lettcode的题目，思路就是用并查集来求解：</p><p><a href="https://leetcode.com/problems/friend-circles/" target="_blank" rel="noopener">547.Friend Circles</a></p><p>思路是将朋友的关系用边来表示，最后看parent数组中有多少根节点（等于-1）。</p><p>解法代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span><span class="params">(self, M)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type M: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        edge = []</span><br><span class="line">        <span class="keyword">if</span> M == [] <span class="keyword">or</span> M[<span class="number">0</span>] == []:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(M)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(M[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> i &lt;= j:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> M[i][j] == <span class="number">1</span>:</span><br><span class="line">                    edge.append([i,j])</span><br><span class="line">                </span><br><span class="line">        parent = [<span class="number">-1</span>]*len(M)</span><br><span class="line">        rank = [<span class="number">0</span>]*len(M)</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_root</span><span class="params">(parent,x)</span>:</span></span><br><span class="line">            x_root = x</span><br><span class="line">            <span class="keyword">while</span> parent[x_root] != <span class="number">-1</span>:</span><br><span class="line">                x_root = parent[x_root]</span><br><span class="line">            <span class="keyword">return</span> x_root</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">union_joint</span><span class="params">(parent,x,y,rank)</span>:</span></span><br><span class="line">            x = find_root(parent,x)</span><br><span class="line">            y = find_root(parent,y)</span><br><span class="line">            <span class="keyword">if</span> x  != y:</span><br><span class="line">                <span class="keyword">if</span> rank[x] &lt; rank[y]:</span><br><span class="line">                    parent[x] = y</span><br><span class="line">                <span class="keyword">elif</span> rank[x] &gt; rank[y]:</span><br><span class="line">                    parent[y] = x</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    parent[x] = y</span><br><span class="line">                    rank[y] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> edge:</span><br><span class="line">            union_joint(parent,e[<span class="number">0</span>],e[<span class="number">1</span>],rank)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> parent:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">-1</span>:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并查集是一种数据结构，在合并不相交的集合，用来判断一个图中是否有环这种问题时，具有很高的性能。&lt;/p&gt;
    
    </summary>
    
      <category term="算法扫盲" scheme="https://wenhui-zhou.github.io/categories/%E7%AE%97%E6%B3%95%E6%89%AB%E7%9B%B2/"/>
    
    
      <category term="算法" scheme="https://wenhui-zhou.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>哈希表，python示例</title>
    <link href="https://wenhui-zhou.github.io/2019/08/25/%E5%93%88%E5%B8%8C%E8%A1%A8-python%E7%A4%BA%E4%BE%8B/"/>
    <id>https://wenhui-zhou.github.io/2019/08/25/哈希表-python示例/</id>
    <published>2019-08-25T03:06:24.000Z</published>
    <updated>2019-08-27T13:36:57.147Z</updated>
    
    <content type="html"><![CDATA[<p>哈希表一直都是一个很重要的数据结构，从上大学开始，一直有听闻，面试题也有相当的涉及，接下来继续扫盲。</p><a id="more"></a><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希表根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把<strong>关键码值通过哈希函数映射到表中一个位置来访问记录</strong>，以加快查找的速度。</p><p>哈希表的工作原理如下</p><p><img src="/images/hash.png" alt=""></p><p>首先拿到key值，通过哈希函数将key值转化为数组的下标，在插入元素之前，判断该下标位置上是否已经存在元素，若已经存在元素则称为collision（碰撞）。</p><p>当元素发生碰撞时，存在很多方法来处理这种碰撞，常用的方法有<strong>链接法</strong>（java hashmap的实现），每一个index位置连一个链表，用来存储发生碰撞的元素。</p><p><img src="/images/link.png" alt=""></p><p><strong>另一种解决碰撞的方法为开放寻址法</strong>（python中dict的实现）。</p><p>开放寻址法指当前位置发生了碰撞，采用某种方法（线性，二次，双倍散列）对哈希表中其他位置进行访问。如果哈希表全都装满了则需要对哈希表进行扩容。</p><p><img src="/images/openadress.png" alt=""></p><h3 id="python-中dict常用方法"><a href="#python-中dict常用方法" class="headerlink" title="python 中dict常用方法"></a>python 中dict常用方法</h3><p>遍历操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dicts:</span><br><span class="line">    print(i)</span><br><span class="line">    print(dicts[i])</span><br></pre></td></tr></table></figure><p>删除操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dicts.pop(key)</span><br><span class="line">dicts.popitem() <span class="comment">#删除最后一个加入的元素</span></span><br><span class="line"><span class="keyword">del</span> dicts <span class="comment">#直接删除元素</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哈希表一直都是一个很重要的数据结构，从上大学开始，一直有听闻，面试题也有相当的涉及，接下来继续扫盲。&lt;/p&gt;
    
    </summary>
    
      <category term="算法扫盲" scheme="https://wenhui-zhou.github.io/categories/%E7%AE%97%E6%B3%95%E6%89%AB%E7%9B%B2/"/>
    
    
      <category term="算法" scheme="https://wenhui-zhou.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>堆排序，python实现</title>
    <link href="https://wenhui-zhou.github.io/2019/08/22/%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%8Cpython%E5%AE%9E%E7%8E%B0/"/>
    <id>https://wenhui-zhou.github.io/2019/08/22/堆排序，python实现/</id>
    <published>2019-08-22T11:08:57.000Z</published>
    <updated>2019-08-25T03:09:15.393Z</updated>
    
    <content type="html"><![CDATA[<p>堆排序这个名称一直困扰着我，现在扫一下盲。</p><a id="more"></a><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>首先介绍一下堆的概念：堆是一棵完全二叉树，即指允许最后一层的叶子是不满的，其他层都是满的。叶子节点的出现顺序也是从左边开始向右边累加，不允许中断。父结点必须比子节点要大。</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序的算法复杂度是O(nlog(n))。由于节点满足完全二叉树，因此可以通过下标的关系找到父节点，子节点。</p><p>例如当前节点为i，父节点：(i - 1) /2。左孩子：2i+1,右孩子：2i+2。因此堆排序的策略如下：</p><h3 id="堆排序步骤"><a href="#堆排序步骤" class="headerlink" title="堆排序步骤"></a>堆排序步骤</h3><ol><li>构造堆结构，从最后一个元素（叶子）的父节点开始，循环到根节点，每次执行heapify函数（三个节点，找最大的放到根位置）。</li><li>位于根节点的元素是最大的，每次将根节点的数拿出来，作为排序的最后一个值。然后将最后一个叶节点放到根的位置。依次循环下去，直到结束。</li></ol><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(nums,n,i)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    i 表示要进行调换的根节点位置</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    c1 = <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">    c2 = <span class="number">2</span>*i + <span class="number">2</span></span><br><span class="line">    max_index = i</span><br><span class="line">    <span class="keyword">if</span> c1 &lt;= n <span class="keyword">and</span> nums[c1] &gt; nums[i]:</span><br><span class="line">        max_index = c1</span><br><span class="line">    <span class="keyword">if</span> c2 &lt;= n <span class="keyword">and</span> nums[c2] &gt; nums[max_index]:</span><br><span class="line">        max_index = c2</span><br><span class="line">    <span class="keyword">if</span> max_index != i:</span><br><span class="line">        nums[max_index],nums[i] = nums[i],nums[max_index]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_heap</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums) - <span class="number">1</span></span><br><span class="line">    last_index = (n - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(last_index+<span class="number">1</span>)[::<span class="number">-1</span>]:</span><br><span class="line">        heapify(nums,n,i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    print(nums)</span><br><span class="line">    build_heap(nums)</span><br><span class="line">    print(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))[::<span class="number">-1</span>]:</span><br><span class="line">        print(i)</span><br><span class="line">        nums[<span class="number">0</span>],nums[i] = nums[i],nums[<span class="number">0</span>]</span><br><span class="line">        heapify(nums,i<span class="number">-1</span>,<span class="number">0</span>)</span><br><span class="line">    print(nums)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">heap_sort(nums)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;堆排序这个名称一直困扰着我，现在扫一下盲。&lt;/p&gt;
    
    </summary>
    
      <category term="算法扫盲" scheme="https://wenhui-zhou.github.io/categories/%E7%AE%97%E6%B3%95%E6%89%AB%E7%9B%B2/"/>
    
    
      <category term="算法" scheme="https://wenhui-zhou.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>

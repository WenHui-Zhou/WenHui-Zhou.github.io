<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WenHuiZhou</title>
  
  <subtitle>perper（打起精神！）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wenhui-zhou.github.io/"/>
  <updated>2020-01-01T03:35:58.848Z</updated>
  <id>https://wenhui-zhou.github.io/</id>
  
  <author>
    <name>WenHuiZhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2019！2020！</title>
    <link href="https://wenhui-zhou.github.io/2020/01/01/2019%EF%BC%812020%EF%BC%81/"/>
    <id>https://wenhui-zhou.github.io/2020/01/01/2019！2020！/</id>
    <published>2020-01-01T03:34:18.000Z</published>
    <updated>2020-01-01T03:35:58.848Z</updated>
    
    <content type="html"><![CDATA[<p>2019年的最后几天，我在想给这一年打上一个什么样的标签，让我十几二十年后还能想起来这一年。确实是，我记不清过去的二十几年，唯一的感触剩下时间匆匆。</p><p>2019年1月份，和xu在北大三教的咖啡厅搭了这个网站，与此同时进行的还有刷算法题，准备着一些东西。再往前推几天，我匆匆完成了研一上最后的考试，连夜收拾行李进城。和yingying在雁栖湖有很多美好的回忆，可惜那些事情发生在2018年了，2018年对我来说是煎熬的一年，有一种引力阻止我思考里头究竟发生了什么事情。不过最令我开心的是在2018年结束的时候，我收获了很多宝贵的友谊。</p><p>所以我想，我不能在失去2019年了。</p><p>让我努力回忆几件事情，把一年的生活串起来。</p><p><strong>第一件事情</strong>，2019年新年在2月5号，过完春节我提前了两周时间回到雁栖湖。北京大雪后不久，校园里寂静的景象让我震惊，整个雁栖湖被雪裹住，我拖着行李箱，踏出一条雪路。接下来一个月我把时间安排的满满当当，这段时间，自我怀疑、喝鸡汤、再次怀疑循环往复。这段经历给我的启发很多，我愿意把它写出来：</p><ul><li>制定一个目标每时每刻努力着，这个过程是非常充实且令人满足的。结果反而是其次</li><li>目标明确的好处是知道自己要干什么，坏处是焦虑越来越严重</li></ul><p><strong>第二件事，</strong>我开始慢慢窥探自己的性格。事情讲起来很琐碎，我意识到自己在很多不确定的事情面前，显得唯唯诺诺，不敢承担责任。和老板聊到这件事情让我感触颇深，也对老板充满了感激。我在此总结一下导师给我的帮助：一个人自信与否在于他看待问题的角度，林彪认为一场战役七层胜算则可以打，粟裕有四层胜算便胸有成竹，侃侃而谈。</p><p>所以我大可不必这样的担心，也由此我摆脱了大部分的焦虑。后来才意识到，突破自己是困难的，很大一部分原因是无法找到问题的关键。此刻我很需要这样的信心，我也感到自己有了长足的进步。给人以正能量，给人以信心！</p><p>另一方面是自我意识的觉醒，顺从应当是我从小到大的习惯，当我发现我讨厌这样的自己，我会刻意去做一些改变，我会愿意决定一些事情，事先想好事情的应对方案。在这件事情上我还不够好。</p><p><strong>第三件事，</strong>生活需要理想，信仰。如果物质追求成为生活的目标时，生活是沉重且乏味的。而后读了《乔布斯传》，发现在物质之上，有着一群人，在追逐着梦想，渴望改变世界，追求着精神上更美好的东西。这对我的冲击是巨大的，我被这些浅显的道理击中，在回头看时，发现这些东西对我是多么的重要。想起来一次去参观腾讯，晚上8点和朋友坐班车回来，看到眼前拥堵的公路，熙熙攘攘的车子仿佛看到了日后无数个上下班的日日夜夜 ，备受打击。但是回头一想，你每天为着心中的理想奋斗，这是多么振奋人心的事情啊！</p><p>嗯，人生是伟大的理想，是诗和远方。</p><p><strong>最后</strong>，以上三件事情能够大致的勾勒出2019的轮廓，也许到我人生快结束的时候，也会有三件事情，勾勒我的一生。毕竟和时间比起来我们都太渺小。2019年很多时候在忙碌，但是真正对我有推动作用的事情却很少，最后还希望记录一些感悟：</p><ul><li>没有一个夜晚允许我们有一点软弱</li><li>永远不要掉队</li><li>人生应当有更高的追求和理想</li><li>相信积累的力量</li><li>阅读能够拯救我的内心，让我体会到真正的快乐</li><li>清醒的认识自己</li><li>展现积极的一面，永远是自己给别人信心</li></ul><p><strong>最后的最后，2020，happy new year!</strong></p><p><strong>2019/12/31</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2019年的最后几天，我在想给这一年打上一个什么样的标签，让我十几二十年后还能想起来这一年。确实是，我记不清过去的二十几年，唯一的感触剩下时间匆匆。&lt;/p&gt;
&lt;p&gt;2019年1月份，和xu在北大三教的咖啡厅搭了这个网站，与此同时进行的还有刷算法题，准备着一些东西。再往前推几
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GPT</title>
    <link href="https://wenhui-zhou.github.io/2019/12/29/GPT/"/>
    <id>https://wenhui-zhou.github.io/2019/12/29/GPT/</id>
    <published>2019-12-29T13:44:32.000Z</published>
    <updated>2019-12-29T14:09:08.121Z</updated>
    
    <content type="html"><![CDATA[<p>GPT在bert出现之前就与我们见面了，它利用了transformer的结构，在众多的任务中，取得了比较好的成绩。GPT的核心思想是 <strong>通过无标签的文本去训练生成语言模型</strong>，根据具体的NLP任务，利用新的数据进行finetune（和bert简直一模一样）。</p><a id="more"></a><h3 id="模型的结构"><a href="#模型的结构" class="headerlink" title="模型的结构"></a>模型的结构</h3><p>模型的结构是使用了多层的单向transformer结构，如下图：</p><p><img src="/images/nlp/v2-fb7be8467a0231607f3f2e4ace92534e_hd.jpg" alt="img"></p><p>GPT即gerneral pre-training 通用预训练语言模型，是一种利用transformer作为特征抽取器，基于语言模型进行训练的预训练语言模型。因此GPT有两个重点，一个是语言模型，另一个是transformer。</p><p><strong>语言模型</strong></p><p>一个语言模型通常可以理解成一句话出现的概率 p(W) 的计算。语言模型利用语料进行训练，训练的目的就是：<strong>计算某个句子出现的概率。</strong>一个句子的概率的计算方式如下：</p><p>对于一个有T个词按顺序构成的句子，P(W)实际上求解的是字符串的<strong>联合概率</strong>，利用贝叶斯公式，链式分解如下：<br>$$<br>\begin{aligned}<br>P\left(W_{1}^{T}\right) &amp;=P\left(\mathrm{w}_{1}, w_{2}, \ldots, w_{T}\right) \\<br>&amp;=P\left(w_{1}\right) P\left(w_{2} | w_{1}\right) P\left(w_{3} | w_{1}, w_{2}\right) \ldots P\left(w_{T} | w_{1}, w_{2}, \ldots w_{T-1}\right)<br>\end{aligned}<br>$$<br>从上面可以看出来，一个统计语言模型可以表示成给定前面的词，求后面的一个词出现的条件概率。当我们在求P(w)的时候，我们就已经建立了一个模型，这里的诸多条件概率就是模型的参数。GPT预训练过程就是利用语料，构造训练数据，利用上述语言模型，不断预测，学习参数的过程。</p><p><strong>GPT结构</strong></p><p>GPT的结构由12个transformer组成，和bert的一个最大的不同在于，他的transformer是单向的，输入为文本token和position信息结合一起后embedding。输入经过12个transformer结果处理之后，到输出层，经过一个lienar层之后，使用softmax进行初始化，随后使得似然最大化（交叉熵的负数最大），得到最后的结果：<br>$$<br>P\left(y | x^{1}, \ldots, x^{m}\right)=\operatorname{softmax}\left(h_{l}^{m} W_{y}\right)<br>$$<br>其中$h_l^m$表示12个transformer输出的结果，W表示linear层的参数，最大化似然，即得到最终的结果：<br>$$<br>L_{2}(\mathcal{C})=\sum_{(x, y)} \log P\left(y | x^{1}, \ldots, x^{m}\right)<br>$$<br><strong>如何使用GPT</strong></p><p>GPT训练过程分为两步，第一步在一个非常大的数据集上进行数据的无监督训练，第二阶段，我们在一个很小的数据集上对模型进行finetune，使用有监督的方法解决特定方向的问题。通过大量的实验，作者发现，只要经过很小的fintune就可以应用到很多不同的任务上。</p><p>第一步使用无监督的方式学习语言本身存在的相关性，训练方式是单向的，模型从左到有，利用已经出现的词，来预测下一个位置上的词。和bert不同，bert使用mask技术，能够学到语言中双向的特征。</p><p>之所以使用unsupervised learning的原因是，标注大量的数据的成本是很高的，同时人工标注的难度也很大。使用无监督的方式可以学到数据之间的相关性。</p><p><strong>GPT和下游任务的结合</strong></p><p><img src="/images/nlp/gpt.jpg" alt="img"></p><p>使用GPT作为pretraining模型，第一步将数据转化成序列结构，如上图输入的组合方式，然后通过修改输出部分的结构，达到网络在多个特定任务上的应用：</p><ul><li>For text classification, we can directly fine-tune the model.</li><li>For textual entailment, we concatenate the premise and hypothesis token sequences, with a delimiter token in between.</li><li>For similarity tasks, since there is no inherent ordering of the two sentences being compared, the input sequence is modified to contain both possible sentence orderings. Each input sequence is processed independently to produce two sequence representations, which are finally added element-wise before being fed into the linear output layer.</li><li>For question answering and commonsense reasoning, we are given a context document zz, a question qq, and a set of possible answers akak. We concatenate the document context and question with each possible answer as [start;z;q;delim;ak;extract]. Each of these sequences are processed independently and then normalized via a softmax layer to produce an output distribution over possible answers.</li></ul><p>上面主要介绍的是输入的组合方式。</p><p><img src="/images/nlp/difference.jpg" alt=""></p><p><strong>bert下游任务</strong></p><p><img src="/images/nlp/fine-tuning.jpg" alt=""></p><h3 id="GPT-2"><a href="#GPT-2" class="headerlink" title="GPT-2"></a>GPT-2</h3><p>GPT-2 是GPT-1的升级版本，它在文本生成上有着惊艳的表现，其<strong>生成的文本在上下文连贯性和情感表达上</strong>都超过了人们对目前阶段语言模型的预期。</p><p>GPT-2有着海量的训练数据，GPT-2结构采用了只有解码器的transformer架构，接下来我们将一起探索GPT-2的应用以及在生成任务中的奥秘。</p><p>语言模型的作用是根据已有的句子的一部分来预测下一个单词是什么。GPT-2使用transformer解码器模块构建，而bert则是通过transformer编码器模块构建，他们之间一个关键的不同在于GPT-2一次只输出一个单词，新的单词产生之后就被添加到单词序列中，作为下一个单词预测的输入。这种机制叫做自回归（auto-regression），诸如TransformerXL和XLNet都是用了自回归，XLNet同时还找到了一种能够同时兼顾前后的上下文信息的方法。</p><p>GPT-2对transformer模块进行了改造，仅仅选择了Decoder的部分：</p><p><img src="/images/nlp/640-1577377624300.webp" alt=""></p><p>即只允许看到当前预测位置左边的单词，transformer结构只允许片段的长度为512，而这种结构可以支持最长1024个单词序列。</p><p><strong>GPT-2的工作流程</strong></p><p>训练一个GPT-2模型，最简单的方法就是让他随机工作。我们随机选择一个单词作为起始单词让它根据我们提供得词生成一段样本（即生成交互式条件样本）。</p><p>此时模型的输入只有一个词，然后经过若干层的transformer，得到一个向量输出。然后将这个向量与词汇表中的每一个单词计算一个概率，我们选择概率最高的一个单词作为下一个单词。GPT-2的词汇表中有50000个单词。</p><p>有时选择top1的方法会出现问题，有时模型可能会陷入一直推荐同一个词的循环中，因此我们在选择下一个词的时候，通常我们从topk个词中按概率随机选择一个（torch.distribution.categorical.Categorical）。</p><p>接下来我们将新增的单词添加在序列的尾部，作为预测下一个单词的输入，GPT-2网络的参数保留了对第一个单词的解释，然后根据这些信息来生成第二个单词。在向后生成的过程中，GPT-2已生成的单词将不会被改变。</p><h3 id="深入GPT-2内部"><a href="#深入GPT-2内部" class="headerlink" title="深入GPT-2内部"></a>深入GPT-2内部</h3><p><strong>输入编码</strong></p><p>GPT-2输入从词嵌入矩阵中查找单词对应的嵌入向量word embedding，该矩阵也是模型训练的一部分：</p><p><img src="/images/nlp/640-1577377615340.webp" alt=""></p><p>模型的大小和词向量的长度有关，词向量长度最小为768。此外我们还需要对输入序列的每一个位置都对应一个位置编码，这些编码矩阵也是训练参数的一部分：</p><p><img src="/images/nlp/640.webp" alt=""></p><p>因此在准备输入数据的时候，我们随机找到一个起始单词，然后根据起始单词，去vocab中转化成词向量，然后加上第一个位置上的位置编码：</p><p><img src="/images/nlp/640-1577377765194.webp" alt=""></p><p>随后序列进入transformer中，transformer中的自注意力机制将每个词与序列中的相关性学习到，体现了transformer超强的特征提取能力。</p><p>对于自注意力机制来说，存在三个矩阵，Key，Query，Value，首先将这三个矩阵与输入相乘，然后得到K，Q，V，可以认为接下来就是找到相互匹配的K，Q（query和key的匹配对），即softmax的值最高，然后乘以V，得到当前词对序列中其他词的相关性的大小：</p><p><img src="/images/nlp/640-1577378601211.webp" alt="img"></p><p><strong>模型输出</strong></p><p>当最后一个transformer输出向量之后，这个向量本质上就会预测词的词向量。我们将这个词向量乘上词嵌入矩阵，得到一个长度为词汇表长度的向量。这个向量每一个位置就表示当前预测位置上的词对词汇表中该位置词的相似概率。</p><p><img src="/images/nlp/640-1577378813143.webp" alt="img"></p><p>然后我们现在top-k（40）个概率，然后从topk中，按照概率大小，选择出一个单词作为当前预测的单词。</p><p><img src="/images/nlp/640-1577378918869.webp" alt="img"></p><p>重复上述的过程，直到生成1024个词，遇到终止符。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GPT在bert出现之前就与我们见面了，它利用了transformer的结构，在众多的任务中，取得了比较好的成绩。GPT的核心思想是 &lt;strong&gt;通过无标签的文本去训练生成语言模型&lt;/strong&gt;，根据具体的NLP任务，利用新的数据进行finetune（和bert简直一模一样）。&lt;/p&gt;
    
    </summary>
    
      <category term="NLP" scheme="https://wenhui-zhou.github.io/categories/NLP/"/>
    
    
  </entry>
  
  <entry>
    <title>finetune-诗句生成</title>
    <link href="https://wenhui-zhou.github.io/2019/12/29/finetune-%E8%AF%97%E5%8F%A5%E7%94%9F%E6%88%90/"/>
    <id>https://wenhui-zhou.github.io/2019/12/29/finetune-诗句生成/</id>
    <published>2019-12-29T13:35:47.000Z</published>
    <updated>2019-12-29T13:42:42.141Z</updated>
    
    <content type="html"><![CDATA[<p>原先的诗句生成模型仅仅利用了bert language model，而没有去利用诗句语料进行finetune，尽管language model生成的结果已经令人比较满意了。但是我们想知道在特定的数据集上进行finetune的话，结果是否能得到提升，于是这篇post主要完成这个工作：continue training。</p><a id="more"></a><h3 id="pytorch-多卡分布式训练"><a href="#pytorch-多卡分布式训练" class="headerlink" title="pytorch 多卡分布式训练"></a>pytorch 多卡分布式训练</h3><p>关于分布式训练，通常可以使用<strong>DataLoader</strong>，这个wrapper可以方便使用多张卡，而进程只有一个，唯一的问题是这个方法只能满足一台计算机上GPU的通信，对需要使用多个机器，多个GPU的任务无能为力。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net = nn.DataParallel(net)</span><br></pre></td></tr></table></figure><p>以上代码将整个网络分布到多个GPU上。pytorch定义的网络模型参数默认放在GPU 0上，所以dataparallel的时候，实质上是把训练参数从gpu靠背到其他的gpu上同时训练。此时dataloader加载数据的时候，batch_size需要设置成原来batch的n倍，n为gpu的数量。</p><p>如果我们要使用多个机器上的GPU，pytorch依然提供了办法：</p><ul><li><code>torch.utils.parallel.DistributedDataParallel</code>方法：与dataloader类似，用来实现多机多卡分布训练，他可实现在不同机器的多个模型拷贝之间的平均梯度</li><li><code>torch.utils.data.distributed.DistributedSampler</code> 方法：在多机多卡的情况下，每个卡读取的数据显然是不同的，dataparallel的做法是直接将batch切分到不同的卡上。对于多机来说，直接进行数据传输将会耗费很多时间，于是使用distributedSampler，确保每一个dataloader只会load到整个数据集的一个特定子集，避免不同进程之间数据重复</li></ul><p><strong>使用方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataloader,Dataset</span><br><span class="line"><span class="keyword">from</span> torch.utils.data.distributed <span class="keyword">import</span> DistributedSampler</span><br><span class="line"><span class="keyword">from</span> torch.nn.parallel <span class="keyword">import</span> DistributedDataParallel</span><br><span class="line"></span><br><span class="line">dataset = your_dataset()</span><br><span class="line">datasample =DistributedSampler(dataset,num_replicas=world_size,rank = rank)</span><br><span class="line">dataloader = Dataloader(dataset,batch_size=batch_size_per_gpu,sampler = datasampler)</span><br><span class="line">model = your_model()</span><br><span class="line">model = DistributedDataParallel(model,device_ids = [local_rank],output_device=local_rank)</span><br></pre></td></tr></table></figure><p>在设置dataloader的batch-size的时候，只需要设置单卡的batch-size即可。world_size指进程总数，就是卡的数量，rank是进程编号，local_rank指本地序号。要想使用DistributedDataParallel就需要先完成多进程的初始化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.distributed.init_process_group()</span><br></pre></td></tr></table></figure><p><img src="/images/nlp/image-20191224122842203.png" alt=""></p><p><img src="/images/nlp/image-20191224122817322.png" alt="image-20191224122817322"></p><p><img src="/images/nlp/image-20191224123807016.png" alt="image-20191224123807016"></p><p><img src="/images/nlp/image-20191224123750444.png" alt="image-20191224123750444"></p><p><img src="/images/nlp/image-20191224124839172.png" alt="image-20191224124839172"></p><p><strong>梯度积累</strong></p><p>梯度累加的步骤如下：</p><ol><li>获取loss，输入图像和标签，通过infer计算得到预测值，计算损失函数</li><li><code>loss.backward()</code> 反向传播，计算当前梯度</li><li>多次循环1-2，不清空梯度，使梯度累加在已有的梯度上</li><li>梯度累加了一定的次数以后，先<code>optimizer.step()</code>根据累计的梯度更新网络参数，然后通过<code>optimizer.zero_grad()</code> 清空过往的梯度，为下一波梯度累加做准备</li></ol><p>梯度累加总结来说就是每次获取一个batch吼不清空梯度，而是累加到一定程度的时候去清空梯度，变相的相当于扩大了batchsize，同时可以避免计算多个损失函数时，存储多个计算图。</p><p><strong>pytorch采样器（dataloader）</strong></p><p>pytorch在加载数据的时候提供了一个sampler模块，这个模块用来对数据进行采样，常用的采样器有<code>RandomSampler</code>，当dataloader中shuffle的参数为true的时候，系统会自动调用这个采样器。dataloader默认使用的采样器为sequentialSampler，即按顺序来进行采样。sampler组织好数据的下标后，在dataloader中将数据取出来。</p><p><strong>pytorch and apex</strong></p><p>pytorch在分布式训练上存在着一些问题：</p><ul><li>混合精度训练难以收敛：pytorch可以方面得将模型转换成fp16，但是训练batchnorm层的时候，又需要转成f32，导致了混合精度，难以优化的问题。</li><li>bn同步的问题，bn同步能够极大的加快模型的收敛，精度也会有所提升，原生的方法一直未能较好地解决</li></ul><p>apex是NVIDIA维护的一个支持</p><p><strong>bert优化器</strong></p><p>bert常使用的优化器有BertAdam，AdamW，FusedAdam（和BertAdam类似，当用到apex时配套当做优化器使用）。Bert的优化器和传统的Adam优化器有什么不同呢，主要的不同有以下两点：</p><ul><li>bertAdam/AdamW 能够固定权重衰减，可用于微调模型</li><li>bertAdam/AdamW 不会对偏差bias进行补偿</li></ul><p><strong>bert loss function</strong></p><p>bert损失函数主要由两部分组成，第一部分来自Mask-LM的单词级别分类任务，另一部分是句子级别的分类任务。通过联合学习，使bert学习到语言中token级别，以及句子级别的语义信息，具体的损失函数如下：</p><p>第一部分的损失函数是mask部分的词的一个多分类问题，词典的大小为分类的大小。第二部分的损失函数是是否是下一句的二分类问题，两个分类函数结合作为最后的loss.</p><p><strong>bert激活函数：gelu</strong></p><p>gelu：高斯误差线性单元，是一种高性能的神经网络激活函数，GELU的非线性变换是一种符合预期的随机正则变换方式：</p><p><img src="/images/nlp/image-20191224220030781.png" alt="image-20191224220030781"></p><p><strong>总结</strong></p><p>总结一下上面的工作，我基本上了解了生成诗句的一套流程，对bert的结构也有了比较多的了解。总体来说，代码比较容易看懂，这比起C++的代码，简直轻松很多。</p><p>还可以梳理一下bert的脉络，研究一下whole word marking的实现方法。明后两天把这个事情做完。其他在按计划慢慢推进！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原先的诗句生成模型仅仅利用了bert language model，而没有去利用诗句语料进行finetune，尽管language model生成的结果已经令人比较满意了。但是我们想知道在特定的数据集上进行finetune的话，结果是否能得到提升，于是这篇post主要完成这个工作：continue training。&lt;/p&gt;
    
    </summary>
    
      <category term="NLP" scheme="https://wenhui-zhou.github.io/categories/NLP/"/>
    
    
  </entry>
  
  <entry>
    <title>bert的一些思考</title>
    <link href="https://wenhui-zhou.github.io/2019/12/19/bert%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>https://wenhui-zhou.github.io/2019/12/19/bert的一些思考/</id>
    <published>2019-12-19T07:00:31.000Z</published>
    <updated>2019-12-24T08:37:40.791Z</updated>
    
    <content type="html"><![CDATA[<p>观其大致，能够比较好的融会贯通，理解整个任务。这是这篇post的主要目的。</p><a id="more"></a><p>Bert的应用模式</p><p>bert在应用到具体的任务上时，通常采用两阶段策略：</p><ul><li>第一阶段利用通用语言模型任务，采用自监督的学习方法，选择某个具体的特征抽取器，来学习预训练模型</li><li>第二个阶段，根据手头具体的监督学习任务，采取特征集成或finetune的应用模型，</li></ul><p>总之，加载预训练模型，然后为不同的任务定制第二阶段的定制网络</p><p><strong>特征集成任务</strong></p><p>ELMO方法是典型的特征集成方式，把当前要判断的输入句子，走一遍ELMO预训练好的的双层双向LSTM网络，然后把每个输入单词对应位置的高层LSTM激活embedding（或者输入单词对应位置的若干层embedding进行加权求和），作为下游任务单词对应的输入。</p><p>这是一种典型的应用预训练模型的方法，更侧重于单词的上下文特征表达方面。</p><p><strong>finetune模式</strong></p><p>GPT和bert采用finetune应用模式，在获得了预训练模型以及对应的网络结构（Transformer）后，第二个阶段仍然采用与预训练过程相同的网络结构，拿出手头任务的部分训练数据，直接在这个网络上进行模型训练，以针对性地修正预训练阶段获得的网络参数，一般这个阶段被称为Fine-tuning。</p><p><strong>搜索引擎的未来就是QA和阅读理解</strong>：搜索引擎通过理解文本，对于用户提出的问题直接给出答案。</p><p><strong>Bert生成式任务</strong></p><p>例如将bert用在生成式摘要任务中。从技术角度上来讲，生成式任务符合典型的encoder-decoder框架。encoder部分好解决，只需要用预训练好的Bert模型初始化encoder部分的transformer即可。另一方面是decoder端。大量的实验证明直接将bert的预训练参数用来初始化decoder的部分效果都不好。主要原因是bert预训练的时候使用的是双向的语言模型，而一般的decoder任务是从左到右依次生成的，无法利用bert在预训练阶段学到的上下文信息。这也是bert在做生成类任务时遇到的最大问题。</p><p><strong>如何用bert</strong></p><p>简而言之，使用bert的核心在于使用transformer作为特征提取器，用bert预训练模型初始化transformer参数，然后再用当前的任务去finetune。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;观其大致，能够比较好的融会贯通，理解整个任务。这是这篇post的主要目的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="NLP" scheme="https://wenhui-zhou.github.io/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>pytorch 重点回顾</title>
    <link href="https://wenhui-zhou.github.io/2019/12/09/pytorch-%E9%87%8D%E7%82%B9%E5%9B%9E%E9%A1%BE/"/>
    <id>https://wenhui-zhou.github.io/2019/12/09/pytorch-重点回顾/</id>
    <published>2019-12-09T07:57:45.000Z</published>
    <updated>2019-12-18T02:17:08.305Z</updated>
    
    <content type="html"><![CDATA[<p>pytorch 在日常实践中的一些常用的函数，工作流。</p><a id="more"></a><h3 id="pytorch-简介"><a href="#pytorch-简介" class="headerlink" title="pytorch 简介"></a>pytorch 简介</h3><p>pytorch是一个基于torch的python开源库。前身torch是一个有大量机器学习算法支持的科学计算框架，以及与numpy类似的张量操作库。通过pytorch的反向求导技术，可以实现动态的修改神经网络，实现速度快是一大特点。</p><p>缺点是全面性不如TensorFlow，移动端的部署性能有待提升。</p><h3 id="张量tensors"><a href="#张量tensors" class="headerlink" title="张量tensors"></a>张量tensors</h3><p>张量在神经网络中大量的应用，支持pytorch的反向求导，可以和numpy库互换，GPU计算，是pytorch中的<strong>砖块</strong>的角色。</p><p><strong>创建张量</strong></p><p>在深度学习中，<code>torch.float</code>类型使用比较多，常见的，当我们使用tensor申请参数的时候，常用的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 申请一个未初始化的矩阵</span></span><br><span class="line">x = torch.empty(<span class="number">3</span>,<span class="number">3</span>) <span class="comment"># 大小为3x3的一个矩阵，数字可以无限加，每一个数值表示一个矩阵</span></span><br><span class="line"><span class="comment"># 随机初始化，感觉这个会用的比较多一点</span></span><br><span class="line">x = torch.rand(<span class="number">24</span>,<span class="number">24</span>,<span class="number">3</span>，dtype = torch.float) <span class="comment"># 大小为24x24x3，dtype = float</span></span><br><span class="line">x = torch.zeros(<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>) <span class="comment">#维度为3x3x3</span></span><br><span class="line"><span class="comment"># 直接使用数据来构造</span></span><br><span class="line">x = torch.tensor([<span class="number">5.1</span>,<span class="number">1</span>]) </span><br><span class="line"><span class="comment"># 使用已经存在的数据来构造</span></span><br><span class="line">x = x.new_ones(<span class="number">5</span>,<span class="number">4</span>,dtype=  torch.double)</span><br><span class="line">x = torch.randn_like(x,dtype = torch.float) <span class="comment"># 维度与之前的x相同</span></span><br><span class="line">x.size() <span class="comment"># 返回一个tuple，表示tensor的维度</span></span><br></pre></td></tr></table></figure><p><strong>张量操作</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#加法</span></span><br><span class="line">z =  x + y</span><br><span class="line"><span class="comment">#减法</span></span><br><span class="line">z = x - y</span><br><span class="line"><span class="comment"># 获得float的输出（而不是tensor）</span></span><br><span class="line">x.item()</span><br><span class="line"><span class="comment"># 改变tensor的形状</span></span><br><span class="line">x.view(<span class="number">16</span>) <span class="comment"># 变成1*16的向量</span></span><br><span class="line">x.view(<span class="number">-1</span>,<span class="number">4</span>)<span class="comment"># 4x4的向量</span></span><br><span class="line">x.view(<span class="number">-1</span>,<span class="number">2</span>,<span class="number">2</span>)<span class="comment"># 2x2x2的向量</span></span><br><span class="line"><span class="comment"># tensor支持所有的numpy切片操作</span></span><br><span class="line">x[:<span class="number">10</span>]</span><br><span class="line"><span class="comment"># cat拼接向量</span></span><br><span class="line">torch.cat((x,y),dim = <span class="number">0</span>) <span class="comment"># y轴方向</span></span><br><span class="line">torch.cat((x,y),dim = <span class="number">1</span>) <span class="comment"># x轴方向</span></span><br><span class="line"><span class="comment"># chunk，向量拆分</span></span><br><span class="line">x.chunk(chunks = <span class="number">3</span>,dim = <span class="number">0</span>) <span class="comment"># y方向，等分成三份，第三份可能会少一点</span></span><br><span class="line">x.chunk(chunks = <span class="number">3</span>,dim = <span class="number">1</span>) <span class="comment"># x方向</span></span><br><span class="line"><span class="comment"># 截断</span></span><br><span class="line">x.clamp(<span class="number">0.3</span>,<span class="number">0.7</span>) <span class="comment"># 数值限制在这个范围</span></span><br><span class="line">x.sort(dim = <span class="number">0</span>) <span class="comment"># 沿着x方向排序，返回下标</span></span><br><span class="line">x.flatten() <span class="comment"># 将向量展成一列</span></span><br><span class="line"><span class="comment"># 选择前topK</span></span><br><span class="line">x.topk(<span class="number">2</span>,dim=<span class="number">0</span>) <span class="comment"># 返回 值以及下标</span></span><br><span class="line">x.numel()<span class="comment">#返回所有元素</span></span><br><span class="line">torch.stack((x,y), dim = <span class="number">0</span>/<span class="number">1</span>) <span class="comment"># 保留维度，然后将向量组合在一起</span></span><br><span class="line">x.permute(<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>) <span class="comment"># 调整每一维度向量的先后</span></span><br><span class="line">x.squeeze(dim = <span class="number">1</span>) <span class="comment"># 维度为1的坍缩</span></span><br><span class="line">x.unsqueeze(dim = <span class="number">0</span>) <span class="comment"># 增加一个维度为1的</span></span><br><span class="line">x.cuda() <span class="comment"># 放回在GPU上的拷贝</span></span><br><span class="line">torch.where(x&gt;<span class="number">0</span>,x,y) <span class="comment"># x&gt;0 返回x，否则返回y</span></span><br><span class="line">x.round() <span class="comment"># 取整</span></span><br><span class="line">x.contiguous() <span class="comment"># 转成连续存储模式 </span></span><br><span class="line">x.numpy() <span class="comment"># 返回numpy格式</span></span><br><span class="line">x = torch.from_numpy(a) <span class="comment"># numpy转成tensor</span></span><br></pre></td></tr></table></figure><h3 id="pytorch自动微分"><a href="#pytorch自动微分" class="headerlink" title="pytorch自动微分"></a>pytorch自动微分</h3><p>autograd包是pytorch所有神经网络的核心，autograd为tensor上所有的操作提供自动微分。当我们在定义一个tensor的时候，将<code>requires_grad</code>设置成true，pytorch将会开始跟踪该tensor的所有操作。<code>backward()</code>将会自动计算所有的梯度。</p><p>要停止计算梯度可以使用detach()，或者使用<code>with torch.no_grad()</code>包起来。每个张量都有一个grad_fn的属性，这个属性保存着一个Function的引用，保存计算过程的完整信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = torch.ones(<span class="number">2</span>,<span class="number">2</span>,requires_grad = <span class="keyword">True</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">x = tensor([[1,1],</span></span><br><span class="line"><span class="string">             [1,1]],requires_grad = True)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">y = x + <span class="number">2</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">y = tensor([[3,3],[3,3]],grad_fn = &lt;AddBackward0&gt;)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="搭建神经网络"><a href="#搭建神经网络" class="headerlink" title="搭建神经网络"></a>搭建神经网络</h3><p>神经网络可以通过torch.nn来构建。一个nn.Module包含层以及一个正向传播的方法,<code>forward()</code>。一个典型的神经网络训练过程包括以下几点：</p><ol><li>定义一个包含可训练参数的神经网络</li><li>迭代整个输入</li><li>通过神经网络处理输入</li><li>计算loss</li><li>反向传播梯度到神经网络的参数</li><li>更新网络的参数，使用一些优化器等</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">      super(net,self).__init__()</span><br><span class="line">      <span class="comment"># 定义一些层</span></span><br><span class="line">      .</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,x)</span>:</span></span><br><span class="line">      <span class="comment"># x 为输入，下面是定义网络正向传播的过程</span></span><br><span class="line">      .</span><br><span class="line">nets = net()</span><br><span class="line">print(nets) <span class="comment"># 输出net的结构信息</span></span><br><span class="line">net.parameters() <span class="comment"># 得到net中的所有的参数</span></span><br><span class="line"></span><br><span class="line">net.zero_grad() <span class="comment"># 将所有参数梯度缓存置零</span></span><br><span class="line"></span><br><span class="line">output = nets(input)</span><br><span class="line">target = torch.rand(<span class="number">10</span>)</span><br><span class="line">target = target.view(<span class="number">1</span>,<span class="number">-1</span>)</span><br><span class="line">criterion = nn.MSELoss() <span class="comment"># 定义loss</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数更新规则</span></span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line">optimizer = optim.SGD(net.parameters(),lr = <span class="number">0.01</span>)</span><br><span class="line">optimizer.zero_grad()</span><br><span class="line">output = nets(input)</span><br><span class="line">loss = criterion(output,target)</span><br><span class="line">loss.backward()</span><br><span class="line">optimizer.step()</span><br></pre></td></tr></table></figure><p><strong>处理数据</strong></p><ul><li>处理图像时，我们可以使用pillow，opencv这些库</li><li>处理语音时，我们可以使用scipy，librosa</li><li>处理文本，可以使用python的基础数据加载模块，或者使用NTLK，SpaCy这些库</li></ul><p><strong>GPU数据处理</strong></p><p>如何将数据转移到GPU上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">device = torch.device(<span class="string">'cuda:0,1,2,3'</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">'cpu'</span>)</span><br><span class="line">net.to(device)</span><br><span class="line"><span class="comment"># 输入，输出也有传输到gpu上</span></span><br><span class="line">inputs,labels = inputs.to(device),labels.to(devices)</span><br></pre></td></tr></table></figure><p>pytorch默认使用一个GPU，我们可以通过<code>DataParallel()</code>来设定模型在GPU上跑。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line">model = DataParallel(model)</span><br></pre></td></tr></table></figure><p>尽管我们的模型只获得一个输入，执行一个线性操作，然后输出。数据并行操作自动拆分了你的数据，将任务单发到多个GPU上。当每一个模型都完成自己的任务，DataParallel收集这些结果，然后返回到输出中。（代码形式是线性的，但是程序执行的时候是并行的）</p><p>代码见github链接。</p><p><strong>数据类</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset,DataLoader</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">own_dataset</span><span class="params">(Dataset)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,data)</span>:</span></span><br><span class="line">    self.data = data</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self,index)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.data[index]</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> len(self.data)</span><br><span class="line">data_loader = DataLoader(own_dataset,batch_size = <span class="number">4</span>,num_works = <span class="number">2</span>,shuffle = <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>继承Dataset需要实现其中的<code>__getitem__()</code>，<code>__len__()</code>方法。</p><p>继而实现dataLoader类，作为一个迭代器，每次向model中喂数据，batch_size这些参数都在这里设置。</p><p>如何将自己的数据转化成DataLoader的类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.utils.data <span class="keyword">as</span> Data</span><br><span class="line">x = torch.rand(<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">y = torch.rand(<span class="number">10</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 转换成dataset</span></span><br><span class="line">datas = Data.TensorDataset(x ,y)</span><br><span class="line">lloader = DataLoader(datas,batch_size=<span class="number">4</span>,shuffle=<span class="keyword">True</span>)</span><br><span class="line"><span class="keyword">for</span> data_x,data_y <span class="keyword">in</span> lloader:</span><br><span class="line">    print(data_x,data_y)</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p><strong>python</strong></p><h3 id="pytorch-迁移学习"><a href="#pytorch-迁移学习" class="headerlink" title="pytorch 迁移学习"></a>pytorch 迁移学习</h3><p>事实上，很少人从头开始训练一个完整的网络。通常的做法是在一个很大的数据集上进行预训练，得到网络的初始化参数，或者固定这些参数，去优化下游任务。</p><p><strong>保存、加载模型</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># save 参数</span></span><br><span class="line">torch.save(model.state_dict(),<span class="string">'my_resnet.pth'</span>)</span><br><span class="line">resnet = ResNet()</span><br><span class="line">resnet.load_state_dict(torch.load(<span class="string">'my_resnet.pth'</span>))</span><br><span class="line"><span class="comment"># save 模型结构</span></span><br><span class="line">torch.save(model,<span class="string">'my_resnet.pth'</span>)</span><br><span class="line">resnet = torch.load(<span class="string">'my_resnet.pth'</span>)</span><br><span class="line"><span class="comment"># 保存checkpoint</span></span><br><span class="line">torch.save(&#123;</span><br><span class="line">  <span class="string">'epoch'</span>:epoch,</span><br><span class="line">  <span class="string">'model_state_dict'</span>:model.state_dict(),</span><br><span class="line">  <span class="string">'optimizer_state_dict'</span>:optimizer.state_dict(),</span><br><span class="line">  <span class="string">'loss'</span>:loss,</span><br><span class="line">  .</span><br><span class="line">&#125;, PATH)</span><br><span class="line"></span><br><span class="line"><span class="comment"># DataParallel模型的保存使用：</span></span><br><span class="line">torch.save(model.module.state_dict(),PATH)</span><br></pre></td></tr></table></figure><p><strong>加载部分预训练参数</strong></p><p>有些场景我们基于一个基础网络做的，因此我们需要为主干网络进行初始化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pretrain = model_zoo.load_url(model_urls[<span class="string">'resnet152'</span>])</span><br><span class="line">model_dict = model.state_dict()</span><br><span class="line">pretrain = &#123;k:v <span class="keyword">for</span> k,v <span class="keyword">in</span> pretrain.items() <span class="keyword">if</span> k <span class="keyword">in</span> model_dict&#125;</span><br><span class="line">model_dict.update(pretrain)</span><br><span class="line">model.load_state_dict(model_dict)</span><br></pre></td></tr></table></figure><h3 id="当一个batch中，句子不等长的时候"><a href="#当一个batch中，句子不等长的时候" class="headerlink" title="当一个batch中，句子不等长的时候"></a>当一个batch中，句子不等长的时候</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn.utils.rnn <span class="keyword">as</span> rnn_utils</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> DataLoader</span><br><span class="line"><span class="keyword">import</span> torch.utils.data <span class="keyword">as</span> data</span><br><span class="line">train  = [tensor([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]),tensor([<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]),tensor([<span class="number">6</span>,<span class="number">6</span>])]</span><br><span class="line"><span class="comment"># 将train 变量的长度补全后面补上0，使得其长度一致</span></span><br><span class="line">x = rnn_utils.pad_sequence(train, batch_first=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># 由于直接用上面的变长变量，会增加很多工作，因此我们需要pack，将向量的长度减小</span></span><br><span class="line"><span class="comment"># 其中第二个参数为每一个序列，实际的长度</span></span><br><span class="line"><span class="comment"># 返回值为：data=tensor([1., 3., 6., 1., 3., 6., 1., 3., 1., 3., 1., 3., 1., 1.]),</span></span><br><span class="line"><span class="comment">#          batch_sizes=tensor([3, 3, 2, 2, 2, 1, 1]))</span></span><br><span class="line">x = rnn_utils.pack_padded_sequence(x,[<span class="number">7</span>,<span class="number">5</span>,<span class="number">2</span>],batch_first = <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面函数为上面函数的逆函数，恢复填充0之后的tensor</span></span><br><span class="line">x = rnn_utils.pad_packed_sequence(x,batch_first = <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p><strong>pytorch库的大致功能</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn <span class="comment"># 包含的大量的网络层nn.Linear() 等等</span></span><br><span class="line"><span class="keyword">from</span> torch.utils.data <span class="keyword">import</span> Dataset,DataLoader <span class="comment"># 包含了数据读取的方式</span></span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F <span class="comment"># 包含了激活函数等</span></span><br><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim <span class="comment"># 包含了优化器</span></span><br><span class="line"><span class="keyword">import</span> torch.nn.utils.rnn <span class="keyword">as</span> rnn <span class="comment"># rnn中的一些方法</span></span><br></pre></td></tr></table></figure><h3 id="机器翻译模型"><a href="#机器翻译模型" class="headerlink" title="机器翻译模型"></a>机器翻译模型</h3><p>将词转化成可以输入网络的格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="comment"># 首先经过一系列的分词，去除不正确的词</span></span><br><span class="line"><span class="comment"># 建立词向量表，用随机值初始化</span></span><br><span class="line">embed = nn.embedding(n_vocabulary,embedding_size) <span class="comment">#字典的字数，每个词向量的长度</span></span><br><span class="line"><span class="comment"># embedding是一个二维的矩阵，y轴方向为每个单词，x轴为词向量的具体表示</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">word2vec</span><span class="params">(input_seq)</span>:</span></span><br><span class="line">  <span class="comment"># input_seq是一个batch，含有多个句子，但是句子的长度不一致，</span></span><br><span class="line">  <span class="comment"># 因此需要将句子的长度补充到一致的水平</span></span><br><span class="line">  <span class="comment"># 可以使用nn.utils.rnn.pad_sequence(x,batch_first = True)</span></span><br><span class="line">  words = nn.utils.rnn.pad_sequence(x,batch_first = <span class="keyword">True</span>)</span><br><span class="line">  <span class="comment"># 输入的数据每次喂给模型的为batch中句子的第n列词，因此需要把维度改为seq*batch</span></span><br><span class="line">  words = word.T</span><br><span class="line">  embed_word = embed(words) <span class="comment"># 将词替换成词向量</span></span><br><span class="line">  <span class="comment"># 下一步送入模型之前，对填充变量进行压缩</span></span><br><span class="line">  x = rnn_utils.pack_padded_sequence(x,lengths = [<span class="number">7</span>,<span class="number">5</span>,<span class="number">2</span>],batch_first = <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>上述过程就得到了输入数据的格式。通常机器翻译模型由encoder和decoder的机构组成。</p><p><img src="/images/nlp/seq1.png" style="zoom:50%;"></p><p>Encoder将句子编码成一个语义向量，decoder一个一个产生目标单词，根据之前的单词，产生之后的单词：</p><p><img src="/images/nlp/seq2.png" style="zoom:50%;"></p><p>具体如何选择encoder和decoder有非常多的选择（LSTM，GRU）等等。</p><p><strong>下面实现encoder部分:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 搭建encoder模型</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">encoder的输入input_seq大小为【最大句子长度*batch-size】</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EncoderRNN</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,hidden_size,embedding,n_layers=<span class="number">1</span>,dropout=<span class="number">0</span>)</span>:</span></span><br><span class="line">        super(EncoderRNN,self).__init__()</span><br><span class="line">        self.n_layers = n_layers</span><br><span class="line">        self.hidden_size = hidden_size</span><br><span class="line">        self.embedding = embedding</span><br><span class="line">        self.gru = nn.GRU(hidden_size,hidden_size,n_layers,droput=(<span class="number">0</span> <span class="keyword">if</span></span><br><span class="line">                          n_layers==<span class="number">1</span> <span class="keyword">else</span> dropout),bidirectional=<span class="keyword">True</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,input_seq,input_lengths,hidden=None)</span>:</span></span><br><span class="line">        embedded = self.embedding(input_seq) <span class="comment"># 转化成词向量</span></span><br><span class="line">        packed = nn.utils.rnn.pack_paded_sequence(embedding,input_lengths)<span class="comment"># 压缩</span></span><br><span class="line">        <span class="comment"># 整体的一个output，和最后一层的hidden输出</span></span><br><span class="line">        outputs,hidden = self.gru(packed,hidden)</span><br><span class="line">        <span class="comment"># 将tensor填充到维度一致，还返回一个每个句子的长度</span></span><br><span class="line">        outputs,_ = nn.utils.rnn.pad_packed_sequence(outputs) </span><br><span class="line">        <span class="comment"># 将正反两向的值相加</span></span><br><span class="line">        outputs = outputs[:,:,:self.hidden_size] + output[:,:,:self.hidden_size] </span><br><span class="line">        <span class="keyword">return</span> outputs,hidden</span><br></pre></td></tr></table></figure><p><strong>GRU的使用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gru = torch.nn.GRU(input_size,hidden_size,n_layers)</span><br><span class="line"><span class="comment"># 这里的input_size就是词向量的维度，hidden_size就是RNN隐藏层的维度，这两个一般相同就可以</span></span><br><span class="line"><span class="comment"># n_layers是GRU的层数</span></span><br><span class="line"><span class="comment"># GRU实现自身迭代，不需要时间步数</span></span><br><span class="line"><span class="comment"># GRU的输入是经过pack后的向量</span></span><br><span class="line"><span class="comment"># GRU的输出有两个，分别为整体的输出和最后一层的hidden</span></span><br></pre></td></tr></table></figure><p>注意力机制的应用：</p><p><img src="/images/nlp/seq3.png" style="zoom:67%;"></p><p>上面$h_s$表示GRU向上的所有输出，用来分类。$h_t$表示GRU向右的输出，是隐藏状态值。</p><p>由上面分析，最终权重将会有三种计算方式：</p><ul><li><p>第一个是直接将输出和隐藏状态的输出相乘，linear层的输出作为权重。</p></li><li><p>第二种方式是加入一个linear层，输入为output。linear的输出再乘以hidden。</p></li><li>第三种首先hidden转化为output的shape，然后将hidden和output串在一起，经过一个linear层，之后用tanh激活函数，最后用hidden_shape的value乘以tanh的输出，得到最后权重</li></ul><p>但是这个还没完，最后还要经过一个softmax，才能得到最终的权重，然后乘以output，作为decoder的输入。</p><p><strong>下面是attention第三种公式的实现部分</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">atten</span><span class="params">(nn.Moudle)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,hidden_size)</span>:</span></span><br><span class="line">        super(atten,self).__init__()</span><br><span class="line">        self.fc = linear(hidden_size*<span class="number">2</span>,hidden_size)</span><br><span class="line">        self.v = nn.Parameter(torch.FloatTensor(hidden_size))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,hidden,encoder_output)</span>:</span></span><br><span class="line">        x = torch.cat((hidden.expand(encoder_output.size(<span class="number">0</span>),<span class="number">-1</span>,<span class="number">-1</span>),</span><br><span class="line">                       encoder_output),<span class="number">2</span>)</span><br><span class="line">        x = self.fc(x) <span class="comment"># shape = [hidden_size,hidden]</span></span><br><span class="line">        x = F.tanh(x)</span><br><span class="line">        x = torch.sum(self.v * x,dim = <span class="number">2</span>)</span><br><span class="line">        x = F.softmax(x.T,dim = <span class="number">1</span>).unsqueze(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>最后的输出转置之后，经过一个softmax转换成概率之后，输出。</p><p>decoder接受encoder部分的hidden-state，即句子的深层特征。然后输入全是<code>&lt;SOS&gt;</code>，即句子的结束符。所以首先decoder需要进行word2vec，然后接受encoder的中间层的输出，最后得到decoder的output（可能会有全连接层），然后输出结果和target计算一个loss。</p><p>下面实现以下decoder的部分，包括输入的形成以及decoder最后的输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># decoder 部分</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">decoder</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,embedding,hidden_size,n_layers = <span class="number">1</span>,dropout=<span class="number">0.1</span>)</span>:</span></span><br><span class="line">        super(decoder,self).__init__()</span><br><span class="line">        self.hidden_size = hidden_size <span class="comment"># encoder,decoder都会用到</span></span><br><span class="line">        self.n_layers = n_layers</span><br><span class="line">        self.dropout = dropout</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 定义decoder的层</span></span><br><span class="line">        self.embedding = embedding</span><br><span class="line">        self.embedding_dropout = nn.Dropout(dropout)</span><br><span class="line">        self.gru = nn.GRU(hidden_size,hidden_size,n_layers,dropout)</span><br><span class="line">        self.fc1 = nn.Linear(hidden_size*<span class="number">2</span>,hidden_size)</span><br><span class="line">        self.fc2 = nn.Linear(hidden_size,hidden_size)</span><br><span class="line">        self.attn = atten(hidden_size)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self,inputs,last_hidden,encoder_output)</span>:</span></span><br><span class="line">        embedd = self.embedding(inputs)</span><br><span class="line">        embedd = self.embedding_dropout(embedd)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 进入GRU网络</span></span><br><span class="line">        rnn_output,hidden = self.gru(embedd,last_hidden)</span><br><span class="line">        <span class="comment"># 然后rnn_output作为是一个输出结合连个输出的attention，去做分类的工作</span></span><br><span class="line">        attention = self.attn(rnn_output,encoder_output)</span><br><span class="line">        x = torch.cat((rnn_output,attention),<span class="number">1</span>)</span><br><span class="line">        x = self.fc1(x)</span><br><span class="line">        x = torch.tanh(x)</span><br><span class="line">        x = self.fc2(x)</span><br><span class="line">        x = F.softmax(x,dim = <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> output,hidden <span class="comment"># 返回输出和最终隐藏状态（每一个词的长度都是词向量的长度）</span></span><br></pre></td></tr></table></figure><p>下面调用encoder和decoder，使得整个网络连贯起来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">encoder_outputs, encoder_hidden = encoder(input_variable, lengths)</span><br><span class="line">attens = atten(encoder_hidden,encoder_output)</span><br><span class="line">encoder_outputs = encoder_outputs*attens</span><br><span class="line">decoder_output,decoder_hidden = decoder(inputs,encoder_outputs,encoder_hidden)</span><br></pre></td></tr></table></figure><p><strong>定义损失函数：</strong></p><p>由于我们处理的是批量填充序列，因此在计算损失时我们不能简单地考虑张量的所有元素。我们定义<code>maskNLLLoss</code>可以根据解码器的输出张量、 描述目标张量填充的<code>binary mask</code>张量来计算损失。该损失函数计算与<code>mask tensor</code>中的1对应的元素的平均负对数似然。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maskNLLLoss</span><span class="params">(inp, target, mask)</span>:</span></span><br><span class="line">    nTotal = mask.sum()</span><br><span class="line">    crossEntropy = -torch.log(torch.gather(inp, <span class="number">1</span>, target.view(<span class="number">-1</span>, <span class="number">1</span>)).squeeze(<span class="number">1</span>))</span><br><span class="line">    loss = crossEntropy.masked_select(mask).mean()</span><br><span class="line">    loss = loss.to(device)</span><br><span class="line">    <span class="keyword">return</span> loss, nTotal.item()</span><br></pre></td></tr></table></figure><p>本文github地址：<a href="https://github.com/WenHui-Zhou/NLP_pratice/blob/master/pytorh_review.ipynb" target="_blank" rel="noopener">https://github.com/WenHui-Zhou/NLP_pratice/blob/master/pytorh_review.ipynb</a></p><h3 id="inference"><a href="#inference" class="headerlink" title="inference"></a>inference</h3><ul><li><a href="https://www.cnblogs.com/duye/p/10590146.html" target="_blank" rel="noopener">https://www.cnblogs.com/duye/p/10590146.html</a></li><li><a href="https://plmsmile.github.io/2017/10/12/Attention-based-NMT/" target="_blank" rel="noopener">https://plmsmile.github.io/2017/10/12/Attention-based-NMT/</a></li><li><a href="http://www.nlpuser.com/pytorch/2018/11/04/Attention-In-TextClassification/" target="_blank" rel="noopener">http://www.nlpuser.com/pytorch/2018/11/04/Attention-In-TextClassification/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;pytorch 在日常实践中的一些常用的函数，工作流。&lt;/p&gt;
    
    </summary>
    
      <category term="NLP" scheme="https://wenhui-zhou.github.io/categories/NLP/"/>
    
    
  </entry>
  
</feed>

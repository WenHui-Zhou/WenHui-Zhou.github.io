<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WenHuiZhou</title>
  
  <subtitle>perper（打起精神！）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wenhui-zhou.github.io/"/>
  <updated>2019-08-29T15:42:11.557Z</updated>
  <id>https://wenhui-zhou.github.io/</id>
  
  <author>
    <name>WenHuiZhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Deep Learning for image Super-resolution: a Survey II</title>
    <link href="https://wenhui-zhou.github.io/2019/08/29/Deep-Learning-for-image-Super-resolution-a-Survey-II/"/>
    <id>https://wenhui-zhou.github.io/2019/08/29/Deep-Learning-for-image-Super-resolution-a-Survey-II/</id>
    <published>2019-08-29T15:41:09.000Z</published>
    <updated>2019-08-29T15:42:11.557Z</updated>
    
    <content type="html"><![CDATA[<h3 id="学习策略"><a href="#学习策略" class="headerlink" title="学习策略"></a>学习策略</h3><h4 id="Loss-Functions"><a href="#Loss-Functions" class="headerlink" title="Loss Functions"></a>Loss Functions</h4><p>​    在超分辨率领域，损失函数用来衡量生成的HR图片与原始的HR图片之间的差距，同时指导模型的优化。下面简要介绍一下存在的一些损失函数的形式。其中$\hat{I}$ 表示原始超分辨图像，$I$ 表示生成的超分辨率图像。</p><p><strong>像素级别的loss （pixel loss）</strong></p><p>对比GT与生成的图片在像素级别上的L1以及L2 loss：<br>$$<br>\begin{aligned} \mathcal{L}_{\text {pixel_L1 }}(\hat{I}, I) &amp;=\frac{1}{h w c} \sum_{i, j, k}\left|\hat{I}_{i, j, k}-I_{i, j, k}\right| \ \mathcal{L}_{\text {pixel_L2}}(\hat{I}, I) &amp;=\frac{1}{h w c} \sum_{i, j, k}\left(\hat{I}_{i, j, k}-I_{i, j, k}\right)^{2} \end{aligned}<br>$$<br>L2 loss 相比较于L1 loss 来说，更加的惩罚比较大的误差，而对一些小的误差的容忍度更大。L1 loss在对性能和最终的收敛上比L2更好。对于指标PSNR来说，最小化pixel loss就可以达到最大化PSNR的目的。但是pixel loss没有将图片的质量考虑在内，因此生成的图片过于平滑，失去了高频的细节信息。</p><p><strong>满意度损失（content loss）</strong></p><p>基于感知的满意度损失，这个loss是一个L2 loss。他的不同点在于，我们将GT与生成的图片，分别输入一个欲训练好的分类网络中，取其高层特征（第$l$ 层）进行pixel wise上的loss计算。<br>$$<br>\mathcal{L}_{\text {content }}(\hat{I}, I ; \phi, l)=\frac{1}{h_{l} w_{l} c_{l}} \sqrt{\sum_{i, j, k}\left(\phi_{i, j, k}^{(l)}(\hat{I})-\phi_{i, j, k}^{(l)}(I)\right)^{2}}<br>$$<br>其中h,w,h是抽取出来的特征层的大小。</p><p>这个loss更加强调图片在生成上的相似性，最常用的分类网络是VGG，resNet。</p><p><strong>纹理损失（Texture Loss）</strong></p><p>一些文章认为图片的纹理由特征不同通道的相关性组成，定义为下面Gram matrix：<br>$$<br>G_{i j}^{(l)}(I)=\operatorname{vec}\left(\phi_{i}^{(l)}(I)\right) \cdot \operatorname{vec}\left(\phi_{j}^{(l)}(I)\right)<br>$$<br>上式中表示两个不同通道的向量的点乘结果。即第 $l$ 层特征向量的i通道和j通道的点乘结果。纹理损失依旧是L2损失，输入是生成图片和GT之间的纹理表示。<br>$$<br>\mathcal{L}_{\text {texture }}(\hat{I}, I ; \phi, l)=\frac{1}{c_{l}^{2}} \sqrt{\sum_{i, j}\left(G_{i, j}^{(l)}(\hat{I})-G_{i, j}^{(l)}(I)\right)^{2}}<br>$$<br>通过这种损失可以很好的得到较为真实的图片。但是仍然有一个难以解决的问题是，用于计算纹理损失的图片patch（方块，补丁）大小的确定依旧要根据经验来确定，太大或太小的patch使得生成的纹理不够真实。</p><p><strong>对抗损失（adversarial loss）</strong></p><p>我们使用一个SR模型作为生成器，另外我们需要定义一个判别器，下面的判别器D使用<strong>交叉熵</strong>来表示。生成器希望生成的样本判别器无法辨认，判别器希望能够鉴别出生成器生成的样本是假的。<br>$$<br>\begin{aligned} \mathcal{L}_{\text {gan_ce_g}}(\hat{I} ; D) &amp;=-\log D(\hat{I}) \ \mathcal{L}_{\text {gan_ce_d }\left(\hat{I}, I_{s} ; D\right)} &amp;=-\log D\left(I_{s}\right)-\log (1-D(\hat{I})) \end{aligned}<br>$$<br>下面还有使用<strong>最小平方差</strong>最为判别器，能够得到更加真实的且高质量的结果。<br>$$<br>\begin{aligned} \mathcal{L}_{\text{gan_ls_g}}(\hat{I} ; D) &amp;=(D(\hat{I})-1)^{2} \ \mathcal{L}_{\text{gan_ls_d}}\left(\hat{I}, I_{s} ; D\right) &amp;=(D(\hat{I}))^{2}+\left(D\left(I_{s}\right)-1\right)^{2} \end{aligned}<br>$$<br>下面是使用hinge loss形式的对抗损失：<br>$$<br>\begin{aligned} \mathcal{L}_{\text{gan_hi_g}}(\hat{I} ; D) &amp;=-D(\hat{I}) \ \mathcal{L}_{\text{gan_hi_d}}\left(\hat{I}, I_{s} ; D\right) &amp;=\min (0, D(\hat{I})-1)+\min \left(0,-D\left(I_{s}\right)-1\right) \end{aligned}<br>$$<br>使用对抗损失很大程度上带来的感知质量的提升，虽然PSNR指数有所下降，但是MOS指数有上升，取得了一个很好的视觉效果，生成的图片更加的真实。</p><p><strong>循环连续损失 （Cycle Consistency Loss）</strong></p><p>改损失受到循环GAN的启发，所用的网络不仅需要从LR到SR，还需要从SR到LR，重新生成的LR需要和输入一致，因此loss 如下：<br>$$<br>\mathcal{L}_{\text {cycle }}\left(I^{\prime}, I\right)=\frac{1}{h w c} \sqrt{\sum_{i, j, k}\left(I_{i, j, k}^{\prime}-I_{i, j, k}\right)^{2}}<br>$$<br><strong>总差异损失（total variation loss）</strong></p><p>这个算是是为了压制在生成图像过程中生成的噪声对图像质量产生的影响。他的loss有相邻像素的差异组合成。<br>$$<br>\mathcal{L}_{\mathrm{TV}}(\hat{I})=\frac{1}{h w c} \sum_{i, j, k} \sqrt{\left(\hat{I}_{i, j+1, k}-\hat{I}_{i, j, k}\right)^{2}+\left(\hat{I}_{i+1, j, k}-\hat{I}_{i, j, k}\right)^{2}}<br>$$<br><strong>基于先验损失（prior based loss）</strong></p><p>对于特定的数据，可以引入一下数据所特有的先验特征。通过这种先验特征可以很快的提升网络对这类数据恢复的性能。</p><h4 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h4><p>BN的提出是为了消除网络训练过程中内部参数的偏移问题。具体做法是对每一个bach做一个归一化操作，并且训练两个变量用于还原网络的表达能力。因此我们在训练过程中可以使用更高的学习率，以及不用太在意参数的初始化值。因此BN在SR网络中同样得到了广泛的应用。</p><p>但是有一些学者认为BN使得网络丧失了尺度信息，使得网络失去灵活度，同样有些网络中去除BN后，取得了一个很好的性能。</p><h4 id="课程学习-Curriculum-learning"><a href="#课程学习-Curriculum-learning" class="headerlink" title="课程学习 Curriculum learning"></a>课程学习 Curriculum learning</h4><p>渐进性的课程学习方法指的是网络从一个简单的任务出发，逐渐增加问题的难度，以此来得到一个鲁棒的模型。</p><p>超分辨率问题本质上是一个病态问题（ill-posed problem），即一些干扰对结果的影响非常的大，且系统十分不稳定，难以从结果反推回输入。这些干扰包括噪声，图片的模糊度，以及超分辨的倍数等等。</p><p>课程学习可以通过渐进学习的方式来解决这些问题，对于放大倍数很大（例如8）的任务，可以利用该思想，现训练简单的情况，例如可以先放大2，4，8倍来解决这个问题，这种方式能够大大缩短网络的训练时间，提升性能。</p><h4 id="多监督问题-（multi-supervision）"><a href="#多监督问题-（multi-supervision）" class="headerlink" title="多监督问题 （multi-supervision）"></a>多监督问题 （multi-supervision）</h4><p>多监督问题在loss 中增加一些变量，用来对某些信号进行监督，最终能够得到一个性能较好的模型。</p><h3 id="其他有用的方法"><a href="#其他有用的方法" class="headerlink" title="其他有用的方法"></a>其他有用的方法</h3><p><strong>context-wise network fusion</strong></p><p>这种方式使用多个不同结构的网络，分别进行超分辨率的训练，然后依次将这些训练结果通过卷积层组合最终的结果（SRCNN），使用这种方法能够也能够达到state of art的效果，同时效率也是可以接受的。</p><p><strong>data augmentation</strong></p><p>数据增强方面，常用于网络中的方法有random cropping, flipping,scaling,rotation, color jittering, 此外还有一个特殊的增强方式，random shuffle RGB,随机打乱RGB的颜色值，这种方法能够消除颜色带来的偏差。</p><p><strong>multi-task learning</strong></p><p>多任务学习指的是将多种任务于SR任务结合，例如语义分割网络于SR网络结合（SFT-GAN）等，将去噪声网络和SR网络结合（DNSR），这种方式能够提供数据的先验，能够更好的提升SR的效果。</p><p><strong>network interpolation</strong></p><p>网络的结合，将基于pxiel loss和基于感知loss的两种方法结合起来，得到一种中间状态的网络，这种网络同时在PSNR和真实感上有很好的表现。</p><h3 id="无监督的方法"><a href="#无监督的方法" class="headerlink" title="无监督的方法"></a>无监督的方法</h3><p>在超分辨率问题上，由于很难获得真实数据的超分辨率结果，因此 通常的做法是使用一个下采样方法，从超分辨率图像中得到他的低分辨率版本你，组成一个数据对，因此监督学习更像是学习这个方法的逆方法，人们通常忽略了提前定义好的下采样方法给数据带来的副作用。对于无监督方法来说，直接使用高分辨率的图片，更加符合现实中的场景。无监督方法上，目前仍然有很多值得探索的地方。</p><h4 id="zero-shot-super-resolution"><a href="#zero-shot-super-resolution" class="headerlink" title="zero-shot super-resolution"></a>zero-shot super-resolution</h4><p>这个方法训练了一个预测核函数直接针对每张图片都生成一个下采样（degradation）核方法，使用这个核方法来构造数据集，采用不同的缩放尺度得到测试数据，然后训练一个CNN网络来实现SR。由于这个模型需要为每一张图片构造一个函数，因此需要更多的时间。</p><h4 id="weakly-supervised-Super-resolution"><a href="#weakly-supervised-Super-resolution" class="headerlink" title="weakly-supervised Super-resolution"></a>weakly-supervised Super-resolution</h4><p>弱监督的学习方法有两个思路，第一种是不是用传统的HR-to-LR的退化函数，而是学习一个网络来实现这个过程，然后构造一个数据集，然后使用这个数据集来训练SR模型。另一种是cycle-in-cycle的方法，同时学习LR-to-HR和HR-to-LR两方面。</p><p><strong>learning degradation</strong></p><p>有学者提出了一个两个阶段的学习网络，提出一个GAN网络，学习HR to LR，用这个网络生成一个LR-HR配对的数据集，然后训练一个LR to SR的GAN网络使用上诉的数据集进行训练，最终结果能够显著提升数据恢复的真实性。</p><p><strong>cycle in cycle super resolution</strong></p><p>CinCGAN网络使用了四个生成器，两个判别器。生成器分别为noise LR -&gt; clean LR -&gt; clean HR，另外两个生成器进行反方向的生成。然后生成器用于判别生成了LR和SR的真实性，这其中引入了大量的损失函数，来保证这一过程的合理性。此外，这个方法还有很多改进的地方，来降低它训练的难度。</p><h4 id="图像的深度先验"><a href="#图像的深度先验" class="headerlink" title="图像的深度先验"></a>图像的深度先验</h4><p>使用一个随机初始化参数的CNN，对一张输入的图像，直接恢复他的超分辨率图像，仅仅利用CNN的结构先验来解决这个问题。模型的效果比传统的双线性插值要好些，但是效果不如其他监督方法，这种方法给我门提供了一种思路，仅仅利用一些手工制作的先验对图像进行超分辨率的恢复。</p><h3 id="领域相关的应用"><a href="#领域相关的应用" class="headerlink" title="领域相关的应用"></a>领域相关的应用</h3><h4 id="高光谱影像-（Hyperspectral-Image-Super-resolution）"><a href="#高光谱影像-（Hyperspectral-Image-Super-resolution）" class="headerlink" title="高光谱影像 （Hyperspectral Image Super-resolution）"></a>高光谱影像 （Hyperspectral Image Super-resolution）</h4><p>高光谱影像在视觉任务中有着很多的用途，但是由于硬件的约束，收集到高质量的高光谱数据是十分的困难的，高光谱数据的分辨率因此也十分的低。因此在高光谱数据领域应用超分辨率方法是很有前景的。</p><p>基于高光谱的超分辨率工作有以下几种：</p><p>W. Huang, L. Xiao, Z. Wei, H. Liu, and S. Tang, “A new pan- sharpening method with deep neural networks,” <em>GRSL</em>, vol. 12, 2015.</p><p>G. Masi, D. Cozzolino, L. Verdoliva, and G. Scarpa, “Pansharp- ening by convolutional neural networks,” <em>Remote Sensing</em>, vol. 8, 2016. Y.Wei,Q.Yuan,H.Shen,andL.Zhang,“Boostingtheaccuracyof multispectral image pansharpening by learning a deep residual network,” <em>GRSL</em>, vol. 14, 2017.</p><p>Y. Qu, H. Qi, and C. Kwan, “Unsupervised sparse dirichlet-net for hyperspectral image super-resolution,” in <em>CVPR</em>, 2018.</p><h3 id="未来的研究方向"><a href="#未来的研究方向" class="headerlink" title="未来的研究方向"></a>未来的研究方向</h3><h4 id="网络结构设计"><a href="#网络结构设计" class="headerlink" title="网络结构设计"></a>网络结构设计</h4><p><strong>结合图片局部和全局信息</strong>： 更大的感受野能够帮助网络获得更多图片的纹理细节。</p><p><strong>结合图片中的高低频数据：</strong>cnn网络的浅层部分能够获取图像的颜色和边界信息，深层网络能够获取图像的语义信息。</p><p><strong>纹理注意力机制：</strong>不同的纹理反应出来的细节特征是不同的，引入注意力机制能够增强图片的真实性。</p><p><strong>轻量级的结构：</strong>预测一张DIV2k的图片，EDSR模型需要花费20s，这是难以接受的，因此我们需要精简网络结构。</p><p><strong>上采样层：</strong>当前使用的上采样层均存在着不同程度的缺陷，提出一个好的上采样层，能够提升网络效能。</p><h4 id="学习策略-1"><a href="#学习策略-1" class="headerlink" title="学习策略"></a>学习策略</h4><p><strong>损失函数：</strong> 当前仍未找到一个很好的损失函数，能够兼顾感知和pixel wise</p><p><strong>Normalization：</strong>BN归一化方法十分花费时间，需要找到它的替代结构</p><h4 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a><strong>评价指标</strong></h4><p>当前的评价指标有PSNR，SSIM，MOS三种，其中PSNR容易生成过于平滑的图像，SSIM根据图片的光照，对比度，结构来评价，当时离人的感知还有一定距离，MOS与人的感知比较接近，但是统计起来十分的耗费人力及复杂。</p><h4 id="现实场景的使用"><a href="#现实场景的使用" class="headerlink" title="现实场景的使用"></a><strong>现实场景的使用</strong></h4><p>无监督学习方向上，可以学习一个degradation函数，用于数据的上采样，更符合现实数据的现状。</p><p>一些特定领域的应用方面，超分辨率可以作为整个流程的一部分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;学习策略&quot;&gt;&lt;a href=&quot;#学习策略&quot; class=&quot;headerlink&quot; title=&quot;学习策略&quot;&gt;&lt;/a&gt;学习策略&lt;/h3&gt;&lt;h4 id=&quot;Loss-Functions&quot;&gt;&lt;a href=&quot;#Loss-Functions&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="super resolution" scheme="https://wenhui-zhou.github.io/categories/super-resolution/"/>
    
    
      <category term="论文阅读" scheme="https://wenhui-zhou.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>并查集，python示例</title>
    <link href="https://wenhui-zhou.github.io/2019/08/27/%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%8Cpython%E7%A4%BA%E4%BE%8B/"/>
    <id>https://wenhui-zhou.github.io/2019/08/27/并查集，python示例/</id>
    <published>2019-08-27T12:09:07.000Z</published>
    <updated>2019-08-27T13:43:59.021Z</updated>
    
    <content type="html"><![CDATA[<p>并查集是一种数据结构，在合并不相交的集合，用来判断一个图中是否有环这种问题时，具有很高的性能。</p><a id="more"></a><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>并查集的主要操作就是为一个集合中的元素找到一个代表（根节点）。并查集的基本操作是合并两个集合，当拿到两个节点，第一步需要找到各自节点的根，然后选择一个节点作为新的代表，那么就完成了两个集合的合并。</p><h3 id="并查集实现"><a href="#并查集实现" class="headerlink" title="并查集实现"></a>并查集实现</h3><p>并查集可以使用一个数组来表示，数组表示图上的节点，下标表示节点的编号，数组的值表示该下标的父节点是哪一个。例如A[0] = 1 表示节点0的父节点是节点1.</p><p>并查集的实现过程主要分为两步，一步是实现节点的根的查找，另一步是实现两个集合的合并，这里包含了节点的路径压缩。</p><p>下面实现find_root算法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">joint = <span class="number">10</span></span><br><span class="line">parent = [<span class="number">-1</span>]*<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_root</span><span class="params">(parent,x)</span>:</span></span><br><span class="line">  x_root = x</span><br><span class="line">  <span class="keyword">while</span> parent[x_root] != <span class="number">-1</span>:</span><br><span class="line">    x_root = parent[x_root]</span><br><span class="line">  <span class="keyword">return</span> x_root</span><br></pre></td></tr></table></figure><p>上面代码说明当x不是根节点时，循环继续往上找，当x时根节点时则返回。</p><p>下面是union的算法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union_joint</span><span class="params">(parent,x,y)</span>:</span></span><br><span class="line">  x = find_root(parent,x)</span><br><span class="line">  y = find_root(parent,y)</span><br><span class="line">  <span class="keyword">if</span> x == y:</span><br><span class="line">    print(<span class="string">'circle'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    parent[x] = y</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>上诉代码如果返回的结果是0的话则说明存在一个环，否则不存在环。</p><p>存在一种极端的情况，即每次union合成的集合它形成了一个很长的链，每次寻找一个节点的根需要遍历一下整个节点，复杂度太高，下面在union中引入路径压缩的思想，即引入另一个数组rank，表明当前节点的位置，当进行union的时候，rank小的数连接到rank大的树底下，当两个rank相同的时候，可以随意连接，但是连接之后作为父节点的rank需要加1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rank = [<span class="number">0</span>]*joint</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(parent,x,y,rank)</span>:</span></span><br><span class="line">  x = find_root(parent,x)</span><br><span class="line">  y = find_root(parent,y)</span><br><span class="line">  <span class="keyword">if</span> x == y:</span><br><span class="line">    print(<span class="string">'circle'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> rank[x] &gt; rank[y]:</span><br><span class="line">      parent[y] = x</span><br><span class="line">    <span class="keyword">elif</span> rank[x] &lt; rank[y]:</span><br><span class="line">      parent[x] = y</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      parent[x] = y</span><br><span class="line">      rank[y] += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在判断一个图是否存在环的时候，依次遍历图的所有边，如果union返回的结果是0的话，表明有环。</p><p>下面是一道lettcode的题目，思路就是用并查集来求解：</p><p><a href="https://leetcode.com/problems/friend-circles/" target="_blank" rel="noopener">547.Friend Circles</a></p><p>思路是将朋友的关系用边来表示，最后看parent数组中有多少根节点（等于-1）。</p><p>解法代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span><span class="params">(self, M)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type M: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        edge = []</span><br><span class="line">        <span class="keyword">if</span> M == [] <span class="keyword">or</span> M[<span class="number">0</span>] == []:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(M)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(M[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> i &lt;= j:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> M[i][j] == <span class="number">1</span>:</span><br><span class="line">                    edge.append([i,j])</span><br><span class="line">                </span><br><span class="line">        parent = [<span class="number">-1</span>]*len(M)</span><br><span class="line">        rank = [<span class="number">0</span>]*len(M)</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_root</span><span class="params">(parent,x)</span>:</span></span><br><span class="line">            x_root = x</span><br><span class="line">            <span class="keyword">while</span> parent[x_root] != <span class="number">-1</span>:</span><br><span class="line">                x_root = parent[x_root]</span><br><span class="line">            <span class="keyword">return</span> x_root</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">union_joint</span><span class="params">(parent,x,y,rank)</span>:</span></span><br><span class="line">            x = find_root(parent,x)</span><br><span class="line">            y = find_root(parent,y)</span><br><span class="line">            <span class="keyword">if</span> x  != y:</span><br><span class="line">                <span class="keyword">if</span> rank[x] &lt; rank[y]:</span><br><span class="line">                    parent[x] = y</span><br><span class="line">                <span class="keyword">elif</span> rank[x] &gt; rank[y]:</span><br><span class="line">                    parent[y] = x</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    parent[x] = y</span><br><span class="line">                    rank[y] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> edge:</span><br><span class="line">            union_joint(parent,e[<span class="number">0</span>],e[<span class="number">1</span>],rank)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> parent:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">-1</span>:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并查集是一种数据结构，在合并不相交的集合，用来判断一个图中是否有环这种问题时，具有很高的性能。&lt;/p&gt;
    
    </summary>
    
      <category term="算法扫盲" scheme="https://wenhui-zhou.github.io/categories/%E7%AE%97%E6%B3%95%E6%89%AB%E7%9B%B2/"/>
    
    
      <category term="算法" scheme="https://wenhui-zhou.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>哈希表，python示例</title>
    <link href="https://wenhui-zhou.github.io/2019/08/25/%E5%93%88%E5%B8%8C%E8%A1%A8-python%E7%A4%BA%E4%BE%8B/"/>
    <id>https://wenhui-zhou.github.io/2019/08/25/哈希表-python示例/</id>
    <published>2019-08-25T03:06:24.000Z</published>
    <updated>2019-08-27T13:36:57.147Z</updated>
    
    <content type="html"><![CDATA[<p>哈希表一直都是一个很重要的数据结构，从上大学开始，一直有听闻，面试题也有相当的涉及，接下来继续扫盲。</p><a id="more"></a><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希表根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把<strong>关键码值通过哈希函数映射到表中一个位置来访问记录</strong>，以加快查找的速度。</p><p>哈希表的工作原理如下</p><p><img src="/images/hash.png" alt=""></p><p>首先拿到key值，通过哈希函数将key值转化为数组的下标，在插入元素之前，判断该下标位置上是否已经存在元素，若已经存在元素则称为collision（碰撞）。</p><p>当元素发生碰撞时，存在很多方法来处理这种碰撞，常用的方法有<strong>链接法</strong>（java hashmap的实现），每一个index位置连一个链表，用来存储发生碰撞的元素。</p><p><img src="/images/link.png" alt=""></p><p><strong>另一种解决碰撞的方法为开放寻址法</strong>（python中dict的实现）。</p><p>开放寻址法指当前位置发生了碰撞，采用某种方法（线性，二次，双倍散列）对哈希表中其他位置进行访问。如果哈希表全都装满了则需要对哈希表进行扩容。</p><p><img src="/images/openadress.png" alt=""></p><h3 id="python-中dict常用方法"><a href="#python-中dict常用方法" class="headerlink" title="python 中dict常用方法"></a>python 中dict常用方法</h3><p>遍历操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dicts:</span><br><span class="line">    print(i)</span><br><span class="line">    print(dicts[i])</span><br></pre></td></tr></table></figure><p>删除操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dicts.pop(key)</span><br><span class="line">dicts.popitem() <span class="comment">#删除最后一个加入的元素</span></span><br><span class="line"><span class="keyword">del</span> dicts <span class="comment">#直接删除元素</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哈希表一直都是一个很重要的数据结构，从上大学开始，一直有听闻，面试题也有相当的涉及，接下来继续扫盲。&lt;/p&gt;
    
    </summary>
    
      <category term="算法扫盲" scheme="https://wenhui-zhou.github.io/categories/%E7%AE%97%E6%B3%95%E6%89%AB%E7%9B%B2/"/>
    
    
      <category term="算法" scheme="https://wenhui-zhou.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>堆排序，python实现</title>
    <link href="https://wenhui-zhou.github.io/2019/08/22/%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%8Cpython%E5%AE%9E%E7%8E%B0/"/>
    <id>https://wenhui-zhou.github.io/2019/08/22/堆排序，python实现/</id>
    <published>2019-08-22T11:08:57.000Z</published>
    <updated>2019-08-25T03:09:15.393Z</updated>
    
    <content type="html"><![CDATA[<p>堆排序这个名称一直困扰着我，现在扫一下盲。</p><a id="more"></a><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>首先介绍一下堆的概念：堆是一棵完全二叉树，即指允许最后一层的叶子是不满的，其他层都是满的。叶子节点的出现顺序也是从左边开始向右边累加，不允许中断。父结点必须比子节点要大。</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序的算法复杂度是O(nlog(n))。由于节点满足完全二叉树，因此可以通过下标的关系找到父节点，子节点。</p><p>例如当前节点为i，父节点：(i - 1) /2。左孩子：2i+1,右孩子：2i+2。因此堆排序的策略如下：</p><h3 id="堆排序步骤"><a href="#堆排序步骤" class="headerlink" title="堆排序步骤"></a>堆排序步骤</h3><ol><li>构造堆结构，从最后一个元素（叶子）的父节点开始，循环到根节点，每次执行heapify函数（三个节点，找最大的放到根位置）。</li><li>位于根节点的元素是最大的，每次将根节点的数拿出来，作为排序的最后一个值。然后将最后一个叶节点放到根的位置。依次循环下去，直到结束。</li></ol><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(nums,n,i)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    i 表示要进行调换的根节点位置</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    c1 = <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">    c2 = <span class="number">2</span>*i + <span class="number">2</span></span><br><span class="line">    max_index = i</span><br><span class="line">    <span class="keyword">if</span> c1 &lt;= n <span class="keyword">and</span> nums[c1] &gt; nums[i]:</span><br><span class="line">        max_index = c1</span><br><span class="line">    <span class="keyword">if</span> c2 &lt;= n <span class="keyword">and</span> nums[c2] &gt; nums[max_index]:</span><br><span class="line">        max_index = c2</span><br><span class="line">    <span class="keyword">if</span> max_index != i:</span><br><span class="line">        nums[max_index],nums[i] = nums[i],nums[max_index]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_heap</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums) - <span class="number">1</span></span><br><span class="line">    last_index = (n - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(last_index+<span class="number">1</span>)[::<span class="number">-1</span>]:</span><br><span class="line">        heapify(nums,n,i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    print(nums)</span><br><span class="line">    build_heap(nums)</span><br><span class="line">    print(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))[::<span class="number">-1</span>]:</span><br><span class="line">        print(i)</span><br><span class="line">        nums[<span class="number">0</span>],nums[i] = nums[i],nums[<span class="number">0</span>]</span><br><span class="line">        heapify(nums,i<span class="number">-1</span>,<span class="number">0</span>)</span><br><span class="line">    print(nums)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">heap_sort(nums)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;堆排序这个名称一直困扰着我，现在扫一下盲。&lt;/p&gt;
    
    </summary>
    
      <category term="算法扫盲" scheme="https://wenhui-zhou.github.io/categories/%E7%AE%97%E6%B3%95%E6%89%AB%E7%9B%B2/"/>
    
    
      <category term="算法" scheme="https://wenhui-zhou.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深度学习代码的框架</title>
    <link href="https://wenhui-zhou.github.io/2019/08/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E7%9A%84%E6%A1%86%E6%9E%B6/"/>
    <id>https://wenhui-zhou.github.io/2019/08/16/深度学习代码的框架/</id>
    <published>2019-08-16T01:31:51.000Z</published>
    <updated>2019-08-27T08:20:39.915Z</updated>
    
    <content type="html"><![CDATA[<p>以pytorch为例，梳理一下深度学习中，数据的读取，神经网络的搭建，NMS，以及各个指标的计算流程。</p><a id="more"></a><h3 id="main-函数，程序入口，以及代码配置"><a href="#main-函数，程序入口，以及代码配置" class="headerlink" title="main 函数，程序入口，以及代码配置"></a>main 函数，程序入口，以及代码配置</h3><p>通常main函数中，通过实现argparse功能包，从函数的外部接受参数的传入，对数据，网络等进行一些基本的配置。argparse的使用方法：<a href="https://docs.python.org/zh-cn/3/library/argparse.html" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/argparse.html</a></p><p>main函数中一些常用的配置项：</p><ul><li>数据集的格式：coco，csv，pascal voc等等</li><li>数据的路径，包括训练集，测试集的路径等等</li><li>网络的一些细节配置，如深度，backbone 类型</li><li>一些功能的开关设置，如数据的增强等</li><li>训练过程中，一些变量的设置，比如epoch的设置，batch_size的设置等等</li></ul><h3 id="数据读取部分"><a href="#数据读取部分" class="headerlink" title="数据读取部分"></a>数据读取部分</h3><p>数据读取部分的操作包括数据集文件的读取，对图片进行数据的增强，继承dataloader实现数据的批量读取。</p><h4 id="数据文件的读取"><a href="#数据文件的读取" class="headerlink" title="数据文件的读取"></a>数据文件的读取</h4><p>这部分读取任务主要包括读取annotation文件，以及class_id文件，这里以csv格式的数据集文件为例。</p><p>首先实现一个CSVDataset类，继承至torch.utils.data.Dataset类。该类必须实现<code>__len__</code>,<code>__getitem__</code>两个方法。</p><p>在CSVDataset方法的<code>__init__</code>中，进行数据集文件的读取，最终将得到：</p><ul><li>self.classes</li><li>self.image_names : list 包含所有的数据集图片路径</li><li>self.image_data: dict[image_name] = [ {x1,y1,x2,y2,class_name},…]</li></ul><p><code>__getitem__</code>函数中需要实现的方法有根据下标来得到image，以及其对应的标注。最终返回的格式为：</p><p><code>sample = {&#39;img&#39;: img, &#39;annot&#39;: annot}</code>。在返回之前，如果有数据增强部分，还需要进行数据的增强。</p><h4 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a>数据增强</h4><p>数据增强的方法有很多种，常用的图片的翻转，切割，resize，归一化等等。数据增强利用一张图片，得到它的许多副本，有效的增大数据集。数据增强能够起效果的一个本质因素在于，卷积操作对位移，视角，图片大小，光照等因素具有不变性。数据增强有线下增强和线上增强两种方式，后一种方式在dataloader提取数据的时候，才对数据进行增强。</p><p>数据增强的方法通常可以写成一个类，通过pytorch中的<code>transforms.Compose([Augumenter(),Resizer()])</code> 来对所有的增强方法进行整合。</p><p><strong>Normalizer</strong></p><p>实现一个Normalizer类，覆盖其中的<code>__call__</code>方法，对每张图片做一个正则化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Normalizer</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.mean = np.array([[[<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>]]])</span><br><span class="line">        self.std = np.array([[[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>]]])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, sample)</span>:</span></span><br><span class="line"></span><br><span class="line">        image, annots = sample[<span class="string">'img'</span>], sample[<span class="string">'annot'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'img'</span>:((image.astype(np.float32)-self.mean)/self.std), <span class="string">'annot'</span>: annots&#125;</span><br></pre></td></tr></table></figure><p><strong>argument</strong></p><p>实现对图片的翻转，需要注意对标注也要进行处理。</p><p><strong>Resizer</strong></p><p>该方法意图将图片的大小限制在一定范围以内。因此在缩放的时候，需要找到最大的缩放比例,同时保证图片能够被32整除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resizer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Convert ndarrays in sample to Tensors."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, sample, min_side=<span class="number">608</span>, max_side=<span class="number">1024</span>)</span>:</span> <span class="comment">#将图片resize到608，1024以下的大小</span></span><br><span class="line">        image, annots = sample[<span class="string">'img'</span>], sample[<span class="string">'annot'</span>]       <span class="comment"># 不能超过这个尺寸（有一边等于这个尺寸）</span></span><br><span class="line"></span><br><span class="line">        rows, cols, cns = image.shape</span><br><span class="line"></span><br><span class="line">        smallest_side = min(rows, cols)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># rescale the image so the smallest side is min_side</span></span><br><span class="line">        scale = min_side / smallest_side</span><br><span class="line"></span><br><span class="line">        <span class="comment"># check if the largest side is now greater than max_side, which can happen</span></span><br><span class="line">        <span class="comment"># when images have a large aspect ratio</span></span><br><span class="line">        largest_side = max(rows, cols)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> largest_side * scale &gt; max_side:</span><br><span class="line">            scale = max_side / largest_side</span><br><span class="line"></span><br><span class="line">        <span class="comment"># resize the image with the computed scale</span></span><br><span class="line">        image = skimage.transform.resize(image, (int(round(rows*scale)), int(round((cols*scale)))))</span><br><span class="line">        rows, cols, cns = image.shape</span><br><span class="line"></span><br><span class="line">        pad_w = <span class="number">32</span> - rows%<span class="number">32</span></span><br><span class="line">        pad_h = <span class="number">32</span> - cols%<span class="number">32</span></span><br><span class="line"></span><br><span class="line">        new_image = np.zeros((rows + pad_w, cols + pad_h, cns)).astype(np.float32)</span><br><span class="line">        new_image[:rows, :cols, :] = image.astype(np.float32) <span class="comment"># 两个边长需要保证被32整除，少掉的的那部分使用0来补全</span></span><br><span class="line"></span><br><span class="line">        annots[:, :<span class="number">4</span>] *= scale</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'img'</span>: torch.from_numpy(new_image), <span class="string">'annot'</span>: torch.from_numpy(annots), <span class="string">'scale'</span>: scale&#125;</span><br></pre></td></tr></table></figure><h3 id="数据调用-dataloader"><a href="#数据调用-dataloader" class="headerlink" title="数据调用 dataloader"></a>数据调用 dataloader</h3><p>pytorch通过实现dataloader方法来实现网络训练时，每次iteration的数据的输出。dataloader的逻辑是，每次从dataset中调用<code>__getitem__()</code>获取单个数据，然后组合成batch，在使用<code>collate_fn</code>参数对batch进行一些操作。</p><p><code>torch.utils.data.Dataloader</code><strong>中的参数</strong>：</p><blockquote><p><strong>dataset</strong>(<a href="https://pytorch.org/docs/stable/data.html?highlight=dataloader#torch.utils.data.Dataset" target="_blank" rel="noopener"><em>Dataset</em></a>) – dataset from which to load the data.</p><p><strong>batch_size</strong>(<a href="https://docs.python.org/3/library/functions.html#int" target="_blank" rel="noopener"><em>int</em></a>, <em>optional</em>) – how many samples per batch to load (default: 1).</p><p><strong>shuffle</strong>(<a href="https://docs.python.org/3/library/functions.html#bool" target="_blank" rel="noopener"><em>bool</em></a>, <em>optional</em>) – set to <code>True</code>to have the data reshuffled at every epoch (default: False).</p><p><strong>sampler</strong>(<a href="https://pytorch.org/docs/stable/data.html?highlight=dataloader#torch.utils.data.Sampler" target="_blank" rel="noopener"><em>Sampler</em></a>, <em>optional</em>) – defines the strategy to draw samples from the dataset. If specified, <code>shuffle</code>must be False.</p><p><strong>batch_sampler</strong>(<a href="https://pytorch.org/docs/stable/data.html?highlight=dataloader#torch.utils.data.Sampler" target="_blank" rel="noopener"><em>Sampler</em></a>, <em>optional</em>) – like sampler, but returns a batch of indices at a time. Mutually exclusive with batch_size, shuffle, sampler, and drop_last.</p><p><strong>num_workers</strong>(<a href="https://docs.python.org/3/library/functions.html#int" target="_blank" rel="noopener"><em>int</em></a>, <em>optional</em>) – how many subprocesses to use for data loading. 0 means that the data will be loaded in the main process. (default: 0)</p><p><strong>collate_fn</strong>(<em>callable<strong>, </strong>optional</em>) – merges a list of samples to form a mini-batch.</p><p><strong>pin_memory</strong>(<a href="https://docs.python.org/3/library/functions.html#bool" target="_blank" rel="noopener"><em>bool</em></a>, <em>optional</em>) – If <code>True</code>, the data loader will copy tensors into CUDA pinned memory before returning them.</p><p><strong>drop_last</strong>(<a href="https://docs.python.org/3/library/functions.html#bool" target="_blank" rel="noopener"><em>bool</em></a>, <em>optional</em>) – set to <code>True</code>to drop the last incomplete batch, if the dataset size is not divisible by the batch size. If <code>False</code>and the size of dataset is not divisible by the batch size, then the last batch will be smaller. (default: False)</p><p><strong>timeout</strong>(<em>numeric</em>, <em>optional</em>) – if positive, the timeout value for collecting a batch from workers. Should always be non-negative. (default: 0)</p><p><strong>worker_init_fn</strong>(<em>callable</em>, <em>optional</em>) – If not None, this will be called on each worker subprocess with the worker id (an int in <code>[0, num_workers - 1]</code>) as input, after seeding and before data loading. (default: None)</p></blockquote><p>算法中使用如下参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataloader_train = DataLoader(dataset_train, num_workers=3, collate_fn=collater, batch_sampler=sampler)</span><br></pre></td></tr></table></figure><p>其中<code>dataset_train</code>为<code>Dataset</code>类的对象，如上实现数据问价读取的部分。<code>num_workers</code>设置了这个类的线程数。<code>batch_sampler</code> 设置了每次从数据集中返回一个batch的sample的策略。<code>collate_fn</code> 将一系列的样本融合成一个小的mini-batch。</p><p><strong>首先是batch_sampler:</strong></p><p>继承至采样器类，需要实现其中的<code>__len__</code>方法，<code>__iter__</code>方法。该参数的作用是将数据集做成许多group组成的一个list。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AspectRatioBasedSampler</span><span class="params">(Sampler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data_source, batch_size, drop_last)</span>:</span></span><br><span class="line">        self.data_source = data_source</span><br><span class="line">        self.batch_size = batch_size</span><br><span class="line">        self.drop_last = drop_last</span><br><span class="line">        self.groups = self.group_images()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        random.shuffle(self.groups)</span><br><span class="line">        <span class="keyword">for</span> group <span class="keyword">in</span> self.groups:</span><br><span class="line">            <span class="keyword">yield</span> group</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.drop_last:</span><br><span class="line">            <span class="keyword">return</span> len(self.data_source) // self.batch_size</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (len(self.data_source) + self.batch_size - <span class="number">1</span>) // self.batch_size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">group_images</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># determine the order of the images</span></span><br><span class="line">        order = list(range(len(self.data_source)))</span><br><span class="line">        order.sort(key=<span class="keyword">lambda</span> x: self.data_source.image_aspect_ratio(x))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># divide into groups, one group = one batch</span></span><br><span class="line">        <span class="keyword">return</span> [[order[x % len(order)] <span class="keyword">for</span> x <span class="keyword">in</span> range(i, i + self.batch_size)] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(order), self.batch_size)]</span><br></pre></td></tr></table></figure><p>如上，这个方法将数据分别存入group中，然后组成一个groups的list。通过一个<code>__iter__()</code>方法，迭代的方式将数据输出。每次输出一个batch大小的数据。</p><p><strong>collate_fn参数：</strong></p><p>该参数接受来自batch_sampler的数据，对数据进行进一步的处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">collater</span><span class="params">(data)</span>:</span></span><br><span class="line">    imgs = [s[<span class="string">'img'</span>] <span class="keyword">for</span> s <span class="keyword">in</span> data]</span><br><span class="line">    annots = [s[<span class="string">'annot'</span>] <span class="keyword">for</span> s <span class="keyword">in</span> data]</span><br><span class="line">    scales = [s[<span class="string">'scale'</span>] <span class="keyword">for</span> s <span class="keyword">in</span> data]     </span><br><span class="line">    widths = [int(s.shape[<span class="number">0</span>]) <span class="keyword">for</span> s <span class="keyword">in</span> imgs]</span><br><span class="line">    heights = [int(s.shape[<span class="number">1</span>]) <span class="keyword">for</span> s <span class="keyword">in</span> imgs]</span><br><span class="line">    batch_size = len(imgs)</span><br><span class="line">    max_width = np.array(widths).max()</span><br><span class="line">    max_height = np.array(heights).max()</span><br><span class="line">    padded_imgs = torch.zeros(batch_size, max_width, max_height, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(batch_size):</span><br><span class="line">        img = imgs[i]</span><br><span class="line">        padded_imgs[i, :int(img.shape[<span class="number">0</span>]), :int(img.shape[<span class="number">1</span>]), :] = img</span><br><span class="line">    max_num_annots = max(annot.shape[<span class="number">0</span>] <span class="keyword">for</span> annot <span class="keyword">in</span> annots)</span><br><span class="line">    <span class="keyword">if</span> max_num_annots &gt; <span class="number">0</span>:</span><br><span class="line">        annot_padded = torch.ones((len(annots), max_num_annots, <span class="number">5</span>)) * <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> max_num_annots &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> idx, annot <span class="keyword">in</span> enumerate(annots):</span><br><span class="line">                <span class="comment">#print(annot.shape)</span></span><br><span class="line">                <span class="keyword">if</span> annot.shape[<span class="number">0</span>] &gt; <span class="number">0</span>:</span><br><span class="line">                    annot_padded[idx, :annot.shape[<span class="number">0</span>], :] = annot</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        annot_padded = torch.ones((len(annots), <span class="number">1</span>, <span class="number">5</span>)) * <span class="number">-1</span></span><br><span class="line">    padded_imgs = padded_imgs.permute(<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'img'</span>: padded_imgs, <span class="string">'annot'</span>: annot_padded, <span class="string">'scale'</span>: scales&#125;</span><br></pre></td></tr></table></figure><p>上面的操作，将同一个batch中的图片的大小统一同样的大小。annotation的维度也统一到同样大小的维度。然后进行RGB通道的变换之后，放回一个dict。</p><p>上面这些步骤就完成了数据的loader，通过for循环从其中取得元素。</p><h3 id="retinanet网络结构"><a href="#retinanet网络结构" class="headerlink" title="retinanet网络结构"></a>retinanet网络结构</h3><p>下面从数据流动的角度分析一下retinanet的各个结构的组成。</p><p>retinanet的特征提取部分，使用的是resnet，resnet有多种深度的选择，分别有18，34，50，101，152五种深度。常用的网络深度为50，101:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resnet50</span><span class="params">(num_classes, pretrained=False, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""Constructs a ResNet-50 model.</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        pretrained (bool): If True, returns a model pre-trained on ImageNet</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    model = ResNet(num_classes, Bottleneck, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>], **kwargs)</span><br><span class="line">    <span class="keyword">if</span> pretrained:</span><br><span class="line">        model.load_state_dict(model_zoo.load_url(model_urls[<span class="string">'resnet50'</span>], model_dir=<span class="string">'.'</span>), strict=<span class="keyword">False</span>)</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure><p>让我们一行一行来看，第一个调用了ResNet()类，创建了一个ResNet对象。ResNet继承至<code>nn.Module</code>,需要实现函数<code>__init__</code>以及<code>forward()</code>两个方法，通常将可学习的参数放到构造函数<code>__init__()</code>中，在<code>forward</code>中实现网络数据的流动，即可实现网络的自动求导机制。</p><p><strong>ResNet</strong></p><p>resnet首次提出残差的思想，传统的卷积网络或者全连接网络在信息传递的时候或多或少会存在信息丢失，损耗等问题，同时还有导致梯度消失或者梯度爆炸，导致很深的网络无法训练。ResNet通过学习残差的方式，在一定程度上解决了<strong>网络退化和梯度消失</strong>的问题。ResNet通过大量叠加残差块的方式，加深网络的深度的同时，保证了网络的梯度不消失。ResNet有着两种不同的残差单元。分别是basicBlock 和 bottleneck结构。深层次网络使用bottleneck结构，每次经过残差结构之前都对数据进行一次降维，大大降低了网络的参数量。</p><p><img src="/images/res_unit.png" alt=""></p><p>bottleneck的结构feature经过第一个1x1的卷积层，将特征的维度压缩，对压缩后的特征进行3x3的卷积，然后经过1x1卷积层，将特征的维度放大到原来的大小。</p><p>bottleneck的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bottleneck</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    expansion = <span class="number">4</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inplanes, planes, stride=<span class="number">1</span>, downsample=None)</span>:</span></span><br><span class="line">        super(Bottleneck, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(inplanes, planes, kernel_size=<span class="number">1</span>, bias=<span class="keyword">False</span>)</span><br><span class="line">        self.bn1 = nn.BatchNorm2d(planes)</span><br><span class="line">        self.conv2 = nn.Conv2d(planes, planes, kernel_size=<span class="number">3</span>, stride=stride,</span><br><span class="line">                               padding=<span class="number">1</span>, bias=<span class="keyword">False</span>)</span><br><span class="line">        self.bn2 = nn.BatchNorm2d(planes)</span><br><span class="line">        self.conv3 = nn.Conv2d(planes, planes * <span class="number">4</span>, kernel_size=<span class="number">1</span>, bias=<span class="keyword">False</span>)</span><br><span class="line">        self.bn3 = nn.BatchNorm2d(planes * <span class="number">4</span>)</span><br><span class="line">        self.relu = nn.ReLU(inplace=<span class="keyword">True</span>)</span><br><span class="line">        self.downsample = downsample</span><br><span class="line">        self.stride = stride</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        residual = x</span><br><span class="line">        out = self.conv1(x)</span><br><span class="line">        out = self.bn1(out)</span><br><span class="line">        out = self.relu(out)</span><br><span class="line">        </span><br><span class="line">        out = self.conv2(out)</span><br><span class="line">        out = self.bn2(out)</span><br><span class="line">        out = self.relu(out)</span><br><span class="line">        </span><br><span class="line">        out = self.conv3(out)</span><br><span class="line">        out = self.bn3(out)</span><br><span class="line">        <span class="keyword">if</span> self.downsample <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            residual = self.downsample(x)</span><br><span class="line">        out += residual</span><br><span class="line">        out = self.relu(out)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><p>pytorch中常用的搭建网络的函数如下：</p><p>Conv2d卷积：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line">nn.Conv2d(in_channels, out_channels, kernel_size, stride=<span class="number">1</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, groups=<span class="number">1</span>, bias=<span class="keyword">True</span>)</span><br><span class="line">参数：</span><br><span class="line">in_channels(int) – 输入信号的通道</span><br><span class="line">out_channels(int) – 卷积产生的通道</span><br><span class="line">kerner_size(int <span class="keyword">or</span> tuple) - 卷积核的尺寸</span><br><span class="line">stride(int <span class="keyword">or</span> tuple, optional) - 卷积步长</span><br><span class="line">padding(int <span class="keyword">or</span> tuple, optional) - 输入的每一条边补充<span class="number">0</span>的层数</span><br><span class="line">dilation(int <span class="keyword">or</span> tuple, optional) – 卷积核元素之间的间距</span><br><span class="line">groups(int, optional) – 从输入通道到输出通道的阻塞连接数</span><br><span class="line">bias(bool, optional) - 如果bias=<span class="keyword">True</span>，添加偏置</span><br><span class="line">输入：</span><br><span class="line">input: (N,C_in,H_in,W_in) </span><br><span class="line">输出：</span><br><span class="line">output: (N,C_out,H_out,W_out)</span><br><span class="line">计算公式：Fout = (Fin + <span class="number">2</span>*padding-kernel)/stride + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>batchNorm2d：</p><p>在训练时，该层计算每次输入的均值与方差，并进行移动平均。移动平均默认的动量值为0.1。</p><p>在验证时，训练求得的均值/方差将用于标准化验证数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BatchNorm2d(num_features, eps=<span class="number">1e-05</span>, momentum=<span class="number">0.1</span>, affine=<span class="keyword">True</span>)</span><br><span class="line">参数：</span><br><span class="line">num_features： 来自期望输入的特征数，该期望输入的大小为<span class="string">'batch_size x num_features x height x width'</span></span><br><span class="line">eps： 为保证数值稳定性（分母不能趋近或取<span class="number">0</span>）,给分母加上的值。默认为<span class="number">1e-5</span>。</span><br><span class="line">momentum： 动态均值和动态方差所使用的动量。默认为<span class="number">0.1</span>。</span><br><span class="line">affine： 一个布尔值，当设为true，给该层添加可学习的仿射变换参数。</span><br><span class="line">输入：（N, C，H, W) - 输出：（N, C, H, W）</span><br><span class="line">值得至于的是，参数num_feature写channel数即可。</span><br></pre></td></tr></table></figure><p>ReLU：修正线性单元函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nn.ReLU(inplace=<span class="keyword">False</span>)</span><br><span class="line">参数：</span><br><span class="line">inplace：表示是否进行覆盖计算，节省内存</span><br><span class="line">不会引起数据维度的变化</span><br></pre></td></tr></table></figure><p>MaxPool2d 层</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nn.MaxPool2d(kernel_size, stride=<span class="keyword">None</span>, padding=<span class="number">0</span>, dilation=<span class="number">1</span>, return_indices=<span class="keyword">False</span>, ceil_mode=<span class="keyword">False</span>)</span><br><span class="line">参数：</span><br><span class="line">kernel_size(int <span class="keyword">or</span> tuple) - max pooling的窗口大小</span><br><span class="line">stride(int <span class="keyword">or</span> tuple, optional) - max pooling的窗口移动的步长。默认值是kernel_size</span><br><span class="line">padding(int <span class="keyword">or</span> tuple, optional) - 输入的每一条边补充<span class="number">0</span>的层数</span><br><span class="line">dilation(int <span class="keyword">or</span> tuple, optional) – 一个控制窗口中元素步幅的参数</span><br><span class="line">return_indices - 如果等于<span class="keyword">True</span>，会返回输出最大值的序号，对于上采样操作会有帮助</span><br><span class="line">ceil_mode - 如果等于<span class="keyword">True</span>，计算输出信号大小的时候，会使用向上取整，代替默认的向下取整的操作</span><br><span class="line">输入: (N,C,H_&#123;<span class="keyword">in</span>&#125;,W_in) </span><br><span class="line">输出: (N,C,H_out,W_out)</span><br><span class="line">计算公式：Fout = (Fin + <span class="number">2</span>*padding - kernel)/stride + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>nn.Upsample 上采样操作对channel进行采样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nn.Upsample(size=<span class="keyword">None</span>, scale_factor=<span class="keyword">None</span>, mode=<span class="string">'nearest'</span>, align_corners=<span class="keyword">None</span>)</span><br><span class="line">给定上采样策略mode，上采样的大小：scale_factor</span><br></pre></td></tr></table></figure><p>nn.Sequential一个有序的容器，神经网络模块将按照在传入构造器的顺序依次被添加到计算图中执行，同时以神经网络模块为元素的有序字典也可以作为传入参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">downsample = nn.Sequential(</span><br><span class="line">                nn.Conv2d(self.inplanes, planes * block.expansion,</span><br><span class="line">                          kernel_size=<span class="number">1</span>, stride=stride, bias=<span class="keyword">False</span>),</span><br><span class="line">                nn.BatchNorm2d(planes * block.expansion),</span><br><span class="line">            )</span><br></pre></td></tr></table></figure><p><strong>网络结构类继承至<code>nn.Module</code>,需要实现函数<code>__init__</code>以及<code>forward()</code>两个方法，通常在<strong>init</strong>中完成网络层的初始化工作，定义各类的网络层。在forward中完成网络层数据的流动。</strong></p><p>retinanet金字塔模型的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PyramidFeatures</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, C3_size, C4_size, C5_size, feature_size=<span class="number">256</span>)</span>:</span></span><br><span class="line">        super(PyramidFeatures, self).__init__()</span><br><span class="line">        <span class="comment"># upsample C5 to get P5 from the FPN paper</span></span><br><span class="line">        self.P5_1           = nn.Conv2d(C5_size, feature_size, kernel_size=<span class="number">1</span>, stride=<span class="number">1</span>, padding=<span class="number">0</span>)</span><br><span class="line">        self.P5_upsampled   = nn.Upsample(scale_factor=<span class="number">2</span>, mode=<span class="string">'nearest'</span>)</span><br><span class="line">        self.P5_2           = nn.Conv2d(feature_size, feature_size, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># add P5 elementwise to C4</span></span><br><span class="line">        self.P4_1           = nn.Conv2d(C4_size, feature_size, kernel_size=<span class="number">1</span>, stride=<span class="number">1</span>, padding=<span class="number">0</span>)</span><br><span class="line">        self.P4_upsampled   = nn.Upsample(scale_factor=<span class="number">2</span>, mode=<span class="string">'nearest'</span>)</span><br><span class="line">        self.P4_2           = nn.Conv2d(feature_size, feature_size, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># add P4 elementwise to C3</span></span><br><span class="line">        self.P3_1 = nn.Conv2d(C3_size, feature_size, kernel_size=<span class="number">1</span>, stride=<span class="number">1</span>, padding=<span class="number">0</span>)</span><br><span class="line">        self.P3_2 = nn.Conv2d(feature_size, feature_size, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># "P6 is obtained via a 3x3 stride-2 conv on C5"</span></span><br><span class="line">        self.P6 = nn.Conv2d(C5_size, feature_size, kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># "P7 is computed by applying ReLU followed by a 3x3 stride-2 conv on P6"</span></span><br><span class="line">        self.P7_1 = nn.ReLU()</span><br><span class="line">        self.P7_2 = nn.Conv2d(feature_size, feature_size, kernel_size=<span class="number">3</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, inputs)</span>:</span></span><br><span class="line"></span><br><span class="line">        C3, C4, C5 = inputs</span><br><span class="line"></span><br><span class="line">        P5_x = self.P5_1(C5)</span><br><span class="line">        P5_upsampled_x = self.P5_upsampled(P5_x)</span><br><span class="line">        P5_x = self.P5_2(P5_x)</span><br><span class="line">        </span><br><span class="line">        P4_x = self.P4_1(C4)</span><br><span class="line">        P4_x = P5_upsampled_x + P4_x</span><br><span class="line">        P4_upsampled_x = self.P4_upsampled(P4_x)</span><br><span class="line">        P4_x = self.P4_2(P4_x)</span><br><span class="line"></span><br><span class="line">        P3_x = self.P3_1(C3)</span><br><span class="line">        P3_x = P3_x + P4_upsampled_x</span><br><span class="line">        P3_x = self.P3_2(P3_x)</span><br><span class="line"></span><br><span class="line">        P6_x = self.P6(C5)</span><br><span class="line"></span><br><span class="line">        P7_x = self.P7_1(P6_x)</span><br><span class="line">        P7_x = self.P7_2(P7_x)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [P3_x, P4_x, P5_x, P6_x, P7_x]</span><br></pre></td></tr></table></figure><p>retinanet在金字塔之后，接了一个回归网络以及分类网络，分别对边框位置以及类别进行分类。</p><p><strong>回归网络</strong>简单的接了五个卷积层，保持feature的大小不变，每一个channel的维度最终降为num_anchors x 4，即每一个channel需要回归出num_anchors x 4 个坐标点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegressionModel</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_features_in, num_anchors=<span class="number">9</span>, feature_size=<span class="number">256</span>)</span>:</span></span><br><span class="line">        super(RegressionModel, self).__init__()</span><br><span class="line">        </span><br><span class="line">        self.conv1 = nn.Conv2d(num_features_in, feature_size, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.act1 = nn.ReLU()</span><br><span class="line"></span><br><span class="line">        self.conv2 = nn.Conv2d(feature_size, feature_size, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.act2 = nn.ReLU()</span><br><span class="line"></span><br><span class="line">        self.conv3 = nn.Conv2d(feature_size, feature_size, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.act3 = nn.ReLU()</span><br><span class="line"></span><br><span class="line">        self.conv4 = nn.Conv2d(feature_size, feature_size, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.act4 = nn.ReLU()</span><br><span class="line"></span><br><span class="line">        self.output = nn.Conv2d(feature_size, num_anchors*<span class="number">4</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line"></span><br><span class="line">        out = self.conv1(x)</span><br><span class="line">        out = self.act1(out)</span><br><span class="line"></span><br><span class="line">        out = self.conv2(out)</span><br><span class="line">        out = self.act2(out)</span><br><span class="line"></span><br><span class="line">        out = self.conv3(out)</span><br><span class="line">        out = self.act3(out)</span><br><span class="line"></span><br><span class="line">        out = self.conv4(out)</span><br><span class="line">        out = self.act4(out)</span><br><span class="line"></span><br><span class="line">        out = self.output(out)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># out is B x C x W x H, with C = 4*num_anchors</span></span><br><span class="line">        out = out.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out.contiguous().view(out.shape[<span class="number">0</span>], <span class="number">-1</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>上诉最后一行值得注意一下view()函数相当于numpy中的reshape函数，但是要求数据必须在内存中是连续存储的。由于permute函数，改变了数据的分布（浅拷贝）。因此在使用view之前，需要执行contiguous函数使得数据内存连续分布。最终out的shape为[batch_size，w x h ，4]。上诉得到的out最终输入criterion中，计算loss。</p><p><strong>分类模型</strong>的网络结构和回归模型的结构相同，唯一不同的地方在于最终输出的channel的大小。分类模型输出的channel大小为anchor的数量乘以类别（num_anchor x num_classes）。即每一个框都要预测一个类别信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassificationModel</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_features_in, num_anchors=<span class="number">9</span>, num_classes=<span class="number">80</span>, prior=<span class="number">0.01</span>, feature_size=<span class="number">256</span>)</span>:</span></span><br><span class="line">        super(ClassificationModel, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.num_classes = num_classes</span><br><span class="line">        self.num_anchors = num_anchors</span><br><span class="line">        </span><br><span class="line">        self.conv1 = nn.Conv2d(num_features_in, feature_size, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.act1 = nn.ReLU()</span><br><span class="line"></span><br><span class="line">        self.conv2 = nn.Conv2d(feature_size, feature_size, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.act2 = nn.ReLU()</span><br><span class="line"></span><br><span class="line">        self.conv3 = nn.Conv2d(feature_size, feature_size, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.act3 = nn.ReLU()</span><br><span class="line"></span><br><span class="line">        self.conv4 = nn.Conv2d(feature_size, feature_size, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.act4 = nn.ReLU()</span><br><span class="line"></span><br><span class="line">        self.output = nn.Conv2d(feature_size, num_anchors*num_classes, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.output_act = nn.Sigmoid()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line"></span><br><span class="line">        out = self.conv1(x)</span><br><span class="line">        out = self.act1(out)</span><br><span class="line"></span><br><span class="line">        out = self.conv2(out)</span><br><span class="line">        out = self.act2(out)</span><br><span class="line"></span><br><span class="line">        out = self.conv3(out)</span><br><span class="line">        out = self.act3(out)</span><br><span class="line"></span><br><span class="line">        out = self.conv4(out)</span><br><span class="line">        out = self.act4(out)</span><br><span class="line"></span><br><span class="line">        out = self.output(out)</span><br><span class="line">        out = self.output_act(out)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># out is B x C x W x H, with C = n_classes + n_anchors</span></span><br><span class="line">        out1 = out.permute(<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        batch_size, width, height, channels = out1.shape</span><br><span class="line"></span><br><span class="line">        out2 = out1.view(batch_size, width, height, self.num_anchors, self.num_classes)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out2.contiguous().view(x.shape[<span class="number">0</span>], <span class="number">-1</span>, self.num_classes)</span><br></pre></td></tr></table></figure><p>最后一行首先将out的维度控制在anchor x num_classes，然后通过一个view将其变为[x.shape[0],W x H x anchor, num_classes]，每一个值表示一个框的类别，然后到criterion中去做预测。</p><p>Torch.cat 用法：<a href="https://blog.csdn.net/qq_39709535/article/details/80803003" target="_blank" rel="noopener">https://blog.csdn.net/qq_39709535/article/details/80803003</a></p><p>接下来需要生成anchor。</p><h3 id="anchor的生成"><a href="#anchor的生成" class="headerlink" title="anchor的生成"></a>anchor的生成</h3><p>anchor的设置上面，对于retinaNet最终的P3，P4，P5，P6，P7均有一个不同的设置。anchor的长宽比和scale的大小分别有三种设置，一共有9种组合。anchor的大小与feature map的大小也是相关的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.ratios = np.array([<span class="number">0.5</span>,<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line">self.scales = np.array([<span class="number">2</span>**<span class="number">0</span>,<span class="number">2</span>**(<span class="number">1.0</span>/<span class="number">3.0</span>),<span class="number">2</span>**(<span class="number">2.0</span>/<span class="number">3.0</span>)])</span><br></pre></td></tr></table></figure><p>几个常用的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a = np.tile(a,(<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment"># a = [[1,2,3,1,2,3,1,2,3]</span></span><br><span class="line">       [<span class="number">1.2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br></pre></td></tr></table></figure><p>np.repeat</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">a = np.repeat(a,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># a = [1,1,2,2,3,3]</span></span><br><span class="line"><span class="comment"># 与np.tile的区别是，他是一个元素一个元素的增加后进行排序的。tile则是一起增加。</span></span><br></pre></td></tr></table></figure><p>生成anchor的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Anchors</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pyramid_levels=None, strides=None, sizes=None, ratios=None, scales=None)</span>:</span></span><br><span class="line">        super(Anchors, self).__init__()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> pyramid_levels <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            self.pyramid_levels = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">        <span class="keyword">if</span> strides <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            self.strides = [<span class="number">2</span> ** x <span class="keyword">for</span> x <span class="keyword">in</span> self.pyramid_levels]</span><br><span class="line">        <span class="keyword">if</span> sizes <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            self.sizes = [<span class="number">2</span> ** (x + <span class="number">2</span>) <span class="keyword">for</span> x <span class="keyword">in</span> self.pyramid_levels]</span><br><span class="line">        <span class="keyword">if</span> ratios <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            self.ratios = np.array([<span class="number">0.5</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">if</span> scales <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            self.scales = np.array([<span class="number">2</span> ** <span class="number">0</span>, <span class="number">2</span> ** (<span class="number">1.0</span> / <span class="number">3.0</span>), <span class="number">2</span> ** (<span class="number">2.0</span> / <span class="number">3.0</span>)])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, image)</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># image = [2,3,640,832]</span></span><br><span class="line">        image_shape = image.shape[<span class="number">2</span>:]</span><br><span class="line">        image_shape = np.array(image_shape)</span><br><span class="line">        image_shapes = [(image_shape + <span class="number">2</span> ** x - <span class="number">1</span>) // (<span class="number">2</span> ** x) <span class="keyword">for</span> x <span class="keyword">in</span> self.pyramid_levels]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># compute anchors over all pyramid levels</span></span><br><span class="line">        all_anchors = np.zeros((<span class="number">0</span>, <span class="number">4</span>)).astype(np.float32)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> idx, p <span class="keyword">in</span> enumerate(self.pyramid_levels):</span><br><span class="line">            anchors         = generate_anchors(base_size=self.sizes[idx], ratios=self.ratios, scales=self.scales)</span><br><span class="line">            shifted_anchors = shift(image_shapes[idx], self.strides[idx], anchors)</span><br><span class="line">            all_anchors     = np.append(all_anchors, shifted_anchors, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        all_anchors = np.expand_dims(all_anchors, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> torch.from_numpy(all_anchors.astype(np.float32)).cuda()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_anchors</span><span class="params">(base_size=<span class="number">16</span>, ratios=None, scales=None)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Generate anchor (reference) windows by enumerating aspect ratios X</span></span><br><span class="line"><span class="string">    scales w.r.t. a reference window.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ratios <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        ratios = np.array([<span class="number">0.5</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> scales <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        scales = np.array([<span class="number">2</span> ** <span class="number">0</span>, <span class="number">2</span> ** (<span class="number">1.0</span> / <span class="number">3.0</span>), <span class="number">2</span> ** (<span class="number">2.0</span> / <span class="number">3.0</span>)])</span><br><span class="line"></span><br><span class="line">    num_anchors = len(ratios) * len(scales) <span class="comment"># 9个点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># initialize output anchors</span></span><br><span class="line">    anchors = np.zeros((num_anchors, <span class="number">4</span>)) <span class="comment"># 每一个位置上都有9个点，每个点都有四个坐标值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># scale base_size,feature 的大小与scale相乘，得到每一层anchor的大小</span></span><br><span class="line">    anchors[:, <span class="number">2</span>:] = base_size * np.tile(scales, (<span class="number">2</span>, len(ratios))).T</span><br><span class="line"></span><br><span class="line">    <span class="comment"># compute areas of anchors</span></span><br><span class="line">    areas = anchors[:, <span class="number">2</span>] * anchors[:, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># correct for ratios 构造长宽比</span></span><br><span class="line">    anchors[:, <span class="number">2</span>] = np.sqrt(areas / np.repeat(ratios, len(scales)))</span><br><span class="line">    anchors[:, <span class="number">3</span>] = anchors[:, <span class="number">2</span>] * np.repeat(ratios, len(scales))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># transform from (x_ctr, y_ctr, w, h) -&gt; (x1, y1, x2, y2)</span></span><br><span class="line">    anchors[:, <span class="number">0</span>::<span class="number">2</span>] -= np.tile(anchors[:, <span class="number">2</span>] * <span class="number">0.5</span>, (<span class="number">2</span>, <span class="number">1</span>)).T</span><br><span class="line">    anchors[:, <span class="number">1</span>::<span class="number">2</span>] -= np.tile(anchors[:, <span class="number">3</span>] * <span class="number">0.5</span>, (<span class="number">2</span>, <span class="number">1</span>)).T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> anchors</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shift</span><span class="params">(shape, stride, anchors)</span>:</span></span><br><span class="line">    shift_x = (np.arange(<span class="number">0</span>, shape[<span class="number">1</span>]) + <span class="number">0.5</span>) * stride</span><br><span class="line">    shift_y = (np.arange(<span class="number">0</span>, shape[<span class="number">0</span>]) + <span class="number">0.5</span>) * stride</span><br><span class="line"></span><br><span class="line">    shift_x, shift_y = np.meshgrid(shift_x, shift_y)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># shifts = [shape[0]*shape[1],4]</span></span><br><span class="line">    shifts = np.vstack((</span><br><span class="line">        shift_x.ravel(), shift_y.ravel(),</span><br><span class="line">        shift_x.ravel(), shift_y.ravel()</span><br><span class="line">    )).transpose()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># add A anchors (1, A, 4) to</span></span><br><span class="line">    <span class="comment"># cell K shifts (K, 1, 4) to get</span></span><br><span class="line">    <span class="comment"># shift anchors (K, A, 4)</span></span><br><span class="line">    <span class="comment"># reshape to (K*A, 4) shifted anchors</span></span><br><span class="line">    A = anchors.shape[<span class="number">0</span>]</span><br><span class="line">    K = shifts.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 下面这一行进行了广播赋值，每一行都赋予维度不同的行进行广播，</span></span><br><span class="line">    <span class="comment"># 最终形成[1,A,4] + [k,1,4] = [k,A,4],其中k = shape[0]*shape[1]</span></span><br><span class="line">    <span class="comment"># 也就是说每一个像素位置都将产生9个anchor，每个anchor有四个坐标。 shape的大小则是由计算产生的</span></span><br><span class="line">    <span class="comment"># 每张图片在每个level处的大小在__init__处进行初始化</span></span><br><span class="line">    all_anchors = (anchors.reshape((<span class="number">1</span>, A, <span class="number">4</span>)) + \</span><br><span class="line">                   shifts.reshape((<span class="number">1</span>, K, <span class="number">4</span>)).transpose((<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>)))</span><br><span class="line">    all_anchors = all_anchors.reshape((K * A, <span class="number">4</span>))</span><br><span class="line">    <span class="keyword">return</span> all_anchors</span><br></pre></td></tr></table></figure><p>每一行进行分析就是先设置每一层feature map的level，stride，sizes，ratios，scales的值。然后在forward里面<strong>generate_anchor()，对每一个level的feature生成符合要求的size的anchor</strong>，长宽比组合后共9种anchor。具体的设置可看代码。</p><p>然后进入shift()函数，shift()函数的作用是将anchor散布到每一个位置上。流程大概是，一张图片进来，分别计算出这种图片在每一层level上的size大小，然后根据每一层的anchor的大小，每一个像素点位置取9个anchor，然后返回一个$[shape[0]<em>shape[1]</em>9,4]$ 大小的矩阵。</p><p>几个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">np.meshgrid(x,y)<span class="comment"># 将x中元素与y中元素一一对应起来组合成坐标的形式。</span></span><br><span class="line">np.vstack((x,y))<span class="comment"># 将x，y中元素按照垂直方向叠加</span></span><br><span class="line"><span class="comment">#ravel()</span></span><br><span class="line">a = [[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">a.ravel() <span class="comment"># 将多维数组拉平，不存生新的副本 a = [2,2,1,1]</span></span><br><span class="line">a.flatten() <span class="comment"># 作用与上面函数相同，将返回一个数据副本</span></span><br><span class="line">np.squeeze([[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>]]) <span class="comment"># 对维度为1的数据进行压缩，得到[1,2,3]</span></span><br><span class="line">a = a.reshape(<span class="number">-1</span>) <span class="comment"># 同样能够得到1维的数据</span></span><br><span class="line">a.transpose() <span class="comment"># 不指定参数表示对矩阵进行转置</span></span><br></pre></td></tr></table></figure><p>经过上面的过程，在for循环部分，将5层的anchor全部装入一个list中，anchor生成完毕。</p><p><strong>torch.cat函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">torch.cat((a,b),<span class="number">0</span>) <span class="comment"># 垂直方向 [[1,2,3],[3,4,5]]</span></span><br><span class="line">torch.cat((a,b),<span class="number">1</span>) <span class="comment"># 水平方向 [[1,2,3,4,5,6]]</span></span><br></pre></td></tr></table></figure><h3 id="focalLoss部分"><a href="#focalLoss部分" class="headerlink" title="focalLoss部分"></a>focalLoss部分</h3><p>focalLoss紧接着上面的一部分。现在回过头来梳理一下网络中数据流动到的位置：</p><p>将图片输入ResNet中，通过一个多层金字塔结构，输出5个不同深度feature map（P3，P4，P5，P6，P7），依次将这些层输入到regression网络和classification网络中，每一层都将得到$[batch,w<em>h,4]$的输出和$[batch,w</em>h*anchors,class_nums]$的输出，然后将所有结果cat到一起（水平拼接），即所有level上的anchor 的预测框会被cat到regression_anchor 和classification_anchor中。接下来要做的是判断这些anchor的好坏。根据我们的先验知识，我们产生了一部分anchor的设置，我们将网络产生的anchor和我们预生成的anchor输入focalLoss中，对anchor进行过滤，计算产生的loss。</p><p>下面介绍focalLoss：</p><p>focalLoss部分按batch为单位，每次输入一个batch的数据，然后进行loss的计算。首先计算预设置的anchor与当前图片GT的IoU。（重叠部分 / 相并部分）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_iou</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    area = (b[:, <span class="number">2</span>] - b[:, <span class="number">0</span>]) * (b[:, <span class="number">3</span>] - b[:, <span class="number">1</span>])</span><br><span class="line">    iw = torch.min(torch.unsqueeze(a[:, <span class="number">2</span>], dim=<span class="number">1</span>), b[:, <span class="number">2</span>]) -\</span><br><span class="line">    torch.max(torch.unsqueeze(a[:, <span class="number">0</span>], <span class="number">1</span>), b[:, <span class="number">0</span>])</span><br><span class="line">    ih = torch.min(torch.unsqueeze(a[:, <span class="number">3</span>], dim=<span class="number">1</span>), b[:, <span class="number">3</span>]) -\</span><br><span class="line">    torch.max(torch.unsqueeze(a[:, <span class="number">1</span>], <span class="number">1</span>), b[:, <span class="number">1</span>])</span><br><span class="line">    iw = torch.clamp(iw, min=<span class="number">0</span>)</span><br><span class="line">    ih = torch.clamp(ih, min=<span class="number">0</span>)</span><br><span class="line">    ua = torch.unsqueeze((a[:, <span class="number">2</span>] - a[:, <span class="number">0</span>]) * (a[:, <span class="number">3</span>] - a[:, <span class="number">1</span>]), dim=<span class="number">1</span>) + area - iw * ih</span><br><span class="line">    ua = torch.clamp(ua, min=<span class="number">1e-8</span>)</span><br><span class="line">    intersection = iw * ih</span><br><span class="line">    IoU = intersection / ua</span><br><span class="line">    <span class="keyword">return</span> IoU</span><br></pre></td></tr></table></figure><p>focalLoss主要对每一个anchor进入classification的分类结果，focalLoss的原理如下：</p><p><img src="/images/focal-loss.png" alt=""></p><p>整个网络的loss其实由两部分组成，一部分是分类loss，一部分是回归loss。分类loss即focal loss，回归部分的loss为边框回归的loss。实现代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FocalLoss</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="comment">#def __init__(self):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, classifications, regressions, anchors, annotations)</span>:</span></span><br><span class="line">        alpha = <span class="number">0.25</span></span><br><span class="line">        gamma = <span class="number">2.0</span></span><br><span class="line">        batch_size = classifications.shape[<span class="number">0</span>]</span><br><span class="line">        classification_losses = []</span><br><span class="line">        regression_losses = []</span><br><span class="line"></span><br><span class="line">        anchor = anchors[<span class="number">0</span>, :, :]</span><br><span class="line"></span><br><span class="line">        anchor_widths  = anchor[:, <span class="number">2</span>] - anchor[:, <span class="number">0</span>]</span><br><span class="line">        anchor_heights = anchor[:, <span class="number">3</span>] - anchor[:, <span class="number">1</span>]</span><br><span class="line">        anchor_ctr_x   = anchor[:, <span class="number">0</span>] + <span class="number">0.5</span> * anchor_widths</span><br><span class="line">        anchor_ctr_y   = anchor[:, <span class="number">1</span>] + <span class="number">0.5</span> * anchor_heights</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(batch_size):</span><br><span class="line"></span><br><span class="line">            classification = classifications[j, :, :]</span><br><span class="line">            regression = regressions[j, :, :]</span><br><span class="line"></span><br><span class="line">            bbox_annotation = annotations[j, :, :]</span><br><span class="line">            bbox_annotation = bbox_annotation[bbox_annotation[:, <span class="number">4</span>] != <span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> bbox_annotation.shape[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                regression_losses.append(torch.tensor(<span class="number">0</span>).float().cuda())</span><br><span class="line">                classification_losses.append(torch.tensor(<span class="number">0</span>).float().cuda())</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            classification = torch.clamp(classification, <span class="number">1e-4</span>, <span class="number">1.0</span> - <span class="number">1e-4</span>)</span><br><span class="line"></span><br><span class="line">            IoU = calc_iou(anchors[<span class="number">0</span>, :, :], bbox_annotation[:, :<span class="number">4</span>]) <span class="comment"># num_anchors x num_annotations</span></span><br><span class="line"></span><br><span class="line">            IoU_max, IoU_argmax = torch.max(IoU, dim=<span class="number">1</span>) <span class="comment"># num_anchors x 1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#import pdb</span></span><br><span class="line">            <span class="comment">#pdb.set_trace()</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># compute the loss for classification</span></span><br><span class="line">            <span class="comment"># target 的维度为类别的个数</span></span><br><span class="line">            targets = torch.ones(classification.shape) * <span class="number">-1</span></span><br><span class="line">            targets = targets.cuda()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># lt : less than 如果IoU_max的面积小于0.4，那么就认为没有匹配上</span></span><br><span class="line">            targets[torch.lt(IoU_max, <span class="number">0.4</span>), :] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            positive_indices = torch.ge(IoU_max, <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">            num_positive_anchors = positive_indices.sum()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># IoU_argmax记录着当前的anchor与哪一个GT比较匹配</span></span><br><span class="line">            <span class="comment"># 下面这个赋值语句就是给对应的anchor选择一个GT</span></span><br><span class="line">            <span class="comment"># 第一个参数选择候选的anchor，第二个参数将候选anchor的坐标值都取到</span></span><br><span class="line">            assigned_annotations = bbox_annotation[IoU_argmax, :]</span><br><span class="line"></span><br><span class="line">            targets[positive_indices, :] = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 下面一句表明对每个满足IoU条件的anchor，赋予一个类别。形成一个one hot编码（原先target的维度长度等于类别的个数）</span></span><br><span class="line">            targets[positive_indices, assigned_annotations[positive_indices, <span class="number">4</span>].long()] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            alpha_factor = torch.ones(targets.shape).cuda() * alpha</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            alpha_factor = torch.where(torch.eq(targets, <span class="number">1.</span>), alpha_factor, <span class="number">1.</span> - alpha_factor)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 对focal weight进行统一的计算，然后赋值</span></span><br><span class="line">            focal_weight = torch.where(torch.eq(targets, <span class="number">1.</span>), <span class="number">1.</span> - classification, classification)</span><br><span class="line">            focal_weight = alpha_factor * torch.pow(focal_weight, gamma)</span><br><span class="line">            <span class="comment">#      当y=1,即只有targets=1参与计算              当y=0，即只有targets=0参与</span></span><br><span class="line">            bce = -(targets * torch.log(classification) + (<span class="number">1.0</span> - targets) * torch.log(<span class="number">1.0</span> - classification))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># cls_loss = focal_weight * torch.pow(bce, gamma)</span></span><br><span class="line">            cls_loss = focal_weight * bce</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 注意对target的处理，当IoU在【0.4，0.5】之间时target=-1，不提供loss，其他情况均赋予一个cls_loss</span></span><br><span class="line">            cls_loss = torch.where(torch.ne(targets, <span class="number">-1.0</span>), cls_loss, torch.zeros(cls_loss.shape).cuda())</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 计算所有的loss在正例中的平均值</span></span><br><span class="line">            classification_losses.append(cls_loss.sum()/torch.clamp(num_positive_anchors.float(), min=<span class="number">1.0</span>))</span><br><span class="line"></span><br><span class="line">            <span class="comment"># compute the loss for regression</span></span><br><span class="line">            <span class="comment">#只有预测为正例的部分参与边框的回归，下面一部分为回归loss。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> positive_indices.sum() &gt; <span class="number">0</span>:</span><br><span class="line">                assigned_annotations = assigned_annotations[positive_indices, :]</span><br><span class="line"></span><br><span class="line">                anchor_widths_pi = anchor_widths[positive_indices]</span><br><span class="line">                anchor_heights_pi = anchor_heights[positive_indices]</span><br><span class="line">                anchor_ctr_x_pi = anchor_ctr_x[positive_indices]</span><br><span class="line">                anchor_ctr_y_pi = anchor_ctr_y[positive_indices]</span><br><span class="line"></span><br><span class="line">                gt_widths  = assigned_annotations[:, <span class="number">2</span>] - assigned_annotations[:, <span class="number">0</span>]</span><br><span class="line">                gt_heights = assigned_annotations[:, <span class="number">3</span>] - assigned_annotations[:, <span class="number">1</span>]</span><br><span class="line">                gt_ctr_x   = assigned_annotations[:, <span class="number">0</span>] + <span class="number">0.5</span> * gt_widths</span><br><span class="line">                gt_ctr_y   = assigned_annotations[:, <span class="number">1</span>] + <span class="number">0.5</span> * gt_heights</span><br><span class="line"></span><br><span class="line">                <span class="comment"># clip widths to 1</span></span><br><span class="line">                gt_widths  = torch.clamp(gt_widths, min=<span class="number">1</span>)</span><br><span class="line">                gt_heights = torch.clamp(gt_heights, min=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">                targets_dx = (gt_ctr_x - anchor_ctr_x_pi) / anchor_widths_pi</span><br><span class="line">                targets_dy = (gt_ctr_y - anchor_ctr_y_pi) / anchor_heights_pi</span><br><span class="line">                targets_dw = torch.log(gt_widths / anchor_widths_pi)</span><br><span class="line">                targets_dh = torch.log(gt_heights / anchor_heights_pi)</span><br><span class="line"></span><br><span class="line">                targets = torch.stack((targets_dx, targets_dy, targets_dw, targets_dh))</span><br><span class="line">                targets = targets.t()</span><br><span class="line"></span><br><span class="line">                targets = targets/torch.Tensor([[<span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.2</span>]]).cuda()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                negative_indices = <span class="number">1</span> - positive_indices</span><br><span class="line"></span><br><span class="line">                regression_diff = torch.abs(targets - regression[positive_indices, :])</span><br><span class="line"></span><br><span class="line">                regression_loss = torch.where(</span><br><span class="line">                    torch.le(regression_diff, <span class="number">1.0</span> / <span class="number">9.0</span>),</span><br><span class="line">                    <span class="number">0.5</span> * <span class="number">9.0</span> * torch.pow(regression_diff, <span class="number">2</span>),</span><br><span class="line">                    regression_diff - <span class="number">0.5</span> / <span class="number">9.0</span></span><br><span class="line">                )</span><br><span class="line">                regression_losses.append(regression_loss.mean())</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                regression_losses.append(torch.tensor(<span class="number">0</span>).float().cuda())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> torch.stack(classification_losses).mean(dim=<span class="number">0</span>, keepdim=<span class="keyword">True</span>), torch.stack(regression_losses).mean(dim=<span class="number">0</span>, keepdim=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>边框回归部分学习一个边框的平移以及缩放关系：</p><p><img src="/images/box-regress.png" alt=""></p><p>最终将得到的分类loss以及regression loss的平均值整合成一个stack，返回下一步。</p><p>几个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">torch.cat(a,b) <span class="comment">#水平方向将a与b进行拼接</span></span><br><span class="line">torch.clamp(a,min_val,max_val) <span class="comment"># 将a中的值控制在min_val与max_val之间，小于取min_val，大于取max_val</span></span><br><span class="line">max_val, max_index = torch.max(a,dim = <span class="number">1</span>) <span class="comment"># 返回每一列最大值以及每一列的最大值的索引</span></span><br><span class="line">torch.lt(a,<span class="number">0.4</span>) <span class="comment"># 返回a中值小于0.4的元素的下标，ge均类似</span></span><br><span class="line">torch.where(condition,true_val,false_val) <span class="comment"># 如果满足条件者该位置为true_val,否则为false_val,其中参数的维度均相同（比如都为三维）</span></span><br></pre></td></tr></table></figure><h3 id="训练阶段"><a href="#训练阶段" class="headerlink" title="训练阶段"></a>训练阶段</h3><p>训练部分有几个需要完成的工作：</p><ol><li>初始化网络，设置优化器等等</li><li>将数据从dataloader中取出来</li><li>将数据输入网络中，得到网络的loss值</li><li>对loss进行反向传播，一些操作如learning rate的降低，梯度的裁剪可以在其中完成</li><li>打印出每个batch训练的结果</li><li>当训练次数到达一定的epoch时，对网络进行evaluate</li><li>保存mAP较高的网络</li></ol><p>下面通过代码来解读：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将训练过程迁移到gpu上</span></span><br><span class="line"> use_gpu = <span class="keyword">True</span></span><br><span class="line"><span class="keyword">if</span> use_gpu:</span><br><span class="line">retinanet = retinanet.cuda()</span><br><span class="line">retinanet = torch.nn.DataParallel(retinanet).cuda()</span><br><span class="line">retinanet.training = <span class="keyword">True</span></span><br><span class="line"> <span class="comment"># 设置优化器为adam</span></span><br><span class="line">optimizer = optim.Adam(retinanet.parameters(), lr=<span class="number">1e-5</span>)</span><br><span class="line"> <span class="comment"># ；learning rate的缩减器</span></span><br><span class="line">scheduler = optim.lr_scheduler.ReduceLROnPlateau(optimizer, patience=<span class="number">3</span>, verbose=<span class="keyword">True</span>)</span><br><span class="line">loss_hist = collections.deque(maxlen=<span class="number">500</span>) <span class="comment"># 实现了两端的快速添加删除</span></span><br><span class="line">retinanet.train()</span><br><span class="line">retinanet.module.freeze_bn()</span><br><span class="line">print(<span class="string">'Num training images: &#123;&#125;'</span>.format(len(dataset_train)))</span><br><span class="line"><span class="comment"># 从dataloader中取数据</span></span><br><span class="line"> <span class="keyword">for</span> epoch_num <span class="keyword">in</span> range(parser.epochs):</span><br><span class="line">retinanet.train()</span><br><span class="line">retinanet.module.freeze_bn()</span><br><span class="line">epoch_loss = []</span><br><span class="line"><span class="keyword">for</span> iter_num, data <span class="keyword">in</span> enumerate(dataloader_train):</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">       <span class="comment"># 清空梯度，由于pytorch在每次backward的时候，</span></span><br><span class="line">       <span class="comment"># 会进行梯度的累积，这样的做法方便训练RNN模型</span></span><br><span class="line">       <span class="comment"># 但是在训练普通模型的时候，需要将累积的梯度清空。</span></span><br><span class="line">       <span class="comment"># 清空后做backward梯度方向有利于梯度的整体下降</span></span><br><span class="line">optimizer.zero_grad()</span><br><span class="line">       <span class="comment"># 将数据传入网络中，得到loss</span></span><br><span class="line">classification_loss, regression_loss = retinanet([data[<span class="string">'img'</span>].cuda().float(), data[<span class="string">'annot'</span>]])</span><br><span class="line">classification_loss = classification_loss.mean()</span><br><span class="line">regression_loss = regression_loss.mean()</span><br><span class="line">loss = classification_loss + regression_loss</span><br><span class="line"><span class="keyword">if</span> bool(loss == <span class="number">0</span>):</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">       <span class="comment"># 误差的反向传播</span></span><br><span class="line">loss.backward()</span><br><span class="line">       <span class="comment"># 梯度裁剪函数,第二个参数表明允许最大的梯度为0.1</span></span><br><span class="line">torch.nn.utils.clip_grad_norm_(retinanet.parameters(), <span class="number">0.1</span>)</span><br><span class="line">optimizer.step()</span><br><span class="line">loss_hist.append(float(loss))</span><br><span class="line">epoch_loss.append(float(loss))</span><br><span class="line">print(<span class="string">'Epoch: &#123;&#125; | Iteration: &#123;&#125; | Classification loss: &#123;:1.5f&#125; | Regression loss: &#123;:1.5f&#125; | Running loss: &#123;:1.5f&#125;'</span>.format(epoch_num, iter_num, float(classification_loss), float(regression_loss), np.mean(loss_hist)))</span><br><span class="line"><span class="keyword">del</span> classification_loss</span><br><span class="line"><span class="keyword">del</span> regression_loss</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">print(e)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">if</span> parser.dataset == <span class="string">'coco'</span>:</span><br><span class="line">print(<span class="string">'Evaluating dataset'</span>)</span><br><span class="line">     <span class="comment"># 验证集验证模型的有效性</span></span><br><span class="line">coco_eval.evaluate_coco(dataset_val, retinanet)</span><br><span class="line"><span class="keyword">elif</span> parser.dataset == <span class="string">'csv'</span> <span class="keyword">and</span> parser.csv_val <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">print(<span class="string">'Evaluating dataset'</span>)</span><br><span class="line">mAP = csv_eval.evaluate(dataset_val, retinanet)</span><br><span class="line">scheduler.step(np.mean(epoch_loss))</span><br><span class="line">   <span class="comment"># 保存训练好的模型</span></span><br><span class="line">torch.save(retinanet.module, <span class="string">'&#123;&#125;_retinanet_&#123;&#125;.pt'</span>.format(parser.dataset, epoch_num))</span><br><span class="line"> retinanet.eval()</span><br><span class="line">torch.save(retinanet, <span class="string">'model_final.pt'</span>.format(epoch_num))</span><br></pre></td></tr></table></figure><p>需要注意的点：</p><p>在网络进行训练或验证时，通常先进行一次：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model.train()</span><br><span class="line"><span class="comment"># or evaluate</span></span><br><span class="line">model.eval()</span><br></pre></td></tr></table></figure><p>这样的目的是模型在train和eval的时候，需要执行的操作是不一样的。例如batchNorm和Dropout在eval的时候是不需要执行的。因此需要提前对网络进行设置。</p><h3 id="eval-验证"><a href="#eval-验证" class="headerlink" title="eval 验证"></a>eval 验证</h3><p>eval作为验证网络的性能，被安排在网络执行的最后，在每个batch结束，或者达到设定的epoch的时候，对网络进行测试。并以此为依据，是否对网络进行存储。</p><p>eval部分常用的指标是mAP，该指标通过计算recall以及precision的值来得到最终的结果。首先得到网络的eval的结果，然后从标注数据中得到anno的结果，进行mAP的计算。</p><p>得到网络的结果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_detections</span><span class="params">(dataset, retinanet, score_threshold=<span class="number">0.05</span>, max_detections=<span class="number">100</span>, save_path=None)</span>:</span></span><br><span class="line">    <span class="string">""" Get the detections from the retinanet using the generator.</span></span><br><span class="line"><span class="string">    The result is a list of lists such that the size is:</span></span><br><span class="line"><span class="string">        all_detections[num_images][num_classes] = detections[num_detections, 4 + num_classes]</span></span><br><span class="line"><span class="string">    # Arguments</span></span><br><span class="line"><span class="string">        dataset         : The generator used to run images through the retinanet.</span></span><br><span class="line"><span class="string">        retinanet           : The retinanet to run on the images.</span></span><br><span class="line"><span class="string">        score_threshold : The score confidence threshold to use.</span></span><br><span class="line"><span class="string">        max_detections  : The maximum number of detections to use per image.</span></span><br><span class="line"><span class="string">        save_path       : The path to save the images with visualized detections to.</span></span><br><span class="line"><span class="string">    # Returns</span></span><br><span class="line"><span class="string">        A list of lists containing the detections for each image in the generator.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    all_detections = [[<span class="keyword">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(dataset.num_classes())] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(dataset))]</span><br><span class="line">    retinanet.eval()</span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(len(dataset)):</span><br><span class="line">            data = dataset[index]</span><br><span class="line">            scale = data[<span class="string">'scale'</span>]</span><br><span class="line">            <span class="comment"># run network</span></span><br><span class="line">            scores, labels, boxes = retinanet(data[<span class="string">'img'</span>].permute(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>).cuda().float().unsqueeze(dim=<span class="number">0</span>))</span><br><span class="line">            scores = scores.cpu().numpy()</span><br><span class="line">            labels = labels.cpu().numpy()</span><br><span class="line">            boxes  = boxes.cpu().numpy()</span><br><span class="line">            <span class="comment"># correct boxes for image scale</span></span><br><span class="line">            boxes /= scale</span><br><span class="line">            <span class="comment"># select indices which have a score above the threshold</span></span><br><span class="line">            indices = np.where(scores &gt; score_threshold)[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">if</span> indices.shape[<span class="number">0</span>] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># select those scores</span></span><br><span class="line">                scores = scores[indices]</span><br><span class="line">                <span class="comment"># find the order with which to sort the scores</span></span><br><span class="line">                <span class="comment"># 得到score从大到小的下标，然后选择其中的max_detections那么多个</span></span><br><span class="line">                scores_sort = np.argsort(-scores)[:max_detections]</span><br><span class="line">                <span class="comment"># select detections score从大到小</span></span><br><span class="line">                image_boxes      = boxes[indices[scores_sort], :]</span><br><span class="line">                image_scores     = scores[scores_sort]</span><br><span class="line">                image_labels     = labels[indices[scores_sort]]</span><br><span class="line">                image_detections = np.concatenate([image_boxes, np.expand_dims(image_scores, axis=<span class="number">1</span>), np.expand_dims(image_labels, axis=<span class="number">1</span>)], axis=<span class="number">1</span>)</span><br><span class="line">                <span class="comment"># copy detections to all_detections</span></span><br><span class="line">                <span class="keyword">for</span> label <span class="keyword">in</span> range(dataset.num_classes()):</span><br><span class="line">                    <span class="comment"># 每一张图片均表示成一个index，对所有的label都遍历一边，每个label保存若干个anchor,没有的话则不保存</span></span><br><span class="line">                    all_detections[index][label] = image_detections[image_detections[:, <span class="number">-1</span>] == label, :<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># copy detections to all_detections</span></span><br><span class="line">                <span class="keyword">for</span> label <span class="keyword">in</span> range(dataset.num_classes()):</span><br><span class="line">                    all_detections[index][label] = np.zeros((<span class="number">0</span>, <span class="number">5</span>))</span><br><span class="line">            print(<span class="string">'&#123;&#125;/&#123;&#125;'</span>.format(index + <span class="number">1</span>, len(dataset)), end=<span class="string">'\r'</span>)</span><br><span class="line">    <span class="keyword">return</span> all_detections</span><br></pre></td></tr></table></figure><p>从标注文件中读取图片的标注信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_annotations</span><span class="params">(generator)</span>:</span></span><br><span class="line">    <span class="string">""" Get the ground truth annotations from the generator.</span></span><br><span class="line"><span class="string">    The result is a list of lists such that the size is:</span></span><br><span class="line"><span class="string">        all_detections[num_images][num_classes] = annotations[num_detections, 5]</span></span><br><span class="line"><span class="string">    # Arguments</span></span><br><span class="line"><span class="string">        generator : The generator used to retrieve ground truth annotations.</span></span><br><span class="line"><span class="string">    # Returns</span></span><br><span class="line"><span class="string">        A list of lists containing the annotations for each image in the generator.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    all_annotations = [[<span class="keyword">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(generator.num_classes())] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(generator))]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(generator)):</span><br><span class="line">        <span class="comment"># load the annotations</span></span><br><span class="line">        annotations = generator.load_annotations(i)</span><br><span class="line">        <span class="comment"># copy detections to all_annotations</span></span><br><span class="line">        <span class="keyword">for</span> label <span class="keyword">in</span> range(generator.num_classes()):</span><br><span class="line">            all_annotations[i][label] = annotations[annotations[:, <span class="number">4</span>] == label, :<span class="number">4</span>].copy()</span><br><span class="line">        print(<span class="string">'&#123;&#125;/&#123;&#125;'</span>.format(i + <span class="number">1</span>, len(generator)), end=<span class="string">'\r'</span>)</span><br><span class="line">    <span class="keyword">return</span> all_annotations</span><br></pre></td></tr></table></figure><p>得到标注数据之后，开始计算mAP指标，mAP指标由recall（判断正确的占所有正确类别的百分比），precision（判断正确的占预测结果中认为正确的百分比）。通过对这两个指数的积分来计算最终的mAP结果。</p><p>recall = TP/(TP + FN) 即真正预测对的，占所有正类的比例</p><p>precision = TP/(TP + FN) 即真正预测对的，占预测结果为正的比例</p><p>TP,FP,TN,FN这几个指标第一个字母表示预测是不是对的，第二个字母表示，预测的内容是什么（正类或者负类）。关于mAP的计算可以看： <a href="https://perper.site/2019/03/22/手撕mAP/" target="_blank" rel="noopener">这里</a></p><p>下面代码计算mAP的内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_overlap</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    a: (N, 4) ndarray of float</span></span><br><span class="line"><span class="string">    b: (K, 4) ndarray of float</span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    overlaps: (N, K) ndarray of overlap between boxes and query_boxes</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    area = (b[:, <span class="number">2</span>] - b[:, <span class="number">0</span>]) * (b[:, <span class="number">3</span>] - b[:, <span class="number">1</span>])</span><br><span class="line">    iw = np.minimum(np.expand_dims(a[:, <span class="number">2</span>], axis=<span class="number">1</span>), b[:, <span class="number">2</span>]) - np.maximum(np.expand_dims(a[:, <span class="number">0</span>], <span class="number">1</span>), b[:, <span class="number">0</span>])</span><br><span class="line">    ih = np.minimum(np.expand_dims(a[:, <span class="number">3</span>], axis=<span class="number">1</span>), b[:, <span class="number">3</span>]) - np.maximum(np.expand_dims(a[:, <span class="number">1</span>], <span class="number">1</span>), b[:, <span class="number">1</span>])</span><br><span class="line">    iw = np.maximum(iw, <span class="number">0</span>)</span><br><span class="line">    ih = np.maximum(ih, <span class="number">0</span>)</span><br><span class="line">    ua = np.expand_dims((a[:, <span class="number">2</span>] - a[:, <span class="number">0</span>]) * (a[:, <span class="number">3</span>] - a[:, <span class="number">1</span>]), axis=<span class="number">1</span>) + area - iw * ih</span><br><span class="line">    ua = np.maximum(ua, np.finfo(float).eps)</span><br><span class="line">    intersection = iw * ih</span><br><span class="line">    <span class="keyword">return</span> intersection / ua</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_compute_ap</span><span class="params">(recall, precision)</span>:</span></span><br><span class="line">    <span class="string">""" Compute the average precision, given the recall and precision curves.</span></span><br><span class="line"><span class="string">    Code originally from https://github.com/rbgirshick/py-faster-rcnn.</span></span><br><span class="line"><span class="string">    # Arguments</span></span><br><span class="line"><span class="string">        recall:    The recall curve (list).</span></span><br><span class="line"><span class="string">        precision: The precision curve (list).</span></span><br><span class="line"><span class="string">    # Returns</span></span><br><span class="line"><span class="string">        The average precision as computed in py-faster-rcnn.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># correct AP calculation</span></span><br><span class="line">    <span class="comment"># first append sentinel values at the end</span></span><br><span class="line">    mrec = np.concatenate(([<span class="number">0.</span>], recall, [<span class="number">1.</span>]))</span><br><span class="line">    mpre = np.concatenate(([<span class="number">0.</span>], precision, [<span class="number">0.</span>]))</span><br><span class="line">    <span class="comment"># compute the precision envelope</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(mpre.size - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        mpre[i - <span class="number">1</span>] = np.maximum(mpre[i - <span class="number">1</span>], mpre[i])</span><br><span class="line">    <span class="comment"># to calculate area under PR curve, look for points</span></span><br><span class="line">    <span class="comment"># where X axis (recall) changes value</span></span><br><span class="line">    i = np.where(mrec[<span class="number">1</span>:] != mrec[:<span class="number">-1</span>])[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># and sum (\Delta recall) * prec</span></span><br><span class="line">    ap = np.sum((mrec[i + <span class="number">1</span>] - mrec[i]) * mpre[i + <span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> ap</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    generator,</span></span></span><br><span class="line"><span class="function"><span class="params">    retinanet,</span></span></span><br><span class="line"><span class="function"><span class="params">    iou_threshold=<span class="number">0.5</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    score_threshold=<span class="number">0.05</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    max_detections=<span class="number">100</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    save_path=None</span></span></span><br><span class="line"><span class="function"><span class="params">)</span>:</span></span><br><span class="line">    <span class="string">""" Evaluate a given dataset using a given retinanet.</span></span><br><span class="line"><span class="string">    # Arguments</span></span><br><span class="line"><span class="string">        generator       : The generator that represents the dataset to evaluate.</span></span><br><span class="line"><span class="string">        retinanet           : The retinanet to evaluate.</span></span><br><span class="line"><span class="string">        iou_threshold   : The threshold used to consider when a detection is positive or negative.</span></span><br><span class="line"><span class="string">        score_threshold : The score confidence threshold to use for detections.</span></span><br><span class="line"><span class="string">        max_detections  : The maximum number of detections to use per image.</span></span><br><span class="line"><span class="string">        save_path       : The path to save images with visualized detections to.</span></span><br><span class="line"><span class="string">    # Returns</span></span><br><span class="line"><span class="string">        A dict mapping class names to mAP scores.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># gather all detections and annotations</span></span><br><span class="line">    all_detections     = _get_detections(generator, retinanet, score_threshold=score_threshold, max_detections=max_detections, save_path=save_path)</span><br><span class="line">    all_annotations    = _get_annotations(generator)</span><br><span class="line">    average_precisions = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> label <span class="keyword">in</span> range(generator.num_classes()):</span><br><span class="line">        false_positives = np.zeros((<span class="number">0</span>,))</span><br><span class="line">        true_positives  = np.zeros((<span class="number">0</span>,))</span><br><span class="line">        scores          = np.zeros((<span class="number">0</span>,))</span><br><span class="line">        num_annotations = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(generator)):</span><br><span class="line">            detections           = all_detections[i][label]</span><br><span class="line">            annotations          = all_annotations[i][label]</span><br><span class="line">            num_annotations     += annotations.shape[<span class="number">0</span>]</span><br><span class="line">            detected_annotations = []</span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> detections:</span><br><span class="line">                scores = np.append(scores, d[<span class="number">4</span>])</span><br><span class="line">                <span class="keyword">if</span> annotations.shape[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                    <span class="comment"># 表示当前图片没有标注，因此你的标注结果都是错误的</span></span><br><span class="line">                    false_positives = np.append(false_positives, <span class="number">1</span>)</span><br><span class="line">                    true_positives  = np.append(true_positives, <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                overlaps            = compute_overlap(np.expand_dims(d, axis=<span class="number">0</span>), annotations)</span><br><span class="line">                assigned_annotation = np.argmax(overlaps, axis=<span class="number">1</span>) <span class="comment"># 对每个框找出覆盖最多的一个标注,返回标注所在的下标</span></span><br><span class="line">                max_overlap         = overlaps[<span class="number">0</span>, assigned_annotation]</span><br><span class="line">                <span class="keyword">if</span> max_overlap &gt;= iou_threshold <span class="keyword">and</span> assigned_annotation <span class="keyword">not</span> <span class="keyword">in</span> detected_annotations:</span><br><span class="line">                    false_positives = np.append(false_positives, <span class="number">0</span>)</span><br><span class="line">                    true_positives  = np.append(true_positives, <span class="number">1</span>)</span><br><span class="line">                    detected_annotations.append(assigned_annotation)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    false_positives = np.append(false_positives, <span class="number">1</span>)</span><br><span class="line">                    true_positives  = np.append(true_positives, <span class="number">0</span>)</span><br><span class="line">        <span class="comment"># no annotations -&gt; AP for this class is 0 (is this correct?)</span></span><br><span class="line">        <span class="keyword">if</span> num_annotations == <span class="number">0</span>:</span><br><span class="line">            average_precisions[label] = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># sort by score</span></span><br><span class="line">        indices         = np.argsort(-scores)</span><br><span class="line">        false_positives = false_positives[indices]</span><br><span class="line">        true_positives  = true_positives[indices]</span><br><span class="line">        <span class="comment"># compute false positives and true positives</span></span><br><span class="line">        <span class="comment"># 得到一个累加的数组的结果</span></span><br><span class="line">        false_positives = np.cumsum(false_positives)</span><br><span class="line">        true_positives  = np.cumsum(true_positives)</span><br><span class="line">        <span class="comment"># compute recall and precision</span></span><br><span class="line">        recall    = true_positives / num_annotations</span><br><span class="line">        precision = true_positives / np.maximum(true_positives + false_positives, np.finfo(np.float64).eps)</span><br><span class="line">        <span class="comment"># compute average precision</span></span><br><span class="line">        average_precision  = _compute_ap(recall, precision)</span><br><span class="line">        average_precisions[label] = average_precision, num_annotations</span><br><span class="line">    print(<span class="string">'\nmAP:'</span>)</span><br><span class="line">    <span class="keyword">for</span> label <span class="keyword">in</span> range(generator.num_classes()):</span><br><span class="line">        label_name = generator.label_to_name(label)</span><br><span class="line">        print(<span class="string">'&#123;&#125;: &#123;&#125;'</span>.format(label_name, average_precisions[label][<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">return</span> average_precisions</span><br></pre></td></tr></table></figure><p>几个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.argsort(scores) <span class="comment"># 根据从小到大返回元素的下标，小的在前</span></span><br><span class="line">np.argmax(overlaps,axis = <span class="number">1</span>) <span class="comment"># 找出每一列的最大值，返回他的下标</span></span><br><span class="line">np.cumsum(nums) <span class="comment"># 返回一个数组，数组中内容从头开始累加到当前位置</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过上面几个流程我们大致梳理了一下一个网络的搭建，数据的传递，loss的计算，以及最后的验证的过程。</p><p>总结一下：</p><ol><li>构造dataloader，在这里头完成数据的读取，增强等工作</li><li>完成网络的搭建</li><li>完成网络的训练</li><li>完成验证集的测试工作</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以pytorch为例，梳理一下深度学习中，数据的读取，神经网络的搭建，NMS，以及各个指标的计算流程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="深度学习" scheme="https://wenhui-zhou.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WenHuiZhou</title>
  
  <subtitle>perper（打起精神！）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wenhui-zhou.github.io/"/>
  <updated>2019-12-01T16:17:27.648Z</updated>
  <id>https://wenhui-zhou.github.io/</id>
  
  <author>
    <name>WenHuiZhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NLP模型finetune:GPT到Bert（三）</title>
    <link href="https://wenhui-zhou.github.io/2019/12/01/NLP%E6%A8%A1%E5%9E%8Bfinetune-GPT%E5%88%B0Bert%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://wenhui-zhou.github.io/2019/12/01/NLP模型finetune-GPT到Bert（三）/</id>
    <published>2019-12-01T06:24:31.000Z</published>
    <updated>2019-12-01T16:17:27.648Z</updated>
    
    <content type="html"><![CDATA[<p>NLP模型的预训练方式有ELMO的方式，基于特征的融合，通过学习句子的上下文语境来判断句子中多义词的含义，解决多义词歧义的问题，从而提升模型的性能。</p><p>另一种更类似于图像领域的预训练方式为fine tuning模式，该模式有一个代表，即GPT网络。</p><a id="more"></a><h3 id="word-embedding-to-GPT"><a href="#word-embedding-to-GPT" class="headerlink" title="word embedding to GPT"></a>word embedding to GPT</h3><p>GPT的网络结果如下：</p><p><img src="/images/nlp/gpt1.jpg" style="zoom:80%;"></p><p>GPT是Generative Pre-Training的简称，模型分为两个部分，第一个阶段利用语言模型进行预训练，第二个阶段利用fine tune解决下游的任务。上图的预训练过程与ELMO类似，也是分为两个阶段，下面回顾一下ELMO：</p><p><img src="/images/nlp/gpt2.jpg" style="zoom:80%;"></p><p>ELMO利用语言模型得到一个不可区分多义词的word embedding，然后通过下游任务来微调这个word embedding使得其适应具体的语境。</p><p>GPT与ELMO的区别有两个：</p><ul><li>GPT使用transformer结果替代ELMO中的LSTM</li><li>GPT采用单向的语言模型，GPT仅利用到语言的上文信息，而ELMO则是双向模型（可以算一个 缺点）</li></ul><h3 id="使用GPT预训练参数"><a href="#使用GPT预训练参数" class="headerlink" title="使用GPT预训练参数"></a>使用GPT预训练参数</h3><p>GPT利用语言模型就是预训练之后，对不同的下游任务，设计网络结构，这个结构朝GPT看齐。这样在下游任务中，利用GPT的参数去初始化下游模型，然后根据具体数据来对网络 进行 fine tune，这个过程和cv领域的预训练模型一模一样。</p><p>接下来的 问题就转变为，如果将一个下有任务改造成类似GPT的 结构。</p><p>对于常见的任务，GPT的改造 如下：</p><p><img src="/images/nlp/gpt4.jpg" style="zoom:87%;"></p><p>对于GPT来说，一个值得改进的地方是他使用的单向的语言模型，因此在这之后，Bert就填补了这个遗憾。</p><h3 id="Bert"><a href="#Bert" class="headerlink" title="Bert"></a>Bert</h3><p><img src="/images/nlp/bert1.jpg" style="zoom:80%;"></p><p>bert借鉴了GPT中使用的transformer以及ELMO中使用的双向语言模型。使用过程同样分为两步，第一步训练双向语言模型进行参数的预训练。第二步根据具体的下游任务，改造为bert结构。</p><p>Bert的演化过程如下：</p><p><img src="/images/nlp/bert2.jpg" style="zoom:80%;"></p><p>transformer在做双向的时候，采用的是CBOW的方法，即将当前要预测的词扣掉，利用这个词的上下文来预测，具体做法 如下：</p><p>Masked双向语言模型：随机选择语料中15%的单词，把它抠掉，也就是用[Mask]掩码代替原始单词，然后要求模型去正确预测被抠掉的单词。但是这里有个问题：训练过程大量看到[mask]标记，但是真正后面用的时候是不会有这个标记的，这会引导模型认为输出是针对[mask]这个标记的，但是实际使用又见不到这个标记，这自然会有问题。为了避免这个问题，Bert改造了一下，15%的被上天选中要执行[mask]替身这项光荣任务的单词中，只有80%真正被替换成[mask]标记，10%被狸猫换太子随机替换成另外一个单词，10%情况这个单词还待在原地不做改动。这就是Masked双向语音模型的具体做法。</p><p>Bert在NLP的各大任务中均大方异彩，出现了一统江湖的趋势，成为NLP领域内的一个标杆工作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NLP模型的预训练方式有ELMO的方式，基于特征的融合，通过学习句子的上下文语境来判断句子中多义词的含义，解决多义词歧义的问题，从而提升模型的性能。&lt;/p&gt;
&lt;p&gt;另一种更类似于图像领域的预训练方式为fine tuning模式，该模式有一个代表，即GPT网络。&lt;/p&gt;
    
    </summary>
    
      <category term="NLP" scheme="https://wenhui-zhou.github.io/categories/NLP/"/>
    
    
  </entry>
  
  <entry>
    <title>NLP之transformer（二）</title>
    <link href="https://wenhui-zhou.github.io/2019/11/29/NLP%E4%B9%8Btransformer%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://wenhui-zhou.github.io/2019/11/29/NLP之transformer（二）/</id>
    <published>2019-11-29T12:53:17.000Z</published>
    <updated>2019-11-30T19:44:59.724Z</updated>
    
    <content type="html"><![CDATA[<p>NLP任务的输入往往是一句话或者是一篇文章，他有几个特点：</p><ul><li>输入是一个一维<strong>线性序列</strong></li><li>输入是<strong>不定长的</strong></li><li>输入单词的<strong>相对位置</strong>非常的重要</li><li>句子中的<strong>长特征</strong>对理解句子非常的重要（距离很远的词）</li></ul><p><strong>一个合格的特征抽取器应当很好的适配领域问题的特点，能够充分抽取数据中的特征。</strong></p><a id="more"></a><h3 id="NLP领域主要任务"><a href="#NLP领域主要任务" class="headerlink" title="NLP领域主要任务"></a>NLP领域主要任务</h3><p>该部分在上一篇文章中有简要提到，下面详细记录一下这些任务主要解决的问题：</p><ul><li>序列标注：这是NLP典型的任务，包括中文分词，词性标注，命名实体识别等等。<ul><li>特点：模型根据上下文给每个单词分配一个类别</li></ul></li><li>分类任务：常见有的文本分类和情感计算<ul><li>特点：不论文章多长，总体给出一个分类类别</li></ul></li><li>句子关系判断：问答系统，语义改写，自然语言推理<ul><li>特点：给出两个句子，判断这两个句子是否具有某种语义关系</li></ul></li><li>生成式任务：机器翻译，文本摘要，写诗造句，看图说话<ul><li>特点：输入文本后，需要自主生成另一段文字</li></ul></li></ul><p>从模型的角度来看，模型的特征抽取能力是至关重要的，下面开始详细介绍NLP的三个抽取器。</p><h3 id="久经沙场RNN"><a href="#久经沙场RNN" class="headerlink" title="久经沙场RNN"></a>久经沙场RNN</h3><p>RNN引入NLP之后，一直是一个明星模型，在各种模型中被广泛的应用。它采用线性序列结构不断从前往后收集输入信息。但是这种结构在反向传播过程中存在优化的困难。因为反向传播路径过长，导致严重的梯度消失或爆炸问题。于是很快建LSTM引入RNN作为标准模型中。</p><p><img src="/images/nlp/lstm.png" style="zoom:40%;"></p><p>下面是非常典型的使用RNN来解决NLP任务的基本框架：</p><p><img src="/images/nlp/rnn_frame.png" style="zoom:47%;"></p><p>RNN本身结构就是个可以接纳不定长输入的由前向后进行信息线性传导的网络结构，而在LSTM引入三个门后，对于捕获长距离特征也是非常有效的。所以RNN特别适合NLP这种线形序列应用场景，这是RNN在NLP界如此流行的根本原因。</p><p>但是对于RNN来说，来自一些新型的特征提取器的挑战，以及RNN并行能力差的问题，导致了它很可能被替代。</p><p><strong>RNN并性能力差的原因</strong>：RNNT时刻有两个输入，一个输入为当前的文本，另一个输入为T-1时刻隐藏层的输出S(T-1)，这是最能体现RNN的一点，RNN的历史信息就是通过这个传输渠道向后传的。因此T时刻计算依赖于T-1时刻的结果，因此网络必须按照时序的顺序一个一个往后走。</p><p>而CNN与transformers不存在这种问题，他们是天生的并行计算结构。</p><p>RNN在并行化上也做了一些工作，通常的做法有打断隐层的连接，或者打断部分的连接，层间并行。</p><h3 id="改造CNN"><a href="#改造CNN" class="headerlink" title="改造CNN"></a>改造CNN</h3><p>2014年CNN最早被引入NLP中：</p><p><img src="/images/nlp/kim_cnn.png" style="zoom:50%;"></p><p>每一行为一个单词的数值编码，卷积层将数值编码分割，在编码维度上移动，得到卷积后的特征，但仅仅在句子分类的任务上性能不错。</p><p>但是单个卷积层难以捕获远距离的特征，因此解决的方案<strong>有把卷积层做深；使用dilated 孔洞卷积。</strong>CNN能够捕获向量的位置信息，但是pooling结构通过会破坏掉这种顺序，因此通常使用全连接层替换掉pooling结构。</p><p>目前使用的比较多的CNN如下：</p><p><img src="/images/nlp/cnn.png" style="zoom:50%;"></p><p>上图是现代CNN的主体结构，通常由1-D的卷积层来叠加深度，使用skip-connection来辅助优化，也可以使用dilated等手段。CNN在nlp中的引入，能够保持数据间的时序信息，要设法将CNN的深度做起来。</p><h3 id="transformer结构"><a href="#transformer结构" class="headerlink" title="transformer结构"></a>transformer结构</h3><p>Transformer模型有很多好处，它改进了RNN最被人诟病的训练慢的缺点，利用self-attention机制实现快速并行。且Transformer可以增加到非常深的深度，充分发掘DNN模型的特性。下面具体的讲解一下transformer的机制。</p><p>下面通过引入一个NLP中经典问题的方式来解释这个结构：</p><blockquote><p>我们打算将英语翻译为西班牙语：</p><p><em>X = [‘Hello’, ‘,’, ‘how’, ‘are’, ‘you’, ‘?’] (Input sequence)</em><br><em>Y = [‘Hola’, ‘,’, ‘como’, ‘estas’, ‘?’] (Target sequence)</em></p></blockquote><p>transformer中encoder部分负责提取句子信息，decoder部分负责将encoder的输出与target相结合，得到接近target的翻译结果。</p><h3 id="transformer"><a href="#transformer" class="headerlink" title="transformer"></a>transformer</h3><p>transformer结构是一个由encoder，decoder，ski-connection，layerNorm，FF共同作用的一个结构，在数据特征提取上有着明显的优势。</p><p><img src="/images/nlp/transformer1.png" style="zoom:40%;"></p><p>编码和解码的部分分别都由六个编码器组件组合而成：</p><p><img src="/images/nlp/transformer2.png" style="zoom:30%;"></p><p>将encoder与decoder模块展开来看：</p><p><img src="/images/nlp/transformer4.png" style="zoom:43%;"></p><p>encoder部分由一个自注意力层和一个前向网络构成，其中自注意力层关注句子中的每一个单词对当前编码单词的关系。</p><p>decoder部分由三层构成，其中中间那一层，用来关注句子中的相关部分（和seq2seq类似）。</p><h3 id="decoder模块"><a href="#decoder模块" class="headerlink" title="decoder模块"></a>decoder模块</h3><p>decoder模块是对nlp数据提取特征的模块，将每一个编码器单元展开如下：</p><p><img src="/images/nlp/transformer3.png" style="zoom:50%;"></p><p><strong>数据流动</strong></p><ul><li>将单词转化成词向量（词向量的长度固定，BERT中为512），输入的维度：<strong>句子长度*词向量长度</strong></li><li>生成一个<strong>句子长度*词向量长度</strong>的位置编码信息，添加到输入中</li><li>输入数据经过N个encoder单元，生成<strong>句子长度*词向量长度</strong>大小的向量</li></ul><p>第一步对句子进行分词，将单词转化为词向量：</p><p><img src="/images/nlp/transformer5.png" style="zoom:53%;"></p><p>当我们训练一个batch的数据的时候，我们需要对一些较短的句子进行补充，通过在句首添加padding的方式，将句子长度对齐。</p><blockquote><p>[“<pad>”, “<pad>”, “<pad>”, “Hello”, “, “, “how”, “are”, “you”, “?”] →</pad></pad></pad></p><p>[5, 5, 5, 34, 90, 15, 684, 55, 193]</p></blockquote><p>第二步，对位置信息进行编码，然后将位置信息加入到输入当中，对位置信息进行编码采用以下的公式：</p><p><img src="/images/nlp/transformer6.png" style="zoom:73%;"></p><p>其中i表示y方向即每一个单词，j表示在词向量的长度（emb-dim）上的位置，因此最终得到下面的结果：</p><p><img src="/images/nlp/transformer7.png" style="zoom:45%;"></p><p>将输入与上面的位置编码相加，得到最终的输入数据。</p><p><strong>encoder block</strong></p><p>接下来进入encoder内部，编码器内部采用一层的自注意力层以及一个前向的全连接层。将数据输入编码器，首先遇到的是 <strong>multi-head attention</strong>结构。</p><p><strong>multi-head attention</strong>结构共同训练h次注意力层，这种做法能够扩展专注于不同位置的能力，同时给出了注意力层的多个表示子空间。</p><p>对于每一个head来说，我们训练三个向量，Q，K，V，与输入embedding向量相乘得到中间结果，用于最后计算每一个词最终的得分：</p><p><img src="/images/nlp/transformer8.png" style="zoom:70%;"></p><p>将上面的运算合并为矩阵运算，则算法如下：</p><p><img src="/images/nlp/transformer9.png" style="zoom:67%;"></p><p>利用上面的结果计算每个单词的得分：<br>$$<br>\begin{equation}<br>\text { Attention }(Q, K, V)=\operatorname{softmax}\left(\frac{Q K^{T}}{\sqrt{d_{k}}}\right) V<br>\end{equation}<br>$$<br><img src="/images/nlp/transformer10.png" style="zoom:67%;"></p><p>对于multi-head来说，我们将X输入h个head中，将会得到h个句子不同词之间的得分Z:</p><p><img src="/images/nlp/transformer11.png" style="zoom:67%;"></p><p>对于一个句子来说，我们只希望得到一组表示词语间的相互关系，于是我们将Z拼接起来，通过训练一个权重$W^0$使得最终得到一个 <strong>句子长度*词向量长度</strong>。</p><p><img src="/images/nlp/transformer12.png" style="zoom:60%;"></p><p>通过融合注意力机制的多头的结果，每个词与句子的其他成分之间的关系得到了充分的挖掘：</p><p><img src="/images/nlp/transformer13.png" style="zoom:70%;"></p><p>当我们计算出句子单词之间的注意力分布，下一步为添加残差后归一化：</p><p><img src="/images/nlp/transformer14.png" style="zoom:67%;"></p><p>完成残差之后是一个正向的全连接层（Free Forward），即一个两层的全连接层，第一层的激活函数为ReLU，第二层的激活函数为线性激活函数：<br>$$<br>\begin{equation}<br>\mathrm{FFN}(x)=\max \left(0, x W_{1}+b_{1}\right) W_{2}+b_{2}<br>\end{equation}<br>$$<br>其中W1位第一层，W2为第二层，max函数表示ReLU激活函数，b2为线性激活函数的偏移。最终的输出添加残差，归一化之后得到一个decoder的输出，随后将这个输出输入下一个decoder模块中，直到所有的模块都完成输出，将输出传至decoder模块。</p><h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><p>Decoder部分网络结构相比较于decoder部分，多出了一个encoder to decoder的模块，这个模块的的输入来自于decoder的输出：</p><p><img src="/images/nlp/transformer4.png" style="zoom:43%;"></p><p>encoder和decoder中信息传播如下：</p><p><img src="/images/nlp/transformer15.png" style="zoom:43%;"></p><p>每一个decoder模块都将接受encoder的输出。Decoder的一个单元具体结构如下：</p><p><img src="/images/nlp/transformer16.png" style="zoom:43%;"></p><p><strong>数据流动</strong></p><ul><li>首先将target进行分词，编码成词向量，维度为 <strong>target句子长度*词向量长度</strong></li><li>将第一步得到的数据输入N个Decoder模块中，在每次迭代过程中，接收decoder的输出作为一个额外的输入，最终得到的输出维度为 <strong>target句子长度*词向量的长度</strong></li><li>将decoder得到的输出，输入到一个全连接层，并且每一层做一个逐行的softmax，最终得到的输出是翻译的结果，即维度为<strong>句子长度*每个单词的长度</strong></li></ul><p><strong>输入</strong></p><p>由于input的句子长度和target的句子的长度不一致，因此首先对target句子分词后，进行偏移：</p><blockquote><p><em>[“Hola”, “, “, “como”, “estás”, “?”]→[“”, “Hola”, “, “, “como”, “estás”, “?”]</em></p></blockquote><p><strong>train vs test</strong></p><p>train阶段和test阶段对于decoder部分来说有一个重要的差别：</p><ul><li>在test阶段，我们不知道groundTruth，因此我们将会根据之前给出的单词来预测当前位置的单词，即无法使用当前位置之后的单词的信息。</li><li>在train阶段，我们知道GT，我们会直接告诉模型我们的target是什么，然后根据和test一样的顺序进行预测，但是这将会出现一个问题，<strong>模型可能根据target句子本身的位置关系来预测target，也就是使用了target的信息</strong>，这是不允许的，因为在实际情况中我们不可能提前知道target，因此这样的训练是不充分的。</li></ul><p>因此我们在Decoder的训练阶段必须消除target提供当前词之后的词所提供的信息。例如下面例子，当要预测estás的时候，我们就只能使用绿色部分所使用的信息，而红色部分的信息不能使用：</p><p><img src="/images/nlp/transformer17.png" style="zoom:63%;"></p><p>为了解决上面这个问题，我们提出了mask multi-head attention，即对output的数据进行处理。</p><p><strong>mask multi-head attention</strong></p><p>首先通过与encoder相同的操作，即multi-head attention得到一个 <strong>target句子长度*词向量</strong>的一个输出矩阵，<strong>然后进行mask操作，即将矩阵右上角的数值置为负无穷。</strong></p><p>原始multi head结果：</p><p><img src="/images/nlp/transformer18.png" style="zoom:73%;"></p><p>mask后的结果：</p><p><img src="/images/nlp/transformer19.png" style="zoom:73%;"></p><p>这就意味着当前单词的预测无法使用其后出现的单词信息。</p><p><strong>Encoder to decoder</strong></p><p>将上述的输出添加输入以及归一化之后，输入到下一层encoder to decoder，这一部分接受的输入由两部分组成，第一部分就是decoder的第一阶段的输出，另一个部分就是encoder最终的输出。</p><p>与decoder同样的操作，我们训练三个向量，Q，K，V，与输入embedding向量相乘得到中间结果，用于最后计算每一个词最终的得分，唯一的不同在于这三个向量使用的训练数据不同，如下图：</p><p><img src="/images/nlp/transformer20.png" style="zoom:73%;"></p><p><strong>即Q向量由decoder第一阶段的数据来训练，K，V由encoder最后输出的数据来训练。</strong></p><p>同样的利用与encoder相同的attention公式计算每一个词与句子中其他的成分的关系：<br>$$<br>\begin{equation}\text { Attention }(Q, K, V)=\operatorname{softmax}\left(\frac{Q K^{T}}{\sqrt{d_{k}}}\right) V\end{equation}<br>$$<br>接下来与encoder相同，训练h个head，然后组合在一起通过一个$W^0$矩阵进行组成得到输出，最后传入decoder模块的第三阶段，即全连接层进行前向的传播。</p><p><strong>linear and softmax</strong></p><p>重复上面decoder的基础模块N次，最后得到的输出的维度为 <strong>target句子长度*词向量长度</strong>，然后将这个向量输入一个linear全连接层中，全连接层输出的维度为翻译后句子的真实长度，其实际含义在对每一个词赋予一个权重：<br>$$<br>\begin{equation}<br>x W_{1}<br>\end{equation}<br>$$<br>最后，将上面的输出输入到softmax当中，计算出当前位置上，所有可能出现的翻译的结果的概率，然后根据最大的概率得到模型预测的翻译的结果：</p><p><img src="/images/nlp/transformer21.png" style="zoom:83%;"></p><p>根据第一行的结果，我们可以判断，ss对应的翻译是hello。</p><p>最后放一张encoder和decoder的合照，以便于回顾transformer的各种细节：</p><p><img src="/images/nlp/transformer22.png" style="zoom:43%;"></p><p>最最最后小彩蛋：</p><p><img src="/images/nlp/transformer23.png" style="zoom:43%;"></p><h3 id="inference"><a href="#inference" class="headerlink" title="inference"></a>inference</h3><ul><li><a href="https://medium.com/dissecting-bert/dissecting-bert-appendix-the-decoder-3b86f66b0e5f" target="_blank" rel="noopener">https://medium.com/dissecting-bert/dissecting-bert-appendix-the-decoder-3b86f66b0e5f</a></li><li><a href="https://jalammar.github.io/illustrated-transformer/" target="_blank" rel="noopener">https://jalammar.github.io/illustrated-transformer/</a></li><li><a href="https://zhuanlan.zhihu.com/p/54356280" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/54356280</a></li><li><a href="https://zhuanlan.zhihu.com/p/54743941" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/54743941</a></li><li><a href="https://medium.com/dissecting-bert/dissecting-bert-part-1-d3c3d495cdb3" target="_blank" rel="noopener">https://medium.com/dissecting-bert/dissecting-bert-part-1-d3c3d495cdb3</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NLP任务的输入往往是一句话或者是一篇文章，他有几个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入是一个一维&lt;strong&gt;线性序列&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;输入是&lt;strong&gt;不定长的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;输入单词的&lt;strong&gt;相对位置&lt;/strong&gt;非常的重要&lt;/li&gt;
&lt;li&gt;句子中的&lt;strong&gt;长特征&lt;/strong&gt;对理解句子非常的重要（距离很远的词）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;一个合格的特征抽取器应当很好的适配领域问题的特点，能够充分抽取数据中的特征。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NLP" scheme="https://wenhui-zhou.github.io/categories/NLP/"/>
    
    
  </entry>
  
  <entry>
    <title>NLP之Word2Vec（一）</title>
    <link href="https://wenhui-zhou.github.io/2019/11/29/NLP%E4%B9%8BWord2Vec%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://wenhui-zhou.github.io/2019/11/29/NLP之Word2Vec（一）/</id>
    <published>2019-11-29T06:53:18.000Z</published>
    <updated>2019-12-02T02:41:21.121Z</updated>
    
    <content type="html"><![CDATA[<p>NLP领域有着四个比较大的方向：</p><ul><li>文本分类</li><li>序列标注</li><li>文本匹配</li><li>文本生成</li></ul><p>在NLP里头，最细粒度的就是 <strong>词语</strong>，由词语组成句子，由句子组成文章继而表达一些语言层面上的含义。因此本文从NLP的根源问题 <strong>词语表达</strong> 开始讲起，即word2vec，NLP领域重要的预训练方法。</p><a id="more"></a><h3 id="word2vec考古史"><a href="#word2vec考古史" class="headerlink" title="word2vec考古史"></a>word2vec考古史</h3><p>Word2vec最早出现是以一个副产品的身份出现的。它是在实现语言模型过程中出现的<strong>一个惊喜的意外</strong>。简而言之，就是在做实现语言模型的过程中，我们得到了词语的数值表达，这也就是word2vec的精髓。</p><p><strong>词语是人类对语言在符号上的抽象总结，通过word2vec，将符号语言转化为数值表达，方便计算机寻找语言背后的抽象逻辑。</strong></p><p><strong>语言模型</strong></p><p>生成word2vec的语言模型是个什么东西呢？如下图：</p><p><img src="/images/nlp/language_model.png" style="zoom:50%;"></p><p>语言模型就是量化的衡量哪一个句子更像是人说的，核心函数p的思想是说，通过一系列的前导词，预测出后面跟着哪一个词的概率最大。</p><p><strong>数据的输入问题</strong>，第一步是将每个词用一个向量来唯一表示（<strong>one-hot</strong>），然后才可能对这个向量进行编码，得到具有语言意义的一个向量（<strong>word2vec</strong>）。</p><p><strong>one-hot</strong>的实现过程为建立一个长度为V的表，假设这个V表示世界上所有词语的词语。当我们对出现的一个词语进行编码的时候，只需要将这个词语出现的位置置为1，其他为0，即得到了这个<strong>词语的唯一表达（one-hot形式）。</strong></p><p><strong>语言网络的设计</strong>，加入你设计出了如下的结构：</p><p><img src="/images/nlp/nnlm.png" style="zoom:50%;"></p><p>这就是大名鼎鼎的神经网络语言模型，由Bengio 2003发表在JMLR上，2013年深度学习升温后，才慢慢进入了神坛。</p><p>他的核心思想即是最大似然估计的思想：<br>$$<br>\begin{equation}<br>\left.P\left(W_{t}=\operatorname{‘Bert’} | W_{1}, W_{2}, \ldots W_{(} t-1\right) ; \theta\right)<br>\end{equation}<br>$$<br>即如果当前位置出现了’Bert‘，要求网络预测前t-1的参数，使得当前出现Bert的概率最大。网络的输入，我们最初说使用one-hot的形式，但是为了另其具有语言的含义，我们在将词语输入网络之前，使用矩阵Q进行语义上的转换。从而得到词语的word embedding表达。</p><p>矩阵Q就是所谓的word2vec的转换矩阵，它包含V行，每一行表示一个单词的vector值，有一点值得注意的是，Q矩阵一开始是用随机值进行初始化的，矩阵Q参与网络的训练，当网络训练好之后，矩阵Q就被正确赋值了。</p><p>word2vec有两种训练方式：</p><ul><li>CBOW：从一个句子中将一个词抠掉，用这个词的上下文去预测这个词。</li><li>skip-gram：用一个词去预测这个词的上下文。</li></ul><h3 id="ELMO克服word2vec的多义词缺陷"><a href="#ELMO克服word2vec的多义词缺陷" class="headerlink" title="ELMO克服word2vec的多义词缺陷"></a>ELMO克服word2vec的多义词缺陷</h3><p>word2vec对下游的nlp任务有一些帮助，但是帮助却不是那么大。一个比较严重的问题在于<strong>多义词的问题</strong>，例如bank这个单词，可以指银行也可以指河床，但是在矩阵Q中，这个单词只有一种特征的编码。</p><p>如何解决这个问题呢，ELMO模型提出了一种想法，<strong>利用上下文场景来确定多义词的语义。</strong></p><p><strong>ELMO的本质思想是：</strong>事先用语言模型学好一个单词的Word Embedding，此时多义词无法区分。在下游任务中，实际使用Word Embedding的时候，单词已经具备了特定的上下文，这个时候<strong>可以根据上下文单词的语义去调整单词的Word Embedding表示</strong>，经过调整后的Word Embedding更能表达在这个上下文中的具体含义，即确定了多义词的具体语义。</p><p><img src="/images/nlp/elmo.png" style="zoom:50%;"></p><p>ELMO采用典型的两阶段：</p><ul><li>第一个阶段利用语言模型进行word embedding的预训练</li><li>第二个阶段是提取对应单词网络各层的word embedding作为新特征，补充到下游任务中</li></ul><p>上图是第一阶段的预训练过程，网络结构采用双层的word embedding作为新特征补充到任务中。网络结构采用双层的LSTM，左端正向表示正向的编码器。右边逆向，表示逆向的编码器。从两个方向来预测扣掉的那一个词。</p><p>使用这个网路，每次输入一个句子网络将会输出三个向量，分别是 <strong>单词特征，句法特征，语义特征。</strong></p><p>这三个特征如何使用呢，在下游的任务中，我们给每一个vector一个权重，然后将三个特征相加，整合成一个特征输入下游的任务中。这个权重需要通过网络的学习得到。EMLO效果相比较于传统的word2vec性能上得到了比较明显的提升。</p><p><img src="/images/nlp/elmo_use.png" style="zoom:50%;"></p><p>ELMO有什么缺点呢：</p><ul><li>LSTM抽取特征的能力远弱于transformer</li><li>拼接方式双向融合特征，融合能力偏弱</li></ul><p>接下来，我将在另外的文章中介绍transformer。</p><h3 id="inference"><a href="#inference" class="headerlink" title="inference"></a>inference</h3><p><a href="https://zhuanlan.zhihu.com/p/49271699" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/49271699</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NLP领域有着四个比较大的方向：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文本分类&lt;/li&gt;
&lt;li&gt;序列标注&lt;/li&gt;
&lt;li&gt;文本匹配&lt;/li&gt;
&lt;li&gt;文本生成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在NLP里头，最细粒度的就是 &lt;strong&gt;词语&lt;/strong&gt;，由词语组成句子，由句子组成文章继而表达一些语言层面上的含义。因此本文从NLP的根源问题 &lt;strong&gt;词语表达&lt;/strong&gt; 开始讲起，即word2vec，NLP领域重要的预训练方法。&lt;/p&gt;
    
    </summary>
    
      <category term="NLP" scheme="https://wenhui-zhou.github.io/categories/NLP/"/>
    
    
  </entry>
  
  <entry>
    <title>effective cpp(九)杂项讨论</title>
    <link href="https://wenhui-zhou.github.io/2019/11/26/effective-cpp-%E4%B9%9D-%E6%9D%82%E9%A1%B9%E8%AE%A8%E8%AE%BA/"/>
    <id>https://wenhui-zhou.github.io/2019/11/26/effective-cpp-九-杂项讨论/</id>
    <published>2019-11-26T13:34:29.000Z</published>
    <updated>2019-11-26T14:21:37.864Z</updated>
    
    <content type="html"><![CDATA[<p>2019/11/26 effective cpp 第九章 杂项讨论</p><p>这是这本书的最后一章，今晚应该就能够阅读完！在开始阅读之前，我想感慨一下，最后的几章难度太大，一知半解的看下来，我想原因是相关张章节的实践不多导致的，因此日后有需要要回来重新阅读它们，时间很快大概花了一个月的空闲时间来阅读这本书，收获满满！</p><p>这一章主要说了三个问题：编译器的警告要重视；C++标准库的一个总览；boost一个泛用性C++库的总览。</p><ul><li>53 条款：不要轻视编译器的警告</li><li>54 条款：让自己熟悉包括TR1在内的标准程序库</li><li>55 条款：让自己熟悉Boost</li></ul><a id="more"></a><h3 id="53-条款：不要轻视编译器的警告"><a href="#53-条款：不要轻视编译器的警告" class="headerlink" title="53 条款：不要轻视编译器的警告"></a>53 条款：不要轻视编译器的警告</h3><p>编译器作者在触发一个warning的时候，他比你更加明白将来会发生什么严重的错误，因此我们需要在对待编译器警告的时候更加的小心。</p><p>当出现一个编译器warning的时候，我们应该需要知道它的意图以及真正的意义。</p><p><strong>总结</strong></p><ul><li>严肃对待编译器发出的警告，争取无警告荣誉</li><li>不要过度依赖编译器的报警功能，因为不同的编译器对待事情的反应是不同的</li></ul><h3 id="54-条款：让自己熟悉包括TR1在内的标准程序库"><a href="#54-条款：让自己熟悉包括TR1在内的标准程序库" class="headerlink" title="54 条款：让自己熟悉包括TR1在内的标准程序库"></a>54 条款：让自己熟悉包括TR1在内的标准程序库</h3><p>C++standard定义了C++语言及其标准程序库的规范，里头包含以下：</p><ul><li>STL 标准模板库</li><li>Iostream</li><li>国际化支持</li><li>数值处理</li><li>C89标准程序库</li><li>异常阶层体系</li></ul><p>此外C++的新特性被记录在TR1的文档内，在下一次更新将会加入到标准库中。</p><p><strong>总结</strong></p><ul><li>C++标准库的主要机能由STL，iostreams，locates组成。并包含C99标准程序库。</li><li>TR1添加了智能指针，一般化函数指针，hash-based容器，正则表达式以及另外10个组件的支持</li><li>TR1自身只是一份规范。</li></ul><h3 id="55-条款：让自己熟悉Boost"><a href="#55-条款：让自己熟悉Boost" class="headerlink" title="55 条款：让自己熟悉Boost"></a>55 条款：让自己熟悉Boost</h3><p>如果你在找一个高质量，源码开放，平台独立，编译器独立的程序库，那么Boost是一个很好地选择。他的网址是：<a href="">http://boost.org</a>。</p><p><strong>总结</strong></p><ul><li>Boost是一个社群，也是一个网站，致力于免费，源码开放，同僚复审的C++程序库开发。Boost在C++标准化过程中扮演深居影响力的角色。</li><li>Boost提供许多TR1组件实现品，以及其他许多程序库。</li></ul><p>最后告诫一下自己，熟悉STL，在开始用C++写一个东西之前，应当要过一遍这9篇博客！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019/11/26 effective cpp 第九章 杂项讨论&lt;/p&gt;
&lt;p&gt;这是这本书的最后一章，今晚应该就能够阅读完！在开始阅读之前，我想感慨一下，最后的几章难度太大，一知半解的看下来，我想原因是相关张章节的实践不多导致的，因此日后有需要要回来重新阅读它们，时间很快大概花了一个月的空闲时间来阅读这本书，收获满满！&lt;/p&gt;
&lt;p&gt;这一章主要说了三个问题：编译器的警告要重视；C++标准库的一个总览；boost一个泛用性C++库的总览。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;53 条款：不要轻视编译器的警告&lt;/li&gt;
&lt;li&gt;54 条款：让自己熟悉包括TR1在内的标准程序库&lt;/li&gt;
&lt;li&gt;55 条款：让自己熟悉Boost&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="effective cpp" scheme="https://wenhui-zhou.github.io/categories/effective-cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>effective cpp(八)定制new和delete</title>
    <link href="https://wenhui-zhou.github.io/2019/11/25/effective-cpp-%E5%85%AB-%E5%AE%9A%E5%88%B6new%E5%92%8Cdelete/"/>
    <id>https://wenhui-zhou.github.io/2019/11/25/effective-cpp-八-定制new和delete/</id>
    <published>2019-11-25T13:40:42.000Z</published>
    <updated>2019-11-26T13:31:52.371Z</updated>
    
    <content type="html"><![CDATA[<p>2019/11/25 effective cpp 第8章 定制new和delete</p><p>C++在内存管理，垃圾回收机制上常常受到人们的讨论。下面这一章将讨论C++的内存管理例程。</p><ul><li>49 条款：了解new-handler的行为</li><li>50 条款：了解new和delete的合理替换时机</li><li>51 条款：编写new和delete时需固守常规</li><li>52 条款：写了placement new也要写placement delete</li></ul><a id="more"></a><h3 id="49-条款：了解new-handler的行为"><a href="#49-条款：了解new-handler的行为" class="headerlink" title="49 条款：了解new-handler的行为"></a>49 条款：了解new-handler的行为</h3><p>当operator new无法满足某一内存分配的需求时，它将会抛出异常。当operator new发生异常，它会先调用一个客户指定的错误处理函数，即new-handler函数。为了指定这个用以处理内存不足的函数，客户必须调用set_new_handler，那是声明与<code>&lt;new&gt;</code>的一个标准程序库函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出来new_handler是一个typedef。定义出一个指向函数的指针，该函数没有返回任何东西，set_new_handler则是接受一个指针，返回一个指针，并且不允许抛出任何的异常。</p><p>Set_new_handler的使用方式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outOfMem</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"unable doing something"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">abort</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::set_new_handler(outOfMem);</span><br><span class="line">  <span class="keyword">int</span>* pBig = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">12323232333333</span>];</span><br><span class="line">  <span class="comment">// 当new无法分配这么多空间的时候，将会去调用outOfMem报错。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现new-handler的时候，有几点注意：</p><ul><li><strong>让更多的内存可被使用</strong>，一个做法是程序开始执行的时候就分配了一大块内存，当调用handler的时候，释放给程序使用</li><li><strong>安装另一个new-handler</strong>，如果目前这个new-handler无法处理这个异常，它可以通过调用其他的handler来分配内存。</li><li><p><strong>卸除new-handler</strong>，就是讲null指针传给set_new_handler，一旦没有安装任何new-handler，operator new会在内存分配不成功时抛出异常。</p></li><li><p><strong>跑出bad_alloc异常，</strong>这样的异常不会被operator new捕获，因此会被传播到内存索求处。</p></li><li><strong>不返回</strong>，通常调用abort，exit来中断程序。</li></ul><p><strong>总结</strong></p><ul><li>set_new_handler允许客户指定一个函数，在内存分配无法获得满足时被调用</li><li>Nothrow new是一个颇为局限的工具，因为它只适用于内存分配，后续的构造函数调用还是可能抛出异常。</li></ul><h3 id="50-条款：了解new和delete的合理替换时机"><a href="#50-条款：了解new和delete的合理替换时机" class="headerlink" title="50 条款：了解new和delete的合理替换时机"></a>50 条款：了解new和delete的合理替换时机</h3><p>通常我们选择替换new和delete会出于几个原因：</p><ul><li>用于检测运用上的错误</li><li>为了强化效能</li><li>为了收集使用上的统计数据</li></ul><p>此外，在了解何时可在 <strong>全局性</strong>或 <strong>class专属的</strong>基础上合理替换缺省的new和delete：</p><ul><li>为了检测运用上的错误</li><li>为了手机动态分配内存之使用统计信息</li><li>为了增加分配和归还的速度</li><li>为了降低缺省内存管理器带来的空间额外开销</li><li>为了弥补缺省分配器中的非最佳齐位</li><li>为了将相关对象成簇集中</li><li>为了获得非传统的行为</li></ul><p><strong>总结</strong></p><p>有许多理由需要写个自定义的new和delete，包括改善效能，对heap运用错误进行调试，收集heap使用信息。</p><h3 id="51-条款：编写new和delete时需固守常规"><a href="#51-条款：编写new和delete时需固守常规" class="headerlink" title="51 条款：编写new和delete时需固守常规"></a>51 条款：编写new和delete时需固守常规</h3><p>让我们从实现operator new开始，实现一致性operator new必须返回正确的值，内存不足的时候必须调用new-handling函数，必须有对付零内存需求的准备，还需避免不慎掩盖正常形式的new。</p><p>operator new其实比较单纯，如果能够申请到空间，就返回正确的值，如果申请不到空间就返回一个bad-alloc。但是他也有不单纯的一面，因为operator不止一次的申请内存，如果new-handling有能力做一些操作释放内存出来，因此只有在new-handling返回null的时候才会抛出错误。</p><p>如果你打算控制operator new[]的行为，你唯一要做的事情就是分配一块未加工的内存。因为你无法知道array中将会保存什么东西。</p><p>对于operator delete来说，我们要确保的是 <strong>删除null指针永远安全</strong>。</p><p><strong>总结</strong></p><ul><li>operator new应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存的需求，就调用new-handler。它应该也有能力处理0byte申请。class 专属版本则应该处理 <strong>比正确大小更大的错误。</strong></li><li>operator delete应该受到null指针时不做任何事，class专属版本则还应该处理 <strong>比正确大小更大的申请。</strong></li></ul><h3 id="52-条款：写了placement-new也要写placement-delete"><a href="#52-条款：写了placement-new也要写placement-delete" class="headerlink" title="52 条款：写了placement new也要写placement delete"></a>52 条款：写了placement new也要写placement delete</h3><p>placement new和placement delete应当也成对的出现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">widget* pw = <span class="keyword">new</span> widget;</span><br></pre></td></tr></table></figure><p>当我们通过上面的代码的时候，实际上做了两件事情，第一件是new，第二件是调用了widget的default构造函数。如果在第二种情况下发生了异常，new成功执行。这种情况下我们要去释放new所申请的空间，但是我们手上并没有申请得到的指针，因此释放内存的重任就交给了C++。</p><p>如果当前面对的是拥有正常签名的new和delete函数，那么系统在运行期间就会主动去调用相应的delete函数。</p><p>但是如果我们使用的new是我们修改过的，带有附加参数的new，这时候我们需要制定一个与之对应的delete函数。</p><p>此外，由于成员函数名称将会覆盖其外围作用域的相同名称，你必须小心避免掉这种覆盖。一个简单的做法就是建立一个base class，内含所有正常形式的new和delete，凡是想以自定形式扩充标准形式的客户，可利用继承机制及using声明式来取得标准形式。</p><p><strong>总结</strong></p><ul><li>当你写一个placement operator new。请确定也写出对应了placement operator delete函数，如果没有这样做的话，你的程序可能会发生隐微而断续的内存泄漏。</li><li>当你声明placement new和placement delete，请确定不要无意识地掩盖了他们的正常版本。</li></ul><p>一知半解。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019/11/25 effective cpp 第8章 定制new和delete&lt;/p&gt;
&lt;p&gt;C++在内存管理，垃圾回收机制上常常受到人们的讨论。下面这一章将讨论C++的内存管理例程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;49 条款：了解new-handler的行为&lt;/li&gt;
&lt;li&gt;50 条款：了解new和delete的合理替换时机&lt;/li&gt;
&lt;li&gt;51 条款：编写new和delete时需固守常规&lt;/li&gt;
&lt;li&gt;52 条款：写了placement new也要写placement delete&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="effective cpp" scheme="https://wenhui-zhou.github.io/categories/effective-cpp/"/>
    
    
  </entry>
  
</feed>

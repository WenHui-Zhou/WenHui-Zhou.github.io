<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WenHuiZhou</title>
  
  <subtitle>perper（打起精神！）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wenhui-zhou.github.io/"/>
  <updated>2019-08-22T12:21:46.535Z</updated>
  <id>https://wenhui-zhou.github.io/</id>
  
  <author>
    <name>WenHuiZhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>堆排序，python实现</title>
    <link href="https://wenhui-zhou.github.io/2019/08/22/%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%8Cpython%E5%AE%9E%E7%8E%B0/"/>
    <id>https://wenhui-zhou.github.io/2019/08/22/堆排序，python实现/</id>
    <published>2019-08-22T11:08:57.000Z</published>
    <updated>2019-08-22T12:21:46.535Z</updated>
    
    <content type="html"><![CDATA[<p>堆排序这个名称一直困扰着我，现在扫一下盲。</p><a id="more"></a><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>首先介绍一下堆的概念：堆是一棵完全二叉树，即指允许最后一层的叶子是不满的，其他层都是满的。叶子节点的出现顺序也是从左边开始向右边累加，不允许中断。父结点必须比子节点要大。</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆排序的算法复杂度是O(nlog(n))。由于节点满足完全二叉树，因此可以通过下标的关系找到父节点，子节点。</p><p>例如当前节点为i，父节点：(i - 1) /2。左孩子：2i+1,右孩子：2i+2。因此堆排序的策略如下：</p><h3 id="堆排序步骤"><a href="#堆排序步骤" class="headerlink" title="堆排序步骤"></a>堆排序步骤</h3><ol><li>构造堆结构，从最后一个元素（叶子）的父节点开始，循环到根节点，每次执行heapify函数（三个节点，找最大的放到根位置）。</li><li>位于根节点的元素是最大的，每次将根节点的数拿出来，作为排序的最后一个值。然后将最后一个叶节点放到根的位置。依次循环下去，直到结束。</li></ol><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(nums,n,i)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    i 表示要进行调换的根节点位置</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    c1 = <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">    c2 = <span class="number">2</span>*i + <span class="number">2</span></span><br><span class="line">    max_index = i</span><br><span class="line">    <span class="keyword">if</span> c1 &lt;= n <span class="keyword">and</span> nums[c1] &gt; nums[i]:</span><br><span class="line">        max_index = c1</span><br><span class="line">    <span class="keyword">if</span> c2 &lt;= n <span class="keyword">and</span> nums[c2] &gt; nums[max_index]:</span><br><span class="line">        max_index = c2</span><br><span class="line">    <span class="keyword">if</span> max_index != i:</span><br><span class="line">        nums[max_index],nums[i] = nums[i],nums[max_index]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_heap</span><span class="params">(nums)</span>:</span></span><br><span class="line">    n = len(nums) - <span class="number">1</span></span><br><span class="line">    last_index = (n - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(last_index+<span class="number">1</span>)[::<span class="number">-1</span>]:</span><br><span class="line">        heapify(nums,n,i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    print(nums)</span><br><span class="line">    build_heap(nums)</span><br><span class="line">    print(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums))[::<span class="number">-1</span>]:</span><br><span class="line">        print(i)</span><br><span class="line">        nums[<span class="number">0</span>],nums[i] = nums[i],nums[<span class="number">0</span>]</span><br><span class="line">        heapify(nums,i<span class="number">-1</span>,<span class="number">0</span>)</span><br><span class="line">    print(nums)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">heap_sort(nums)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;堆排序这个名称一直困扰着我，现在扫一下盲。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://wenhui-zhou.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>深度学习代码的框架</title>
    <link href="https://wenhui-zhou.github.io/2019/08/16/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E7%9A%84%E6%A1%86%E6%9E%B6/"/>
    <id>https://wenhui-zhou.github.io/2019/08/16/深度学习代码的框架/</id>
    <published>2019-08-16T01:31:51.000Z</published>
    <updated>2019-08-22T12:24:34.887Z</updated>
    
    <content type="html"><![CDATA[<p>以pytorch为例，梳理一下深度学习中，数据的读取，神经网络的搭建，NMS，以及各个指标的计算流程。</p><a id="more"></a><h3 id="main-函数，程序入口，以及代码配置"><a href="#main-函数，程序入口，以及代码配置" class="headerlink" title="main 函数，程序入口，以及代码配置"></a>main 函数，程序入口，以及代码配置</h3><p>通常main函数中，通过实现argparse功能包，从函数的外部接受参数的传入，对数据，网络等进行一些基本的配置。argparse的使用方法：<a href="https://docs.python.org/zh-cn/3/library/argparse.html" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/argparse.html</a></p><p>main函数中一些常用的配置项：</p><ul><li>数据集的格式：coco，csv，pascal voc等等</li><li>数据的路径，包括训练集，测试集的路径等等</li><li>网络的一些细节配置，如深度，backbone 类型</li><li>一些功能的开关设置，如数据的增强等</li><li>训练过程中，一些变量的设置，比如epoch的设置，batch_size的设置等等</li></ul><h3 id="数据读取部分"><a href="#数据读取部分" class="headerlink" title="数据读取部分"></a>数据读取部分</h3><p>数据读取部分的操作包括数据集文件的读取，对图片进行数据的增强，继承dataloader实现数据的批量读取。</p><h4 id="数据文件的读取"><a href="#数据文件的读取" class="headerlink" title="数据文件的读取"></a>数据文件的读取</h4><p>这部分读取任务主要包括读取annotation文件，以及class_id文件，这里以csv格式的数据集文件为例。</p><p>首先实现一个CSVDataset类，继承至torch.utils.data.Dataset类。该类必须实现<code>__len__</code>,<code>__getitem__</code>两个方法。</p><p>在CSVDataset方法的<code>__init__</code>中，进行数据集文件的读取，最终将得到：</p><ul><li>self.classes</li><li>self.image_names : list 包含所有的数据集图片路径</li><li>self.image_data: dict[image_name] = [ {x1,y1,x2,y2,class_name},…]</li></ul><p><code>__getitem__</code>函数中需要实现的方法有根据下标来得到image，以及其对应的标注。最终返回的格式为：</p><p><code>sample = {&#39;img&#39;: img, &#39;annot&#39;: annot}</code>。在返回之前，如果有数据增强部分，还需要进行数据的增强。</p><h4 id="数据增强"><a href="#数据增强" class="headerlink" title="数据增强"></a>数据增强</h4><p>数据增强的方法有很多种，常用的图片的翻转，切割，resize，归一化等等。数据增强利用一张图片，得到它的许多副本，有效的增大数据集。数据增强能够起效果的一个本质因素在于，卷积操作对位移，视角，图片大小，光照等因素具有不变性。数据增强有线下增强和线上增强两种方式，后一种方式在dataloader提取数据的时候，才对数据进行增强。</p><p>数据增强的方法通常可以写成一个类，通过pytorch中的<code>transforms.Compose([Augumenter(),Resizer()])</code> 来对所有的增强方法进行整合。</p><p><strong>Normalizer</strong></p><p>实现一个Normalizer类，覆盖其中的<code>__call__</code>方法，对每张图片做一个正则化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Normalizer</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.mean = np.array([[[<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>]]])</span><br><span class="line">        self.std = np.array([[[<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>]]])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, sample)</span>:</span></span><br><span class="line"></span><br><span class="line">        image, annots = sample[<span class="string">'img'</span>], sample[<span class="string">'annot'</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'img'</span>:((image.astype(np.float32)-self.mean)/self.std), <span class="string">'annot'</span>: annots&#125;</span><br></pre></td></tr></table></figure><p><strong>argument</strong></p><p>实现对图片的翻转，需要注意对标注也要进行处理。</p><p><strong>Resizer</strong></p><p>该方法意图将图片的大小限制在一定范围以内。因此在缩放的时候，需要找到最大的缩放比例,同时保证图片能够被32整除。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resizer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Convert ndarrays in sample to Tensors."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, sample, min_side=<span class="number">608</span>, max_side=<span class="number">1024</span>)</span>:</span> <span class="comment">#将图片resize到608，1024以下的大小</span></span><br><span class="line">        image, annots = sample[<span class="string">'img'</span>], sample[<span class="string">'annot'</span>]       <span class="comment"># 不能超过这个尺寸（有一边等于这个尺寸）</span></span><br><span class="line"></span><br><span class="line">        rows, cols, cns = image.shape</span><br><span class="line"></span><br><span class="line">        smallest_side = min(rows, cols)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># rescale the image so the smallest side is min_side</span></span><br><span class="line">        scale = min_side / smallest_side</span><br><span class="line"></span><br><span class="line">        <span class="comment"># check if the largest side is now greater than max_side, which can happen</span></span><br><span class="line">        <span class="comment"># when images have a large aspect ratio</span></span><br><span class="line">        largest_side = max(rows, cols)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> largest_side * scale &gt; max_side:</span><br><span class="line">            scale = max_side / largest_side</span><br><span class="line"></span><br><span class="line">        <span class="comment"># resize the image with the computed scale</span></span><br><span class="line">        image = skimage.transform.resize(image, (int(round(rows*scale)), int(round((cols*scale)))))</span><br><span class="line">        rows, cols, cns = image.shape</span><br><span class="line"></span><br><span class="line">        pad_w = <span class="number">32</span> - rows%<span class="number">32</span></span><br><span class="line">        pad_h = <span class="number">32</span> - cols%<span class="number">32</span></span><br><span class="line"></span><br><span class="line">        new_image = np.zeros((rows + pad_w, cols + pad_h, cns)).astype(np.float32)</span><br><span class="line">        new_image[:rows, :cols, :] = image.astype(np.float32) <span class="comment"># 两个边长需要保证被32整除，少掉的的那部分使用0来补全</span></span><br><span class="line"></span><br><span class="line">        annots[:, :<span class="number">4</span>] *= scale</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'img'</span>: torch.from_numpy(new_image), <span class="string">'annot'</span>: torch.from_numpy(annots), <span class="string">'scale'</span>: scale&#125;</span><br></pre></td></tr></table></figure><h3 id="数据调用-dataloader"><a href="#数据调用-dataloader" class="headerlink" title="数据调用 dataloader"></a>数据调用 dataloader</h3><p>pytorch通过实现dataloader方法来实现网络训练时，每次iteration的数据的输出。dataloader的逻辑是，每次从dataset中调用<code>__getitem__()</code>获取单个数据，然后组合成batch，在使用<code>collate_fn</code>参数对batch进行一些操作。</p><p><code>torch.utils.data.Dataloader</code><strong>中的参数</strong>：</p><blockquote><p><strong>dataset</strong>(<a href="https://pytorch.org/docs/stable/data.html?highlight=dataloader#torch.utils.data.Dataset" target="_blank" rel="noopener"><em>Dataset</em></a>) – dataset from which to load the data.</p><p><strong>batch_size</strong>(<a href="https://docs.python.org/3/library/functions.html#int" target="_blank" rel="noopener"><em>int</em></a>, <em>optional</em>) – how many samples per batch to load (default: 1).</p><p><strong>shuffle</strong>(<a href="https://docs.python.org/3/library/functions.html#bool" target="_blank" rel="noopener"><em>bool</em></a>, <em>optional</em>) – set to <code>True</code>to have the data reshuffled at every epoch (default: False).</p><p><strong>sampler</strong>(<a href="https://pytorch.org/docs/stable/data.html?highlight=dataloader#torch.utils.data.Sampler" target="_blank" rel="noopener"><em>Sampler</em></a>, <em>optional</em>) – defines the strategy to draw samples from the dataset. If specified, <code>shuffle</code>must be False.</p><p><strong>batch_sampler</strong>(<a href="https://pytorch.org/docs/stable/data.html?highlight=dataloader#torch.utils.data.Sampler" target="_blank" rel="noopener"><em>Sampler</em></a>, <em>optional</em>) – like sampler, but returns a batch of indices at a time. Mutually exclusive with batch_size, shuffle, sampler, and drop_last.</p><p><strong>num_workers</strong>(<a href="https://docs.python.org/3/library/functions.html#int" target="_blank" rel="noopener"><em>int</em></a>, <em>optional</em>) – how many subprocesses to use for data loading. 0 means that the data will be loaded in the main process. (default: 0)</p><p><strong>collate_fn</strong>(<em>callable<strong>, </strong>optional</em>) – merges a list of samples to form a mini-batch.</p><p><strong>pin_memory</strong>(<a href="https://docs.python.org/3/library/functions.html#bool" target="_blank" rel="noopener"><em>bool</em></a>, <em>optional</em>) – If <code>True</code>, the data loader will copy tensors into CUDA pinned memory before returning them.</p><p><strong>drop_last</strong>(<a href="https://docs.python.org/3/library/functions.html#bool" target="_blank" rel="noopener"><em>bool</em></a>, <em>optional</em>) – set to <code>True</code>to drop the last incomplete batch, if the dataset size is not divisible by the batch size. If <code>False</code>and the size of dataset is not divisible by the batch size, then the last batch will be smaller. (default: False)</p><p><strong>timeout</strong>(<em>numeric</em>, <em>optional</em>) – if positive, the timeout value for collecting a batch from workers. Should always be non-negative. (default: 0)</p><p><strong>worker_init_fn</strong>(<em>callable</em>, <em>optional</em>) – If not None, this will be called on each worker subprocess with the worker id (an int in <code>[0, num_workers - 1]</code>) as input, after seeding and before data loading. (default: None)</p></blockquote><p>算法中使用如下参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataloader_train = DataLoader(dataset_train, num_workers=3, collate_fn=collater, batch_sampler=sampler)</span><br></pre></td></tr></table></figure><p>其中<code>dataset_train</code>为<code>Dataset</code>类的对象，如上实现数据问价读取的部分。<code>num_workers</code>设置了这个类的线程数。<code>batch_sampler</code> 设置了每次从数据集中返回一个batch的sample的策略。<code>collate_fn</code> 将一系列的样本融合成一个小的mini-batch。</p><p><strong>首先是batch_sampler:</strong></p><p>继承至采样器类，需要实现其中的<code>__len__</code>方法，<code>__iter__</code>方法。该参数的作用是将数据集做成许多group组成的一个list。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AspectRatioBasedSampler</span><span class="params">(Sampler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data_source, batch_size, drop_last)</span>:</span></span><br><span class="line">        self.data_source = data_source</span><br><span class="line">        self.batch_size = batch_size</span><br><span class="line">        self.drop_last = drop_last</span><br><span class="line">        self.groups = self.group_images()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        random.shuffle(self.groups)</span><br><span class="line">        <span class="keyword">for</span> group <span class="keyword">in</span> self.groups:</span><br><span class="line">            <span class="keyword">yield</span> group</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.drop_last:</span><br><span class="line">            <span class="keyword">return</span> len(self.data_source) // self.batch_size</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (len(self.data_source) + self.batch_size - <span class="number">1</span>) // self.batch_size</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">group_images</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># determine the order of the images</span></span><br><span class="line">        order = list(range(len(self.data_source)))</span><br><span class="line">        order.sort(key=<span class="keyword">lambda</span> x: self.data_source.image_aspect_ratio(x))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># divide into groups, one group = one batch</span></span><br><span class="line">        <span class="keyword">return</span> [[order[x % len(order)] <span class="keyword">for</span> x <span class="keyword">in</span> range(i, i + self.batch_size)] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(order), self.batch_size)]</span><br></pre></td></tr></table></figure><p>如上，这个方法将数据分别存入group中，然后组成一个groups的list。通过一个<code>__iter__()</code>方法，迭代的方式将数据输出。每次输出一个batch大小的数据。</p><p><strong>collate_fn参数：</strong></p><p>该参数接受来自batch_sampler的数据，对数据进行进一步的处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">collater</span><span class="params">(data)</span>:</span></span><br><span class="line">    imgs = [s[<span class="string">'img'</span>] <span class="keyword">for</span> s <span class="keyword">in</span> data]</span><br><span class="line">    annots = [s[<span class="string">'annot'</span>] <span class="keyword">for</span> s <span class="keyword">in</span> data]</span><br><span class="line">    scales = [s[<span class="string">'scale'</span>] <span class="keyword">for</span> s <span class="keyword">in</span> data]     </span><br><span class="line">    widths = [int(s.shape[<span class="number">0</span>]) <span class="keyword">for</span> s <span class="keyword">in</span> imgs]</span><br><span class="line">    heights = [int(s.shape[<span class="number">1</span>]) <span class="keyword">for</span> s <span class="keyword">in</span> imgs]</span><br><span class="line">    batch_size = len(imgs)</span><br><span class="line">    max_width = np.array(widths).max()</span><br><span class="line">    max_height = np.array(heights).max()</span><br><span class="line">    padded_imgs = torch.zeros(batch_size, max_width, max_height, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(batch_size):</span><br><span class="line">        img = imgs[i]</span><br><span class="line">        padded_imgs[i, :int(img.shape[<span class="number">0</span>]), :int(img.shape[<span class="number">1</span>]), :] = img</span><br><span class="line">    max_num_annots = max(annot.shape[<span class="number">0</span>] <span class="keyword">for</span> annot <span class="keyword">in</span> annots)</span><br><span class="line">    <span class="keyword">if</span> max_num_annots &gt; <span class="number">0</span>:</span><br><span class="line">        annot_padded = torch.ones((len(annots), max_num_annots, <span class="number">5</span>)) * <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> max_num_annots &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> idx, annot <span class="keyword">in</span> enumerate(annots):</span><br><span class="line">                <span class="comment">#print(annot.shape)</span></span><br><span class="line">                <span class="keyword">if</span> annot.shape[<span class="number">0</span>] &gt; <span class="number">0</span>:</span><br><span class="line">                    annot_padded[idx, :annot.shape[<span class="number">0</span>], :] = annot</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        annot_padded = torch.ones((len(annots), <span class="number">1</span>, <span class="number">5</span>)) * <span class="number">-1</span></span><br><span class="line">    padded_imgs = padded_imgs.permute(<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'img'</span>: padded_imgs, <span class="string">'annot'</span>: annot_padded, <span class="string">'scale'</span>: scales&#125;</span><br></pre></td></tr></table></figure><p>上面的操作，将同一个batch中的图片的大小统一同样的大小。annotation的维度也统一到同样大小的维度。然后进行RGB通道的变换之后，放回一个dict。</p><p>上面这些步骤就完成了数据的loader，通过for循环从其中取得元素。</p><h3 id="retinanet网络结构"><a href="#retinanet网络结构" class="headerlink" title="retinanet网络结构"></a>retinanet网络结构</h3><p>下面从数据流动的角度分析一下retinanet的各个结构的组成。</p><p>retinanet的特征提取部分，使用的是resnet，resnet有多种深度的选择，分别有18，34，50，101，152五种深度。常用的网络深度为50，101:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resnet50</span><span class="params">(num_classes, pretrained=False, **kwargs)</span>:</span></span><br><span class="line">    <span class="string">"""Constructs a ResNet-50 model.</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        pretrained (bool): If True, returns a model pre-trained on ImageNet</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    model = ResNet(num_classes, Bottleneck, [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>], **kwargs)</span><br><span class="line">    <span class="keyword">if</span> pretrained:</span><br><span class="line">        model.load_state_dict(model_zoo.load_url(model_urls[<span class="string">'resnet50'</span>], model_dir=<span class="string">'.'</span>), strict=<span class="keyword">False</span>)</span><br><span class="line">    <span class="keyword">return</span> model</span><br></pre></td></tr></table></figure><p>让我们一行一行来看，第一个调用了ResNet()类，创建了一个ResNet对象。ResNet继承至<code>nn.Module</code>,需要实现函数<code>__init__</code>以及<code>forward()</code>两个方法，通常将可学习的参数放到构造函数<code>__init__()</code>中，在<code>forward</code>中实现网络数据的流动，即可实现网络的自动求导机制。</p><p><strong>ResNet</strong></p><p>resnet首次提出残差的思想，传统的卷积网络或者全连接网络在信息传递的时候或多或少会存在信息丢失，损耗等问题，同时还有导致梯度消失或者梯度爆炸，导致很深的网络无法训练。ResNet通过学习残差的方式，在一定程度上解决了<strong>网络退化和梯度消失</strong>的问题。ResNet通过大量叠加残差块的方式，加深网络的深度的同时，保证了网络的梯度不消失。ResNet有着两种不同的残差单元。分别是basicBlock 和 bottleneck结构。深层次网络使用bottleneck结构，每次经过残差结构之前都对数据进行一次降维，大大降低了网络的参数量。</p><p><img src="/images/res_unit.png" alt=""></p><p>bottleneck的结构feature经过第一个1x1的卷积层，将特征的维度压缩，对压缩后的特征进行3x3的卷积，然后经过1x1卷积层，将特征的维度放大到原来的大小。</p><p>bottleneck的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bottleneck</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    expansion = <span class="number">4</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inplanes, planes, stride=<span class="number">1</span>, downsample=None)</span>:</span></span><br><span class="line">        super(Bottleneck, self).__init__()</span><br><span class="line">        self.conv1 = nn.Conv2d(inplanes, planes, kernel_size=<span class="number">1</span>, bias=<span class="keyword">False</span>)</span><br><span class="line">        self.bn1 = nn.BatchNorm2d(planes)</span><br><span class="line">        self.conv2 = nn.Conv2d(planes, planes, kernel_size=<span class="number">3</span>, stride=stride,</span><br><span class="line">                               padding=<span class="number">1</span>, bias=<span class="keyword">False</span>)</span><br><span class="line">        self.bn2 = nn.BatchNorm2d(planes)</span><br><span class="line">        self.conv3 = nn.Conv2d(planes, planes * <span class="number">4</span>, kernel_size=<span class="number">1</span>, bias=<span class="keyword">False</span>)</span><br><span class="line">        self.bn3 = nn.BatchNorm2d(planes * <span class="number">4</span>)</span><br><span class="line">        self.relu = nn.ReLU(inplace=<span class="keyword">True</span>)</span><br><span class="line">        self.downsample = downsample</span><br><span class="line">        self.stride = stride</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        residual = x</span><br><span class="line">        out = self.conv1(x)</span><br><span class="line">        out = self.bn1(out)</span><br><span class="line">        out = self.relu(out)</span><br><span class="line">        </span><br><span class="line">        out = self.conv2(out)</span><br><span class="line">        out = self.bn2(out)</span><br><span class="line">        out = self.relu(out)</span><br><span class="line">        </span><br><span class="line">        out = self.conv3(out)</span><br><span class="line">        out = self.bn3(out)</span><br><span class="line">        <span class="keyword">if</span> self.downsample <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">            residual = self.downsample(x)</span><br><span class="line">        out += residual</span><br><span class="line">        out = self.relu(out)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以pytorch为例，梳理一下深度学习中，数据的读取，神经网络的搭建，NMS，以及各个指标的计算流程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="深度学习" scheme="https://wenhui-zhou.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>normalization</title>
    <link href="https://wenhui-zhou.github.io/2019/07/24/normalization/"/>
    <id>https://wenhui-zhou.github.io/2019/07/24/normalization/</id>
    <published>2019-07-24T01:34:12.000Z</published>
    <updated>2019-07-24T14:45:22.528Z</updated>
    
    <content type="html"><![CDATA[<p>Normalization 正则化在wikipedia上的解释是，使得某个东西更加正规和正常化的一个过程。深度学习中，正则化使用十分广泛，通常网络通过修改loss，添加参数的正则项，对参数的分布进行控制；或是在数据预处理阶段，对数据进行正则化操作。正则化操作通常指的是将数据大小范围缩放到[0,1]之间。<br><a id="more"></a></p><h3 id="对数据集的正则化操作"><a href="#对数据集的正则化操作" class="headerlink" title="对数据集的正则化操作"></a>对数据集的正则化操作</h3><blockquote><p>Normalization is useful when your data has varying scales and the algorithm you are using does not make assumptions about the distribution of your data, such as <strong>k-nearest neighbors and artificial neural networks.</strong></p><p>正则化使用场景是数据特征范围差异大，且数据的分布未知。</p></blockquote><p>对于一般的数据集来说，我们不需要对其进行正则化操作。但如果数据集不同特征的数据范围相差过大时，我们需要对其进行正则化操作。因为数据范围大的数据，其波动对精度的影响很大，而数据范围小的特征，数据波动的影响不会有这么大，这样造成了结果精度无法提升。因此需要对数据进行正则化操作。使得数据局限在一个固定的范围内。</p><h3 id="正则项"><a href="#正则项" class="headerlink" title="正则项"></a>正则项</h3><p>我们知道，当一个网络与数据过度拟合，这个网络能够很好的反应训练数据，但是它的泛化性能也会大大下降。为了避免这种过拟合现象，做法通常有：</p><ol><li>削减特征的数量（难以确定哪些特征是需要丢弃的）</li><li>减少特征的参数，控制参数的分布，即使用正则项方法</li></ol><p>正则项的目的是为了对参数进行控制，包括：</p><ol><li>实现参数的稀疏化，即某些参数为0。参数的稀疏化能够自动对数据的特征进行筛选，过滤掉一些不需要的特征，同时起到简化模型的作用，避免过拟合。</li><li>最小化正则项能够尽量保持参数较小，参数小的好处在于计算方便，且在网络求导的过程中，产生的导数通常比较小，结果比较稳定。</li></ol><h4 id="范数-（norm）"><a href="#范数-（norm）" class="headerlink" title="范数 （norm）"></a>范数 （norm）</h4><p>在线性代数领域中，范数是一个函数，它为向量空间中的每个向量分配严格正长度或大小 。</p><p><strong>L0 范数：指向量空间中非0向量的个数</strong></p><p><strong>无穷范数：指所有向量中欧式距离的最大值作为无穷范数</strong></p><h4 id="参数正则项"><a href="#参数正则项" class="headerlink" title="参数正则项"></a>参数正则项</h4><p><strong>L0正则项：模型参数中，不为0的参数的个数</strong></p><p>​    L0正则化通过最小化不为0的参数的个数，以达到参数稀疏化的目的，使得模型自动选择特征。在使用时，由于L0正则项是一个NP hard问题，L1是L0的最优凸优化，因此通常用L1来代替L0。</p><p><strong>L1正则项：各个模型参数的绝对值之和</strong></p><p>​    最小化L1正则项能够将模型的参数变小，沿着0的方向靠近，降低网络的模型复杂度。添加L1正则项后方程如下：<br>$$<br>L = L_0 + \frac{\lambda}{n}\sum_{w}|W|<br>$$<br><strong>L2 正则项：各个参数的平方和再开根号。</strong></p><p>​    最小化L2正则项可以使得参数变小接近于0，当参数不会变成0（可以看下面的图来理解），因此L2将选择更多的特征，权重比较小，避免过拟合。方程如下：<br>$$<br>C=C_{0}+\frac{\lambda}{2 n} \sum_{w} w^{2}<br>$$<br><strong>lasso回归与岭参数</strong></p><p>L1正则化又称为losso回归，将L1正则项作为loss的惩罚函数。L2正则项又称为岭参数。同样可以将L2正则项作为公式的约束项。可以画图如下,其中等值线为原始的Loss，L1为正方形（绝对值），L2为一个圈（平方根）。可以看出来，图中的交点满足条件的点，因此可以看出L1正则项可以得到更多的稀疏解。</p><p><img src="../images/SR/L1L2_7_24.png" alt=""></p><h3 id="标准化操作（standardization）"><a href="#标准化操作（standardization）" class="headerlink" title="标准化操作（standardization）"></a>标准化操作（standardization）</h3><blockquote><p>Standardization is useful when your data has varying scales and the algorithm you are using does make assumptions about your data having a Gaussian distribution, such as <strong>linear regression, logistic regression and linear discriminant analysis.</strong></p><p>标准化使用场景是数据特征范围差异大，假设数据服从高斯分布。</p></blockquote><p>将数据标准化是指将数据rescale，使得数据的 $mean = 0,\sigma = 1$。数据的标准化操作如下：<br>$$<br>z=\frac{x-\mu}{\sigma}<br>$$<br>标准化操作对于很多机器学习的算法，在网络训练上有着很重要的作用。例如对于梯度下降法来说，处于中心（mean = 0）范围的数据，中心权重的参数更新将会加快。对于一些loss而言（MSE），利用欧式距离作为网络优化的目标，因此标准化操作是很重要的。</p><h3 id="Batch-Normalization（批量标准化）"><a href="#Batch-Normalization（批量标准化）" class="headerlink" title="Batch Normalization（批量标准化）"></a>Batch Normalization（批量标准化）</h3><p>其步骤如下，对一个batch中的数据进行标准化后，并学习$r,\beta$ 两个参数，对得到标准化后的值进行一个偏移，得到最终的结果：</p><p><img src="../images/SR/BN_7_24.png" alt=""></p><p><u>当进来一个batch的时候，具体的做法是，在数据输入到下一层神经元激活函数之前，计算整个batch的mean，variance，偏移后最终得到下一层的输入。</u></p><p><strong>为什么要加入Batch Normalization层？</strong></p><p>由于深层网络的输入，经过多层神经网络层的作用后发生偏移（ReLu激活函数输出均大于0，因此整体输出的mean将往大于0的方向偏移）。导致网络训练难以收敛，落入梯度饱和区导致梯度消失等问题。BN层重新通过将数据拉回N(0,1)的正态分布上，是的输入值落入激活函数梯度敏感的区域，避免梯度消失，加速网络的训练。（输入变小也有助于降低模型计算复杂度）。</p><p>但是仅仅做到这一步还不行，由于我们引入非线性的激活函数，使得网络能够学到一些非线性的性质。我们通过BN将输出拉回到N(0,1)分布上，削弱了激活函数的非线性部分的作用。因此BN通过学习两个参数$\gamma, \beta$ 来对输出做一个scale和shit操作。恢复学习到的非线性部分知识。最终得到的$y_i$ 在正态分布和非线性性质中做了一个trade off。</p><p><strong>Batch Normalization的作用</strong></p><ol><li>batch normalization极大的提升了网络训练的速度</li><li>每次BN都将网络的输出控制在一个范围内，近似于符合正态分布，能够起到正则项的作用</li><li>对参数的初始化要求降低，调参变得简单</li></ol><h4 id="layer-normalization"><a href="#layer-normalization" class="headerlink" title="layer normalization"></a>layer normalization</h4><p><img src="../images/SR/layer_normal_7_24.png" alt=""></p><p>layer normalization 正则化的方向是沿着feature的方向对CHW归一化，batch normalization 正则化的方向是以sample为单位，对NHW做归一化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Normalization 正则化在wikipedia上的解释是，使得某个东西更加正规和正常化的一个过程。深度学习中，正则化使用十分广泛，通常网络通过修改loss，添加参数的正则项，对参数的分布进行控制；或是在数据预处理阶段，对数据进行正则化操作。正则化操作通常指的是将数据大小范围缩放到[0,1]之间。&lt;br&gt;
    
    </summary>
    
      <category term="super resolution" scheme="https://wenhui-zhou.github.io/categories/super-resolution/"/>
    
    
      <category term="深度学习" scheme="https://wenhui-zhou.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>image upsample-downsample method</title>
    <link href="https://wenhui-zhou.github.io/2019/07/23/image-upsample-downsample-method/"/>
    <id>https://wenhui-zhou.github.io/2019/07/23/image-upsample-downsample-method/</id>
    <published>2019-07-23T07:30:25.000Z</published>
    <updated>2019-07-23T09:43:08.879Z</updated>
    
    <content type="html"><![CDATA[<p>图像尺度的放大，缩小是图形学中一个十分常见的问题。然而这个过程并不是无损的，缩放的过程是一个非线性的过程，因此存在许多算法在效率，平滑度，清晰度和速度上进行一些权衡（trade-off）。在图形的缩放过程中，存在插值，采样等一些关键的步骤，下面对一些在图像缩放过程中使用的算法进行简要的介绍，这些算法均有其优缺点。</p><p>参考资料：<a href="https://clouard.users.greyc.fr/Pantheon/experiments/rescaling/index-en.html#bicubic" target="_blank" rel="noopener">https://clouard.users.greyc.fr/Pantheon/experiments/rescaling/index-en.html#bicubic</a></p><a id="more"></a><h3 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h3><p>在处理图片的缩放问题时，需要解决的问题是：</p><ul><li>在放大过程中，新增的像素的颜色如何确定。</li><li>在缩小过程中，哪些像素需要被保留。</li></ul><h3 id="图形缩放"><a href="#图形缩放" class="headerlink" title="图形缩放"></a>图形缩放</h3><p>下面用一个1D的问题举例,如下图，y轴表示灰度图的灰度值:</p><p><img src="../images/SR/img_1d.png" alt=""></p><p>现在对这个图形进行进行放大，有两种做法：</p><ol><li>使用<strong>最近邻方法</strong>，用左边的像素填补这个位置的像素</li></ol><p><img src="../images/SR/upsample_7_23.png" alt=""></p><ol start="2"><li>使用线性插值的方法，利用前后位置的像素值生成该位置上的像素</li></ol><p><img src="../images/SR/interpolation_7_23.png" alt=""></p><p><strong>将这个问题一般化，我们通过引入卷积来完成这个操作。</strong>例如对于最近邻方法，可以使用[1,1,0]卷积核，对于插值法，可以使用[0.5,1,0.5]卷积核。</p><hr><p>与上述思路相同，我们将卷积核推广到2D的情况，同时在x和y方向上做卷积，各个像素的取值由卷积权重决定。</p><h4 id="Nearest-Neighbor-Resampling（最近邻采样）"><a href="#Nearest-Neighbor-Resampling（最近邻采样）" class="headerlink" title="Nearest Neighbor Resampling（最近邻采样）"></a>Nearest Neighbor Resampling（最近邻采样）</h4><p><img src="../images/SR/nnre.png" alt=""></p><p>用这种方式得到的图像块状比较明显，但是这种方法执行效率最快。</p><h4 id="Bilinear-Resampling-B-spline-order-1-（双线性插值）"><a href="#Bilinear-Resampling-B-spline-order-1-（双线性插值）" class="headerlink" title="Bilinear Resampling (B-spline order 1) （双线性插值）"></a>Bilinear Resampling (B-spline order 1) （双线性插值）</h4><p><img src="../images/SR/bilinear_7_23.png" alt=""></p><p>上诉公式是沿着x方向的线性差值的值，对于y方向同样用这种方式进行插值。</p><h4 id="Bicubic-Resampling-（双三次插值）"><a href="#Bicubic-Resampling-（双三次插值）" class="headerlink" title="Bicubic Resampling （双三次插值）"></a>Bicubic Resampling （双三次插值）</h4><p><img src="../images/SR/bicubic_7_23.png" alt=""></p><p>该方法需要选取的最近的16个像素点作为计算目标图像B(X,Y)处像素值的参数。每个位置的权重与像素值，以及像素的变化率有关。当a取-0.5是，bicubic函数有以下的形状：</p><p><img src="../images/SR/bicubic_shape_7_23.png" alt=""></p><p>该算法在各中图像的缩放过程中使用的最多。其中心点像素计算公式如下：<br>$$<br>\sum_{i=0}^{3} \sum_{j=0}^{3} a_{i j} x^{i} y^{j}<br>$$<br>其中参数a需要根据临近的四个点的像素值，偏导数等等来计算。具体的计算过程可以看<a href="https://en.wikipedia.org/wiki/Bicubic_interpolation" target="_blank" rel="noopener">wiki上的解释</a>。</p><hr><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>在处理具体问题时，我们知道一张图片在显示屏上是以点阵的方式排列的。当我们要放大，或者缩小时，例如用双三次插值时，对于每个像素点，无论是放大还是缩小，我们总能找到最邻近的16个位置，可以很方便的对图片进行缩放。此外，用卷积的方式进行求解，能够并行对图片进行处理，提高图片的处理效率。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图像尺度的放大，缩小是图形学中一个十分常见的问题。然而这个过程并不是无损的，缩放的过程是一个非线性的过程，因此存在许多算法在效率，平滑度，清晰度和速度上进行一些权衡（trade-off）。在图形的缩放过程中，存在插值，采样等一些关键的步骤，下面对一些在图像缩放过程中使用的算法进行简要的介绍，这些算法均有其优缺点。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;a href=&quot;https://clouard.users.greyc.fr/Pantheon/experiments/rescaling/index-en.html#bicubic&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://clouard.users.greyc.fr/Pantheon/experiments/rescaling/index-en.html#bicubic&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="super resolution" scheme="https://wenhui-zhou.github.io/categories/super-resolution/"/>
    
    
  </entry>
  
  <entry>
    <title>Deep Learning for image Super-resolution: a Survey</title>
    <link href="https://wenhui-zhou.github.io/2019/07/23/Deep-Learning-for-image-Super-resolution-a-Survey/"/>
    <id>https://wenhui-zhou.github.io/2019/07/23/Deep-Learning-for-image-Super-resolution-a-Survey/</id>
    <published>2019-07-23T02:48:22.000Z</published>
    <updated>2019-07-30T20:20:57.414Z</updated>
    
    <content type="html"><![CDATA[<p>本篇论文是2019年2月份，发表在arxiv上的篇关于超分辨率的一篇综述。这篇文章系统且全面的介绍了一些基于深度学习的超分辨率方法。其中包括：</p><ul><li>超分辨率问题的定义 (problem setting)</li><li>benchmark datasets</li><li>性能评价指标 (performance metrics)</li><li>基于深度学习的超分辨率方法</li><li>特定领域的超分辨率应用 (domain-specific application)</li></ul><p>此外作者对比每个超分辨率方法，指出了网络的优点以及局限。最后对该领域的一些开放性问题(open issuse) 以及挑战提出了未来研究的方向。</p><a id="more"></a><h3 id="超分辨率问题的定义（problem-setting）"><a href="#超分辨率问题的定义（problem-setting）" class="headerlink" title="超分辨率问题的定义（problem setting）"></a>超分辨率问题的定义（problem setting）</h3><p>图像的超分辨率要解决的问题是：从一张低分辨率（LR）的图像中，恢复出一张高分辨率（HR）的图像。</p><p>通常来说，我们通过下面的方式得到低分辨率的图像：<br>$$<br>I_{x}=\mathcal{D}\left(I_{y} ; \delta\right)<br>$$<br>$I_x$ 表示低分辨率图像，$I_y$ 表示高分辨率图像，$D()$ 表示下采样的映射函数，$\delta$ 表示映射函数的参数。图片清晰度不够的原因可能有很多种，例如聚焦，图片压缩，传感器噪声等问题。一些学者提出了下面的模型来模拟这种失真的映射。<br>$$<br>\mathcal{D}\left(I_{y} ; \delta\right)=\left(I_{y} \otimes \kappa\right) \downarrow_{s}+n_{\zeta},{\kappa, s, \zeta} \subset \delta<br>$$<br>$I_{y} \otimes \kappa$ 表示HR图片与模糊核（blur kernel）k的卷积操作，下箭头表示下采样，$n_{\zeta}$ 表示方差为$\zeta$ 的白高斯噪声。</p><hr><p>目前大多数的数据库，产生LR图像的方法是直接对SR图像做一些下采样(双三次插值算法(bicubic interpolation))，同时对图片作抗锯齿（anti aliasing），去模糊等操作(blur) 。关于下采样，上采样的一些方法可以看 <a href="http://eeweb.poly.edu/~yao/EL5123/lecture8_sampling.pdf" target="_blank" rel="noopener">这个课件</a>，或<a href="https://clouard.users.greyc.fr/Pantheon/experiments/rescaling/index-en.html#bicubic" target="_blank" rel="noopener">这里</a>。</p><p>关于超分问题，我们更关注的是如何由低分辨率的图片得到高分辨率的图片，即：<br>$$<br>\hat{I}_{y}=\mathcal{F}\left(I_{x} ; \theta\right)<br>$$<br>其中$\mathcal{F}()$ 为超分模型，由低分辨率图片生成高分辨率的图片。</p><p>对于一个典型的超分辨率问题来说，我们需要从一个LR图像中恢复出它的HR版本。模型的目标是最小化我们恢复出来的图片与原始HR图片的差距，<strong>目标方程</strong>如下：<br>$$<br>\hat{\theta}=\underset{\theta}{\arg \min } \mathcal{L}\left(\hat{I}_{y}, I_{y}\right)+\lambda \Phi(\theta)<br>$$<br>其中$\mathcal{L}\left(\hat{I}_{y}, I_{y}\right)$ 为生成的HR图像与原始图像的Loss，公式尾项是一个<strong>正则项</strong>。目前使用较多的loss为像素级别的MSE loss，同时一些组合型的loss也经常被使用。引入正则项的目的是控制参数的变化，使得网络更容易收敛。<a href="https://www.jianshu.com/p/70487abdf96b" target="_blank" rel="noopener">正则项可以看这里。</a></p><hr><h3 id="Benchmark-dataset"><a href="#Benchmark-dataset" class="headerlink" title="Benchmark dataset"></a>Benchmark dataset</h3><p>在一个典型的超分辨率的文章中，通常需要对一些公开数据集上进行试验，在这些公开数据集上的效果指标作为这个算法性能的评价标准。主要使用的数据集有：</p><p><img src="../images/SR/dataset_7_25.png" alt=""></p><hr><h3 id="Image-Quality-Assessment"><a href="#Image-Quality-Assessment" class="headerlink" title="Image Quality Assessment"></a>Image Quality Assessment</h3><p>图片质量的评价是一个与感知，视觉相关的问题。通常存在客观和主观的两类方法。其中客观方法根据指标计算模型直接计算得出，如MSE。主观方法则与人们的感知更为接近。下面介绍一下常用的评价方法。</p><h4 id="Peak-Signal-to-Noise-Ratio-峰值信噪比"><a href="#Peak-Signal-to-Noise-Ratio-峰值信噪比" class="headerlink" title="Peak Signal-to-Noise Ratio(峰值信噪比)"></a>Peak Signal-to-Noise Ratio(峰值信噪比)</h4><p>峰值信号比是一种图像的客观评价标准。他用最大值信号与背景噪声信号（重建与原始信号的差）的比值作为评价标准：<br>$$<br>\begin{aligned} \operatorname{MSE} &amp;=\frac{1}{N} \sum_{i=1}^{N}(I(i)-\hat{I}(i))^{2} \ \operatorname{PSNR} &amp;=10 \cdot \log _{10}\left(\frac{L^{2}}{\mathrm{MSE}}\right) \end{aligned}<br>$$<br>其中L为图像点颜色的最大数值，若采样点采样8位表示，那么L = 255。该指标更加注重像素点之间的误差。典型的<strong>PSNR值在20到40之间</strong>。指标越高越好。</p><p>但是由于PSNR指标更多的放映相同位置上像素值的差异，而未考虑到人眼的视觉感知，因此作为质量评价指标是存在缺陷的。但这个指标仍是目前使用最多的一个指标。</p><p><strong>人眼视觉特征</strong></p><ol><li>对空间频率较低的对比差异敏感度高</li><li>人眼对亮度对比差异的敏感度较色度高</li><li>人眼对一个区域的感知结果会影响到周围邻近区域</li></ol><hr><h4 id="SSIM（Structural-Similarity-结构相似性）"><a href="#SSIM（Structural-Similarity-结构相似性）" class="headerlink" title="SSIM（Structural Similarity 结构相似性）"></a>SSIM（Structural Similarity 结构相似性）</h4><p>SSIM分别从亮度，对比度，结构三个方面度量图片的相似性。</p><p>首先计算图片的mean和variance：<br>$$<br>\begin{aligned} \mu_{I} &amp;=\frac{1}{N} \sum_{i=1}^{N} I(i) \ \sigma_{I} &amp;=\left(\frac{1}{N-1} \sum_{i=1}^{N}\left(I(i)-\mu_{I}\right)^{2}\right)^{\frac{1}{2}} \end{aligned}<br>$$<br><strong>亮度</strong>（luminance）指标（$\hat{I}$ 指生成的图片）:<br>$$<br>\mathcal{C}_{l}(I, \hat{I})=\frac{2 \mu_{I} \mu_{\hat{I}}+C_{1}}{\mu_{I}^{2}+\mu_{\hat{I}}^{2}+C_{1}}<br>$$<br><strong>对比度（contrast）</strong>指标：<br>$$<br>\mathcal{C}_{c}(I, \hat{I})=\frac{2 \sigma_{I} \sigma_{\hat{I}}+C_{2}}{\sigma_{I}^{2}+\sigma_{\hat{I}}^{2}+C_{2}}<br>$$<br><strong>结构对比度（structure comparison）</strong>指标：<br>$$<br>\begin{aligned} \sigma_{I \hat{I}} &amp;=\frac{1}{N-1} \sum_{i=1}^{N}\left(I(i)-\mu_{I}\right)\left(\hat{I}(i)-\mu_{\hat{I}}\right) \ \mathcal{C}_{s}(I, \hat{I}) &amp;=\frac{\sigma_{I \hat{I}}+C_{3}}{\sigma_{I} \sigma_{\hat{I}}+C_{3}} \end{aligned}<br>$$<br>其中$C_1 = (K_1L)^2$,$C_2 = (K_2L)^2$,$C_3 = C_2 / 2$。</p><p>SSIM的指标有三面三个指标组合而成：<br>$$<br>\operatorname{SSIM}(I, \hat{I})=\left[\mathcal{C}_{l}(I, \hat{I})\right]^{\alpha}\left[\mathcal{C}_{c}(I, \hat{I})\right]^{\beta}\left[\mathcal{C}_{s}(I, \hat{I})\right]^{\gamma}<br>$$<br>通常使用下面这个形式：<br>$$<br>\operatorname{SSIM}(I, \hat{I})=\frac{\left(2 \mu_{I} \mu_{\hat{I}}+C_{1}\right)\left(\sigma_{I \hat{I}}+C_{2}\right)}{\left(\mu_{I}^{2}+\mu_{\overline{I}}^{2}+C_{1}\right)\left(\sigma_{I}^{2}+\sigma_{\tilde{I}}^{2}+C_{2}\right)}<br>$$<br>一般的，$k_1 = 0.01,k_2 = 0.03, L =255$。</p><p>此外还有一些主观的评价方法（mean opinion score），利用志愿者对生成图片的质量进行五个等级的评价，来确定图片的质量。</p><p>对于图片的颜色空间来说，常用的颜色空间有RGB空间与YCbCr。</p><hr><h3 id="基于有监督的超分辨率方法"><a href="#基于有监督的超分辨率方法" class="headerlink" title="基于有监督的超分辨率方法"></a>基于有监督的超分辨率方法</h3><h4 id="超分辨率框架分类"><a href="#超分辨率框架分类" class="headerlink" title="超分辨率框架分类"></a>超分辨率框架分类</h4><p>超分辨率框架总结下来有以下四种：</p><ol><li>Pre-upsampling Super-resolution</li><li>Post-upsampling Super-resolution</li><li>Progressive Upsampling Super-resolution</li><li>Iterative Up-and-down Sampling Super-resolution</li></ol><p>如下图：</p><p><img src="../images/SR/sr_structure_725.png" height="700px" width="600px"></p><p><strong>Pre-upsampling Super-resolution</strong></p><p>该方法在将图片送入网络前先用传统方法进行图片的放大（bicubic interpolation上采样），将图片放大到输出的要求大小，然后送入CNN网络中，学习一个端到端的从LR到HR的映射。</p><p>该方法的优点在于神经网络仅需要学习一张粗糙的（传统方法放大的）图片到HR图片的映射，大大降低了网络学习的难度；同时这种结构可以任意控制图片放大倍数。该方法框架也成为了一种较为主流的框架。</p><p>该方法的缺点在于：传统的图片放大算法中通常需要包含去噪，去模糊等操作，需要花费很大的时间以及空间。</p><hr><p><strong>Post-upsampling Super-resolution</strong></p><p>该方法将LR到HR的整个过程作为网络学习的目标，上采样层在网络的末端，这种设计可以极大发挥网络的潜力，同时能够显著降低网络训练时消耗的时间与空间。在train和inference阶段速度带来了很大的提升。</p><p>缺点：仅通过一个upsample层来放大图片，使得网络学习的难度大大提升；由于upsample层的放大尺度是固定的，如果更换一个倍数，就要更换一个训练模型。</p><hr><p><strong>Progressive Upsampling Super-resolution</strong></p><p>渐进式的上采样可以解决上诉post结构的问题（例如LapSRN网络 laplacian pyramid SR network）。该结构采用许多CNN的级联结构，每个阶段进行一个上采样重构HR，生成放大2倍，4倍，8倍等结果。</p><p>该模型的缺点是结构复杂，训练难度大等等。</p><hr><p><strong>Iterative Up-and-down Sampling Super-resolution</strong></p><p>该结构反复的放大，缩小图片，试图学习到一种后映射（back projection）的关系，该模型可以很好的学习到LR与HR之间的映射关系。基于该框架的网络DBPN也获得了NTIRE 2018的冠军。尽管这种up-down的结构设计标准还未确定，DBPN网络中存在着大量的复杂的结构设计以及繁重的人工设计过程，但是这种结构有很大的研究潜力。还需要进一步探索。</p><h4 id="传统插值算法"><a href="#传统插值算法" class="headerlink" title="传统插值算法"></a>传统插值算法</h4><ol><li>最近邻插值</li><li>线性插值</li><li>双三次插值</li></ol><p>详见<a href="www.baidu.com">这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇论文是2019年2月份，发表在arxiv上的篇关于超分辨率的一篇综述。这篇文章系统且全面的介绍了一些基于深度学习的超分辨率方法。其中包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;超分辨率问题的定义 (problem setting)&lt;/li&gt;
&lt;li&gt;benchmark datasets&lt;/li&gt;
&lt;li&gt;性能评价指标 (performance metrics)&lt;/li&gt;
&lt;li&gt;基于深度学习的超分辨率方法&lt;/li&gt;
&lt;li&gt;特定领域的超分辨率应用 (domain-specific application)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外作者对比每个超分辨率方法，指出了网络的优点以及局限。最后对该领域的一些开放性问题(open issuse) 以及挑战提出了未来研究的方向。&lt;/p&gt;
    
    </summary>
    
      <category term="super resolution" scheme="https://wenhui-zhou.github.io/categories/super-resolution/"/>
    
    
      <category term="论文阅读" scheme="https://wenhui-zhou.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
</feed>

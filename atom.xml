<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WenHuiZhou</title>
  
  <subtitle>perper（打起精神！）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wenhui-zhou.github.io/"/>
  <updated>2019-11-05T03:23:07.172Z</updated>
  <id>https://wenhui-zhou.github.io/</id>
  
  <author>
    <name>WenHuiZhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>推荐系统之用户标签数据(二)</title>
    <link href="https://wenhui-zhou.github.io/2019/11/05/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%94%A8%E6%88%B7%E6%A0%87%E7%AD%BE%E6%95%B0%E6%8D%AE-%E4%BA%8C/"/>
    <id>https://wenhui-zhou.github.io/2019/11/05/推荐系统之用户标签数据-二/</id>
    <published>2019-11-05T02:16:10.000Z</published>
    <updated>2019-11-05T03:23:07.172Z</updated>
    
    <content type="html"><![CDATA[<p>推荐系统的目的是链接用户的兴趣和物品，通常的连接方式可以通过：</p><ol><li>推荐与用户喜欢的物品相似的物品</li><li>推荐与用户兴趣相似的人所喜欢的物品</li><li>给用户推荐那些他喜欢的特征，例如利用用户标签</li></ol><p><strong>标签是一种无层次化结构的，用来描述信息的关键词，它可以用来描述物体的语义。</strong></p><a id="more"></a><h3 id="标签系统中推荐问题"><a href="#标签系统中推荐问题" class="headerlink" title="标签系统中推荐问题"></a>标签系统中推荐问题</h3><p><strong>用户为什么进行标注</strong></p><p>用户通常会给予社会维度、功能维度、传达信息的维度上对物品进行标注。</p><p><strong>用户如何打标签</strong></p><p>用户打标注的标签同样符合一个长尾分布，一些不流行的标签呈现一个长尾。</p><p><strong>用户打什么样的标签</strong></p><ul><li>表明物品是什么</li><li>物品的种类</li><li>用户的观点</li><li>谁拥有用户</li><li>用户相关的标签</li><li>用户的任务</li><li>类型</li><li>时间，人物，地点，语言，奖项</li></ul><h3 id="基于标签的推荐系统"><a href="#基于标签的推荐系统" class="headerlink" title="基于标签的推荐系统"></a>基于标签的推荐系统</h3><p><strong>数据的设计</strong></p><p>一个用户标签的行为的数据集一般由一个三元组的集合表示：(u,i,b)表示用户u给物品i打上了标签b。将数据随机分成10份，分割的键值是用户和物品，其中9份作为训练集，1份作为测试集。</p><p><strong>实验指标</strong></p><p>准确率、召回率、覆盖率、余弦相似度、新颖性（平均热门度）</p><p><strong>一个简单的算法</strong></p><p>利用用户标签进行个性化的推荐，一个直接的想法：</p><ol><li>统计每个用户最常用的标签</li><li>对每个标签，统计被打过这个标签次数最多的物品</li><li>对每个用户找到他最常用的标签，然后给他推荐具有这些标签的最热门的物品</li></ol><p>因此可以归纳出兴趣公式：<br>$$<br>p(u, i)=\sum_{b} n_{u, b} n_{b, i}<br>$$<br>$n_{u,b}$表示用户u打过标签b的次数，$n_{b,i}$ 表示物品i被打过b标签的次数。</p><p><strong>算法的改进：TF-IDF</strong></p><p>对于热门标签，它在许多物品上都有出现过，因此上述的公式对热门标签对应的热门物品给了过大的权重，系统将会倾向于推荐热门的物品，因此将降低推荐结果的新颖性，因此对<strong>热门标签</strong>进行惩罚：<br>$$<br>p(u, i)=\sum_{b} \frac{n_{u, b}}{\log \left(1+n_{b}^{(u)}\right)} n_{b, i}<br>$$<br>此外对<strong>热门物品</strong>进行惩罚：<br>$$<br>p(u, i)=\sum_{b} \frac{n_{u, b}}{\log \left(1+n_{b}^{(u)}\right)} \frac{n_{b, i}}{\log \left(1+n_{i}^{(u)}\right)}<br>$$<br><strong>数据稀疏性</strong></p><p>对于一些新用户或新物品，用户集合中的标签数量很小，可以我们可以将与已有标签相似的标签加入到用户标签中。</p><p>可以利用基于领域的方法，当两个标签同时出现在许多物品的标签集合中时，我们就可以认为这两个标签具有较大的相似度，可以使用余弦相似性进行计算，计算的方式时两个标签的交集除以他们的各自的平方开根号。<br>$$<br>\operatorname{sim}\left(b, b^{\prime}\right)=\frac{\sum_{i \in N(b) \cap V(b)} n_{b i} n_{b ; i}}{\sqrt{\sum_{i \in N(b)} n_{b, i}^{2} \sum_{i \in N(b)} n_{b^{\prime}, i}^{2}}}<br>$$<br><strong>标签清理</strong></p><p>有许多标签仅仅反应了用户的心情（例如不好笑），不能作为用户的兴趣，我们需要对这类标签进行过滤。去除一些停止词，同义词，等等方式去除不良标签。</p><h3 id="给用户推荐标签"><a href="#给用户推荐标签" class="headerlink" title="给用户推荐标签"></a>给用户推荐标签</h3><p>给用户推荐标签指给出一些选项供用户选择，这样的好处有：</p><ul><li>方便用户输入标签</li><li>提高标签的质量</li></ul><p><strong>如何给用户推荐标签</strong></p><ul><li>给用户推荐系统中推荐最热门的标签</li><li>给用户推荐物品i上最热门的标签</li><li>给用户推荐他常用的标签</li><li><strong>结合上述两种方法的加权结果</strong>（用得最多）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;推荐系统的目的是链接用户的兴趣和物品，通常的连接方式可以通过：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;推荐与用户喜欢的物品相似的物品&lt;/li&gt;
&lt;li&gt;推荐与用户兴趣相似的人所喜欢的物品&lt;/li&gt;
&lt;li&gt;给用户推荐那些他喜欢的特征，例如利用用户标签&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;标签是一种无层次化结构的，用来描述信息的关键词，它可以用来描述物体的语义。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="推荐系统" scheme="https://wenhui-zhou.github.io/categories/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>effective cpp (二) 构造、析构、赋值运算</title>
    <link href="https://wenhui-zhou.github.io/2019/11/02/effective-cpp-%E4%BA%8C-%E6%9E%84%E9%80%A0%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97/"/>
    <id>https://wenhui-zhou.github.io/2019/11/02/effective-cpp-二-构造、析构、赋值运算/</id>
    <published>2019-11-02T13:56:24.000Z</published>
    <updated>2019-11-05T07:46:36.715Z</updated>
    
    <content type="html"><![CDATA[<p>2019/11/02，effective cpp 第二章</p><ul><li>05条款：了解C++默默编写并调用哪些函数</li><li>06条款：若不想使用编译器自动生成的函数，就该明确拒绝</li><li>07 条款：为多态基类声明virtual 析构函数</li><li>08 条款：别让异常逃离析构函数（不传播）</li><li>09 条款：绝不在构造和析构过程中调用virtual函数</li><li>10 条款：令operator= 返回一个reference to *this</li><li>11 条款：在operator=中处理自我赋值</li><li>12 条款：复制对象时勿忘其每一个成分</li></ul><a id="more"></a><h3 id="05-条款：了解C-默默编写并调用哪些函数"><a href="#05-条款：了解C-默默编写并调用哪些函数" class="headerlink" title="05 条款：了解C++默默编写并调用哪些函数"></a>05 条款：了解C++默默编写并调用哪些函数</h3><p>在一个类中，当你自己没声明，C++编译器将会替你生成的函数有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">entry</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  entry()&#123;...&#125; <span class="comment">//默认构造函数</span></span><br><span class="line">  ~entry(<span class="keyword">const</span> entry&amp; rth)&#123;...&#125; <span class="comment">// copy 构造函数</span></span><br><span class="line">  ~entry()&#123;...&#125; <span class="comment">// 析构函数</span></span><br><span class="line">  entry&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> entry&amp; rhs)&#123;...&#125; <span class="comment">//等号运算符重载</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的四个函数，分别负责对象的创建和销毁工作。其中default和析构函数用于防止一些幕后的代码，如调用父类的构造函数等。</p><p>copy构造函数和等号函数，起到的作用是将对象内每一个元素拷贝到目标对象上。</p><p>存在一个例外，如果成员变量不可以改变值的时候，例如成员变量含引用的时候（string&amp; name;）,含有const成员的时候，由于这些类型初始化之后，不允许改变它的值，因此系统不会为这些类生成copy构造函数以及重载等号初始化。</p><p><strong>总结</strong></p><p>编译器可以暗自生成构造函数，析构函数，copy构造函数，copy assignment操作符。一些含reference，const成员的函数，将不会产生copy，等号重载这两个函数。</p><h3 id="06-条款：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#06-条款：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="06 条款：若不想使用编译器自动生成的函数，就该明确拒绝"></a>06 条款：若不想使用编译器自动生成的函数，就该明确拒绝</h3><p>某些情况你不希望对象具有copy，等号这些操作，你就该明确拒绝。<strong>可以将copy，copy assignment申明成private，并且故意不去实现他们</strong>（只有声明没有实现），这样就能有效的阻止人们调用它，同时当类的friend函数调用的时候，将返回连接错误。</p><p>此外，还可以继承一个不可拷贝的对象，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">homeforsale</span>:</span><span class="keyword">private</span> Uncopyable&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中Uncopyable的copy和copy assignment函数声明为private，而且未提供实现，这样可以将赋值的错误转移至编译期间。</p><p><strong>总结</strong></p><p>为了阻止编译器自动添加一些函数，可将相应的成员函数声明为private并且不写实现过程。使用Uncopyable这样的base class也是一种方法。</p><h3 id="07-条款：为多态基类声明virtual-析构函数"><a href="#07-条款：为多态基类声明virtual-析构函数" class="headerlink" title="07 条款：为多态基类声明virtual 析构函数"></a>07 条款：为多态基类声明virtual 析构函数</h3><p>例如一个基类实现了计时的功能，然后它派生出去的许多类，分别代表了不同特点的时钟。因此可以设计<strong>factory工厂方法</strong>，返回指针指向一个父类的计时对象，父类对象根据子类的指针类型得到一个子类的指针对象。</p><p>当我们通过上述的方法，生成了很多basic class指针（指向派生类），当我们希望回收内存的时候，使用delete方法释放内存，这时候C++只会调用basic class的non-virtual的析构函数。因此只对属于basic class部分的成员内存进行了释放，子类的内存无法得到释放。</p><p>解决上面的问题就是<strong>将basic class的析构函数定义为virtual</strong>，这样在释放指针所指空间的内存的时候，就可以就调用相应的子类的析构函数，销毁整个对象。</p><p>通常基类都会定义virtual的函数，供不同的子类指针调用，通常这类函数都需要有一个virtual的析构函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">entry</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">virtual</span> ~entry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不含virtual的类基本上也不会加virtual的析构函数，因为加上virtual之后函数器对象需要加上徐函数的指针表，对象的大小会增加。</p><p>也不要在程序中继承一些带有non-virtual析构函数的class，因此如何你打算回收这个对象的时候，往往没办法完全回收内存。</p><p>倘若你想要将基类设计成一个抽象类，即不能实例化的一class，你可以选择将析构函数做成一个纯虚的析构函数，并且提供一份空的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AWOV</span>&#123;</span></span><br><span class="line">  <span class="keyword">virtual</span> ~AWOV() = <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AWOV::AWOV()&#123;&#125; <span class="comment">// 提供一份空的实现</span></span><br></pre></td></tr></table></figure><p>当执行析构的时候，最深层的派生class的析构函数最先被调用，因此调用到AWOV这个类的析构函数。</p><p><strong>总结</strong></p><ul><li>含多态性质的base class应该声明一个virtual析构函数，如果class 带有任何virtual函数，他就应该拥有一个virtual析构函数。</li><li>classes的设计目的如果不是作为base classes使用，或不是为了具备多态性，就不该声明virtual</li></ul><h3 id="08-条款：别让异常逃离析构函数（不传播）"><a href="#08-条款：别让异常逃离析构函数（不传播）" class="headerlink" title="08 条款：别让异常逃离析构函数（不传播）"></a>08 条款：别让异常逃离析构函数（不传播）</h3><p>C++你并不能禁止析构函数吐出异常，因为例如在程序销毁的时候，析构函数将会销毁其构建的所有对象，当重复的对象在销毁的时候抛出异常，那么所有的这些对象在销毁的时候，都将会抛出异常，而多于一个异常被抛出的情况，将会导致不明确的行为。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBConn</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  ~DBConn()&#123;</span><br><span class="line">    db.close(); <span class="comment">// 在DBConn的析构函数中，将会调用db.close()，然而db.close可能会发生异常，导致不明确的事情</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>C++不喜欢析构函数吐出异常，这将导致函数的提前结束或出现不明确的行为</strong></p><p>因此，如果在析构函数中出现异常，函数应该选择吞下这个异常，而不是抛出异常。如果必须对这个异常进行处理的话，应该提供一个普通函数来处理这个异常，而不是在析构函数中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">DBConn::DBConn&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">try</span>&#123;bd.close();&#125;</span><br><span class="line">  <span class="keyword">catch</span>&#123;...&#125;&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">abort</span>(); <span class="comment">// 终止程序,主动对异常进行捕获，而不是抛出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者在一个普通函数中进行异常的捕获</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">  db.close();</span><br><span class="line">  closed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">~DBConn()&#123;</span><br><span class="line">  <span class="keyword">if</span>(!closed)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      db.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...)&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li>析构函数绝对不要吐出异常，如果一个被析构函数调用的函数可能抛出异常，那么析构函数应该去捕获异常，（try，catch）然后吞下它们或结束程序。</li><li>如果客户需要对某个函数在运行期间抛出的异常做出反应，那么class应该提供一个普通函数执行该操作。</li></ul><h3 id="09-条款：绝不在构造和析构过程中调用virtual函数"><a href="#09-条款：绝不在构造和析构过程中调用virtual函数" class="headerlink" title="09 条款：绝不在构造和析构过程中调用virtual函数"></a>09 条款：绝不在构造和析构过程中调用virtual函数</h3><p>在构造或析构函数中，如果在函数中调用虚函数，在子类的构造函数往回回溯的时候。这时候在父类中执行构造函数，构造函数内部的虚函数调用的是base class的版本，而不是子类的版本。</p><p><strong>在derived class对象的base class构造期间，对象的类型是base class，而不是derived class版本。</strong>如果使用了运行期类型信息，那么这时候也是base class的类型信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">transaction</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    transaction()&#123;</span><br><span class="line">      logtransaction(); <span class="comment">// 构造函数中的virtual函数只会使用base class（本类）的版本</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">logtransaction</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><p>在构造和析构期间不用调用virtual函数，因为这类调用从不下降至derived class（即这个版本的virtual函数不是你想要的那个。）</p><h3 id="10-条款：令operator-返回一个reference-to-this"><a href="#10-条款：令operator-返回一个reference-to-this" class="headerlink" title="10 条款：令operator= 返回一个reference to *this"></a>10 条款：令operator= 返回一个reference to *this</h3><p>关于重载等号=赋值运算符，由于赋值运算符可以连续赋值，形如：x=y=z=15，因此赋值运算符必须返回一个reference指向操作符的左侧实参，这是你为class需要遵循的协议：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> widget&amp; rhs)&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;       <span class="comment">// this调用=运算符，rhs为参数，返回this等于返回左边元素的引用</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 上述协议同样适用于+=，以及参数是其他类型的情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述写法只是一个协议，在CPP所有内置类型以及标准程序库中提供的类型都将共同准守。</p><p><strong>总结</strong></p><p>令赋值操作返回一个<code>reference to *this</code>的引用。</p><h3 id="11-条款：在operator-中处理自我赋值"><a href="#11-条款：在operator-中处理自我赋值" class="headerlink" title="11 条款：在operator=中处理自我赋值"></a>11 条款：在operator=中处理自我赋值</h3><p>自我赋值指的是自己给自己赋值的情况，这种情况通常出现在引用后指针的自我赋值上。例如一个类用来保存一个指针指向一块动态分配的位图：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">widget</span>&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  Bitmap* pb;</span><br><span class="line">  widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> widget&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">delete</span> pb;    <span class="comment">// 这种方式可能造成不安全，当pb和rhs.pb指向同一块地址的时候，两个指针的对象会被删除</span></span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的危险可以使用验证是否相同的方式来化解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">widget&amp; widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> widget&amp; rhs)&#123;</span><br><span class="line">  <span class="keyword">if</span>(*<span class="keyword">this</span> == &amp;rhs) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">     <span class="keyword">delete</span> pb; </span><br><span class="line">    pb = <span class="keyword">new</span> Bitmap(*rhs.pb);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//但是每次都要进行判断，效率不是很高，下面通过调换赋值的顺序，达到同样的效果</span></span><br><span class="line">widget&amp; widget::<span class="keyword">operator</span>=(<span class="keyword">const</span> widget&amp; rhs)&#123;</span><br><span class="line">  Bitmap* pOrig = pb;</span><br><span class="line">  pb = <span class="keyword">new</span> Bitmap(*rhs.pb);  <span class="comment">// 令pb指向一块新的pb的副本地址</span></span><br><span class="line">  <span class="keyword">delete</span> pOrig;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li>确保当对象自我赋值的时候，operator=有良好的行为，利用来源对象和目标对象的地址，语句的顺序等等，避免将自身对象删除。</li><li>确保当函数操作一个以上对象的时候，它的行为是正确的。</li></ul><h3 id="12-条款：复制对象时勿忘其每一个成分"><a href="#12-条款：复制对象时勿忘其每一个成分" class="headerlink" title="12 条款：复制对象时勿忘其每一个成分"></a>12 条款：复制对象时勿忘其每一个成分</h3><p>当我们为一个类写copy构造函数和copy assignment构造函数的时候，编译器则会有一个报复行为，就是当你的类中新添了成员变量的时候，而未修改copy构造函数为这个值赋值的时候，编译器也不会报错：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    Customer(<span class="keyword">const</span> Customer&amp; rhs);</span><br><span class="line">    Customer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Customer&amp; rhs);</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">&#125;</span><br><span class="line">Customer::Customer(<span class="keyword">const</span> Customer&amp; rhs):name(rhs.name)&#123;</span><br><span class="line">  <span class="keyword">do</span> something <span class="keyword">else</span>;</span><br><span class="line">&#125;</span><br><span class="line">Customer&amp; Customer::<span class="keyword">operator</span>=(<span class="keyword">const</span> Customer&amp; rhs)&#123;</span><br><span class="line">  name = rhs.name;</span><br><span class="line">  <span class="keyword">do</span> something <span class="keyword">else</span>;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码可以正常的执行，但是当加入一个<code>int age;</code>的成员变量的时候，如果你忘记修改了上面的copy，assignment函数，编译器也不会提醒你，因此：</p><p><strong>如果你为class添加了一个成员变量，你必须同时修改copy和assignment，否则编译器也不会提醒你。</strong></p><p>当你为一个子类函数重写copy和assignment函数的时候，这种事情仍然会发生：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span>:</span> <span class="keyword">public</span> Person&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    Customer(<span class="keyword">const</span> Customer&amp; rhs);</span><br><span class="line">    Customer&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Customer&amp; rhs);</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">&#125;</span><br><span class="line">Customer::Customer(<span class="keyword">const</span> Customer&amp; rhs):name(rhs.name)&#123;</span><br><span class="line">  <span class="keyword">do</span> something <span class="keyword">else</span>;</span><br><span class="line">&#125;</span><br><span class="line">Customer&amp; Customer::<span class="keyword">operator</span>=(<span class="keyword">const</span> Customer&amp; rhs)&#123;</span><br><span class="line">  name = rhs.name;</span><br><span class="line">  <span class="keyword">do</span> something <span class="keyword">else</span>;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Customer继承自Person对象，现实Customer的copy的时候没有对Person对象传递参数，那么编译器将会调用default构造函数，Person的数据并不会被拷贝到新的对象中，因此：</p><p><strong>我们在重写子类的copy函数的时候，需要调用base class 的copy函数。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Customer&amp; Customer(const Customer&amp; rhs):Person(rhs),name(rhs.name)&#123;</span><br><span class="line">  <span class="keyword">do</span> something <span class="keyword">else</span>;</span><br><span class="line">&#125;</span><br><span class="line">Customer&amp; Customer::<span class="keyword">operator</span>=(<span class="keyword">const</span> Customer&amp; rhs)&#123;</span><br><span class="line">  Person::<span class="keyword">operator</span>=(rhs);</span><br><span class="line">  <span class="keyword">do</span> something <span class="keyword">else</span>;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此当你编写一个copying函数，请确保（1）复制多有的local变量。（2）调用所有base classes内的适当copying函数。</p><p><strong>总结</strong></p><ul><li>copying函数应当确保复制对象内的所有成员变量，以及所有base class成分</li><li>不要尝试以某个copying函数实现另一个copying函数，可以将相同代码的部分单独提取出来，放到init函数中。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019/11/02，effective cpp 第二章&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;05条款：了解C++默默编写并调用哪些函数&lt;/li&gt;
&lt;li&gt;06条款：若不想使用编译器自动生成的函数，就该明确拒绝&lt;/li&gt;
&lt;li&gt;07 条款：为多态基类声明virtual 析构函数&lt;/li&gt;
&lt;li&gt;08 条款：别让异常逃离析构函数（不传播）&lt;/li&gt;
&lt;li&gt;09 条款：绝不在构造和析构过程中调用virtual函数&lt;/li&gt;
&lt;li&gt;10 条款：令operator= 返回一个reference to *this&lt;/li&gt;
&lt;li&gt;11 条款：在operator=中处理自我赋值&lt;/li&gt;
&lt;li&gt;12 条款：复制对象时勿忘其每一个成分&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="effective cpp" scheme="https://wenhui-zhou.github.io/categories/effective-cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>推荐系统之协同过滤（一）</title>
    <link href="https://wenhui-zhou.github.io/2019/11/02/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E4%B9%8B%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://wenhui-zhou.github.io/2019/11/02/推荐系统之协同过滤（一）/</id>
    <published>2019-11-02T05:34:08.000Z</published>
    <updated>2019-11-02T12:11:06.970Z</updated>
    
    <content type="html"><![CDATA[<p>基于领域的算法是推荐系统中最为基本的算法，这篇post主要针对其中重要的两类算法：基于用户的协同过滤，基于产品的协同过滤进行介绍。</p><a id="more"></a><h3 id="长尾效应"><a href="#长尾效应" class="headerlink" title="长尾效应"></a>长尾效应</h3><p>在需求曲线中，少量的需求会形成一条长长的尾巴，将所有非流行的需要累加起来，将会形成一个比流行市场还要庞大的市场。</p><p>长尾效应最直接的原因就是强调用户的个性化，将市场需求细分，这些小的需求市场的累积效应将形成巨大的理论。</p><p>推荐系统的一个迫切需求在于，存在信息过载以及用户需求不明显的问题，因此需要将用户感兴趣，或有潜在兴趣的商品推荐给用户。</p><h3 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h3><p>在介绍协同过滤之前，我们粗略设计一下算法的流程。</p><ul><li>将用户数据均匀成M（m = 8）份，挑选其中一份作为测试集。重复进行M次实验。（交叉验证，防止过拟合）</li><li>在训练集上训练用户兴趣模型，在测试集上进行预测，统计评测指标。</li><li>将M次实验结果的平均值作为最后的测评指标。</li></ul><h3 id="测评指标"><a href="#测评指标" class="headerlink" title="测评指标"></a>测评指标</h3><ul><li>召回率：recall = (用户感兴趣 与 推荐商品交集) / （推荐商品的总数）</li><li>准确率：precision = (用户感兴趣 与 推荐商品交集) / （用户感兴趣物品集合）</li><li>覆盖率：coverage = （推荐商品） / （总商品）</li><li>平均流行度：每个物品流行度的对数值（流行度满足长尾，取对数更加的稳定）</li><li>新颖度：新颖度可由流行度度量，负相关。</li></ul><h3 id="基于用户的协同过滤算法"><a href="#基于用户的协同过滤算法" class="headerlink" title="基于用户的协同过滤算法"></a>基于用户的协同过滤算法</h3><p>基于用户的协同过滤算法是推荐算法中最古老的算法，在1992年被提出（很年轻的领域）。主要包括两个部分：</p><ul><li>找到和目标用户兴趣相似的用户集合</li><li>找到这个集合中用户喜欢的，但目标用户中没有产生过行为的，推荐给目标用户</li></ul><p><strong>找出目标用户兴趣群</strong></p><p>如何判断两个用户的相似性，可以使用用户感兴趣物体N(u)的相似性来代替用户的相似性，使用Jaccard相似度，计算u，v用户的相似度：<br>$$<br>w_{u v}=\frac{|N(u) \cap N(v)|}{|N(u) \cup N(v)|}<br>$$<br>或者使用余弦相似度计算：<br>$$<br>w_{u v}=\frac{|N(u) \cap N(v)|}{\sqrt{|N(u)||N(v)|}}<br>$$<br>在具体的计算时，我们只关注两个用户之间存在交集的那部分商品：</p><ul><li><p>首先建立一个<strong>商品为表头的链表，链表上的节点是对该商品发生过行为的用户。</strong></p></li><li><p>随后建立一个<strong>用户与用户之间的相似矩阵</strong>，如果这两个用户出现在同一个链表中k次，则用户之间的数组值为k。相似矩阵作为余弦相似度的分子，总数作为分母，计算得到用户之间的相似度。</p></li><li>给目标用户提供与他相似度topK用户喜欢的产品。</li></ul><p><strong>用户相似性的改进：</strong></p><p>对于一些热门的产品，大家可能都会去购买，比如面包大家都会买，但是购买用户之间的相似性就天差地别了，换句话说，<strong>冷门商品更能说明用户兴趣</strong>，因此需要对热门商品进行惩罚：<br>$$<br>w_{u v}=\frac{\sum_{i \in N(u) \cap N(v)} \frac{1}{\log (1+|N(i)|)}}{\sqrt{|N(u)||N(v)|}}<br>$$<br>分子是u，v用户共同感兴趣的物品i，N(i)表示对i发生过行为的所有人的集合，i越热门惩罚越大。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于领域的算法是推荐系统中最为基本的算法，这篇post主要针对其中重要的两类算法：基于用户的协同过滤，基于产品的协同过滤进行介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="推荐系统" scheme="https://wenhui-zhou.github.io/categories/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>effective cpp（一）: 让自己习惯cpp</title>
    <link href="https://wenhui-zhou.github.io/2019/10/31/effective-cpp-%EF%BC%88%E4%B8%80%EF%BC%89-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFcpp/"/>
    <id>https://wenhui-zhou.github.io/2019/10/31/effective-cpp-（一）-让自己习惯cpp/</id>
    <published>2019-10-31T11:37:49.000Z</published>
    <updated>2019-11-02T13:51:11.697Z</updated>
    
    <content type="html"><![CDATA[<p>2019/10/31，effective cpp第一章：</p><ul><li>01条款：视c++为一个语言联邦</li><li>02条款：尽量以const, enum,inline替换 #define</li><li>03条款：尽可能使用 const</li><li>04条款：确定对象被使用前已被初始化</li></ul><a id="more"></a><h3 id="01-条款：视c-为一个语言联邦"><a href="#01-条款：视c-为一个语言联邦" class="headerlink" title="01 条款：视c++为一个语言联邦"></a>01 条款：视c++为一个语言联邦</h3><p>c++最初从c语言发展而来，最初的名称是c with classes，同时这们语言接受了很多的不同的观点，特性，和编程的设计。使得cpp有着巨大的弹性和威力，因此在cpp不同的语言领域内，将有不同的最优用法。</p><p>cpp有着四个主要的次语言：</p><ul><li>C语言，cpp很多编程上的特性继承至C语言</li><li>面向对象的C++：很多关于类的操作在这一部分引入</li><li>template C++：C++的范型编程，<strong>唯template适用</strong></li><li>STL：标准模板库，里头有着大量的容器，迭代器等</li></ul><p><strong>总结</strong></p><p>C++由上面四种次语言组成，不存在一组高效编程的守则，而是视适用的次语言而定。</p><h3 id="02-条款：-尽量以const-enum-inline替换-define"><a href="#02-条款：-尽量以const-enum-inline替换-define" class="headerlink" title="02 条款： 尽量以const, enum,inline替换 #define"></a>02 条款： 尽量以const, enum,inline替换 #define</h3><p>将cpp程序转化成机器能够看懂的语言，需要经过预处理，编译，汇编，链接这些步骤。<strong>#define</strong>在预处理阶段就会被处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define RATIO 1.25</span><br></pre></td></tr></table></figure><p>在编译器处理源代码阶段，define定义的符号将会被移走，因此RATIO可能根本就没进入<strong>符号表。</strong>当出现错误的时候，根据报错信息将很难定位错误，因此最好将define进行替换，也就是<strong>编译器替换预处理器。</strong></p><p><strong>符号表</strong></p><p>符号表在程序的编译阶段，将函数以及变量名地址记录起来，在链接阶段，根据符号表中记录的内容，去链接程序。</p><p><strong>用const替换define</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> ratio = <span class="number">1.25</span>;</span><br></pre></td></tr></table></figure><p>由于常量的定义经常在头文件之中，因此定义常量指针的时候，通常也将指针定义成const。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> author = <span class="string">"names"</span>;</span><br></pre></td></tr></table></figure><p>当我们需要创建一个类的常量的时候，需要在声明的时候，加一个static，使得这个常量只有一份实体，而且将这个常量的定义域限制在类内。</p><p>最后可以使用enum来代替define：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span>&#123;num1 = <span class="number">1</span>,num2 = <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; num1 &lt;&lt; num2;</span><br></pre></td></tr></table></figure><p>enum将数字符号化，也无法取到enum的地址。</p><p>此外，使用宏定义的另外一部分作用是定义一个简单的函数，避免函数调用带来的麻烦，同时不必要制定变量的类型（需要是同一个类别的），在宏定义的时候，注意为我每一个变量添加一个括号。</p><p>但是我们完全没必要去定义define，而是使用inline去替代：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">callwith</span><span class="params">(<span class="keyword">const</span> T&amp; a ,<span class="keyword">const</span> T&amp; b)</span></span>&#123;</span><br><span class="line">  f(a&gt;b ? a:b); <span class="comment">// 谁大调用谁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li>对于单纯的变量，使用const，enum替换define</li><li>对于宏定义的函数，改成template + inline的形式</li></ul><h3 id="条款-03：尽可能使用-const"><a href="#条款-03：尽可能使用-const" class="headerlink" title="条款 03：尽可能使用 const"></a>条款 03：尽可能使用 const</h3><p>const的原则，<strong>你在可以使用它的时候就使用它</strong>，</p><p>const 是一个语义的束缚，说明内容不可修改，因此只要有这样的一种约束在，就应该声明出来，获得编译器的协助。</p><p>const声明指针的时候有以下几种方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> greeting[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p = greeting; <span class="comment">// 指针所指内容为const</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span>* p = greeting; <span class="comment">// const在*左边，与上相同</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p = greeting; <span class="comment">// 指针为const，内容可变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p = greeting; <span class="comment">//指针，内容都不变</span></span><br></pre></td></tr></table></figure><p><strong>令函数的返回值为一个常量值，往往可以降低造成意外的风险</strong></p><p>函数的返回值，正常不应该作为一个变量来被其他赋值，因为这个不符合逻辑，如果可以被直接赋值的话，函数就没什么用了。因此对于大多数函数的返回值来说，可以加上const。</p><p><strong>const成员函数</strong></p><p>const成员函数指的是在一个类里头，这个函数用const进行了标注，表明这个函数是只读的不可以在函数内部对数据成员进行修改，格式如下,const在函数的最后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> position) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tex[position];</span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将函数定义成const，可以容易得知这个函数无法修改对象的值；同时使得操作const对象成为可能。</p><p><strong>真实程序中，const对象大多用于传参数，passed-by-pointer-to-const；passed-by-reference-to-const</strong>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">point</span><span class="params">(cosnt TextBlock&amp; ctb)</span></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ctb[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一些类中，const标注的函数其内部不允许对成员数据进行修改，但是也存在例外，<strong>mutable</strong>变量定义的变量将改变一些值的const属性，允许在const函数中修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">block</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">mutable</span> <span class="keyword">int</span> len;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> block::length() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">  len = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> len; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>const和non-const函数允许函数进行重载，</strong>但是在使用的时候应该避免写两个函数，而是在non-const函数中，通过类型的转换来调用const类型的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">block</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> position) <span class="keyword">const</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> position)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;(<span class="keyword">static_cast</span>&lt;cosnt block&amp;&gt;)(*<span class="keyword">this</span>)[position];</span><br><span class="line">    <span class="comment">// const_cast 去掉const</span></span><br><span class="line">    <span class="comment">// static_cast 将this转换为const类型，调用上一个函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li>const可以施加于任何作用域内的对象，函数参数，返回值，成员函数。</li><li>在能够使用const的时候尽量使用const，利用编译器规则为你排除错误。</li><li>编译器强制实行bitwise constness，编写程序的时候应该遵守逻辑上的const（避免const函数，有些指针是const，但是其内部的值可以修改）。</li><li>const和非const函数有本质上的相似的话，应该使用non-const的版本去调用，避免代码重复。</li></ul><h3 id="条款-04：确定对象被使用前已被初始化"><a href="#条款-04：确定对象被使用前已被初始化" class="headerlink" title="条款 04：确定对象被使用前已被初始化"></a>条款 04：确定对象被使用前已被初始化</h3><p>由于cpp是一个语言联邦，因此它并不保证所有的对象都会被初始化。因此：<strong>在使用对象之前先将对象进行初始化。</strong></p><p>特别值得注意的是，在对成员函数进行初始化时，在构造函数本体内进行的的并非初始化，而是赋值操作。<strong>cpp规定，对象的成员变量的初始化动作发生在进入构造函数本体之前。</strong>因此将成员初始化写在初始化成员列表中，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AB</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> aa;</span><br><span class="line">    <span class="keyword">int</span> bb;</span><br><span class="line">    AB(<span class="keyword">int</span> a,<span class="keyword">int</span> b);</span><br><span class="line">&#125;</span><br><span class="line">AB::AB(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;  <span class="comment">// 这种方式时赋值，初始化之后又做一遍赋值，效率很低</span></span><br><span class="line">  aa = a;</span><br><span class="line">  bb = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改版本如下：</span></span><br><span class="line">AB::AB(<span class="keyword">int</span> a,<span class="keyword">int</span> b):aa(a),bb(b)  <span class="comment">// 构造初始化表，效率比较高</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，对于不同单元内定义的static变量，他们的初始化次序是不确定的。static对象，他们的寿命从构造出来一直到函数的结束。定义在函数内部的称为local static，定义在其他地方位置的称为non-local static，由于定义在不同编译单元的non-local-static中初始化的顺序不同，如果另一个初始化单元，用到了一个未被初始化的static的话，可能会发生很不好的事情，因此：<strong>将每个non-local-static对象搬到自己的专属函数内，这些函数返回一个reference对象，然后指针直接调用这些函数。</strong>这样你在调用这个函数之前，这个变量将会被初始化。</p><p><strong>总结</strong></p><ul><li>为内置的对象进行初始化，cpp不会保证初始化</li><li>构造函数最好使用成员初始化列表的方式进行初始化，成员的次序应该于定义的顺序相同</li><li>为了免除<strong>跨编译单元初始化次序问题</strong>，最好将non-local-static变量变为local static，定义在函数内部，函数返回一个该对象的引用。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019/10/31，effective cpp第一章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;01条款：视c++为一个语言联邦&lt;/li&gt;
&lt;li&gt;02条款：尽量以const, enum,inline替换 #define&lt;/li&gt;
&lt;li&gt;03条款：尽可能使用 const&lt;/li&gt;
&lt;li&gt;04条款：确定对象被使用前已被初始化&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="effective cpp" scheme="https://wenhui-zhou.github.io/categories/effective-cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>FastFCN: 大工不巧</title>
    <link href="https://wenhui-zhou.github.io/2019/10/31/FastFCN-%E5%A4%A7%E5%B7%A5%E4%B8%8D%E5%B7%A7/"/>
    <id>https://wenhui-zhou.github.io/2019/10/31/FastFCN-大工不巧/</id>
    <published>2019-10-31T08:33:31.000Z</published>
    <updated>2019-11-04T01:39:04.869Z</updated>
    
    <content type="html"><![CDATA[<p>FastFCN是自动化所2019年cvpr上的一个工作，提出JPU模块，代替dilated conv，在保证网络精度的前提下，大大降低网络的计算复杂度，是的FPS得到提升。</p><p>这些年来计算机视觉得到广泛的发展，网络结构也越来越复杂，这篇文章做了一些下修改，可以说耳目一新，结构十分简单，结果十分有效。</p><a id="more"></a><h3 id="语义分割常用的提取feature-map"><a href="#语义分割常用的提取feature-map" class="headerlink" title="语义分割常用的提取feature map"></a>语义分割常用的提取feature map</h3><p><img src="/images/3D/fcn_struct.png" style="zoom:80%;"></p><p><strong>a）FCN结构：</strong>通过一个全卷积的网络，直接得到图像分割后的结果。缺点是图像中的特征丢失。</p><p><strong>b）encoder-decoder结构：</strong>encoder结构得到高层次的特征，decoder阶段通过结合多层次的特征来得到一个多尺度融合的feature map，缺点是仍然存在数据的丢失（pooling 结构）</p><p><strong>c） DilatedFCN：</strong>利用空洞卷积替换pooling层，扩大feature map感受野的同时，没有降低feature map的分辨率。但是这种结构导致了很大的计算量。</p><p>###JPU结构</p><p>作者提出JPU（joint pyramid upsampling）结构，替换DilateFCN中的空洞卷积结构，能够大大的减少内存以及时间上的消耗。</p><p><img src="/images/jpu.png" alt="image-20191101134143826" style="zoom:60%;"></p><p>###FastFCN结构 </p><p><img src="/images/fastfcn.png" alt="image-20191101134311586" style="zoom:50%;"></p><p>FastFCN的backbone采用的是原始的FCN的结构，将FCN的最后三层输入JPU模块中进行训练，最终在许多任务上都得到一个性能一致，但速度得到提升的网络。</p><p><strong>mIoU：</strong>对每一类计算真实标签和预测标签的交并比，然后对所有类别求一个平均得到最后的结果。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章对FCN的网络中的dilated conv进行了一个很小的修改，达到一个比较合理的结果，文章非常的简单，不过可能是因为过于简单的原因，文中也有许多可有可无的内容，总之，对于做工程来说，得到一个FPS比较快的网络还是比较好的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;FastFCN是自动化所2019年cvpr上的一个工作，提出JPU模块，代替dilated conv，在保证网络精度的前提下，大大降低网络的计算复杂度，是的FPS得到提升。&lt;/p&gt;
&lt;p&gt;这些年来计算机视觉得到广泛的发展，网络结构也越来越复杂，这篇文章做了一些下修改，可以说耳目一新，结构十分简单，结果十分有效。&lt;/p&gt;
    
    </summary>
    
    
      <category term="论文阅读" scheme="https://wenhui-zhou.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
</feed>

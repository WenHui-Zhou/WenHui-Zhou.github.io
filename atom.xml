<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WenHuiZhou</title>
  
  <subtitle>perper（打起精神！）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wenhui-zhou.github.io/"/>
  <updated>2019-11-30T19:33:32.693Z</updated>
  <id>https://wenhui-zhou.github.io/</id>
  
  <author>
    <name>WenHuiZhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NLP之transformer（二）</title>
    <link href="https://wenhui-zhou.github.io/2019/11/29/NLP%E4%B9%8Btransformer%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://wenhui-zhou.github.io/2019/11/29/NLP之transformer（二）/</id>
    <published>2019-11-29T12:53:17.000Z</published>
    <updated>2019-11-30T19:33:32.693Z</updated>
    
    <content type="html"><![CDATA[<p>NLP任务的输入往往是一句话或者是一篇文章，他有几个特点：</p><ul><li>输入是一个一维<strong>线性序列</strong></li><li>输入是<strong>不定长的</strong></li><li>输入单词的<strong>相对位置</strong>非常的重要</li><li>句子中的<strong>长特征</strong>对理解句子非常的重要（距离很远的词）</li></ul><p><strong>一个合格的特征抽取器应当很好的适配领域问题的特点，能够充分抽取数据中的特征。</strong></p><a id="more"></a><h3 id="NLP领域主要任务"><a href="#NLP领域主要任务" class="headerlink" title="NLP领域主要任务"></a>NLP领域主要任务</h3><p>该部分在上一篇文章中有简要提到，下面详细记录一下这些任务主要解决的问题：</p><ul><li>序列标注：这是NLP典型的任务，包括中文分词，词性标注，命名实体识别等等。<ul><li>特点：模型根据上下文给每个单词分配一个类别</li></ul></li><li>分类任务：常见有的文本分类和情感计算<ul><li>特点：不论文章多长，总体给出一个分类类别</li></ul></li><li>句子关系判断：问答系统，语义改写，自然语言推理<ul><li>特点：给出两个句子，判断这两个句子是否具有某种语义关系</li></ul></li><li>生成式任务：机器翻译，文本摘要，写诗造句，看图说话<ul><li>特点：输入文本后，需要自主生成另一段文字</li></ul></li></ul><p>从模型的角度来看，模型的特征抽取能力是至关重要的，下面开始详细介绍NLP的三个抽取器。</p><h3 id="久经沙场RNN"><a href="#久经沙场RNN" class="headerlink" title="久经沙场RNN"></a>久经沙场RNN</h3><p>RNN引入NLP之后，一直是一个明星模型，在各种模型中被广泛的应用。它采用线性序列结构不断从前往后收集输入信息。但是这种结构在反向传播过程中存在优化的困难。因为反向传播路径过长，导致严重的梯度消失或爆炸问题。于是很快建LSTM引入RNN作为标准模型中。</p><p><img src="/images/nlp/lstm.png" style="zoom:40%;"></p><p>下面是非常典型的使用RNN来解决NLP任务的基本框架：</p><p><img src="/images/nlp/rnn_frame.png" style="zoom:47%;"></p><p>RNN本身结构就是个可以接纳不定长输入的由前向后进行信息线性传导的网络结构，而在LSTM引入三个门后，对于捕获长距离特征也是非常有效的。所以RNN特别适合NLP这种线形序列应用场景，这是RNN在NLP界如此流行的根本原因。</p><p>但是对于RNN来说，来自一些新型的特征提取器的挑战，以及RNN并行能力差的问题，导致了它很可能被替代。</p><p><strong>RNN并性能力差的原因</strong>：RNNT时刻有两个输入，一个输入为当前的文本，另一个输入为T-1时刻隐藏层的输出S(T-1)，这是最能体现RNN的一点，RNN的历史信息就是通过这个传输渠道向后传的。因此T时刻计算依赖于T-1时刻的结果，因此网络必须按照时序的顺序一个一个往后走。</p><p>而CNN与transformers不存在这种问题，他们是天生的并行计算结构。</p><p>RNN在并行化上也做了一些工作，通常的做法有打断隐层的连接，或者打断部分的连接，层间并行。</p><h3 id="改造CNN"><a href="#改造CNN" class="headerlink" title="改造CNN"></a>改造CNN</h3><p>2014年CNN最早被引入NLP中：</p><p><img src="/images/nlp/kim_cnn.png" style="zoom:50%;"></p><p>每一行为一个单词的数值编码，卷积层将数值编码分割，在编码维度上移动，得到卷积后的特征，但仅仅在句子分类的任务上性能不错。</p><p>但是单个卷积层难以捕获远距离的特征，因此解决的方案<strong>有把卷积层做深；使用dilated 孔洞卷积。</strong>CNN能够捕获向量的位置信息，但是pooling结构通过会破坏掉这种顺序，因此通常使用全连接层替换掉pooling结构。</p><p>目前使用的比较多的CNN如下：</p><p><img src="/images/nlp/cnn.png" style="zoom:50%;"></p><p>上图是现代CNN的主体结构，通常由1-D的卷积层来叠加深度，使用skip-connection来辅助优化，也可以使用dilated等手段。CNN在nlp中的引入，能够保持数据间的时序信息，要设法将CNN的深度做起来。</p><h3 id="transformer结构"><a href="#transformer结构" class="headerlink" title="transformer结构"></a>transformer结构</h3><p>Transformer模型有很多好处，它改进了RNN最被人诟病的训练慢的缺点，利用self-attention机制实现快速并行。且Transformer可以增加到非常深的深度，充分发掘DNN模型的特性。下面具体的讲解一下transformer的机制。</p><p>下面通过引入一个NLP中经典问题的方式来解释这个结构：</p><blockquote><p>我们打算将英语翻译为西班牙语：</p><p><em>X = [‘Hello’, ‘,’, ‘how’, ‘are’, ‘you’, ‘?’] (Input sequence)</em><br><em>Y = [‘Hola’, ‘,’, ‘como’, ‘estas’, ‘?’] (Target sequence)</em></p></blockquote><p>transformer中encoder部分负责提取句子信息，decoder部分负责将encoder的输出与target相结合，得到接近target的翻译结果。</p><h3 id="transformer"><a href="#transformer" class="headerlink" title="transformer"></a>transformer</h3><p>transformer结构是一个由encoder，decoder，ski-connection，layerNorm，FF共同作用的一个结构，在数据特征提取上有着明显的优势。</p><p><img src="/images/nlp/transformer1.png" style="zoom:40%;"></p><p>编码和解码的部分分别都由六个编码器组件组合而成：</p><p><img src="/images/nlp/transformer2.png" style="zoom:30%;"></p><p>将encoder与decoder模块展开来看：</p><p><img src="/images/nlp/transformer4.png" style="zoom:43%;"></p><p>encoder部分由一个自注意力层和一个前向网络构成，其中自注意力层关注句子中的每一个单词对当前编码单词的关系。</p><p>decoder部分由三层构成，其中中间那一层，用来关注句子中的相关部分（和seq2seq类似）。</p><h3 id="decoder模块"><a href="#decoder模块" class="headerlink" title="decoder模块"></a>decoder模块</h3><p>decoder模块是对nlp数据提取特征的模块，将每一个编码器单元展开如下：</p><p><img src="/images/nlp/transformer3.png" style="zoom:50%;"></p><p><strong>数据流动</strong></p><ul><li>将单词转化成词向量（词向量的长度固定，BERT中为512），输入的维度：<strong>句子长度*词向量长度</strong></li><li>生成一个<strong>句子长度*词向量长度</strong>的位置编码信息，添加到输入中</li><li>输入数据经过N个encoder单元，生成<strong>句子长度*词向量长度</strong>大小的向量</li></ul><p>第一步对句子进行分词，将单词转化为词向量：</p><p><img src="/images/nlp/transformer5.png" style="zoom:53%;"></p><p>当我们训练一个batch的数据的时候，我们需要对一些较短的句子进行补充，通过在句首添加padding的方式，将句子长度对齐。</p><blockquote><p>[“<pad>”, “<pad>”, “<pad>”, “Hello”, “, “, “how”, “are”, “you”, “?”] →</pad></pad></pad></p><p>[5, 5, 5, 34, 90, 15, 684, 55, 193]</p></blockquote><p>第二步，对位置信息进行编码，然后将位置信息加入到输入当中，对位置信息进行编码采用以下的公式：</p><p><img src="/images/nlp/transformer6.png" style="zoom:73%;"></p><p>其中i表示y方向即每一个单词，j表示在词向量的长度（emb-dim）上的位置，因此最终得到下面的结果：</p><p><img src="/images/nlp/transformer7.png" style="zoom:45%;"></p><p>将输入与上面的位置编码相加，得到最终的输入数据。</p><p><strong>encoder block</strong></p><p>接下来进入encoder内部，编码器内部采用一层的自注意力层以及一个前向的全连接层。将数据输入编码器，首先遇到的是 <strong>multi-head attention</strong>结构。</p><p><strong>multi-head attention</strong>结构共同训练h次注意力层，这种做法能够扩展专注于不同位置的能力，同时给出了注意力层的多个表示子空间。</p><p>对于每一个head来说，我们训练三个向量，Q，K，V，与输入embedding向量相乘得到中间结果，用于最后计算每一个词最终的得分：</p><p><img src="/images/nlp/transformer8.png" style="zoom:70%;"></p><p>将上面的运算合并为矩阵运算，则算法如下：</p><p><img src="/images/nlp/transformer9.png" style="zoom:67%;"></p><p>利用上面的结果计算每个单词的得分：<br>$$<br>\begin{equation}<br>\text { Attention }(Q, K, V)=\operatorname{softmax}\left(\frac{Q K^{T}}{\sqrt{d_{k}}}\right) V<br>\end{equation}<br>$$<br><img src="/images/nlp/transformer10.png" style="zoom:67%;"></p><p>对于multi-head来说，我们将X输入h个head中，将会得到h个句子不同词之间的得分Z:</p><p><img src="/images/nlp/transformer11.png" style="zoom:67%;"></p><p>对于一个句子来说，我们只希望得到一组表示词语间的相互关系，于是我们将Z拼接起来，通过训练一个权重$W^0$使得最终得到一个 <strong>句子长度*词向量长度</strong>。</p><p><img src="/images/nlp/transformer12.png" style="zoom:60%;"></p><p>通过融合注意力机制的多头的结果，每个词与句子的其他成分之间的关系得到了充分的挖掘：</p><p><img src="/images/nlp/transformer13.png" style="zoom:70%;"></p><p>当我们计算出句子单词之间的注意力分布，下一步为添加残差后归一化：</p><p><img src="/images/nlp/transformer14.png" style="zoom:67%;"></p><p>完成残差之后是一个正向的全连接层（Free Forward），即一个两层的全连接层，第一层的激活函数为ReLU，第二层的激活函数为线性激活函数：<br>$$<br>\begin{equation}<br>\mathrm{FFN}(x)=\max \left(0, x W_{1}+b_{1}\right) W_{2}+b_{2}<br>\end{equation}<br>$$<br>其中W1位第一层，W2为第二层，max函数表示ReLU激活函数，b2为线性激活函数的偏移。最终的输出添加残差，归一化之后得到一个decoder的输出，随后将这个输出输入下一个decoder模块中，直到所有的模块都完成输出，将输出传至decoder模块。</p><h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><p>Decoder部分网络结构相比较于decoder部分，多出了一个encoder to decoder的模块，这个模块的的输入来自于decoder的输出：</p><p><img src="/images/nlp/transformer4.png" style="zoom:43%;"></p><p>encoder和decoder中信息传播如下：</p><p><img src="/images/nlp/transformer15.png" style="zoom:43%;"></p><p>每一个decoder模块都将接受encoder的输出。Decoder的一个单元具体结构如下：</p><p><img src="/images/nlp/transformer16.png" style="zoom:43%;"></p><p><strong>数据流动</strong></p><ul><li>首先将target进行分词，编码成词向量，维度为 <strong>target句子长度*词向量长度</strong></li><li>将第一步得到的数据输入N个Decoder模块中，在每次迭代过程中，接收decoder的输出作为一个额外的输入，最终得到的输出维度为 <strong>target句子长度*词向量的长度</strong></li><li>将decoder得到的输出，输入到一个全连接层，并且每一层做一个逐行的softmax，最终得到的输出是翻译的结果，即维度为<strong>句子长度*每个单词的长度</strong></li></ul><p><strong>输入</strong></p><p>由于input的句子长度和target的句子的长度不一致，因此首先对target句子分词后，进行偏移：</p><blockquote><p><em>[“Hola”, “, “, “como”, “estás”, “?”]→[“”, “Hola”, “, “, “como”, “estás”, “?”]</em></p></blockquote><p><strong>train vs test</strong></p><p>train阶段和test阶段对于decoder部分来说有一个重要的差别：</p><ul><li>在test阶段，我们不知道groundTruth，因此我们将会根据之前给出的单词来预测当前位置的单词，即无法使用当前位置之后的单词的信息。</li><li>在train阶段，我们知道GT，我们会直接告诉模型我们的target是什么，然后根据和test一样的顺序进行预测，但是这将会出现一个问题，<strong>模型可能根据target句子本身的位置关系来预测target，也就是使用了target的信息</strong>，这是不允许的，因为在实际情况中我们不可能提前知道target，因此这样的训练是不充分的。</li></ul><p>因此我们在Decoder的训练阶段必须消除target提供当前词之后的词所提供的信息。例如下面例子，当要预测estás的时候，我们就只能使用绿色部分所使用的信息，而红色部分的信息不能使用：</p><p><img src="/images/nlp/transformer17.png" style="zoom:63%;"></p><p>为了解决上面这个问题，我们提出了mask multi-head attention，即对output的数据进行处理。</p><p><strong>mask multi-head attention</strong></p><p>首先通过与encoder相同的操作，即multi-head attention得到一个 <strong>target句子长度*词向量</strong>的一个输出矩阵，<strong>然后进行mask操作，即将矩阵右上角的数值置为负无穷。</strong></p><p>原始multi head结果：</p><p><img src="/images/nlp/transformer18.png" style="zoom:73%;"></p><p>mask后的结果：</p><p><img src="/images/nlp/transformer19.png" style="zoom:73%;"></p><p>这就意味着当前单词的预测无法使用其后出现的单词信息。</p><p><strong>Encoder to decoder</strong></p><p>将上述的输出添加输入以及归一化之后，输入到下一层encoder to decoder，这一部分接受的输入由两部分组成，第一部分就是decoder的第一阶段的输出，另一个部分就是encoder最终的输出。</p><p>与decoder同样的操作，我们训练三个向量，Q，K，V，与输入embedding向量相乘得到中间结果，用于最后计算每一个词最终的得分，唯一的不同在于这三个向量使用的训练数据不同，如下图：</p><p><img src="/images/nlp/transformer20.png" style="zoom:73%;"></p><p><strong>即Q向量由decoder第一阶段的数据来训练，K，V由encoder最后输出的数据来训练。</strong></p><p>同样的利用与encoder相同的attention公式计算每一个词与句子中其他的成分的关系：<br>$$<br>\begin{equation}\text { Attention }(Q, K, V)=\operatorname{softmax}\left(\frac{Q K^{T}}{\sqrt{d_{k}}}\right) V\end{equation}<br>$$<br>接下来与encoder相同，训练h个head，然后组合在一起通过一个$W^0$矩阵进行组成得到输出，最后传入decoder模块的第三阶段，即全连接层进行前向的传播。</p><p><strong>linear and softmax</strong></p><p>重复上面decoder的基础模块N次，最后得到的输出的维度为 <strong>target句子长度*词向量长度</strong>，然后将这个向量输入一个linear全连接层中，全连接层输出的维度为翻译后句子的真实长度，其实际含义在对每一个词赋予一个权重：<br>$$<br>\begin{equation}<br>x W_{1}<br>\end{equation}<br>$$<br>最后，将上面的输出输入到softmax当中，计算出当前位置上，所有可能出现的翻译的结果的概率，然后根据最大的概率得到模型预测的翻译的结果：</p><p><img src="/images/nlp/transformer21.png" style="zoom:83%;"></p><p>根据第一行的结果，我们可以判断，ss对应的翻译是hello。</p><p>最后放一张encoder和decoder的合照，以便于回顾transformer的各种细节：</p><p><img src="/images/nlp/transformer22.png" style="zoom:43%;"></p><h3 id="inference"><a href="#inference" class="headerlink" title="inference"></a>inference</h3><ul><li><a href="https://medium.com/dissecting-bert/dissecting-bert-appendix-the-decoder-3b86f66b0e5f" target="_blank" rel="noopener">https://medium.com/dissecting-bert/dissecting-bert-appendix-the-decoder-3b86f66b0e5f</a></li><li><a href="https://jalammar.github.io/illustrated-transformer/" target="_blank" rel="noopener">https://jalammar.github.io/illustrated-transformer/</a></li><li><a href="https://zhuanlan.zhihu.com/p/54356280" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/54356280</a></li><li><a href="https://zhuanlan.zhihu.com/p/54743941" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/54743941</a></li><li><a href="https://medium.com/dissecting-bert/dissecting-bert-part-1-d3c3d495cdb3" target="_blank" rel="noopener">https://medium.com/dissecting-bert/dissecting-bert-part-1-d3c3d495cdb3</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NLP任务的输入往往是一句话或者是一篇文章，他有几个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入是一个一维&lt;strong&gt;线性序列&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;输入是&lt;strong&gt;不定长的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;输入单词的&lt;strong&gt;相对位置&lt;/strong&gt;非常的重要&lt;/li&gt;
&lt;li&gt;句子中的&lt;strong&gt;长特征&lt;/strong&gt;对理解句子非常的重要（距离很远的词）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;一个合格的特征抽取器应当很好的适配领域问题的特点，能够充分抽取数据中的特征。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NLP" scheme="https://wenhui-zhou.github.io/categories/NLP/"/>
    
    
  </entry>
  
  <entry>
    <title>NLP之Word2Vec（一）</title>
    <link href="https://wenhui-zhou.github.io/2019/11/29/NLP%E4%B9%8BWord2Vec%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://wenhui-zhou.github.io/2019/11/29/NLP之Word2Vec（一）/</id>
    <published>2019-11-29T06:53:18.000Z</published>
    <updated>2019-11-29T12:52:45.793Z</updated>
    
    <content type="html"><![CDATA[<p>NLP领域有着四个比较大的方向：</p><ul><li>文本分类</li><li>序列标注</li><li>文本匹配</li><li>文本生成</li></ul><p>在NLP里头，最细粒度的就是 <strong>词语</strong>，由词语组成句子，由句子组成文章继而表达一些语言层面上的含义。因此本文从NLP的根源问题 <strong>词语表达</strong> 开始讲起，即word2vec，NLP领域重要的预训练方法。</p><a id="more"></a><h3 id="word2vec考古史"><a href="#word2vec考古史" class="headerlink" title="word2vec考古史"></a>word2vec考古史</h3><p>Word2vec最早出现是以一个副产品的身份出现的。它是在实现语言模型过程中出现的<strong>一个惊喜的意外</strong>。简而言之，就是在做实现语言模型的过程中，我们得到了词语的数值表达，这也就是word2vec的精髓。</p><p><strong>词语是人类对语言在符号上的抽象总结，通过word2vec，将符号语言转化为数值表达，方便计算机寻找语言背后的抽象逻辑。</strong></p><p><strong>语言模型</strong></p><p>生成word2vec的语言模型是个什么东西呢？如下图：</p><p><img src="/images/nlp/language_model.png" style="zoom:50%;"></p><p>语言模型就是量化的衡量哪一个句子更像是人说的，核心函数p的思想是说，通过一系列的前导词，预测出后面跟着哪一个词的概率最大。</p><p><strong>数据的输入问题</strong>，第一步是将每个词用一个向量来唯一表示（<strong>one-hot</strong>），然后才可能对这个向量进行编码，得到具有语言意义的一个向量（<strong>word2vec</strong>）。</p><p><strong>one-hot</strong>的实现过程为建立一个长度为V的表，假设这个V表示世界上所有词语的词语。当我们对出现的一个词语进行编码的时候，只需要将这个词语出现的位置置为1，其他为0，即得到了这个<strong>词语的唯一表达（one-hot形式）。</strong></p><p><strong>语言网络的设计</strong>，加入你设计出了如下的结构：</p><p><img src="/images/nlp/nnlm.png" style="zoom:50%;"></p><p>这就是大名鼎鼎的神经网络语言模型，由Bengio 2003发表在JMLR上，2013年深度学习升温后，才慢慢进入了神坛。</p><p>他的核心思想即是最大似然估计的思想：<br>$$<br>\begin{equation}<br>\left.P\left(W_{t}=\operatorname{‘Bert’} | W_{1}, W_{2}, \ldots W_{(} t-1\right) ; \theta\right)<br>\end{equation}<br>$$<br>即如果当前位置出现了’Bert‘，要求网络预测前t-1的参数，使得当前出现Bert的概率最大。网络的输入，我们最初说使用one-hot的形式，但是为了另其具有语言的含义，我们在将词语输入网络之前，使用矩阵Q进行语义上的转换。从而得到词语的word embedding表达。</p><p>矩阵Q就是所谓的word2vec的转换矩阵，它包含V行，每一行表示一个单词的vector值，有一点值得注意的是，Q矩阵一开始是用随机值进行初始化的，矩阵Q参与网络的训练，当网络训练好之后，矩阵Q就被正确赋值了。</p><p>word2vec有两种训练方式：</p><ul><li>CBOW：从一个句子中将一个词抠掉，用这个词的上下文去预测这个词。</li><li>skip-gram：用一个词去预测这个词的上下文。</li></ul><h3 id="ELMO克服word2vec的多义词缺陷"><a href="#ELMO克服word2vec的多义词缺陷" class="headerlink" title="ELMO克服word2vec的多义词缺陷"></a>ELMO克服word2vec的多义词缺陷</h3><p>word2vec对下游的nlp任务有一些帮助，但是帮助却不是那么大。一个比较严重的问题在于<strong>多义词的问题</strong>，例如bank这个单词，可以指银行也可以指河床，但是在矩阵Q中，这个单词只有一种特征的编码。</p><p>如何解决这个问题呢，ELMO模型提出了一种想法，<strong>利用上下文场景来确定多义词的语义。</strong></p><p><strong>ELMO的本质思想是：</strong>事先用语言模型学好一个单词的Word Embedding，此时多义词无法区分。在下游任务中，实际使用Word Embedding的时候，单词已经具备了特定的上下文，这个时候<strong>可以根据上下文单词的语义去调整单词的Word Embedding表示</strong>，经过调整后的Word Embedding更能表达在这个上下文中的具体含义，即确定了多义词的具体语义。</p><p><img src="/images/nlp/elmo.png" style="zoom:50%;"></p><p>ELMO采用典型的两阶段：</p><ul><li>第一个阶段利用语言模型进行word embedding的预训练</li><li>第二个阶段是提取对应单词网络各层的word embedding作为新特征，补充到下游任务中</li></ul><p>上图是第一阶段的预训练过程，网络结构采用双层的word embedding作为新特征补充到任务中。网络结构采用双层的LSTM，左端正向表示正向的编码器。右边逆向，表示逆向的编码器。从两个方向来预测扣掉的那一个词。</p><p>使用这个网路，每次输入一个句子网络将会输出三个向量，分别是 <strong>单词特征，句法特征，语义特征。</strong></p><p>这三个特征如何使用呢，在下游的任务中，我们给每一个vector一个权重，然后将三个特征相加，整合成一个特征输入下游的任务中。这个权重需要通过网络的学习得到。EMLO效果相比较于传统的word2vec性能上得到了比较明显的提升。</p><p><img src="/images/nlp/elmo_use.png" style="zoom:50%;"></p><p>ELMO有什么缺点呢：</p><ul><li>LSTM抽取特征的能力远弱于transformer</li><li>拼接方式双向融合特征，融合能力偏弱</li></ul><p>接下来，我将在另外的文章中介绍transformer。</p><h3 id="inference"><a href="#inference" class="headerlink" title="inference"></a>inference</h3><p><a href="https://zhuanlan.zhihu.com/p/49271699" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/49271699</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NLP领域有着四个比较大的方向：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文本分类&lt;/li&gt;
&lt;li&gt;序列标注&lt;/li&gt;
&lt;li&gt;文本匹配&lt;/li&gt;
&lt;li&gt;文本生成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在NLP里头，最细粒度的就是 &lt;strong&gt;词语&lt;/strong&gt;，由词语组成句子，由句子组成文章继而表达一些语言层面上的含义。因此本文从NLP的根源问题 &lt;strong&gt;词语表达&lt;/strong&gt; 开始讲起，即word2vec，NLP领域重要的预训练方法。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>effective cpp(九)杂项讨论</title>
    <link href="https://wenhui-zhou.github.io/2019/11/26/effective-cpp-%E4%B9%9D-%E6%9D%82%E9%A1%B9%E8%AE%A8%E8%AE%BA/"/>
    <id>https://wenhui-zhou.github.io/2019/11/26/effective-cpp-九-杂项讨论/</id>
    <published>2019-11-26T13:34:29.000Z</published>
    <updated>2019-11-26T14:21:37.864Z</updated>
    
    <content type="html"><![CDATA[<p>2019/11/26 effective cpp 第九章 杂项讨论</p><p>这是这本书的最后一章，今晚应该就能够阅读完！在开始阅读之前，我想感慨一下，最后的几章难度太大，一知半解的看下来，我想原因是相关张章节的实践不多导致的，因此日后有需要要回来重新阅读它们，时间很快大概花了一个月的空闲时间来阅读这本书，收获满满！</p><p>这一章主要说了三个问题：编译器的警告要重视；C++标准库的一个总览；boost一个泛用性C++库的总览。</p><ul><li>53 条款：不要轻视编译器的警告</li><li>54 条款：让自己熟悉包括TR1在内的标准程序库</li><li>55 条款：让自己熟悉Boost</li></ul><a id="more"></a><h3 id="53-条款：不要轻视编译器的警告"><a href="#53-条款：不要轻视编译器的警告" class="headerlink" title="53 条款：不要轻视编译器的警告"></a>53 条款：不要轻视编译器的警告</h3><p>编译器作者在触发一个warning的时候，他比你更加明白将来会发生什么严重的错误，因此我们需要在对待编译器警告的时候更加的小心。</p><p>当出现一个编译器warning的时候，我们应该需要知道它的意图以及真正的意义。</p><p><strong>总结</strong></p><ul><li>严肃对待编译器发出的警告，争取无警告荣誉</li><li>不要过度依赖编译器的报警功能，因为不同的编译器对待事情的反应是不同的</li></ul><h3 id="54-条款：让自己熟悉包括TR1在内的标准程序库"><a href="#54-条款：让自己熟悉包括TR1在内的标准程序库" class="headerlink" title="54 条款：让自己熟悉包括TR1在内的标准程序库"></a>54 条款：让自己熟悉包括TR1在内的标准程序库</h3><p>C++standard定义了C++语言及其标准程序库的规范，里头包含以下：</p><ul><li>STL 标准模板库</li><li>Iostream</li><li>国际化支持</li><li>数值处理</li><li>C89标准程序库</li><li>异常阶层体系</li></ul><p>此外C++的新特性被记录在TR1的文档内，在下一次更新将会加入到标准库中。</p><p><strong>总结</strong></p><ul><li>C++标准库的主要机能由STL，iostreams，locates组成。并包含C99标准程序库。</li><li>TR1添加了智能指针，一般化函数指针，hash-based容器，正则表达式以及另外10个组件的支持</li><li>TR1自身只是一份规范。</li></ul><h3 id="55-条款：让自己熟悉Boost"><a href="#55-条款：让自己熟悉Boost" class="headerlink" title="55 条款：让自己熟悉Boost"></a>55 条款：让自己熟悉Boost</h3><p>如果你在找一个高质量，源码开放，平台独立，编译器独立的程序库，那么Boost是一个很好地选择。他的网址是：<a href="">http://boost.org</a>。</p><p><strong>总结</strong></p><ul><li>Boost是一个社群，也是一个网站，致力于免费，源码开放，同僚复审的C++程序库开发。Boost在C++标准化过程中扮演深居影响力的角色。</li><li>Boost提供许多TR1组件实现品，以及其他许多程序库。</li></ul><p>最后告诫一下自己，熟悉STL，在开始用C++写一个东西之前，应当要过一遍这9篇博客！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019/11/26 effective cpp 第九章 杂项讨论&lt;/p&gt;
&lt;p&gt;这是这本书的最后一章，今晚应该就能够阅读完！在开始阅读之前，我想感慨一下，最后的几章难度太大，一知半解的看下来，我想原因是相关张章节的实践不多导致的，因此日后有需要要回来重新阅读它们，时间很快大概花了一个月的空闲时间来阅读这本书，收获满满！&lt;/p&gt;
&lt;p&gt;这一章主要说了三个问题：编译器的警告要重视；C++标准库的一个总览；boost一个泛用性C++库的总览。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;53 条款：不要轻视编译器的警告&lt;/li&gt;
&lt;li&gt;54 条款：让自己熟悉包括TR1在内的标准程序库&lt;/li&gt;
&lt;li&gt;55 条款：让自己熟悉Boost&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="effective cpp" scheme="https://wenhui-zhou.github.io/categories/effective-cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>effective cpp(八)定制new和delete</title>
    <link href="https://wenhui-zhou.github.io/2019/11/25/effective-cpp-%E5%85%AB-%E5%AE%9A%E5%88%B6new%E5%92%8Cdelete/"/>
    <id>https://wenhui-zhou.github.io/2019/11/25/effective-cpp-八-定制new和delete/</id>
    <published>2019-11-25T13:40:42.000Z</published>
    <updated>2019-11-26T13:31:52.371Z</updated>
    
    <content type="html"><![CDATA[<p>2019/11/25 effective cpp 第8章 定制new和delete</p><p>C++在内存管理，垃圾回收机制上常常受到人们的讨论。下面这一章将讨论C++的内存管理例程。</p><ul><li>49 条款：了解new-handler的行为</li><li>50 条款：了解new和delete的合理替换时机</li><li>51 条款：编写new和delete时需固守常规</li><li>52 条款：写了placement new也要写placement delete</li></ul><a id="more"></a><h3 id="49-条款：了解new-handler的行为"><a href="#49-条款：了解new-handler的行为" class="headerlink" title="49 条款：了解new-handler的行为"></a>49 条款：了解new-handler的行为</h3><p>当operator new无法满足某一内存分配的需求时，它将会抛出异常。当operator new发生异常，它会先调用一个客户指定的错误处理函数，即new-handler函数。为了指定这个用以处理内存不足的函数，客户必须调用set_new_handler，那是声明与<code>&lt;new&gt;</code>的一个标准程序库函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出来new_handler是一个typedef。定义出一个指向函数的指针，该函数没有返回任何东西，set_new_handler则是接受一个指针，返回一个指针，并且不允许抛出任何的异常。</p><p>Set_new_handler的使用方式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outOfMem</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"unable doing something"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">abort</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::set_new_handler(outOfMem);</span><br><span class="line">  <span class="keyword">int</span>* pBig = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">12323232333333</span>];</span><br><span class="line">  <span class="comment">// 当new无法分配这么多空间的时候，将会去调用outOfMem报错。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现new-handler的时候，有几点注意：</p><ul><li><strong>让更多的内存可被使用</strong>，一个做法是程序开始执行的时候就分配了一大块内存，当调用handler的时候，释放给程序使用</li><li><strong>安装另一个new-handler</strong>，如果目前这个new-handler无法处理这个异常，它可以通过调用其他的handler来分配内存。</li><li><p><strong>卸除new-handler</strong>，就是讲null指针传给set_new_handler，一旦没有安装任何new-handler，operator new会在内存分配不成功时抛出异常。</p></li><li><p><strong>跑出bad_alloc异常，</strong>这样的异常不会被operator new捕获，因此会被传播到内存索求处。</p></li><li><strong>不返回</strong>，通常调用abort，exit来中断程序。</li></ul><p><strong>总结</strong></p><ul><li>set_new_handler允许客户指定一个函数，在内存分配无法获得满足时被调用</li><li>Nothrow new是一个颇为局限的工具，因为它只适用于内存分配，后续的构造函数调用还是可能抛出异常。</li></ul><h3 id="50-条款：了解new和delete的合理替换时机"><a href="#50-条款：了解new和delete的合理替换时机" class="headerlink" title="50 条款：了解new和delete的合理替换时机"></a>50 条款：了解new和delete的合理替换时机</h3><p>通常我们选择替换new和delete会出于几个原因：</p><ul><li>用于检测运用上的错误</li><li>为了强化效能</li><li>为了收集使用上的统计数据</li></ul><p>此外，在了解何时可在 <strong>全局性</strong>或 <strong>class专属的</strong>基础上合理替换缺省的new和delete：</p><ul><li>为了检测运用上的错误</li><li>为了手机动态分配内存之使用统计信息</li><li>为了增加分配和归还的速度</li><li>为了降低缺省内存管理器带来的空间额外开销</li><li>为了弥补缺省分配器中的非最佳齐位</li><li>为了将相关对象成簇集中</li><li>为了获得非传统的行为</li></ul><p><strong>总结</strong></p><p>有许多理由需要写个自定义的new和delete，包括改善效能，对heap运用错误进行调试，收集heap使用信息。</p><h3 id="51-条款：编写new和delete时需固守常规"><a href="#51-条款：编写new和delete时需固守常规" class="headerlink" title="51 条款：编写new和delete时需固守常规"></a>51 条款：编写new和delete时需固守常规</h3><p>让我们从实现operator new开始，实现一致性operator new必须返回正确的值，内存不足的时候必须调用new-handling函数，必须有对付零内存需求的准备，还需避免不慎掩盖正常形式的new。</p><p>operator new其实比较单纯，如果能够申请到空间，就返回正确的值，如果申请不到空间就返回一个bad-alloc。但是他也有不单纯的一面，因为operator不止一次的申请内存，如果new-handling有能力做一些操作释放内存出来，因此只有在new-handling返回null的时候才会抛出错误。</p><p>如果你打算控制operator new[]的行为，你唯一要做的事情就是分配一块未加工的内存。因为你无法知道array中将会保存什么东西。</p><p>对于operator delete来说，我们要确保的是 <strong>删除null指针永远安全</strong>。</p><p><strong>总结</strong></p><ul><li>operator new应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存的需求，就调用new-handler。它应该也有能力处理0byte申请。class 专属版本则应该处理 <strong>比正确大小更大的错误。</strong></li><li>operator delete应该受到null指针时不做任何事，class专属版本则还应该处理 <strong>比正确大小更大的申请。</strong></li></ul><h3 id="52-条款：写了placement-new也要写placement-delete"><a href="#52-条款：写了placement-new也要写placement-delete" class="headerlink" title="52 条款：写了placement new也要写placement delete"></a>52 条款：写了placement new也要写placement delete</h3><p>placement new和placement delete应当也成对的出现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">widget* pw = <span class="keyword">new</span> widget;</span><br></pre></td></tr></table></figure><p>当我们通过上面的代码的时候，实际上做了两件事情，第一件是new，第二件是调用了widget的default构造函数。如果在第二种情况下发生了异常，new成功执行。这种情况下我们要去释放new所申请的空间，但是我们手上并没有申请得到的指针，因此释放内存的重任就交给了C++。</p><p>如果当前面对的是拥有正常签名的new和delete函数，那么系统在运行期间就会主动去调用相应的delete函数。</p><p>但是如果我们使用的new是我们修改过的，带有附加参数的new，这时候我们需要制定一个与之对应的delete函数。</p><p>此外，由于成员函数名称将会覆盖其外围作用域的相同名称，你必须小心避免掉这种覆盖。一个简单的做法就是建立一个base class，内含所有正常形式的new和delete，凡是想以自定形式扩充标准形式的客户，可利用继承机制及using声明式来取得标准形式。</p><p><strong>总结</strong></p><ul><li>当你写一个placement operator new。请确定也写出对应了placement operator delete函数，如果没有这样做的话，你的程序可能会发生隐微而断续的内存泄漏。</li><li>当你声明placement new和placement delete，请确定不要无意识地掩盖了他们的正常版本。</li></ul><p>一知半解。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019/11/25 effective cpp 第8章 定制new和delete&lt;/p&gt;
&lt;p&gt;C++在内存管理，垃圾回收机制上常常受到人们的讨论。下面这一章将讨论C++的内存管理例程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;49 条款：了解new-handler的行为&lt;/li&gt;
&lt;li&gt;50 条款：了解new和delete的合理替换时机&lt;/li&gt;
&lt;li&gt;51 条款：编写new和delete时需固守常规&lt;/li&gt;
&lt;li&gt;52 条款：写了placement new也要写placement delete&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="effective cpp" scheme="https://wenhui-zhou.github.io/categories/effective-cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>effective cpp(七) 模板与范型编程</title>
    <link href="https://wenhui-zhou.github.io/2019/11/19/effective-cpp-%E4%B8%83-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E8%8C%83%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    <id>https://wenhui-zhou.github.io/2019/11/19/effective-cpp-七-模板与范型编程/</id>
    <published>2019-11-19T05:58:47.000Z</published>
    <updated>2019-11-25T13:39:12.086Z</updated>
    
    <content type="html"><![CDATA[<p>2019/11/19 effective cpp 第七章 模板与范型编程</p><p>C++ template最初是为了让我们建立类型安全的容器，如vector，list，map等等，后来随着越来越多的人用上模板之后，人们发现，template这种代码与其处理对象类型分离，彼此独立的风格很好，于是人们道出了模板元编程，template的作用越来越大。</p><p>本章主要解决在使用template上遇到的一些可以避免，优化的问题。</p><ul><li>41 条款：了解隐式接口和编译期多态</li><li>42 条款：了解typename的双重含义</li><li>43 条款：学习处理模板化基类内的名称</li><li>44 条款：将与参数无关的代码抽离template</li><li>45 条款：运用成员函数模板接受所有兼容类型</li><li>46 条款：需要类型转换时请为模板定义非成员函数</li><li>47 条款：请使用traits classes表现类型信息</li><li>48 条款：认识template元编程</li></ul><!--moew--><h3 id="41-条款：了解隐式接口和编译期多态"><a href="#41-条款：了解隐式接口和编译期多态" class="headerlink" title="41 条款：了解隐式接口和编译期多态"></a>41 条款：了解隐式接口和编译期多态</h3><p>面向对象编程总是以显式的接口和运行期多态来解决问题，它具有两个特点：</p><ul><li>必须在子类总的各种方法，且他的代码在源码中是明确可见的。</li><li>由于widget的某些成员函数是virtual，w对于那些函数的调用将表现出运行期间的多态，根据运行期间w的动态类型来决定调用哪一个函数。</li></ul><p>在template的泛型编程中，我们将函数转变为函数模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doProcessing</span><span class="params">(T&amp; w)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (w.size() &gt; <span class="number">10</span> &amp;&amp; w!= someWidget)&#123;</span><br><span class="line">    <span class="function">T <span class="title">temp</span><span class="params">(w)</span></span>;</span><br><span class="line">    temp.normalize();</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码，我们可以认为T这种类型应该具有size(),normalize()这些函数，允许进行大小的比较。但是实际上，对于模板类来说，他不一定必须要具备这些，这就是和显示接口的一个重大的不同。</p><p><strong>对于显式接口来说</strong>，<strong>他由函数的签名式构成，即包含函数的名称，参数类型，返回类型。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">widget</span>&#123;</span></span><br><span class="line">  widget();</span><br><span class="line">  <span class="keyword">virtual</span> ~widget();</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">normalize</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对于隐式接口来说，他并不是基于函数签名式，而是由有效表达式组成的，如上的第一份代码。</strong></p><p>由于操作符允许重载，因此在实现上述接口的时候，类型T不必要满足支持size成员函数，operation成员函数等。对于size()可由他的父类来提供。对于operator&gt;来说，只要存在一个隐式转换就能够进行类型的转换，将操作符两边的对象转换为同一种对象即可。</p><p><strong>总结</strong></p><ul><li>classes和templates都支持接口和多态</li><li>对class而言，接口式显式的，以函数签名为中心，多态则是通过virtual函数发生于运行期。</li><li>对template参数而言，接口式隐式的，基于有效表达式。多态则是通过template具现化和函数重载解析与编译期的。</li></ul><h3 id="42-条款：了解typename的双重含义"><a href="#42-条款：了解typename的双重含义" class="headerlink" title="42 条款：了解typename的双重含义"></a>42 条款：了解typename的双重含义</h3><p><strong>在template的声明式中，class和typename没有不同。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">widget</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">widget</span>;</span></span><br></pre></td></tr></table></figure><p>当我们在声明参数的时候，上面的两种表达方式完全相同。</p><p>在template中，我们存在着两种类型的变量。</p><p><strong>从属名称：</strong>template内部出现名称依赖于某个template参数。如果存在嵌套的话，则称为嵌套从属名称，如C::iterator，类型C的从属名称。</p><p><strong>非从属名称：</strong>对于类似于int那种名称，不依赖于template。</p><p>对于从属名称来说，typename有时候表示为一种类型，而有时候则是一个成员白能量，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span></span>&#123;</span><br><span class="line">  C::const_iterator*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当上式C::const_iterator表示一个变量的时候，上面变成一个乘法的表达式，如果他是一个类型的话，那就表示声明了一个local的指针。</strong></p><p>C++是如何区分这种情况的呢，<strong>C++在默认的情况下，处理从属关系的时候优先认为这是一个变量，而不是一个类型，除非你告诉编译器。</strong></p><p>显式告诉编译器这是个类型的方式是通过typename来实现的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span></span>&#123;</span><br><span class="line">  <span class="keyword">typename</span> C::<span class="function">cosnt_iterator <span class="title">iter</span><span class="params">(container.begin())</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>typename只被用来确定嵌套从属类型的名称，在其他地方不要去使用它。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> C&amp; container,         <span class="comment">// 一定不要使用typename</span></span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">typename</span> C::iterator iter)</span></span>;  <span class="comment">// 一定要使用typename</span></span><br></pre></td></tr></table></figure><p>此外，在typename在一个特殊的例子中是不允许使用的，就是 <strong>base class list 以及mem init list即父类列表，以及成员初始化的初始化列表中不允许使用。</strong></p><p>当我们在使用嵌套类型的时候，有时候类型名非常的长，我们希望通过typedef来给他重命名，可以将typedef typename一起连用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;iterT&gt;::value_type value_type;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li>声明template参数时，前缀关键字class和typename可互换。</li><li>请使用关键字typename标识嵌套从属类型的名称，但不得在base class lists或mem init list以他作为base class修饰符。</li></ul><h3 id="43-条款：学习处理模板化基类内的名称"><a href="#43-条款：学习处理模板化基类内的名称" class="headerlink" title="43 条款：学习处理模板化基类内的名称"></a>43 条款：学习处理模板化基类内的名称</h3><p>template的继承和显式的继承有些不同之处：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loggin</span>:</span><span class="keyword">public</span> MsgSender&lt;company&gt;&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMSG</span><span class="params">(<span class="keyword">const</span> MsgSender&lt;Company&gt;)</span></span>&#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">      sendClear(info);  <span class="comment">// 调用父类中的sendClear函数</span></span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码如果实在class的继承中，一定是成立的，但是template继承中则会出错，因为在继承<code>MsgSender&lt;company&gt;</code>的时候，编译器并不知道这是个什么样的class，也就自然不知道这个class中是否有一个sendClear函数了，因此上面的调用将会出错。</p><p>解决方法：</p><ol><li><strong>在base class函数调用动作之前加上this-&gt;</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loggin</span>:</span><span class="keyword">public</span> MsgSender&lt;company&gt;&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMSG</span><span class="params">(<span class="keyword">const</span> MsgSender&lt;Company&gt;)</span></span>&#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">      <span class="keyword">this</span>-&gt;sendClear(info);  <span class="comment">// 调用父类中的sendClear函数</span></span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>使用using声明式，是的父类的方法能够在子类中可见</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loggin</span>:</span><span class="keyword">public</span> MsgSender&lt;company&gt;&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMSG</span><span class="params">(<span class="keyword">const</span> MsgSender&lt;Company&gt;)</span></span>&#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">      <span class="keyword">using</span> MsgSender&lt;company&gt;::sendClear;</span><br><span class="line">      sendClear(info);  <span class="comment">// 调用父类中的sendClear函数</span></span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>明确指出函数在base class内</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loggin</span>:</span><span class="keyword">public</span> MsgSender&lt;company&gt;&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMSG</span><span class="params">(<span class="keyword">const</span> MsgSender&lt;Company&gt;)</span></span>&#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">      MsgSender::sendClear(info);  <span class="comment">// 调用父类中的sendClear函数</span></span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在template继承的时候，子类对父类的方法一无所知，因此我们需要通过this，或者明确指出父类方法的方式得到函数的声明。</p><p><strong>总结</strong></p><ul><li>可在derived class templates内通过<code>this-&gt;</code>指涉base class template内的成员名称，或由一个明白写出的base class资格的修饰符，使用using 或直接由类调用。</li></ul><h3 id="44-条款：将与参数无关的代码抽离template"><a href="#44-条款：将与参数无关的代码抽离template" class="headerlink" title="44 条款：将与参数无关的代码抽离template"></a>44 条款：将与参数无关的代码抽离template</h3><p>template是一个节约时间与避免代码重复的一个方法。但是有时候我们可能会导致代码膨胀。</p><p>一些指针，vector，list等等，位于父类函数中，将会造成代码的膨胀。</p><p><strong>总结</strong></p><ul><li>template生成多个class和多个参数，所以任何template代码都不该与某个造成膨胀的template参数产生相依的关系。</li><li>因非类型末班参数而造成的代码膨胀，往往可以消除，做法是用函数参数或class成员变量替代template参数</li><li>因类型参数而造成的代码膨胀往往可以降低，做法是让带有完全相同的二进制表述的具现类型共享实现码。</li></ul><h3 id="45-条款：运用成员函数模板接受所有兼容类型"><a href="#45-条款：运用成员函数模板接受所有兼容类型" class="headerlink" title="45 条款：运用成员函数模板接受所有兼容类型"></a>45 条款：运用成员函数模板接受所有兼容类型</h3><p>智能指针是行为上像是一个指针的对象，它提供了指针的所有机能，在STL容器中，我们总是使用智能指针。此外指针的另一很好的优点在于支持<strong>隐式转换</strong>，即子类指针可以隐式的转换为父类指针。但是这种关系在template类模板中是不存在的。</p><p><strong>用具有base-derived关系的对象去具现化某个template的时候，产生出来的的具现体并不具有base-derived的关系。</strong></p><p>一个可行的方法就是实现一个template构造函数，即构造模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    SmartPtr(<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; other);  <span class="comment">// 将一个具现化的u转型为t</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这一构造函数根据对象u创建对象t，而u和t的类型是同一个template的不同具现体，我们称这个函数为泛化copy构造函数。需要注意的是，<strong>上面的前提是说，一个U可以被转型为T。</strong></p><p>我们同样可以在构造函数中完成我们想要达到的转化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    SmartPtr(<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; other)</span><br><span class="line">      :heldPtr(other.get())&#123;...&#125;  <span class="comment">//  使用u的指针去初始化t变量的指针</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    T* heldPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样的，上述的做法是在 <strong>U指针可以隐式转换为T*的基础上才成立的。</strong></p><p>泛化copy构造函数与普通的copy构造函数之间不存在冲突，因此具现化后的类，依旧会为这个类实现一个copy构造函数。</p><p><strong>总结</strong></p><ul><li>请使用member function templates成员函数模板，生成可接受所有兼容类型的函数。（即上面的u-&gt;t）。</li><li>如果你声明member templates用于泛化copy构造或泛化assignment操作，你还是需要声明正常的copy构造函数和copy assignment操作符，因为编译器默认生成的函数不会因为生成泛化copy构造函数受到影响。</li></ul><h3 id="46-条款：需要类型转换时请为模板定义非成员函数"><a href="#46-条款：需要类型转换时请为模板定义非成员函数" class="headerlink" title="46 条款：需要类型转换时请为模板定义非成员函数"></a>46 条款：需要类型转换时请为模板定义非成员函数</h3><p>当我们在使用template来定义非成员函数，同时这个成员函数的参数需要隐式的转换的话，我们可能会遇到问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs,<span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure><p>当我们调用上面代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rational&lt;<span class="keyword">int</span>&gt; result = onehalf*<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>将会出现编译错误，因为template类型<code>Rational&lt;T&gt;</code>在具现化的时候需要确定T的类型，当遇到2的时候，C++无法推断出T为int，因此无法通过编译。</p><p>此路不通，我们曲线救国，通过将<code>Rational&lt;T&gt;</code>申请为class Rational的friend函数的方式来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">friend</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> rational&amp; lhs,<span class="keyword">const</span>&amp; rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过友元的方式来制定一个具体的函数，从而避免template进行参数的推导。</p><p>但是上面方法同样会引发一个问题，就是我们通过友元的方式，使得我们可以通过友元来确定函数，但是仅仅是个声明，没有函数的实现，一个最直接的方法就是我们直接将函数的本体定义在Rational乘法里头。</p><p><strong>总结</strong></p><ul><li>当我们需要编写一个class template，而他所提供的与此template相关的函数支持所有参数隐式类型转换时，请将那些函数定义为class template内部的friend函数。</li></ul><h3 id="47-条款：请使用traits-classes表现类型信息"><a href="#47-条款：请使用traits-classes表现类型信息" class="headerlink" title="47 条款：请使用traits classes表现类型信息"></a>47 条款：请使用traits classes表现类型信息</h3><p>在一些状况下，我们需要知道一个类的某些信息。<strong>traits构件</strong>就是做这件事情的，他是一种技术，也是C++程序员所遵守的一种协议。我们将trait放入一个template中去：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TT&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>;</span></span><br></pre></td></tr></table></figure><p>接下来我们确认一个traits中应该包含哪些信息：</p><ul><li>确认若干你希望将来可取得的类型的相关信息，例如对于迭代器，我们希望将来可取的他的分类。</li><li>为该信息选择一个名称</li><li>提供一个template与一组特化版本，内含你希望看到的相关信息</li></ul><p>接下来是如何使用traits：</p><ul><li>建立一个重载函数或函数模板，彼此的差异在于各自的trait参数；</li><li>建立一个控制函数或函数模板，用于调用上述的函数，并传递trait信息。</li></ul><p><strong>总结</strong></p><ul><li>traits class使得类型相关信息在编译期可用，它以template和templates特化完成实现。</li><li>整合重载技术后，trait class有可能在编译期对类型执行if … else 操作。</li></ul><h3 id="48-条款：认识template元编程"><a href="#48-条款：认识template元编程" class="headerlink" title="48 条款：认识template元编程"></a>48 条款：认识template元编程</h3><p>template metaprogramming元编程是编写template-based c++程序并执行与编译期的过程。</p><p><strong>总结</strong></p><ul><li>元编程可将工作由运行期移往编译期，因而得以实现早期错误侦测和更高的执行效率</li><li>TMP可被用来生成 <strong>基于政策选择组合</strong>的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。</li></ul><p>it is a little difficult for me,but never mind !</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2019/11/19 effective cpp 第七章 模板与范型编程&lt;/p&gt;
&lt;p&gt;C++ template最初是为了让我们建立类型安全的容器，如vector，list，map等等，后来随着越来越多的人用上模板之后，人们发现，template这种代码与其处理对象类型分离
      
    
    </summary>
    
      <category term="effective cpp" scheme="https://wenhui-zhou.github.io/categories/effective-cpp/"/>
    
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WenHuiZhou</title>
  
  <subtitle>perper（打起精神！）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wenhui-zhou.github.io/"/>
  <updated>2019-11-19T06:04:45.797Z</updated>
  <id>https://wenhui-zhou.github.io/</id>
  
  <author>
    <name>WenHuiZhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>effective cpp(七) 模板与范型编程</title>
    <link href="https://wenhui-zhou.github.io/2019/11/19/effective-cpp-%E4%B8%83-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E8%8C%83%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    <id>https://wenhui-zhou.github.io/2019/11/19/effective-cpp-七-模板与范型编程/</id>
    <published>2019-11-19T05:58:47.000Z</published>
    <updated>2019-11-19T06:04:45.797Z</updated>
    
    <content type="html"><![CDATA[<p>2019/11/19 effective cpp 第七章 模板与范型编程</p><p>C++ template最初是为了让我们建立类型安全的容器，如vector，list，map等等，后来随着越来越多的人用上模板之后，人们发现，template这种代码与其处理对象类型分离，彼此独立的风格很好，于是人们道出了模板元编程，template的作用越来越大。</p><p>本章主要解决在使用template上遇到的一些可以避免，优化的问题。</p><ul><li>41 条款：了解隐式接口和编译期多态</li></ul><!--moew--><h3 id="41-条款：了解隐式接口和编译期多态"><a href="#41-条款：了解隐式接口和编译期多态" class="headerlink" title="41 条款：了解隐式接口和编译期多态"></a>41 条款：了解隐式接口和编译期多态</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2019/11/19 effective cpp 第七章 模板与范型编程&lt;/p&gt;
&lt;p&gt;C++ template最初是为了让我们建立类型安全的容器，如vector，list，map等等，后来随着越来越多的人用上模板之后，人们发现，template这种代码与其处理对象类型分离
      
    
    </summary>
    
      <category term="effective cpp" scheme="https://wenhui-zhou.github.io/categories/effective-cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>effective cpp(六) 继承与面向对象设计</title>
    <link href="https://wenhui-zhou.github.io/2019/11/16/effective-cpp-%E5%85%AD-%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/"/>
    <id>https://wenhui-zhou.github.io/2019/11/16/effective-cpp-六-继承与面向对象设计/</id>
    <published>2019-11-16T08:40:17.000Z</published>
    <updated>2019-11-19T10:14:53.249Z</updated>
    
    <content type="html"><![CDATA[<p>2019/11/16 effective cpp 第六章 继承与面向对象设计</p><p>面向对象编程成为一个风靡一时的重要特性，关于C++在面向对象上的一些特性，将在本章进行详细的介绍。</p><ul><li>32 条款：确定你的public继承塑膜出is-a关系</li><li>33 条款：避免遮掩继承而来的名称</li><li>34 条款：区分接口继承和实现继承</li><li>35 条款：考虑virtual函数与外的其他选择</li><li>36 条款：绝不重新定义继承而来的non-virtual函数</li><li>37 条款：绝不重新定义继承而来的缺省参数值</li><li>38 条款：通过符合塑模出has-a或“根据某物实现出”</li><li>39 条款：明智而审慎地使用private继承</li><li>40 条款：明智而审慎地使用多重继承</li></ul><a id="more"></a><h3 id="32-条款：确定你的public继承塑膜出is-a关系"><a href="#32-条款：确定你的public继承塑膜出is-a关系" class="headerlink" title="32 条款：确定你的public继承塑膜出is-a关系"></a>32 条款：确定你的public继承塑膜出is-a关系</h3><p>作者通过一个例子表明立场，说明一个<strong>戒慎恐惧</strong>的东西，将会使人们记得异常牢固。接下来他说我们应该用同样的心态记住下面的话：</p><p><strong>public继承意味着是一种is-a关系</strong>，即子类通过public的方式继承父类，那么子类在任何场合都可以直接转变为父类。</p><p>即D以public的方式继承自B，意味着B比D表现出更一般化的概念，D比B则表现出更加的特殊化。B可以使用的地方D一定可以使用，D可以使用的地方B不一定可以使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span>:</span><span class="keyword">public</span> Person&#123;...&#125;;</span><br></pre></td></tr></table></figure><p>上诉的代码表明是一个学生一定是一个人。任何函数希望得到一个person参数的时候，通常也愿意接受一个student对象。即给父类参数传递一个子类对象作为参数，是符合继承的观点，合法的。</p><p><strong>总结</strong></p><ul><li>public继承意味着“is-a”的关系。适用于base classes身上的每一件事情一定也适用于derived class 身上，因为每一个derived classes 对象也都是一个base classes对象。</li></ul><h3 id="33-条款：避免遮掩继承而来的名称"><a href="#33-条款：避免遮掩继承而来的名称" class="headerlink" title="33 条款：避免遮掩继承而来的名称"></a>33 条款：避免遮掩继承而来的名称</h3><p>这个内容与作用域相关，指的是在不同的作用域之中，变量的遮掩。编译器从local领域从发，向外一步步直到找到变量。</p><p>当我们在谈论继承的时候，当位于一个derived class成员函数的内指涉base class内的某物，编译器可以找出所指涉的东西，因为derived classes继承了声明与base class内的所有东西。<strong>子类的作用域嵌套在base class作用域内，子类对象可以调用父类的成员。</strong></p><p>例如下面例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">boid <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述例子中混合了public，private名称，以及一组成员变量和成员函数名称，包含了pure virtual，virtual，non-virtual三种，假设mf4函数实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Derived::mf4()&#123;</span><br><span class="line">  ...</span><br><span class="line">    mf2();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 当编译器遇到mf2的时候，必须估算他所指涉的东西，编译器的做法是查找各个作用域，看看有没有mf2的声明式，首先是local，然后是外围作用域，base的作用域，最外层的global作用域。</p><p>下面我们考虑一个重载带来的问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们重载了mf1和mf3函数，base class中的mf1和mf3都被子类的函数所代替，但是此时对于父类中的重载函数将会发生错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line">d.mf1(); <span class="comment">//正常调用</span></span><br><span class="line">d.mf1(x); <span class="comment">// 含参数的那个函数也被mf1函数所覆盖，因此调用出现问题</span></span><br><span class="line">d.mf3(); <span class="comment">// 正常调用</span></span><br><span class="line">d.mf3(x); <span class="comment">// 出错</span></span><br></pre></td></tr></table></figure><p>为了解决上面出现的遮掩行为造成的错误，我们可以使用using声明式来达到目的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line">  <span class="keyword">using</span> Base::mf1;</span><br><span class="line">  <span class="keyword">using</span> Base::mf3;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用using机制使得继承可以得到完美的实现。子类中调用d.mf3(x)将会到父类中寻找d.mf3(x)函数进行调用。</p><p><strong>这意味着你继承base class并加上重载函数，而你又希望重新定义或覆盖其中的一部分，那么你必须为那些原本会遮掩的每个名称引入一个using声明式，否则某些你希望的名称将会被遮掩。</strong></p><p>另一种情况是，当我们只希望继承父类重载的多个函数中的一个函数的时候，我们使用转交函数的方式，在子类函数中调用父类的函数，使其成为inline：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">private</span> Base&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>&#123;  <span class="comment">// 转交函数，只实现了一个版本，有参数的那个版本在子类中未继承</span></span><br><span class="line">      Base::mf1();  <span class="comment">// 使其成为inline</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li>子类内的名称会遮掩base classes内的名称，在public继承下从来没有人希望如此</li><li>为了让遮掩的名称重见天日，可以使用using 声明式或转交函数。</li></ul><h3 id="34-条款：区分接口继承和实现继承"><a href="#34-条款：区分接口继承和实现继承" class="headerlink" title="34 条款：区分接口继承和实现继承"></a>34 条款：区分接口继承和实现继承</h3><p>在类的继承中，可以通过三种方式进行继承：</p><ul><li>继承一个接口（pure virtual）</li><li>继承接口以及接口的部分实现，子类选择覆盖这些实现（impure virtual）</li><li>继承接口以及接口的部分实现，子类不覆盖这些实现（non-virtual）</li></ul><p><strong>成员函数的接口总是会被继承</strong></p><p>pure virtual函数最突出的特性，他们必须被任何继承了他们的具象class重新声明，而且他们在抽象class中通常没有定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shape</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>声明一个pure virtual函数的目的是为了让derived classes只继承函数接口。</strong></p><p>对于shape::draw函数来说，这样是十分合理的，因为每个shape对象都应该有一个draw函数，同时由于shape子类形状各异，因此父类无法提供一个缺省（通用的）实现方式。</p><p>但是令人意外的是：<strong>我们可以为纯虚pure virtual函数提供一份实现代码，但是调用他的唯一途径就是明确指出class的名称。</strong>但是pure virtual依然无法创建对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shape* ps = <span class="keyword">new</span> shape;</span><br><span class="line">shape* ps1 = <span class="keyword">new</span> Rectangle;</span><br><span class="line">ps1-&gt;draw();  <span class="comment">// Rectangle的draw函数</span></span><br><span class="line">ps1-&gt;shape::draw(); <span class="comment">// 调用了父类的draw函数</span></span><br></pre></td></tr></table></figure><p><strong>声明非纯impure virtual函数的目的，就是让derived classes继承该函数的接口和缺省实现。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shape</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示每个class都必须支持一个“当遇到错误时可调用”的函数，但每个class可自由处理错误。如果不愿意自己处理错误的话，也可以使用父类的缺省实现。</p><p>但是这就会出现一个问题，当我们继承了一个韩非纯函数的父类的时候，我们可能会忘记实现自己的版本，此时编译器就会为了安排默认的版本，而引发错误，下面这种做法就是为了解决这个问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(cosnt sAirport&amp; destination)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">defaultFly</span><span class="params">(cosnt Ariport&amp; destination)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Airplane::defaultFly(<span class="keyword">const</span> Airport&amp; destination)&#123;</span><br><span class="line">  <span class="comment">//fly函数中的实现部分改到这里来写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述操作将fly函数又impure设置成pure函数，意味着子类必须有自己实现的版本，在缺省的实现部分转移到defaultFly当中去，如果子类不实现fly函数则会报错，如果希望用缺省方式的话，则调用defaultFly函数。</p><p>但是上面这种做法将会导致代码的重复这种情况。</p><p>另一种做法是将默认的实现部分转移到纯虚函数的实现中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(cosnt Airport&amp; destination)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Airplane::fly(cosnt Airport&amp; destination)&#123;</span><br><span class="line">  <span class="comment">//缺省行为，将飞机飞至指定的目的地</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span>:</span><span class="keyword">public</span> Airplane&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>&#123;</span><br><span class="line">      Airplane::fly(destination); <span class="comment">// 使用缺省的方式实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br><span class="line"><span class="comment">// 如果你要自己实现fly这个函数的话，可以自己写相应的方法</span></span><br></pre></td></tr></table></figure><p>这种方式避免了再去定义一个defaultFly函数。现在的fly函数被切割成两个部分，其声明部分表现的是接口，其定义部分表现出缺省行为。</p><p><strong>声明non-virtual函数的目的就是为了令derived classes继承函数的接口及一份强制性的实现。</strong></p><p>由于non-virtual函数代表的意义是不变性凌驾于特异性之上，我们绝对不要在子类中重新定义父类中的non-virtual函数。</p><p><strong>总结</strong></p><ul><li>接口继承和实现继承不同。在public继承之下，derived classes总是继承base class的接口。</li><li>pure virtual函数只具体指定接口继承。</li><li>非纯的函数具体制定接口继承及缺省实现继承。</li><li>non-virtual函数具体指定接口继承以及强制性实现继承。</li></ul><h3 id="35-条款：考虑virtual函数与外的其他选择"><a href="#35-条款：考虑virtual函数与外的其他选择" class="headerlink" title="35 条款：考虑virtual函数与外的其他选择"></a>35 条款：考虑virtual函数与外的其他选择</h3><p>我们可以使用一些其他的方式来代替virtual的使用</p><p><strong>template method模式</strong></p><p>这种模式为将虚函数修改为public的non-virtual函数，然后其具体的实现通过定义一个private的virtual函数来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">      ... <span class="comment">// 调用前准备</span></span><br><span class="line">      <span class="keyword">int</span> retval = dohealthValue();</span><br><span class="line">      ... <span class="comment">// 调用后处理</span></span><br><span class="line">      <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">dohealthValue</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 上面的设计令用户通过public non-virtual成员函数佳节调用private virtual函数的模式（NVI non-virtual interface），把non-virtual函数作为一个外覆器，在调用前后都可以进行一些处理，这是这种方法的一个优点，但是缺点是我们需要定义很多private virtual函数。</p><p><strong>籍由Function Pointers实现strategy模式</strong></p><p>利用传入一个函数指针的方式，进行实际的操作。</p><p>函数指针的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">defaultHealth</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"><span class="comment">//函数指针如下</span></span><br><span class="line">return_types (*func_pointer)( data_types arg1, data_types arg2, ..);</span><br><span class="line"><span class="keyword">int</span> (*defaultHealth)(<span class="keyword">const</span> GameCharacter&amp;);</span><br><span class="line"><span class="comment">//使用上面的定义之后，就可以用指针defaultHealth来调用函数了</span></span><br></pre></td></tr></table></figure><p>上述这种方法提供了某种弹性，在调用不同的类型的时候，传入不同计算方法的函数的指针，得到不同的计算方式。当我们使用了类外的方法的时候，我们可能会陷入一个陷阱中，就是这个函数只能访问类的public部分，如果我们想进一步的话，就只能降低函数的封装级别了。</p><p><strong>籍由tr1::function完成strategy模式</strong></p><p><strong>C++ Technical Report 1 （TR1</strong>）是ISO/IEC TR 19768, C++ Library Extensions（函式库扩充）的一般名称。TR1是一份文件，内容提出了对C++标准函式库的追加项目。这些追加项目包括了正则表达式、智能指针、哈希表、随机数生成器等。</p><p><strong>function 是一种通用、多态的函数封装</strong>。<strong>std::function 的实例可以对任何可以调用的目标进行存储、复制、和调用操作，这些目标包括函数、lambda 表达式、绑定表达式、以及其它函数对象等</strong>。（c++11起的版本可用）<br>　　function（和bind一样）可以实现类似函数指针的功能，却比函数指针更加灵活（体现在占位符上面），尤其是在很多成员调用同一个函数（仅仅是参数类型不同）的时候比较方便。</p><p><strong>C++中的函数签名(function signature)</strong>：包含了一个函数的信息，包括函数名、参数类型、参数个数、顺序以及它所在的类和命名空间。</p><p>function对象只要签名式满足要求，那么这个对象就可以存储任何可调用物。下面我们使用function来替代上面的函数指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::str1::function&lt;<span class="keyword">int</span> (<span class="keyword">const</span> GameCharacter&amp;)&gt; healthCalFunc;</span><br><span class="line">    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc):healthFunc(hfc)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> healthFunc(*<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面代码可以看出来，我们只要传入一下接受一个const reference参数的任意函数都可以，我们可以使用函数，函数对象，成员函数等等。</p><p><strong>古典的strategy模式</strong></p><p>传统的strategy做法将一个健康的计算函数做成一个分离的继承体系中的virtual成员函数。</p><p><strong>替代方案</strong></p><p>本条条款的核心就是可以通过一下几种方式来找到virtual的替代方案：</p><ul><li>使用non-virtual interface手法，那是template method设计模式的一种特殊形式，它以public non-virtual成员函数包裹较低访问性的virtual函数。</li><li>将virtual函数替换为函数指针成员变量，这是strategy设计模式的一种分解形式。</li><li>以tr1::function成员变量替换virtual函数，因而允许使用任何可调用物来搭配一个兼容于需求的签名式。</li><li>将继承体系内的virtual函数替换为另一个继承体系内的virtual函数，这是strategy设计模式的传统实现方法。</li></ul><p><strong>总结</strong></p><ul><li><p>virtual 函数的替代方案包含NVI，以及strategy设计模式的多种形式，NVI手法是一个特殊形式的template method模式。</p></li><li><p>将机能从成员函数一道class外部函数，带来一个缺点，非成员函数无法访问class的non-public成员。</p></li><li>tr1::function对象行为就像一般函数指针，这样的对象可接纳与给定目标签名式兼容的所有可调物。</li></ul><h3 id="36-条款：绝不重新定义继承而来的non-virtual函数"><a href="#36-条款：绝不重新定义继承而来的non-virtual函数" class="headerlink" title="36 条款：绝不重新定义继承而来的non-virtual函数"></a>36 条款：绝不重新定义继承而来的non-virtual函数</h3><p>在一个类中，我们定义了non-virtual函数，意味着我们遵循设计原则，认为这个函数的不变性要大于特异性，因此我们不可以在子类中对这个函数进行覆盖。否则，将同一个元素赋值给父类和子类，将导致不同的行为，这是我们不希望看到的。</p><p><strong>总结</strong></p><ul><li>绝对不要重新定义继承而来的non-virtual函数</li></ul><h3 id="37-条款：绝不重新定义继承而来的缺省参数值"><a href="#37-条款：绝不重新定义继承而来的缺省参数值" class="headerlink" title="37 条款：绝不重新定义继承而来的缺省参数值"></a>37 条款：绝不重新定义继承而来的缺省参数值</h3><p>当我们继承一个父类的时候，如果父类中的virtual函数带有缺省值，我们选择不去重写这个缺省值。原因是：</p><p><strong>virtual函数系动态绑定，而缺省参数值确实静态绑定。</strong>因此缺省的参数值在定义的时候就会被确定，缺省值就是定义这个函数的类给赋予的。如下面代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> shapecolor&#123;red,green,blue&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(shapecolor color = red)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rectangle</span>:</span><span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(shapecolor color = green)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> rectangle::draw(Shape::shapecolor color) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"---"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; color;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"---"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shape *ps = <span class="keyword">new</span> rectangle();</span><br><span class="line">rectangle* rec = <span class="keyword">new</span> rectangle();</span><br><span class="line">ps-&gt;draw();  <span class="comment">// 使用静态绑定的shape中的缺省值</span></span><br><span class="line">rec-&gt;draw(); <span class="comment">// 使用静态绑定的rectangle中的缺省值</span></span><br></pre></td></tr></table></figure><p>上述代码就可以看出矛盾，同一个对象却有不同的表现，导致缺省值的不同。上述代码的一个解决方案就是使用NVI方式，用non-virtual去调用virtual函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> shapecolor&#123;red,green,blue&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(shapecolor color = red)</span></span>&#123;</span><br><span class="line">        doDraw(color);  </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(shapecolor color)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rectangle</span>:</span><span class="keyword">public</span> shape&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(shapecolor color)</span> <span class="keyword">const</span></span>;  <span class="comment">// 这里不需要指定缺省的参数值</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>由于non-virtual函数是不会被子类覆盖。这个设计保证了参数值一定是一致的。</p><p><strong>总结</strong></p><ul><li>绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定的，而virtual函数（你唯一需要覆盖的东西）是动态绑定的。</li></ul><p>###38 条款：通过符合塑模出has-a或“根据某物实现出”</p><p>has-a表现出来的是一种复合关系（composition），当某种类型的对象内含它种类型的对象，便是这种关系。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    Address ad; <span class="comment">// 其他类型的生成对象</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">  PhoneNumber num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，还有另一种关系，成为 <strong>is-implemented-in-terms-of</strong> 关系，例如我们实现一个set，直觉上我们可以继承标准库中的set，但是为了资源等考虑，我们打算另辟蹊径。我们可能就会考虑到list的实现，但是我们不能直接继承list，因为list与set不是is-a的关系。但是我们可以在函数中多次使用list结构来构造一个set，<strong>这就是根据某物实现出</strong>的这种关系。</p><p><strong>总结</strong></p><ul><li>复合的意义和public继承完全不同</li><li>在应用域，复合意味着is-a关系。在实现域，复合意味着根据某物来实现。</li></ul><h3 id="39-条款：明智而审慎地使用private继承"><a href="#39-条款：明智而审慎地使用private继承" class="headerlink" title="39 条款：明智而审慎地使用private继承"></a>39 条款：明智而审慎地使用private继承</h3><p>private继承不是一个is-a继承，而是一种子类实现需要使用父类的某些函数性质的 “implemented-in-terms-of”的关系。</p><p>对于private的选择，我们通常会考虑：<strong>当一个意欲成为derived class者想要访问一个意欲成为base class者的protected成分，或者成为重新定义一个或多个virtual函数。</strong>如果满足这个条件的话，我们会考虑使用private继承，但是很多情况下，我们使用复合，将private继承的类作为一个成员变量的方式，能够提供能多的灵活性。</p><p><strong>即：我们可以使用复合的方式来代替private的继承，保证更大的灵活性。</strong></p><p>但是如果我们追求一种更加激进的空间优化，我们会选择使用private继承来代替复合。</p><p>如果我们使用的类满足不带数据成员，没有virtual等条件，满足空白基类最优化EBO的情况下，我们应该优先考虑private继承，但是这种情况基本很少见。</p><p><strong>总结</strong></p><ul><li>private继承意味着 <strong>根据某物实现出</strong>的关系，它通常比复合的级别要低，当时当子类需要访问protected base class的成员，或需要重新定义继承而来的cirtual函数时，是合理的。</li><li>和复合不同，private继承可以造成empty base最优化，这对于严格要求“对象尺寸最小化”的程序开发者而言是很重要的。</li></ul><h3 id="40-条款：明智而审慎地使用多重继承"><a href="#40-条款：明智而审慎地使用多重继承" class="headerlink" title="40 条款：明智而审慎地使用多重继承"></a>40 条款：明智而审慎地使用多重继承</h3><p>当我们设计到多重继承的时候，在子类的使用上将会面临起义的一个问题，共同父类中相同的函数，必须通过类名的方式进行调用。</p><p>对于钻石形的继承关系，我们使用virtual来继承，使得每一个子类都有一份供自己使用的父类成员变量。但是使用virtual将会导致C++编译器在处理这类继承时，生成体积较大的对象，访问速度也比较慢，virtual继承付出的代价更加的明显，规则复杂不够直观。</p><p><strong>忠告</strong></p><ul><li><p>非必须使用virtual bases的时候不要使用它，大部分情况使用non-virtual继承</p></li><li><p>如果必须使用virtual base继承，那么尽量避免在其中放置数据，使得类小一点，以及不会出现难以察觉的赋值问题。</p></li></ul><p>但是有些时候，双重继承也有其合理的用途，保留使用多重继承的看法。如果能用单一继承代替多重继承的话，单一继承是一个非常好的选择。</p><p><strong>总结</strong></p><ul><li>多重继承比单一继承复杂，他可能导致起义性，以及对virtual继承的需要</li><li>virtual继承会增加大小，速度，初始化复杂度等成本，如果virtual base classes不带任何的数据，将会是多重继承最具有使用价值的情况。</li><li>多重继承的确有正当用途，其中一个情节涉及public继承某个interface class和private继承某个协助实现的class的两相组合。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019/11/16 effective cpp 第六章 继承与面向对象设计&lt;/p&gt;
&lt;p&gt;面向对象编程成为一个风靡一时的重要特性，关于C++在面向对象上的一些特性，将在本章进行详细的介绍。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;32 条款：确定你的public继承塑膜出is-a关系&lt;/li&gt;
&lt;li&gt;33 条款：避免遮掩继承而来的名称&lt;/li&gt;
&lt;li&gt;34 条款：区分接口继承和实现继承&lt;/li&gt;
&lt;li&gt;35 条款：考虑virtual函数与外的其他选择&lt;/li&gt;
&lt;li&gt;36 条款：绝不重新定义继承而来的non-virtual函数&lt;/li&gt;
&lt;li&gt;37 条款：绝不重新定义继承而来的缺省参数值&lt;/li&gt;
&lt;li&gt;38 条款：通过符合塑模出has-a或“根据某物实现出”&lt;/li&gt;
&lt;li&gt;39 条款：明智而审慎地使用private继承&lt;/li&gt;
&lt;li&gt;40 条款：明智而审慎地使用多重继承&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="effective cpp" scheme="https://wenhui-zhou.github.io/categories/effective-cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>effective cpp(五) 实现</title>
    <link href="https://wenhui-zhou.github.io/2019/11/10/effective-cpp-%E4%BA%94-%E5%AE%9E%E7%8E%B0/"/>
    <id>https://wenhui-zhou.github.io/2019/11/10/effective-cpp-五-实现/</id>
    <published>2019-11-10T11:26:50.000Z</published>
    <updated>2019-11-16T08:42:36.806Z</updated>
    
    <content type="html"><![CDATA[<p>2019/11/10，effective cpp第五章 实现</p><p>cpp在实现上存在着很多高效率，代码优化的细节。</p><ul><li>26 条款：经可能延后变量定义式的出现时间</li><li>27 条款：尽量少做转型动作</li><li>28 条款：避免返回handles指向对象内部成分</li><li>29 条款：为异常安全而努力是值得的</li><li>30 条款：透彻了解inlining 的里里外外</li><li>31 条款：将文件间的编译依存关系降至最低</li></ul><a id="more"></a><h3 id="26-条款：经可能延后变量定义式的出现时间"><a href="#26-条款：经可能延后变量定义式的出现时间" class="headerlink" title="26 条款：经可能延后变量定义式的出现时间"></a>26 条款：经可能延后变量定义式的出现时间</h3><p>我们定义一个变量需要承担它的构造成本以及析构成本，如果我们在程序中，由于一些判断条件未能使用到这些变量，那么将造成大量的时间浪费，于是我们应当尽量的延后变量的定义。</p><p>第二个优化的地方在于在定义变量的时候，通过调用构造函数来初始化变量，而不是通过赋值的方式。（通过赋值的方式将会浪费一次系统默认的赋值时间）</p><p>第三个优化的地方，如果我们需要在一个循环中使用变量的话，<strong>我们应该在循环的内部定义变量</strong>，除非析构与构造的成本比较高，且你的代码对效率高度敏感。</p><p><strong>总结</strong></p><ul><li>尽可能延后变量定义式的出现，这样做可以增加程序的清晰度，并改善程序的效率。</li></ul><h3 id="27-条款：尽量少做转型动作"><a href="#27-条款：尽量少做转型动作" class="headerlink" title="27 条款：尽量少做转型动作"></a>27 条款：尽量少做转型动作</h3><p>首先是结论：<strong>优良的C++代码很少使用转型</strong></p><p>C++的设计目标之一就是保证类型错误绝不可能发生，尽量保证任何转型动作尽可能少的发生。转型动作破坏了类型系统，导致一些很隐晦的错误。C++提供的转型变换如下：</p><ul><li><p><code>const_cast&lt;T&gt; (expression)</code>，通常用于对象的常量性移除，将常量去除</p></li><li><p><code>dynamic_cast&lt;T&gt;(expression)</code>，主要用于执行“安全向下转型”，用来决定某对象是否归属继承体系中的某个类型。可能耗费比较大的运行成本。</p></li><li><code>reinterpret_cast&lt;T&gt;(expression)</code>，执行低级转型，例如将point to int 转成int。</li><li><code>static_cast&lt;T&gt;(expression)</code>，用来强迫执行隐式转型，将int转成double等等。</li></ul><p>旧式的转型：</p><ul><li><code>(T)expression</code></li><li><code>T(expression)</code></li></ul><p>旧式的两种写法功能相同，建议使新式的转型方法，因为他们在代码上容易辨认，且各个转型动作目标比较窄，容易排查错误,例如只有const_cast方法才能实现对象的常量移除。</p><p>关于<code>dynamic_cast</code>方法，例如我有有些时候，希望在子类函数调用的时候先调用父类的函数，会写出下面的代码（错误的）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">special</span>:</span> <span class="keyword">public</span> window&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static_cast</span>&lt;window&gt;(*<span class="keyword">this</span>).onResize();</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上诉代码将this转为window的指针，但是他调用的并不是当前对象上的函数，<strong>转型动作将产生一个this对象的base class的成分的一个副本</strong>。因此window上的onsize操作只是在一个副本上执行操作的，并不会改变this对象的内容。解决的方法是直接调用父类的onsize方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">special</span>:</span> <span class="keyword">public</span> window&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onResize</span><span class="params">()</span></span>&#123;</span><br><span class="line">    window::onResize();</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>dynamic_cast</code>的场景通常说，我们手上只有一个base class的指针，但是想希望通过它来执行子类的一些操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;tr1::<span class="built_in">shared_ptr</span>&lt;window&gt;&gt; vpw;</span><br><span class="line">vpw winptr;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">for</span>(vpw::iterator iter=winptr.begin();iter!=winptr.end();++iter)&#123;</span><br><span class="line">    <span class="keyword">if</span>(special* psw=<span class="keyword">dynamic_cast</span>&lt;special*&gt;(iter-&gt;get()))</span><br><span class="line">      psw-&gt;blink();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面代码效率比较低，而且令人担心，因此最后直接用子类的容器存储指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;tr1::<span class="built_in">shared_ptr</span>&lt;special&gt;&gt; vpsw;</span><br><span class="line">vpsw winptr;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(vpsw::iterator iter = winptr.begin();iter!=winptr.end();++iter)&#123;</span><br><span class="line">  (*iter)-&gt;blink();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上面的代码童谣失去了指向所有可能子类的可能，<strong>一个可行的解决方案就是为在base class提供一个缺省实现的blink函数声明。或者是直接用上述方式写出子类</strong></p><p>不论是哪一种写法：使用类型安全容器，或将virtual函数往继承体系上方移动，都是一个替代dynamic_cast 的可行方案。</p><p>绝对需要避免的一种写法是连串使用多个dynamic_cast，这种代码将又大又慢，同时十分的不安全。</p><p><strong>总结</strong></p><ul><li>如果可以，尽可能避免转型，特别在注重效率的代码中避免使用<code>dynamic_cast</code></li><li>如果转型是必要的，试着将它隐藏呀某个函数背后，供客户调用</li><li>宁可使用C++新式的转型，因为容易辨认，同时便于排查错误。</li></ul><h3 id="28-条款：避免返回handles指向对象内部成分"><a href="#28-条款：避免返回handles指向对象内部成分" class="headerlink" title="28 条款：避免返回handles指向对象内部成分"></a>28 条款：避免返回handles指向对象内部成分</h3><p><strong>handles指的是诸如reference，指针，迭代器这种用来取得某个对象的变量，我们应当避免直接返回指向对象内部数据或函数的handle出现。</strong></p><p>如下，我们打算实现一个矩阵类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">point</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    point(<span class="keyword">int</span> x,<span class="keyword">int</span> y);</span><br><span class="line">  ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">int</span> val)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义角</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RectData</span>&#123;</span></span><br><span class="line">  point ulhc;</span><br><span class="line">  point lrhc;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义矩阵</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>&#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    tr1::<span class="built_in">shared_ptr</span>&lt;RectData&gt; pData;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">point&amp; <span class="title">upper</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> pData-&gt;ulhc;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>upper函数取得矩阵左上角的点，返回一个引用，这个引用指向了矩阵内部的点，就会引发一个矛盾，我们使用一个const函数，但是返回的值是private数据，且可以被修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Rectangle <span class="title">rec</span><span class="params">(coord1,coord2)</span></span>;</span><br><span class="line">rec.upper().setX(<span class="number">50</span>); <span class="comment">//被修改</span></span><br></pre></td></tr></table></figure><p>从从上面我们可以得出两条结论，</p><ul><li>第一条，成员变量的封装性只能等于返回其reference的级别，即引用的级别决定了封装性。</li><li>第二条，如果const成员函数传出一个reference，后者所指的数据与对象自身有关联，而他又被存储与对象之外，那么这个函数的调用者可以修改那笔数据。</li></ul><p>一个好的解决办法就是在函数调用的时候，将返回值的内容设置成const：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Point&amp; <span class="title">upperLeft</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> pData-&gt;ulhc;&#125;</span><br></pre></td></tr></table></figure><p>但是即使如此，如果直接返回代表对象内部数据的handle的话，有可能这个handle的生存周期比对象本身的生存周期要长，那么将导致空悬指针的发生（dangling handles）。</p><p>因此：<strong>尽量避免将对象内部的handles传出去。</strong></p><p><strong>总结</strong></p><ul><li>避免返回handles指向对象内部，遵守这个条款可以增加封装性，使得const更加像一个const，并避免虚调handles的发生。</li></ul><h3 id="29-条款：为异常安全而努力是值得的"><a href="#29-条款：为异常安全而努力是值得的" class="headerlink" title="29 条款：为异常安全而努力是值得的"></a>29 条款：为异常安全而努力是值得的</h3><p>对于一个异常安全性的函数来说，他通常有两个条件：</p><ul><li><strong>不泄漏任何资源</strong></li><li><strong>不允许数据败坏</strong>：即出现类似空指针，指向已经销毁的对象这种情况</li></ul><p>第一种情况可以通过资源管理类来完美的解决，下面专门来解决第二种情况</p><p><strong>异常安全函数</strong>提供以下三种程度的保证：</p><ul><li><strong>基本承诺：</strong>如果异常被抛出，程序内的任何事物仍然保持在有效状态下</li><li><strong>强烈承诺：</strong>如果异常被抛出，程序状态不改变，如果函数成功就完全成功，如果函数失败，就恢复到调用函数之前的状态。</li><li><strong>不抛掷保证：</strong>承诺不抛出异常，他们总能完成承诺的功能，例如一些内置类型等。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>上面的函数带有指定的空白异常，也就是说上述函数抛出异常的话，将会产生很严重的后果，但是该函数并不能提供任何异常安全的保证，异常安全的保护正完全由实现来决定。</p><p>对于异常安全来说，保证不抛出异常基本难以实现。基本上能够实现强烈承诺或基本承诺就可以满足需求了。</p><p>实现强烈承诺，即出现异常情况对象的状态不发生改变，有一个策略称为：<strong>copy and swap</strong>，即为打算修改的对象提供一份副本，并在那个副本上做一切必要的修改，如果出现异常，则原对象未发生改变，如果正常则将副本和原对象进行交换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> pretty::changeBackground(istream&amp; imgSrc)&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">  <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;mutex)</span></span>;    <span class="comment">// 获得mutex的副本</span></span><br><span class="line">  tr1::<span class="built_in">shared_ptr</span>&lt;PMImpl&gt; pNew(<span class="keyword">new</span> PMImpl(*pImpl)); </span><br><span class="line">  pNew-&gt;bgImage.reset(<span class="keyword">new</span> Image(imgSrc));</span><br><span class="line">  ++pNew-&gt;imageChanges;</span><br><span class="line">  swap(pImpl,pNew);  <span class="comment">// 释放mutex</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出来，对函数的异常保证将花费大量的资源，因此如果强烈保证不能满足的情况下，你就应该转向基本满足的情况。</p><p>对于一个对象来说，它的异常保证的级别取决于最差的一个异常保证函数。</p><p><strong>总结</strong></p><ul><li>异常安全函数即使发生异常也不会泄露资源或允许任何数据结构败坏，这样的函数区分为三种可能的保证：基本型，强烈型，不抛异常型</li><li>强烈保证往往能够以copy and swap实现出来</li><li>函数提供的异常安全保证，通常最高值等于其所调用的各个函数的异常安全保证种最弱的</li></ul><h3 id="30-条款：透彻了解inlining-的里里外外"><a href="#30-条款：透彻了解inlining-的里里外外" class="headerlink" title="30 条款：透彻了解inlining 的里里外外"></a>30 条款：透彻了解inlining 的里里外外</h3><p>inline函数，使用起来像函数，调用他们又不用蒙受额外的函数调用所导致的开销，编译器的最优化机制通常被设计成用来浓缩那些<strong>不含函数调用</strong>的代码，因此inline函数也会得到编译器在当前语境下的最优化处理。</p><p>但是过度使用inline同样会导致很多问题，首先是使得程序的目标码过大，导致一些效率上的损失。</p><p><strong>总之，如果inline函数的本体很小，编译器对函数本体所产出的代码可能比函数调用所产出的代码要小，这种情况将函数inlining确实可以导致较小的目标码和较高的指令高速缓存装置的击中率。</strong></p><p><strong>inline函数的做法</strong>：隐喻的做法是将函数定义在class内，自动就完成了inline的操作。明确声明的做法则是在函数前面加上inline关键字。</p><p><strong>inline函数通常一定被放置于头文件内，因为大多数的生成环境在编译过程中进行inline，需要知道函数本体长什么样子。</strong></p><p>模版类templates也通常被置于头文件内，因为它一旦被使用，编译器为了将它具体化，需要知道它长什么样子。但是templates与inline没有直接的联系，如果你觉得该templates内的函数都比较简单，可以进行inline的话，才会去定义为inline。</p><p><strong>inline是一个申请，编译器可以拒绝</strong></p><p>也就是说，一个函数最终实现方式是否是inline，取决于编译器是否同意该函数满足inline的条件。</p><p>例如大部分过于复杂（含循环，递归等）的函数，virtual声明的函数，通常都会被定义为outline函数。</p><p>有些编译器有意愿inlining某个函数，但是也可能为函数生成一个函数本体。<strong>例如程序要取得某个inline函数的地址，编译器通常必须为此函数生成一个outline函数本体。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;...&#125; <span class="comment">//假设编译器有意愿inline对f的调用</span></span><br><span class="line"><span class="keyword">void</span> (*f)()  = f;</span><br><span class="line">f(); <span class="comment">// 调用inline</span></span><br><span class="line">pf(); <span class="comment">// 调用outline的本体</span></span><br></pre></td></tr></table></figure><p>有时候，编译器会为析构函数和构造函数生成一个函数的副本，这样他们就可以获得指针指向那些需要指针的函数，但是这样一来，导致了析构函数和构造函数的赋值过程。</p><p>实际上析构函数，构造函数往往是inline糟糕的候选人，因为C++在创建对象的时候，将构造对象，析构对象，异常处理等一些操作隐藏在析构函数和构造函数内部，因此函数内部存在着很多的对象。但是对这些对象的副本往往会造成很大的资源消耗。</p><p><strong>因此，是否将构造函数和析构函数inline化，是一个慎重的考虑。</strong></p><p><strong>inline函数修改后必须重新编译</strong></p><p>此外，inline函数还存在一个问题。当我们对inline函数进行修改的时候，原来函数的本体因为已经编译进程序的内部了，无法通过函数的链接步骤实现修改，而是需要对整个程序进行重新编译。</p><p><strong>总结</strong></p><ul><li>将大多数inlining限制在小型、被频繁调用的函数身上，这可使得日后的调试过程和二进制升级更加容易，也可使潜在的代码膨胀问题最小化，使得程序速度提升最大化。</li><li>不要滥用inline，不用只因为function templates出现在头文件中就将他们声明为inline，因为很多时候，这些函数不符合inline标准，编译器还是会为他们生成outline版本</li></ul><h3 id="31-条款：将文件间的编译依存关系降至最低"><a href="#31-条款：将文件间的编译依存关系降至最低" class="headerlink" title="31 条款：将文件间的编译依存关系降至最低"></a>31 条款：将文件间的编译依存关系降至最低</h3><p>文件之间的依存关系越是复杂将会导致函数之间的耦合度越高，对修改代码带来不便。</p><p>例如你仅仅对class进行轻微的修改，但是这将导致所有用到这个文件的程序都需要进行重新编译，这一连串的编译依存关系将导致难以形容的灾难。</p><p>例如下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"data.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"address.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,<span class="keyword">const</span> Date&amp; birthday);</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">birthday</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> thename;</span><br><span class="line">    Data theData;</span><br><span class="line">    address add;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的类别的私有变量中，string，Data需要用到其他的头文件来创建（实现细则），这些头文件任意一个被修改后都将导致Person class重新编译。</p><p>针对这种形式，我们可以这样做：</p><p><strong>把person分割为两个classes，一个只提供接口，另一个负责实现该接口。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>;</span>   <span class="comment">// 类的前置声明</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name,<span class="keyword">const</span> Date&amp; birthday);</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">birthday</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    str1::<span class="built_in">shared_ptr</span>&lt;PersonImpl&gt; pImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类PersonImpl为person类的实现，这样的话，修改Data类就不需要对Person函数进行重新编译，将person与其他类进行分离。</p><p>这个分离的关键在于：<strong>使用声明的依存性</strong>来代替<strong>定义的依存性</strong>，尽量让头文件自我满足，万一无法做到，那么让它和其他文件内的声明式相依（而不是定义式）。</p><p>下面一些准则都是这个原则下完成的：</p><ul><li>如果使用object references 或objects pointers可以完成任务，就不要使用object，即使用声明式来代替定义式。</li><li><p>尽量以class声明式代替class定义式。</p></li><li><p><strong>为声明式和定义式提供不同的头文件</strong>，为一个文件提供函数的声明，而不是而代替提供class的定义式，这样可将文件见的编译依存关系去掉。因此我们需要定义两个文件，一个是声明式，另一个是定义式。</p></li></ul><p>上面这个实现使得代码编，让Person变成一个handle class。</p><p><strong>抽象基类</strong></p><p>通过制作抽象类的方式，也可以实现这种操作。通过定义抽象类函数接口，创建不同类型的的派生类对象。</p><p>handle classes 和interface class解除了接口和实现之间的耦合关系，从而减低了文件间的编译依存关系。但是也在某种程度上使得每个对象超额付出若干的时间以及空间的成本。</p><p><strong>总结</strong></p><ul><li>支持<strong>编译依存最小化</strong>的一般构想是：相依与声明式，不要相依于定义式，基于此的构想的两个手段是 handle classes，interface classes。</li><li>程序库头文件应该以完全且仅有的声明式的形式存在，这种做法不论是否涉及templates都适用。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019/11/10，effective cpp第五章 实现&lt;/p&gt;
&lt;p&gt;cpp在实现上存在着很多高效率，代码优化的细节。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;26 条款：经可能延后变量定义式的出现时间&lt;/li&gt;
&lt;li&gt;27 条款：尽量少做转型动作&lt;/li&gt;
&lt;li&gt;28 条款：避免返回handles指向对象内部成分&lt;/li&gt;
&lt;li&gt;29 条款：为异常安全而努力是值得的&lt;/li&gt;
&lt;li&gt;30 条款：透彻了解inlining 的里里外外&lt;/li&gt;
&lt;li&gt;31 条款：将文件间的编译依存关系降至最低&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="effective cpp" scheme="https://wenhui-zhou.github.io/categories/effective-cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>effective cpp(四) 设计与声明</title>
    <link href="https://wenhui-zhou.github.io/2019/11/09/effective-cpp-%E5%9B%9B-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E/"/>
    <id>https://wenhui-zhou.github.io/2019/11/09/effective-cpp-四-设计与声明/</id>
    <published>2019-11-09T04:42:31.000Z</published>
    <updated>2019-11-10T11:23:32.252Z</updated>
    
    <content type="html"><![CDATA[<p>2019/11/09 effective cpp 第四章</p><p>良好的cpp接口的设计以及声明是可以令软件作出其最正确的事，包括正确，高效性、封装性、维护性、延展性、以及协议一致性。</p><ul><li>18 条款：让接口容易被正确使用，不易被误用</li><li>19 条款：设计class犹如设计type</li><li>20 条款：宁以 pass-by-reference-to-const 替换 pass-by-value</li><li>21 条款：必须放回对象时，别妄想返回其reference</li><li>22 条款：将成员变量声明为private</li><li>23 条款：宁以non-member、non-friend替换member函数</li><li>24 条款：若所有参数皆需类型转换，请为此采用non-member函数</li><li>25 条款：考虑写出一个不抛异常的swap函数</li></ul><a id="more"></a><h3 id="18-条款：让接口容易被正确使用，不易被误用"><a href="#18-条款：让接口容易被正确使用，不易被误用" class="headerlink" title="18 条款：让接口容易被正确使用，不易被误用"></a>18 条款：让接口容易被正确使用，不易被误用</h3><p>接口开发的目标在于：<strong>让接口容易被正确使用，不易被误用</strong></p><p>但是由于有时候会遇到用户传入的参数和接口能够接受的参数不同，可能会导致错误，这个时候最后通过 <strong>类型系统的方式来预防</strong>，通过导入新的类别来限制数据类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Date(<span class="keyword">const</span> Month&amp; m,<span class="keyword">const</span> Day&amp; d,<span class="keyword">const</span> Year&amp; y)&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Month(<span class="number">3</span>),Day(<span class="number">30</span>),year(<span class="number">1995</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>对数据的限制部分在每一个数据类型的函数内部。明智地选择合适的新类型，能够有效的防止接口被误用。</p><p>另一个预防客户错误的方式是限制类型内可做什么事情，不能做什么事情，常见的限制加上const，阻止用户自定义类型错误。</p><p>另一个准则为除非有好的理由，否则应该尽量令你的types的行为和内置的type的行为一致。例如STL中的所有类均有一个size方法，表示长度。</p><p>如果在接口内部有资源的申请，申请的资源必须在最后得到销毁。因此最好的方法就是将函数的返回值设置为shared_ptr：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str1:：<span class="built_in">shared_ptr</span>&lt;invest&gt; create();</span><br></pre></td></tr></table></figure><p>此外，shared_ptr还允许绑定一个对象释放函数，当对象释放的时候，shared_ptr调用这个函数来释放对象。定义方式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str1::<span class="built_in">shared_ptr</span>&lt;invest&gt; pInt(ptr,deleteMethod);</span><br></pre></td></tr></table></figure><p><code>str1::shared_ptr</code>会自动调用每个使用它的指针专属的删除器，避免跨DLL文件delete导致运行期的错误。<strong>shared_ptr会调用指针的专属删除器</strong>。</p><p>shared_ptr在效率和空间上是用指针的两倍大，使用辅助动态内存，比原始指针要大。</p><p><strong>总结</strong></p><ul><li>设计不容易出错的接口</li><li>保证接口之间的一致性</li><li>阻止误用，建立新类型的方式限制类型上的操作，消除客户资源管理的任务</li><li>Tr1::shared_ptr支持定制删除器，防范DLL问题</li></ul><h3 id="19-条款：设计class犹如设计type"><a href="#19-条款：设计class犹如设计type" class="headerlink" title="19 条款：设计class犹如设计type"></a>19 条款：设计class犹如设计type</h3><p>当你定义了一个新的class，也就定义了一个type，设计好的type有自然的语法和直观的语义，有一下的设计规范：</p><ul><li>新type的对象应该如何创建和销毁</li><li>对象初始化和对象的赋值该有什么样的差别</li><li>新type对象如果被传值（passed by value）该在copy函数中写实现方法</li><li>对type的合法值进行约束</li><li>新的type是否需要配合继承图系</li><li>新type需要什么样的类型转换</li><li>什么样的操作符和函数对新type是合理的</li><li>什么样的标准函数需要驳回</li><li>谁该去用新type成员</li><li>什么是新type的未声明接口</li><li>type的一般化程度</li><li>你真的需要一个新type吗</li></ul><p><strong>总结</strong></p><p>设计一个class的时候，需要充分考虑上面的问题，具体所指可以参考书本84页。</p><h3 id="20-条款：宁以-pass-by-reference-to-const-替换-pass-by-value"><a href="#20-条款：宁以-pass-by-reference-to-const-替换-pass-by-value" class="headerlink" title="20 条款：宁以 pass-by-reference-to-const 替换 pass-by-value"></a>20 条款：宁以 pass-by-reference-to-const 替换 pass-by-value</h3><p>C++默认以传值的方式给函数传递参数，这一过程函数参数的初值都是调用对象的构造函数来实现，当离开这个函数的时候，通过析构函数来回收这些资源，因此传值的方式将会耗费大量的资源和时间。</p><p>一个很好的优化方法就是使用const 引用的方式，这种方式没有任何的构造函数被调用。之所以使用const，是为了保证传入的参数对象不会被改变。</p><p>此外如果直接传值，对于参数类型为父类的情况，传入子类对象，会造成子类特化功能被切割，参数的行为与父类相同，但是如果使用传引用的方式，这种现象不会发生。</p><p>说到这里，我们会好奇，引用到底是个什么东西呢，其实际上运用是通过指针的方式来实现的，传递引用等同于传递指针，<strong>对于内置类型来说，传值方式会比传指针的方式更加高效。</strong> 对于int，float这些类型，直接通过传值的方式更加的高效。</p><p><strong>总结</strong></p><ul><li>尽量以传const引用的方式替换传值的方式，前者通常比较高效，避免对象切割问题</li><li>对于内置类型以及STL迭代器，函数对象来说，直接传值比较高效</li></ul><h3 id="21-条款：必须放回对象时，别妄想返回其reference"><a href="#21-条款：必须放回对象时，别妄想返回其reference" class="headerlink" title="21 条款：必须放回对象时，别妄想返回其reference"></a>21 条款：必须放回对象时，别妄想返回其reference</h3><p>当我们尝试消灭所有的传值行为的时候，我们可能会对函数的返回值下手，这种做法是不可取的。</p><p>所谓的引用，即表明它所指代的对象一定要存在，在函数中我们有两种方式创建对象：</p><p><strong>创建对象在stack内存上</strong></p><p>stack内存存放函数的参数，局部变量值，由编译器自动释放：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Ration&amp; <span class="keyword">operator</span>*(<span class="keyword">const</span> Ration&amp; lhs,<span class="keyword">const</span> Ration&amp; rhs)&#123;</span><br><span class="line">  <span class="function">Ration <span class="title">result</span><span class="params">(lhs.n*rhs.n)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上买代码返回了一个局部变量的引用，但是由于出了这个函数，局部变量就会被销毁，因此这个reference将毫无意义。</p><p><strong>创建对象在heap内存上</strong></p><p>用户自己分配，自己销毁的资源都会分配在heap内存上，有new-delete对来管理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Ration&amp; <span class="keyword">operator</span>*(<span class="keyword">const</span> Ration&amp; lhs,<span class="keyword">const</span> Ration&amp; rhs)&#123;</span><br><span class="line">  Ration* result = <span class="keyword">new</span> Ration(lhs.n*rhs.n);</span><br><span class="line">  <span class="keyword">return</span> *result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面返回的引用是有意义的，但是当我们使用完这个 内存之后，由谁去销毁呢，在一些很复杂的操作里面，程序员往往无法保证资源的完全回收。</p><p><strong>使用static变量</strong></p><p>在函数内部定义static变量，该变量的生命周期是整个程序的生命周期，static变量，全局变量他们的值都是存放在同一块区域，由程序结束后统一回收。</p><p>但这又引发了另一个问题，你想要比较两个数相乘后与另外两个数相乘的大小，但是结果存放在static当中，程序只会保存一份static的结果，因此永远无法比较。</p><p>因此，<strong>如果函数要求返回一个对象，那么我们就承担返回值所产生的构造和析构成本</strong>，不要试图去放回引用。</p><p><strong>总结</strong></p><p>不要返回一个指针或引用指向一个local对象，或指向heap-allocated对象，或指向static对象，而是直接返回该对象（传值）。</p><h3 id="22-条款：将成员变量声明为private"><a href="#22-条款：将成员变量声明为private" class="headerlink" title="22 条款：将成员变量声明为private"></a>22 条款：将成员变量声明为private</h3><p>为保证成员便来那个的约束性，对用户隐藏变量，使得类中的约束条件总会收到维护。如果将一个变量声明为public，破坏了封装性，在我们修改该变量的时候，我们无法预知这个变量所涉及的一切，可能会对程序造成极大的破坏。因此保护类的封装性。protected类型与public相似，其实只有来那个两种访问权限：<strong>private（提供封装）和其他（不提供封装）</strong></p><p><strong>总结</strong></p><ul><li>切记将成员变量声明为private，这可赋予客户访问数据一致性，细微划分访问控制，允许约束条件获得保护，并 提供class作者充分的实现弹性。</li></ul><h3 id="23-条款：宁以non-member、non-friend替换member函数"><a href="#23-条款：宁以non-member、non-friend替换member函数" class="headerlink" title="23 条款：宁以non-member、non-friend替换member函数"></a>23 条款：宁以non-member、non-friend替换member函数</h3><p>这个条款的核心在于：<strong>越少的操作直接接触到数据，对类的封装性，代码的维护越好</strong>。因此如果一些操作可以由非成员函数来完成的话，就不要去写那个成员函数的版本。</p><p>越少的函数接触到数据，我们在改变数据的时候，就可以有越大的灵活度修改这个数据。</p><p>有几种方式可以去实现非类内函数来完成这个操作：</p><ul><li>例如我们指提供了一个完成基础操作的类，我们可以选择另一个类中的函数，传入这个对象，来实现你想要的操作，而不用为基础类添加成员</li><li>C++的一个常用的做法是，将non-member函数与类写在同一个命名空间中，命名空间可以跨越多个源码文件。将所有便利函数放在多个头文件内，但同属于一个命名空间，以为着用户可以轻松扩展这一组便利函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件webbrowser.h</span></span><br><span class="line"><span class="keyword">namespace</span> webbrowserStuff&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">webbrowser</span>&#123;</span>...&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头文件webbrowserbook.h</span></span><br><span class="line"><span class="keyword">namespace</span> webbrowserbook&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 头文件webbrowsercookies.h</span></span><br><span class="line"><span class="keyword">namespace</span> webbrowsercookies&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过include需要的头文件的方式来管理标准程序库，使得那一小部分系统形成编译相依的关系。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//web.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> wweb&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">web</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">get_name</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        web(<span class="built_in">string</span> n):name(n)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">say_hi</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//web.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"web.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::wweb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> web::say_hi() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hihi"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li>宁可用non-member函数替代member函数，这可增加类的封装性，包裹性，机能扩充性。</li><li>non-member的函数通常与class定义在同一个命名空间内</li></ul><h3 id="24-条款：若所有参数皆需类型转换，请为此采用non-member函数"><a href="#24-条款：若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="24 条款：若所有参数皆需类型转换，请为此采用non-member函数"></a>24 条款：若所有参数皆需类型转换，请为此采用non-member函数</h3><p>当我们传入参数都需要进行类型转换的时候，如果将类函数写成如下情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ration</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">const</span> Ration <span class="keyword">operator</span>* (<span class="keyword">const</span> Ration&amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Ration <span class="title">oneE</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">Ration result = oneE*<span class="number">2</span>; <span class="comment">// C++将2转换成Ration类型</span></span><br><span class="line">Ration result = <span class="number">2</span>*oneE; <span class="comment">// 编译错误，因为this不可以作为类型转换的变量</span></span><br></pre></td></tr></table></figure><p>只有当参数可位列于参数列中内，这个参数才允许隐式转换，因此一个比较好的方法就是非类内函数去实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Ration <span class="keyword">operator</span>*(<span class="keyword">const</span> Ration&amp; lhs,<span class="keyword">const</span> Ration&amp; rhs)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能够避免使用友元的情况就一定要避免使用它。</p><p><strong>总结</strong></p><p>如果需要为某个函数的所有参数进行类型的转换，那么这个函数必须是个non-member。</p><h3 id="25-条款：考虑写出一个不抛异常的swap函数"><a href="#25-条款：考虑写出一个不抛异常的swap函数" class="headerlink" title="25 条款：考虑写出一个不抛异常的swap函数"></a>25 条款：考虑写出一个不抛异常的swap函数</h3><p>swap函数的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">namspace <span class="built_in">std</span>&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a,T&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要支持copying，swap就会完成交换。但是上面这种方法需要不断的构造，析构。于是我们选择特性化swap，<strong>通过置换指针的方式就可以达到置换的效果</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">widget</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span></span>&#123;</span><br><span class="line">      <span class="keyword">using</span> <span class="built_in">std</span>::swap;  <span class="comment">//令std内的swap函数可见</span></span><br><span class="line">      swap(pInt,other.pInt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;&gt;  <span class="comment">//告诉编译器，这是个全特化的版本</span></span><br><span class="line">  <span class="keyword">void</span> swap&lt;Widget&gt;(Widget&amp; a,Widget&amp; b)</span><br><span class="line">  &#123;</span><br><span class="line">    a.swap(b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此优化copy：</p><ul><li>提供一个public swap成员函数，让它高效置换你的类型的两个对象值，且不能抛出异常。（置换基本类型）。</li><li>在class或template所在命名空间中提供一个non-member swap函数，并令他调用上述的swap成员函数。</li><li>如果你正编写一个class，为你的class特化std::swap，并调用你的swap。</li></ul><p><strong>总结</strong></p><ul><li><p>当std::swap对你的类型效率不高的时候，提供一个swap成员函数，并确保不抛出异常</p></li><li><p>提供一个member swap函数，也应该提供一个non-member swap用来调用前者，对于classes也请特化std::swap。</p></li><li>调用 swap时应该针对std::swap使用using声明式，然后调用swap并且不带任何命名空间资格修饰。</li><li>为“用户定义类型”进行std::template全特化是好的但是千万不要尝试在std内部加上对std而言全新的东西。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019/11/09 effective cpp 第四章&lt;/p&gt;
&lt;p&gt;良好的cpp接口的设计以及声明是可以令软件作出其最正确的事，包括正确，高效性、封装性、维护性、延展性、以及协议一致性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;18 条款：让接口容易被正确使用，不易被误用&lt;/li&gt;
&lt;li&gt;19 条款：设计class犹如设计type&lt;/li&gt;
&lt;li&gt;20 条款：宁以 pass-by-reference-to-const 替换 pass-by-value&lt;/li&gt;
&lt;li&gt;21 条款：必须放回对象时，别妄想返回其reference&lt;/li&gt;
&lt;li&gt;22 条款：将成员变量声明为private&lt;/li&gt;
&lt;li&gt;23 条款：宁以non-member、non-friend替换member函数&lt;/li&gt;
&lt;li&gt;24 条款：若所有参数皆需类型转换，请为此采用non-member函数&lt;/li&gt;
&lt;li&gt;25 条款：考虑写出一个不抛异常的swap函数&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="effective cpp" scheme="https://wenhui-zhou.github.io/categories/effective-cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>EncNet结合上下文的语义分割</title>
    <link href="https://wenhui-zhou.github.io/2019/11/06/EncNet%E7%BB%93%E5%90%88%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/"/>
    <id>https://wenhui-zhou.github.io/2019/11/06/EncNet结合上下文的语义分割/</id>
    <published>2019-11-06T09:39:32.000Z</published>
    <updated>2019-11-20T05:31:48.982Z</updated>
    
    <content type="html"><![CDATA[<p>《Context Encoding for Semantic Segmentation》是发表在2018年cvpr上的文章，文章的主要insight在于将图像中的内容信息加入到语义分割的网络中，通过一个context encoding module突出图像类别，对分类类别进行简化，降低分割的难度，提升分割的精度。</p><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>目前的分割网络主要的关注点在于pixel-level predict，即对每个像素进行类别的分类。从2016年提出的FCN分割网络开始，图像分割实现了一个端到端的分割，当时由于CNN-pooling的网络设计，使得FCN网络对数据的丢失严重。为了解决这个问题，人们提出了dilated conv以及特征金字塔等（deeplab）结构来解决这个问题，即扩大feature map的感受野的同时，保证feature map的分辨率，保留大部分的数据。</p><p>EncNet另辟蹊径，认为通过图像中给出的类别信息能够对分割种类进行缩小，找到一个比较小的子集，在该类别的子集上进行语义的分割，简化分割问题。本文给出了两个主要的贡献：</p><ol><li>本文提出了一个context encoding mudule模块，以及一个SE-Loss，一个简单的单元来利用全局的场景内容信息学到不同channel的权重，以及学到场景中所包含的类别。</li><li>EncNet，作者的第二个贡献就是提出了EncNet这个网络，能勾在许多公开的语义分割的数据集上取得state of the art的效果。</li></ol><p>下面来看一下作者具体是怎么实现的：</p><p><img src="/images/3D/encnet.png" style="zoom:40%;"></p><h3 id="Context-Encoding-Module"><a href="#Context-Encoding-Module" class="headerlink" title="Context Encoding Module"></a>Context Encoding Module</h3><p><strong>context Enocding</strong></p><p>作者通过使用一系列的卷积层（空洞卷积）去学习一个内在的语义字典的表示，将这个字典作为编码语义，为了方便使用上下文，去学习预测了一组缩放因子用于突出和类别相关的特征图。</p><p>将feature map的大小reshape成二维（WxH）x C，去学习codebook $D = {d_1,d_2,…d_k}$ ,以及一组和视觉中心平滑因子$S = {s_1,s_2,…s_k}$,编码层输出残差编码，通过soft-assignment进行聚合，$e_k = \sum_{i=1}^{N}e_{ik}$，其中$e_{ik}$ 如下：<br>$$<br>\begin{equation}<br>e_{i k}=\frac{\exp \left(-s_{k}\left|r_{i k}\right|^{2}\right)}{\sum_{j=1}^{K} \exp \left(-s_{j}\left|r_{i j}\right|^{2}\right)} r_{i k}<br>\end{equation}<br>$$<br>其中$r_{ik} = x_i - d_k$作为残差加入计算，其中$e = \sum_{k=1}^{K}\phi(e_k)$，对所有的ek进行batch normalization得到e，作为编码层的输出。</p><p><strong>feature attention</strong></p><p>通过编码层输出的e，来学习一组缩放因子，用于强调和抑制一些不同的类别。缩放因子通过全连接层进行学习，最得到一组缩放因子如下：<br>$$<br>\gamma = \sigma(We)<br>$$<br>其中w为全连接层的参数，$\sigma$为sigmoid函数，最终将得到的缩放因子与输入的深度图进行相乘得到最终权重改变后的feature map。</p><p><strong>Semantic Encoding Loss</strong></p><p>作者为了能够更好的理解图片与类别之间的关系，从图像中直接预测出图像中所包含的类别，将编码层的输出传入另一个全连接层中，GT为图片中已有的类别，通过最小化SE-Loss，即二次的交叉熵loss，判断60个类，存在或不存在的方式，来建立图像全局信息与类别之间的映射关系。最终对图像中的类别进行一个削减。</p><h3 id="Context-Encoding-Network"><a href="#Context-Encoding-Network" class="headerlink" title="Context Encoding Network"></a>Context Encoding Network</h3><p>EncNet网络的backbone使用的是resnet，同时使用了之前证明有效的dilated conv，在深度图的state3，和4阶段使用了空洞卷积：</p><p><img src="/images/3D/dilated.png" style="zoom:50%;"></p><p>在stage3位置上同样适用了SE-loss，作为一个额外的正则化的操作，encnet在FCN的基础上进行一些小的改动，通过增加一些轻微的计算量就可以达到一个很好的效果。</p><h3 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h3><p>pixAcc：像素类别预测正确的像素除以所有像素的比例。</p><p>mIoU：每一类预测结果与GT的结果的IoU的平均值。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>看完整篇文章，这篇文章最大的亮点就是认为<strong>飞机不会出现在房间里</strong>，利用图像的feature map，与类别GT，建立一个映射，从而在做最终的逐像素的语义分割的问题时，没必要在所有的类别上做，而是直接在根据图像feature map上映射得到的类别上做，降低了语义分割的难度。</p><p>对图像整个内容信息的提取上，主要由两部分构成，一部分对不同的channel学习一个重要性权重，另一个直接通过图像内容学习一个图像中含有的类别。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Context Encoding for Semantic Segmentation》是发表在2018年cvpr上的文章，文章的主要insight在于将图像中的内容信息加入到语义分割的网络中，通过一个context encoding module突出图像类别，对分类类别进行简化，降低分割的难度，提升分割的精度。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>

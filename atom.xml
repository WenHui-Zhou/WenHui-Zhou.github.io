<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WenHuiZhou</title>
  
  <subtitle>perper（打起精神！）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wenhui-zhou.github.io/"/>
  <updated>2020-05-28T13:26:50.076Z</updated>
  <id>https://wenhui-zhou.github.io/</id>
  
  <author>
    <name>WenHuiZhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常见的目标检测网络</title>
    <link href="https://wenhui-zhou.github.io/2020/05/27/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E7%BD%91%E7%BB%9C/"/>
    <id>https://wenhui-zhou.github.io/2020/05/27/常见的目标检测网络/</id>
    <published>2020-05-27T03:17:51.000Z</published>
    <updated>2020-05-28T13:26:50.076Z</updated>
    
    <content type="html"><![CDATA[<p>总结常见的目标检测网络，持续更新，文章要写很长。</p><p>[TOC]</p><a id="more"></a><h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><p>目标检测任务可以理解为目标的识别和定位，识别指的是判断物体的类别，定位指的是确定物体的位置。</p><p>目前的目标检测模型分为两类，一类是two-stage，这一类的典型代表是RCNN，Fast-RCNN，Faster-RCNN家族。他们的特点是检测精度高，识别错误率低，但是速度较慢，不能满足实时场景的需求。另一类是one-stage，他们典型的网络有yolo，SSD，yolo2并且准确率能够和two-stage基本持平。</p><h3 id="RCNN-2014"><a href="#RCNN-2014" class="headerlink" title="RCNN(2014)"></a>RCNN(2014)</h3><p>RCNN详解：<a href="https://perper.site/2019/02/11/RCNN详解/" target="_blank" rel="noopener">https://perper.site/2019/02/11/RCNN%E8%AF%A6%E8%A7%A3/</a></p><p><strong>大致流程：</strong></p><ul><li>首先通过select search算法选择出图像中可能出现目标的box，最终得到2000个框<ul><li>将图像过分割出2k-3k个框</li><li>对框进行合并（颜色相近，梯度相近等）</li><li>输出曾经有出现过的框</li></ul></li><li>将输出的候选框依次输入到卷积网络中进行网络训练</li><li>将cf7层得到4096维特征输出到SVM中，训练N个SVM二分类器，对每个框进行二分类</li><li>边框回归：边框回归主要学习四个参数分别是x，y的偏移和w，h的缩放。通过优化二模和参数二次项，得到四个变换的参数，然后将参数乘以相应的边得到最终的边框位置（位移和缩放）</li></ul><p>RCNN的流程如下图：</p><p><img src="/Users/zhouwenhui/blog/source/images/nlp/image-20200528011717296.png" alt="image-20200528011717296" style="zoom:50%;"></p><p>该网络的主要缺陷在于：</p><ul><li>候选框由select search算法产生，需要花费很长时间</li><li>对2k个候选框，均需要从头做卷积，存在很多的冗余计算</li><li>模型确定的情况只能接受固定大小的输入</li><li>网络训练过程分段，过程繁琐</li></ul><h3 id="Fast-RCNN-2015"><a href="#Fast-RCNN-2015" class="headerlink" title="Fast-RCNN(2015)"></a>Fast-RCNN(2015)</h3><p>Fast-RCNN详解：<a href="https://perper.site/2019/02/14/Fast-RCNN详解/" target="_blank" rel="noopener">https://perper.site/2019/02/14/Fast-RCNN%E8%AF%A6%E8%A7%A3/</a></p><p><strong>大致流程：</strong></p><ul><li>select search 算法提取2k个候选框</li><li>将图片整体输入卷积网络中，得到整个图片的feature map</li><li>通过RoI projection（通过感受野的映射公式）将2k个region proposal 映射到feature map</li><li>通过RoI pooling变成一样大，然后经过全连接层等接入softmax分类，已经bbox边框回归</li></ul><p><strong>RoI pooling</strong></p><p>RoI pooling将传入不同大小的region proposal划分层h x w个网格，对每个网格做max pooling，因此得到的输出大小是一致的。</p><p>RoI pooling反向传播过程中，原则是，max value那个位置梯度为1，其他位置为0。由于不同的region可能存在重叠的部分，因此重叠部分的梯度是每个region 梯度的求和。</p><p><strong>Loss</strong></p><p>分类部分，Fast RCNN使用的是softmax + 交叉熵：</p><p>softmax：<br>$$<br>P_{i}=\frac{e^{V_{i}}}{\sum_{i}^{C} e^{V_{i}}}<br>$$<br>交叉熵：<br>$$<br>L = -\sum(plog(p))<br>$$</p><p>边框回归使用smooth L1 loss代替原来的L2loss：<br>$$<br>\operatorname{smooth}_{L_{1}}(x)=\left{\begin{array}{lr}0.5 x^{2} &amp; \text { if }|x|&lt;1 \ |x|-0.5 &amp; \text { otherwise }\end{array}\right.<br>$$<br><strong>网络流程：</strong></p><p><img src="/Users/zhouwenhui/blog/source/images/nlp/image-20200528111556483.png" alt="image-20200528111556483" style="zoom:50%;"></p><p><strong>缺点：</strong></p><ul><li>select search 算法提取候选框效率太低了（CPU上），每张图耗时3s</li></ul><h3 id="Faster-RCNN-2016"><a href="#Faster-RCNN-2016" class="headerlink" title="Faster RCNN(2016)"></a>Faster RCNN(2016)</h3><p>Faster RCNN详解：<a href="https://perper.site/2019/02/14/Faster-RCNN详解/" target="_blank" rel="noopener">https://perper.site/2019/02/14/Faster-RCNN%E8%AF%A6%E8%A7%A3/</a></p><p><strong>大致流程：</strong></p><ul><li>将图片输入到卷积网络中，生成feature map</li><li>将feature map输入RPN层（region proposal network）中，输出proposal region</li><li>提取出proposal region内的feature map 输入到RoI pooling层，输出固定维度的向量</li><li>对该向量进行softmax分类以及边框回归</li></ul><p><strong>RPN层</strong></p><p>RPN即region proposal network，输入feature map，输出为候选框的位置。RPN网络有两个分支。一个分支是softmax进行前后景的分类。另一支是边框回归（同RCNN），修正region proposal的位置。</p><p><strong>前后景分类</strong></p><p>在feature map的每一个像素点上，生成9个长宽比不同的anchor作为初始的anchor，然后第一个分支用softmax对每一个边框判断是前景还是背景。对于GT来说，前背景anchor标签分配的规则是：</p><ul><li>与某个GT的IoU最大的为前景</li><li>与任意GT IoU大于0.7为前景</li><li>与任意GT的IoU小于0.3为负类</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结常见的目标检测网络，持续更新，文章要写很长。&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
    
    </summary>
    
      <category term="深度学习总结" scheme="https://wenhui-zhou.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>常见数据结构</title>
    <link href="https://wenhui-zhou.github.io/2020/05/26/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://wenhui-zhou.github.io/2020/05/26/常见数据结构/</id>
    <published>2020-05-26T14:57:20.000Z</published>
    <updated>2020-05-27T03:16:55.375Z</updated>
    
    <content type="html"><![CDATA[<ul><li>array</li><li>链表</li><li>hash map</li><li>set</li><li>红黑树</li></ul><h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><p>数组又叫顺序表，在内存中存储空间是连续的，允许用户对其进行插入，删除，访问和替换等等。Python中的列表是由对其它对象的引用组成的连续数组。</p><p>append复杂度为O(1)，insert复杂度为O(n)，sort复杂度：O(nlogn)。</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表数据存储空间未必是连续的，在插入或删除的时候，只需要改变指针的指向，其他都是不变的。链表的空间不需要提前分配，链表只能顺序访问，无法实现随机访问。</p><h3 id="hash-map"><a href="#hash-map" class="headerlink" title="hash map"></a>hash map</h3><p>哈希表的关键思路在于建立存储对象和地址之间的联系，这个联系即哈希函数。通过哈希函数算出对象的地址。dict类似对key进行了hash,然后再对hash生成一个红黑树进行查找，其查找复杂其实是O(logn)，O(1)是理想情况。</p><p>建立hash map的过程哈希值可能存在冲突，可用的解决方案是：链式地址法，开放定址法，线行探查法，平方探查法等。</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set本质上是一颗红黑树</p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树是一棵自平衡二叉查找树，<strong>二叉查找树</strong>满足左子树节点小于根节点，右子树节点大于根节点。</p><p><strong>红黑树的定义和性质：</strong></p><ul><li>红黑树每个节点要么是红色，要么是黑色</li><li>根节点是黑色</li><li>子节点是黑色</li><li>红色节点两个子节点都是黑色的</li><li>如果一个节点存在一个子黑节点，那么一定会有两个黑色子节点</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;array&lt;/li&gt;
&lt;li&gt;链表&lt;/li&gt;
&lt;li&gt;hash map&lt;/li&gt;
&lt;li&gt;set&lt;/li&gt;
&lt;li&gt;红黑树&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;array&quot;&gt;&lt;a href=&quot;#array&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="深度学习总结" scheme="https://wenhui-zhou.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>序列化RNN系列</title>
    <link href="https://wenhui-zhou.github.io/2020/05/21/%E5%BA%8F%E5%88%97%E5%8C%96RNN%E7%B3%BB%E5%88%97/"/>
    <id>https://wenhui-zhou.github.io/2020/05/21/序列化RNN系列/</id>
    <published>2020-05-21T05:52:45.000Z</published>
    <updated>2020-05-21T13:55:46.728Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么需要RNN"><a href="#为什么需要RNN" class="headerlink" title="为什么需要RNN"></a>为什么需要RNN</h3><p>当我们遇到一些数据是序列的，长度不定的，数据的先后，顺序，是存在相互影响的语义的。对于这类问题，因此就出现了RNN这种结构，能够能够的提取序列数据的特征。</p><h3 id="RNN结构"><a href="#RNN结构" class="headerlink" title="RNN结构"></a>RNN结构</h3><p><img src="/images/nlp/image-20200521141220698.png" alt="image-20200521141220698" style="zoom:50%;"></p><p>最简单的RNN的结构如上所示，左边是一个RNN单元，右边是将这个单元展示后得到的网络。最早的激活函数使用tanh，该网络的特殊之处在于，下一个阶段网络的输入由上一阶段的输出以及x共同组成，用公式表示如下：<br>$$<br>\begin{array}{l}O_{t}=g\left(V \cdot S_{t}\right) \ S_{t}=f\left(U \cdot X_{t}+W \cdot S_{t-1}\right)\end{array}<br>$$</p><h3 id="RNN的优点"><a href="#RNN的优点" class="headerlink" title="RNN的优点"></a>RNN的优点</h3><ol><li>RNN可以记录时间序列上的信息，对于序列数据，前后语义有着相互联系的场景比较适用。</li><li>RNN可以处理文本，语音这些数据，数据的输出长度可以是不定的。</li></ol><h3 id="RNN的缺点"><a href="#RNN的缺点" class="headerlink" title="RNN的缺点"></a>RNN的缺点</h3><ol><li><p>梯度消失和梯度爆炸问题，当对RNN进行梯度求导的时候，得到的表达式是参数的一个连乘形式，任意时刻对$W_s$求偏导如下：<br>$$<br>\frac{\partial L_{t}}{\partial W_{x}}=\sum_{k=0}^{t} \frac{\partial L_{t}}{\partial O_{t}} \frac{\partial O_{t}}{\partial S_{t}}\left(\prod_{j=k+1}^{t} \frac{\partial S_{j}}{\partial S_{j-1}}\right) \frac{\partial S_{k}}{\partial W_{x}}<br>$$<br>随着网络加深，连乘项越来越多，将S用tanh激活函数带入，下面表达式可变为：<br>$$<br>\prod_{j=k+1}^{t} \frac{\partial S_{j}}{\partial S_{j-1}}= \prod_{j=k+1}^{t} \tanh ^{\prime} W_{s}<br>$$<br>即一个参数累乘的形式，当网络足够深的时候，如果参数小于一，则会出现梯度消失的问题，如果参数大于1，多次连乘的结果将导致梯度爆炸。</p></li><li><p>RNN网络难以训练，并且如果使用的是tanh或者relu激活函数，它无法处理非常长的序列。</p></li></ol><p>通过上面可以发现，只要解决了掉偏导公式中参数连乘的哪一项就可以解决梯度问题，LSTM就是按照这个思路，将这一项变成0或者1。</p><h3 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h3><p>LSTM即long short Term memory，LSTM的结构比普通的RNN要复杂一些，由三个门结构组成，分别是遗忘门，输入门，输出门：</p><p><img src="/images/nlp/image-20200521155345276.png" alt="image-20200521155345276" style="zoom:50%;"></p><p>首先是<strong>遗忘门</strong>，对输入的数据做一些选择性的遗忘，控制是否遗忘由sigmoid决定。其次是<strong>输入门</strong>，利用sigmoid对输入数据进行取舍，tanh对输入数据赋予权重。<strong>输出门</strong>：利用sigmoid对输入进行取舍，然后用tanh对数据进行加权，得到下一个输入。</p><p>（通过sigmoid后的特征，最后通过一个乘法加入到网络中）</p><h3 id="为什么LSTM能够解决梯度消失问题"><a href="#为什么LSTM能够解决梯度消失问题" class="headerlink" title="为什么LSTM能够解决梯度消失问题"></a>为什么LSTM能够解决梯度消失问题</h3><p>接在RNN的后面分析，LSTM梯度求导过程每一项中也存在一个累乘项，但是LSTM这个累乘项在LSTM中为0或者为1，因此有效避免了累乘导致的梯度消失问题。</p><p>传统RNN梯度计算如下：<br>$$<br>\frac{\partial L_{3}}{\partial W_{s}}=\frac{\partial L_{3}}{\partial O_{3}} \frac{\partial O_{3}}{\partial S_{3}} \frac{\partial S_{3}}{\partial W_{s}}+\frac{\partial L_{3}}{\partial O_{3}} \frac{\partial O_{3}}{\partial S_{3}} \frac{\partial S_{3}}{\partial S_{2}} \frac{\partial S_{2}}{\partial W_{s}}+\frac{\partial L_{3}}{\partial O_{3}} \frac{\partial O_{3}}{\partial S_{3}} \frac{\partial S_{3}}{\partial S_{2}} \frac{\partial S_{2}}{\partial S_{1}} \frac{\partial S_{1}}{\partial W_{s}}<br>$$<br>LSTM中有表达式：<br>$$<br>\prod_{j=k+1}^{t} \frac{\partial S_{j}}{\partial S_{j-1}}=\prod_{j=k+1}^{t} \tanh ^{\prime} \sigma\left(W_{f} X_{t}+b_{f}\right) \approx 0 | 1<br>$$<br>因此LSTM:<br>$$<br>\frac{\partial L_{3}}{\partial W_{s}}=\frac{\partial L_{3}}{\partial O_{3}} \frac{\partial O_{3}}{\partial S_{3}} \frac{\partial S_{3}}{\partial W_{s}}+\frac{\partial L_{3}}{\partial O_{3}} \frac{\partial O_{3}}{\partial S_{3}} \frac{\partial S_{2}}{\partial W_{s}}+\frac{\partial L_{3}}{\partial O_{3}} \frac{\partial O_{3}}{\partial S_{3}} \frac{\partial S_{1}}{\partial W_{s}}<br>$$<br>梯度中不存在累乘项，因此可以克服梯度消失和梯度爆炸的问题。</p><h3 id="LSTM具有记忆功能"><a href="#LSTM具有记忆功能" class="headerlink" title="LSTM具有记忆功能"></a>LSTM具有记忆功能</h3><p>由于LSTM每次计算都有参考到上一时刻的LSTM状态，每一步决策均使用到了上一次的中间结果，因此具有记忆功能。</p><h3 id="LSTM具记忆时间长"><a href="#LSTM具记忆时间长" class="headerlink" title="LSTM具记忆时间长"></a>LSTM具记忆时间长</h3><p>由于LSTM将连乘项转化为1或者0，因此有效解决了梯度爆炸和梯度消失的问题，可以保存距离当前位置比较远的位置的信息，因此LSTM具有记忆时间长的功能。</p><h3 id="LSTM存在的问题"><a href="#LSTM存在的问题" class="headerlink" title="LSTM存在的问题"></a>LSTM存在的问题</h3><p>无法并行运算，LSTM计算效率太低。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;为什么需要RNN&quot;&gt;&lt;a href=&quot;#为什么需要RNN&quot; class=&quot;headerlink&quot; title=&quot;为什么需要RNN&quot;&gt;&lt;/a&gt;为什么需要RNN&lt;/h3&gt;&lt;p&gt;当我们遇到一些数据是序列的，长度不定的，数据的先后，顺序，是存在相互影响的语义的。对于这类问
      
    
    </summary>
    
      <category term="面试准备" scheme="https://wenhui-zhou.github.io/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    
    
  </entry>
  
  <entry>
    <title>2D animation,SVG文件</title>
    <link href="https://wenhui-zhou.github.io/2020/05/13/2D-animation-SVG%E6%96%87%E4%BB%B6/"/>
    <id>https://wenhui-zhou.github.io/2020/05/13/2D-animation-SVG文件/</id>
    <published>2020-05-13T08:00:44.000Z</published>
    <updated>2020-05-22T09:34:44.866Z</updated>
    
    <content type="html"><![CDATA[<p>这篇post主要为了了解动画的原理，始末，已经一些常用的技术路线，为之后可能遇到的工作做准备。</p><a id="more"></a><h3 id="动画是什么"><a href="#动画是什么" class="headerlink" title="动画是什么"></a>动画是什么</h3><p>计算机动画即利用计算机绘制技术，绘制图画，为了制造连续的假象，将画面显示在计算机上，然后很块的用另一个相似但有一些移动的画面替代，制造平滑移动的假象。</p><p>由于人脑和眼存在<strong>视觉停留</strong>的现象，眼和脑会将看到的画面存储几分之一秒，然后将场景切换的跳跃平滑掉。因此制作动画的一个基本最低切换帧率为12帧，在这个帧率是人们比较能够接受的帧率。通常电影为24帧，当帧率提升到60帧以上时，为人眼处理图像的极限，画面真实感将不再提升。</p><h3 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h3><p>SVG是一种基于XML的标记语言，是由万维网联盟开发的开放标准，用于描述二维的矢量图形。是一个基于文本的开放web标准，可以与CSS，DOM，HTML在统一标准下使用。SVG是可伸缩的矢量图像，本质上是一段文本，可以被编辑，检索，压缩，编辑和创建的。</p><p>通过上面的介绍，容易发现SVG和万维网联盟的其他标准类似，是一种专门为了互联网而生的一种产物。</p><p>SVG文件大小比较小，可用代码进行绘图，支持web协议，可在网页中打开。</p><h3 id="pose-animator"><a href="#pose-animator" class="headerlink" title="pose-animator"></a>pose-animator</h3><p>由模型得到的点位信息的结构如下：</p><p><img src="/Users/zhouwenhui/blog/source/images/nlp/image-20200514223027223.png" alt="image-20200514223027223" style="zoom:50%;"></p><p><img src="/Users/zhouwenhui/blog/source/images/nlp/image-20200514223058374.png" alt="image-20200514223058374" style="zoom:50%;"></p><p>修改代码，将pose的keypoint信息通过json传入，得到相同的结果：</p><p><img src="/Users/zhouwenhui/blog/source/images/nlp/image-20200518161834873.png" alt="image-20200518161834873" style="zoom:40%;"></p><h3 id="Paper-js"><a href="#Paper-js" class="headerlink" title="Paper.js"></a>Paper.js</h3><p>Paper.js在处理path的时候，将整个curve分成多个segment，每个segment由handleOut，handleIn，以及一个点组成，由三个点绘制出一条curve。</p><p>贝塞尔曲线下链接：<a href="https://www.jianshu.com/p/8f82db9556d2" target="_blank" rel="noopener">https://www.jianshu.com/p/8f82db9556d2</a></p><h3 id="绘制动画的基本思路"><a href="#绘制动画的基本思路" class="headerlink" title="绘制动画的基本思路"></a>绘制动画的基本思路</h3><p>pose-animator的总体思路是首先利用PoseNet和faceMesh得到人体和面部的关键点信息。动画部分，使用Paper.js控制SVG图像，首先给出了一个通用的骨骼结构(skeleton.svg)，通过skeleton.js获取关节点的位置以及关节点之间可能存在的骨骼信息：</p><p><img src="/Users/zhouwenhui/blog/source/images/nlp/image-20200522163733751.png" alt="image-20200522163733751" style="zoom:50%;"></p><p>然后利用已有的svg动画图像如下：</p><p><img src="/Users/zhouwenhui/blog/source/images/nlp/image-20200522164204453.png" alt="image-20200522164204453" style="zoom:50%;"></p><p>最后遍历skeleton.svg中path中的segment第三个point与图二中所有的bone计算距离，去寻找最接近的bone，计算距离如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> getClosestPointOnSegment(p0, p1, p) &#123;</span><br><span class="line">    <span class="keyword">let</span> d = p1.subtract(p0);</span><br><span class="line">    <span class="keyword">let</span> c = p.subtract(p0).dot(d) / (d.dot(d));</span><br><span class="line">    <span class="keyword">if</span> (c &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> p1.clone();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> p0.clone();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p0.add(d.multiply(c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上诉函数将返回一个最接近point的点坐标，然后计算distance，作为判断图二最近的segment的标准，随后计算一个weight，以及根据handleIn，handleOut去计算动画的一些形变</p><p>形变代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.handleIn) &#123;</span><br><span class="line">                <span class="keyword">let</span> pHandleIn = s.handleIn.add(s.point);</span><br><span class="line">                segment.handleIn = <span class="keyword">this</span>.getSkinning(pHandleIn, collinear ? weightsP : <span class="keyword">this</span>.getWeights(pHandleIn, bones)); <span class="comment">//skinning指的是肉</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.handleOut) &#123;</span><br><span class="line">                <span class="keyword">let</span> pHandleOut = s.handleOut.add(s.point);</span><br><span class="line">                segment.handleOut = <span class="keyword">this</span>.getSkinning(pHandleOut, collinear ? weightsP : <span class="keyword">this</span>.getWeights(pHandleOut, bones));</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h3 id="添加自己的动画结果"><a href="#添加自己的动画结果" class="headerlink" title="添加自己的动画结果"></a>添加自己的动画结果</h3><p>首先需要绘制一张svg图像，节点的名称与已有的一致，然后传入图片，检测出关键点，然后就可以显示了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇post主要为了了解动画的原理，始末，已经一些常用的技术路线，为之后可能遇到的工作做准备。&lt;/p&gt;
    
    </summary>
    
      <category term="动画" scheme="https://wenhui-zhou.github.io/categories/%E5%8A%A8%E7%94%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>RDSNet总结文档</title>
    <link href="https://wenhui-zhou.github.io/2020/05/12/RDSNet%E6%80%BB%E7%BB%93%E6%96%87%E6%A1%A3/"/>
    <id>https://wenhui-zhou.github.io/2020/05/12/RDSNet总结文档/</id>
    <published>2020-05-12T03:03:27.000Z</published>
    <updated>2020-05-21T05:51:29.407Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="welcome to my blog,enter password to read." />    <label for="pass">welcome to my blog,enter password to read.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      welcome to my blog,enter password to read.
    
    </summary>
    
      <category term="面试准备" scheme="https://wenhui-zhou.github.io/categories/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/"/>
    
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WenHuiZhou</title>
  
  <subtitle>perper（打起精神！）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wenhui-zhou.github.io/"/>
  <updated>2019-11-29T10:49:13.086Z</updated>
  <id>https://wenhui-zhou.github.io/</id>
  
  <author>
    <name>WenHuiZhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NLP之Word2Vec（一）</title>
    <link href="https://wenhui-zhou.github.io/2019/11/29/NLP%E4%B9%8BWord2Vec%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://wenhui-zhou.github.io/2019/11/29/NLP之Word2Vec（一）/</id>
    <published>2019-11-29T06:53:18.000Z</published>
    <updated>2019-11-29T10:49:13.086Z</updated>
    
    <content type="html"><![CDATA[<p>NLP领域有着四个比较大的方向：</p><ul><li>文本分类</li><li>序列标注</li><li>文本匹配</li><li>文本生成</li></ul><p>在NLP里头，最细粒度的就是 <strong>词语</strong>，由词语组成句子，由句子组成文章继而表达一些语言层面上的含义。因此本文从NLP的根源问题 <strong>词语表达</strong> 开始讲起，即word2vec，NLP领域重要的预训练方法。</p><a id="more"></a><h3 id="word2vec考古史"><a href="#word2vec考古史" class="headerlink" title="word2vec考古史"></a>word2vec考古史</h3><p>Word2vec最早出现是以一个副产品的身份出现的。它是在实现语言模型过程中出现的<strong>一个惊喜的意外</strong>。简而言之，就是在做实现语言模型的过程中，我们得到了词语的数值表达，这也就是word2vec的精髓。</p><p><strong>词语是人类对语言在符号上的抽象总结，通过word2vec，将符号语言转化为数值表达，方便计算机寻找语言背后的抽象逻辑。</strong></p><p><strong>语言模型</strong></p><p>生成word2vec的语言模型是个什么东西呢？如下图：</p><p><img src="/images/nlp/language_model.png" style="zoom:50%;"></p><p>语言模型就是量化的衡量哪一个句子更像是人说的，核心函数p的思想是说，通过一系列的前导词，预测出后面跟着哪一个词的概率最大。</p><p><strong>数据的输入问题</strong>，第一步是将每个词用一个向量来唯一表示（<strong>one-hot</strong>），然后才可能对这个向量进行编码，得到具有语言意义的一个向量（<strong>word2vec</strong>）。</p><p><strong>one-hot</strong>的实现过程为建立一个长度为V的表，假设这个V表示世界上所有词语的词语。当我们对出现的一个词语进行编码的时候，只需要将这个词语出现的位置置为1，其他为0，即得到了这个<strong>词语的唯一表达（one-hot形式）。</strong></p><p><strong>语言网络的设计</strong>，加入你设计出了如下的结构：</p><p><img src="/images/nlp/nnlm.png" style="zoom:50%;"></p><p>这就是大名鼎鼎的神经网络语言模型，由Bengio 2003发表在JMLR上，2013年深度学习升温后，才慢慢进入了神坛。</p><p>他的核心思想即是最大似然估计的思想：<br>$$<br>\begin{equation}<br>\left.P\left(W_{t}=\operatorname{‘Bert’} | W_{1}, W_{2}, \ldots W_{(} t-1\right) ; \theta\right)<br>\end{equation}<br>$$<br>即如果当前位置出现了’Bert‘，要求网络预测前t-1的参数，使得当前出现Bert的概率最大。网络的输入，我们最初说使用one-hot的形式，但是为了另其具有语言的含义，我们在将词语输入网络之前，使用矩阵Q进行语义上的转换。从而得到词语的word embedding表达。</p><p>矩阵Q就是所谓的word2vec的转换矩阵，它包含V行，每一行表示一个单词的vector值，有一点值得注意的是，Q矩阵一开始是用随机值进行初始化的，矩阵Q参与网络的训练，当网络训练好之后，矩阵Q就被正确赋值了。</p><p>word2vec有两种训练方式：</p><ul><li>CBOW：从一个句子中将一个词抠掉，用这个词的上下文去预测这个词。</li><li>skip-gram：用一个词去预测这个词的上下文。</li></ul><h3 id="ELMO克服word2vec的多义词缺陷"><a href="#ELMO克服word2vec的多义词缺陷" class="headerlink" title="ELMO克服word2vec的多义词缺陷"></a>ELMO克服word2vec的多义词缺陷</h3><p>word2vec对下游的nlp任务有一些帮助，但是帮助却不是那么大。一个比较严重的问题在于<strong>多义词的问题</strong>，例如bank这个单词，可以指银行也可以指河床，但是在矩阵Q中，这个单词只有一种特征的编码。</p><p>如何解决这个问题呢，ELMO模型提出了一种想法，<strong>利用上下文场景来确定多义词的语义。</strong></p><p><strong>ELMO的本质思想是：</strong>事先用语言模型学好一个单词的Word Embedding，此时多义词无法区分。在下游任务中，实际使用Word Embedding的时候，单词已经具备了特定的上下文，这个时候<strong>可以根据上下文单词的语义去调整单词的Word Embedding表示</strong>，经过调整后的Word Embedding更能表达在这个上下文中的具体含义，即确定了多义词的具体语义。</p><p><img src="/images/nlp/elmo.png" style="zoom:50%;"></p><p>ELMO采用典型的两阶段：</p><ul><li>第一个阶段利用语言模型进行word embedding的预训练</li><li>第二个阶段是提取对应单词网络各层的word embedding作为新特征，补充到下游任务中</li></ul><p>上图是第一阶段的预训练过程，网络结构采用双层的word embedding作为新特征补充到任务中。网络结构采用双层的LSTM，左端正向表示正向的编码器。右边逆向，表示逆向的编码器。从两个方向来预测扣掉的那一个词。</p><p>使用这个网路，每次输入一个句子网络将会输出三个向量，分别是 <strong>单词特征，句法特征，语义特征。</strong></p><p>这三个特征如何使用呢，在下游的任务中，我们给每一个vector一个权重，然后将三个特征相加，整合成一个特征输入下游的任务中。这个权重需要通过网络的学习得到。EMLO效果相比较于传统的word2vec性能上得到了比较明显的提升。</p><p><img src="/images/nlp/elmo_use.png" style="zoom:50%;"></p><p>ELMO有什么缺点呢：</p><ul><li>LSTM抽取特征的能力远弱于transformer</li><li>拼接方式双向融合特征，融合能力偏弱</li></ul><p>接下来，我将在另外的文章中介绍transformer。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NLP领域有着四个比较大的方向：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文本分类&lt;/li&gt;
&lt;li&gt;序列标注&lt;/li&gt;
&lt;li&gt;文本匹配&lt;/li&gt;
&lt;li&gt;文本生成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在NLP里头，最细粒度的就是 &lt;strong&gt;词语&lt;/strong&gt;，由词语组成句子，由句子组成文章继而表达一些语言层面上的含义。因此本文从NLP的根源问题 &lt;strong&gt;词语表达&lt;/strong&gt; 开始讲起，即word2vec，NLP领域重要的预训练方法。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>effective cpp(九)杂项讨论</title>
    <link href="https://wenhui-zhou.github.io/2019/11/26/effective-cpp-%E4%B9%9D-%E6%9D%82%E9%A1%B9%E8%AE%A8%E8%AE%BA/"/>
    <id>https://wenhui-zhou.github.io/2019/11/26/effective-cpp-九-杂项讨论/</id>
    <published>2019-11-26T13:34:29.000Z</published>
    <updated>2019-11-26T14:21:37.864Z</updated>
    
    <content type="html"><![CDATA[<p>2019/11/26 effective cpp 第九章 杂项讨论</p><p>这是这本书的最后一章，今晚应该就能够阅读完！在开始阅读之前，我想感慨一下，最后的几章难度太大，一知半解的看下来，我想原因是相关张章节的实践不多导致的，因此日后有需要要回来重新阅读它们，时间很快大概花了一个月的空闲时间来阅读这本书，收获满满！</p><p>这一章主要说了三个问题：编译器的警告要重视；C++标准库的一个总览；boost一个泛用性C++库的总览。</p><ul><li>53 条款：不要轻视编译器的警告</li><li>54 条款：让自己熟悉包括TR1在内的标准程序库</li><li>55 条款：让自己熟悉Boost</li></ul><a id="more"></a><h3 id="53-条款：不要轻视编译器的警告"><a href="#53-条款：不要轻视编译器的警告" class="headerlink" title="53 条款：不要轻视编译器的警告"></a>53 条款：不要轻视编译器的警告</h3><p>编译器作者在触发一个warning的时候，他比你更加明白将来会发生什么严重的错误，因此我们需要在对待编译器警告的时候更加的小心。</p><p>当出现一个编译器warning的时候，我们应该需要知道它的意图以及真正的意义。</p><p><strong>总结</strong></p><ul><li>严肃对待编译器发出的警告，争取无警告荣誉</li><li>不要过度依赖编译器的报警功能，因为不同的编译器对待事情的反应是不同的</li></ul><h3 id="54-条款：让自己熟悉包括TR1在内的标准程序库"><a href="#54-条款：让自己熟悉包括TR1在内的标准程序库" class="headerlink" title="54 条款：让自己熟悉包括TR1在内的标准程序库"></a>54 条款：让自己熟悉包括TR1在内的标准程序库</h3><p>C++standard定义了C++语言及其标准程序库的规范，里头包含以下：</p><ul><li>STL 标准模板库</li><li>Iostream</li><li>国际化支持</li><li>数值处理</li><li>C89标准程序库</li><li>异常阶层体系</li></ul><p>此外C++的新特性被记录在TR1的文档内，在下一次更新将会加入到标准库中。</p><p><strong>总结</strong></p><ul><li>C++标准库的主要机能由STL，iostreams，locates组成。并包含C99标准程序库。</li><li>TR1添加了智能指针，一般化函数指针，hash-based容器，正则表达式以及另外10个组件的支持</li><li>TR1自身只是一份规范。</li></ul><h3 id="55-条款：让自己熟悉Boost"><a href="#55-条款：让自己熟悉Boost" class="headerlink" title="55 条款：让自己熟悉Boost"></a>55 条款：让自己熟悉Boost</h3><p>如果你在找一个高质量，源码开放，平台独立，编译器独立的程序库，那么Boost是一个很好地选择。他的网址是：<a href="">http://boost.org</a>。</p><p><strong>总结</strong></p><ul><li>Boost是一个社群，也是一个网站，致力于免费，源码开放，同僚复审的C++程序库开发。Boost在C++标准化过程中扮演深居影响力的角色。</li><li>Boost提供许多TR1组件实现品，以及其他许多程序库。</li></ul><p>最后告诫一下自己，熟悉STL，在开始用C++写一个东西之前，应当要过一遍这9篇博客！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019/11/26 effective cpp 第九章 杂项讨论&lt;/p&gt;
&lt;p&gt;这是这本书的最后一章，今晚应该就能够阅读完！在开始阅读之前，我想感慨一下，最后的几章难度太大，一知半解的看下来，我想原因是相关张章节的实践不多导致的，因此日后有需要要回来重新阅读它们，时间很快大概花了一个月的空闲时间来阅读这本书，收获满满！&lt;/p&gt;
&lt;p&gt;这一章主要说了三个问题：编译器的警告要重视；C++标准库的一个总览；boost一个泛用性C++库的总览。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;53 条款：不要轻视编译器的警告&lt;/li&gt;
&lt;li&gt;54 条款：让自己熟悉包括TR1在内的标准程序库&lt;/li&gt;
&lt;li&gt;55 条款：让自己熟悉Boost&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="effective cpp" scheme="https://wenhui-zhou.github.io/categories/effective-cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>effective cpp(八)定制new和delete</title>
    <link href="https://wenhui-zhou.github.io/2019/11/25/effective-cpp-%E5%85%AB-%E5%AE%9A%E5%88%B6new%E5%92%8Cdelete/"/>
    <id>https://wenhui-zhou.github.io/2019/11/25/effective-cpp-八-定制new和delete/</id>
    <published>2019-11-25T13:40:42.000Z</published>
    <updated>2019-11-26T13:31:52.371Z</updated>
    
    <content type="html"><![CDATA[<p>2019/11/25 effective cpp 第8章 定制new和delete</p><p>C++在内存管理，垃圾回收机制上常常受到人们的讨论。下面这一章将讨论C++的内存管理例程。</p><ul><li>49 条款：了解new-handler的行为</li><li>50 条款：了解new和delete的合理替换时机</li><li>51 条款：编写new和delete时需固守常规</li><li>52 条款：写了placement new也要写placement delete</li></ul><a id="more"></a><h3 id="49-条款：了解new-handler的行为"><a href="#49-条款：了解new-handler的行为" class="headerlink" title="49 条款：了解new-handler的行为"></a>49 条款：了解new-handler的行为</h3><p>当operator new无法满足某一内存分配的需求时，它将会抛出异常。当operator new发生异常，它会先调用一个客户指定的错误处理函数，即new-handler函数。为了指定这个用以处理内存不足的函数，客户必须调用set_new_handler，那是声明与<code>&lt;new&gt;</code>的一个标准程序库函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*new_handler)</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">new_handler <span class="title">set_new_handler</span><span class="params">(new_handler p)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出来new_handler是一个typedef。定义出一个指向函数的指针，该函数没有返回任何东西，set_new_handler则是接受一个指针，返回一个指针，并且不允许抛出任何的异常。</p><p>Set_new_handler的使用方式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outOfMem</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"unable doing something"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">abort</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::set_new_handler(outOfMem);</span><br><span class="line">  <span class="keyword">int</span>* pBig = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">12323232333333</span>];</span><br><span class="line">  <span class="comment">// 当new无法分配这么多空间的时候，将会去调用outOfMem报错。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现new-handler的时候，有几点注意：</p><ul><li><strong>让更多的内存可被使用</strong>，一个做法是程序开始执行的时候就分配了一大块内存，当调用handler的时候，释放给程序使用</li><li><strong>安装另一个new-handler</strong>，如果目前这个new-handler无法处理这个异常，它可以通过调用其他的handler来分配内存。</li><li><p><strong>卸除new-handler</strong>，就是讲null指针传给set_new_handler，一旦没有安装任何new-handler，operator new会在内存分配不成功时抛出异常。</p></li><li><p><strong>跑出bad_alloc异常，</strong>这样的异常不会被operator new捕获，因此会被传播到内存索求处。</p></li><li><strong>不返回</strong>，通常调用abort，exit来中断程序。</li></ul><p><strong>总结</strong></p><ul><li>set_new_handler允许客户指定一个函数，在内存分配无法获得满足时被调用</li><li>Nothrow new是一个颇为局限的工具，因为它只适用于内存分配，后续的构造函数调用还是可能抛出异常。</li></ul><h3 id="50-条款：了解new和delete的合理替换时机"><a href="#50-条款：了解new和delete的合理替换时机" class="headerlink" title="50 条款：了解new和delete的合理替换时机"></a>50 条款：了解new和delete的合理替换时机</h3><p>通常我们选择替换new和delete会出于几个原因：</p><ul><li>用于检测运用上的错误</li><li>为了强化效能</li><li>为了收集使用上的统计数据</li></ul><p>此外，在了解何时可在 <strong>全局性</strong>或 <strong>class专属的</strong>基础上合理替换缺省的new和delete：</p><ul><li>为了检测运用上的错误</li><li>为了手机动态分配内存之使用统计信息</li><li>为了增加分配和归还的速度</li><li>为了降低缺省内存管理器带来的空间额外开销</li><li>为了弥补缺省分配器中的非最佳齐位</li><li>为了将相关对象成簇集中</li><li>为了获得非传统的行为</li></ul><p><strong>总结</strong></p><p>有许多理由需要写个自定义的new和delete，包括改善效能，对heap运用错误进行调试，收集heap使用信息。</p><h3 id="51-条款：编写new和delete时需固守常规"><a href="#51-条款：编写new和delete时需固守常规" class="headerlink" title="51 条款：编写new和delete时需固守常规"></a>51 条款：编写new和delete时需固守常规</h3><p>让我们从实现operator new开始，实现一致性operator new必须返回正确的值，内存不足的时候必须调用new-handling函数，必须有对付零内存需求的准备，还需避免不慎掩盖正常形式的new。</p><p>operator new其实比较单纯，如果能够申请到空间，就返回正确的值，如果申请不到空间就返回一个bad-alloc。但是他也有不单纯的一面，因为operator不止一次的申请内存，如果new-handling有能力做一些操作释放内存出来，因此只有在new-handling返回null的时候才会抛出错误。</p><p>如果你打算控制operator new[]的行为，你唯一要做的事情就是分配一块未加工的内存。因为你无法知道array中将会保存什么东西。</p><p>对于operator delete来说，我们要确保的是 <strong>删除null指针永远安全</strong>。</p><p><strong>总结</strong></p><ul><li>operator new应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存的需求，就调用new-handler。它应该也有能力处理0byte申请。class 专属版本则应该处理 <strong>比正确大小更大的错误。</strong></li><li>operator delete应该受到null指针时不做任何事，class专属版本则还应该处理 <strong>比正确大小更大的申请。</strong></li></ul><h3 id="52-条款：写了placement-new也要写placement-delete"><a href="#52-条款：写了placement-new也要写placement-delete" class="headerlink" title="52 条款：写了placement new也要写placement delete"></a>52 条款：写了placement new也要写placement delete</h3><p>placement new和placement delete应当也成对的出现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">widget* pw = <span class="keyword">new</span> widget;</span><br></pre></td></tr></table></figure><p>当我们通过上面的代码的时候，实际上做了两件事情，第一件是new，第二件是调用了widget的default构造函数。如果在第二种情况下发生了异常，new成功执行。这种情况下我们要去释放new所申请的空间，但是我们手上并没有申请得到的指针，因此释放内存的重任就交给了C++。</p><p>如果当前面对的是拥有正常签名的new和delete函数，那么系统在运行期间就会主动去调用相应的delete函数。</p><p>但是如果我们使用的new是我们修改过的，带有附加参数的new，这时候我们需要制定一个与之对应的delete函数。</p><p>此外，由于成员函数名称将会覆盖其外围作用域的相同名称，你必须小心避免掉这种覆盖。一个简单的做法就是建立一个base class，内含所有正常形式的new和delete，凡是想以自定形式扩充标准形式的客户，可利用继承机制及using声明式来取得标准形式。</p><p><strong>总结</strong></p><ul><li>当你写一个placement operator new。请确定也写出对应了placement operator delete函数，如果没有这样做的话，你的程序可能会发生隐微而断续的内存泄漏。</li><li>当你声明placement new和placement delete，请确定不要无意识地掩盖了他们的正常版本。</li></ul><p>一知半解。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019/11/25 effective cpp 第8章 定制new和delete&lt;/p&gt;
&lt;p&gt;C++在内存管理，垃圾回收机制上常常受到人们的讨论。下面这一章将讨论C++的内存管理例程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;49 条款：了解new-handler的行为&lt;/li&gt;
&lt;li&gt;50 条款：了解new和delete的合理替换时机&lt;/li&gt;
&lt;li&gt;51 条款：编写new和delete时需固守常规&lt;/li&gt;
&lt;li&gt;52 条款：写了placement new也要写placement delete&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="effective cpp" scheme="https://wenhui-zhou.github.io/categories/effective-cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>effective cpp(七) 模板与范型编程</title>
    <link href="https://wenhui-zhou.github.io/2019/11/19/effective-cpp-%E4%B8%83-%E6%A8%A1%E6%9D%BF%E4%B8%8E%E8%8C%83%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    <id>https://wenhui-zhou.github.io/2019/11/19/effective-cpp-七-模板与范型编程/</id>
    <published>2019-11-19T05:58:47.000Z</published>
    <updated>2019-11-25T13:39:12.086Z</updated>
    
    <content type="html"><![CDATA[<p>2019/11/19 effective cpp 第七章 模板与范型编程</p><p>C++ template最初是为了让我们建立类型安全的容器，如vector，list，map等等，后来随着越来越多的人用上模板之后，人们发现，template这种代码与其处理对象类型分离，彼此独立的风格很好，于是人们道出了模板元编程，template的作用越来越大。</p><p>本章主要解决在使用template上遇到的一些可以避免，优化的问题。</p><ul><li>41 条款：了解隐式接口和编译期多态</li><li>42 条款：了解typename的双重含义</li><li>43 条款：学习处理模板化基类内的名称</li><li>44 条款：将与参数无关的代码抽离template</li><li>45 条款：运用成员函数模板接受所有兼容类型</li><li>46 条款：需要类型转换时请为模板定义非成员函数</li><li>47 条款：请使用traits classes表现类型信息</li><li>48 条款：认识template元编程</li></ul><!--moew--><h3 id="41-条款：了解隐式接口和编译期多态"><a href="#41-条款：了解隐式接口和编译期多态" class="headerlink" title="41 条款：了解隐式接口和编译期多态"></a>41 条款：了解隐式接口和编译期多态</h3><p>面向对象编程总是以显式的接口和运行期多态来解决问题，它具有两个特点：</p><ul><li>必须在子类总的各种方法，且他的代码在源码中是明确可见的。</li><li>由于widget的某些成员函数是virtual，w对于那些函数的调用将表现出运行期间的多态，根据运行期间w的动态类型来决定调用哪一个函数。</li></ul><p>在template的泛型编程中，我们将函数转变为函数模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doProcessing</span><span class="params">(T&amp; w)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (w.size() &gt; <span class="number">10</span> &amp;&amp; w!= someWidget)&#123;</span><br><span class="line">    <span class="function">T <span class="title">temp</span><span class="params">(w)</span></span>;</span><br><span class="line">    temp.normalize();</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码，我们可以认为T这种类型应该具有size(),normalize()这些函数，允许进行大小的比较。但是实际上，对于模板类来说，他不一定必须要具备这些，这就是和显示接口的一个重大的不同。</p><p><strong>对于显式接口来说</strong>，<strong>他由函数的签名式构成，即包含函数的名称，参数类型，返回类型。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">widget</span>&#123;</span></span><br><span class="line">  widget();</span><br><span class="line">  <span class="keyword">virtual</span> ~widget();</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">normalize</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对于隐式接口来说，他并不是基于函数签名式，而是由有效表达式组成的，如上的第一份代码。</strong></p><p>由于操作符允许重载，因此在实现上述接口的时候，类型T不必要满足支持size成员函数，operation成员函数等。对于size()可由他的父类来提供。对于operator&gt;来说，只要存在一个隐式转换就能够进行类型的转换，将操作符两边的对象转换为同一种对象即可。</p><p><strong>总结</strong></p><ul><li>classes和templates都支持接口和多态</li><li>对class而言，接口式显式的，以函数签名为中心，多态则是通过virtual函数发生于运行期。</li><li>对template参数而言，接口式隐式的，基于有效表达式。多态则是通过template具现化和函数重载解析与编译期的。</li></ul><h3 id="42-条款：了解typename的双重含义"><a href="#42-条款：了解typename的双重含义" class="headerlink" title="42 条款：了解typename的双重含义"></a>42 条款：了解typename的双重含义</h3><p><strong>在template的声明式中，class和typename没有不同。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">widget</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">widget</span>;</span></span><br></pre></td></tr></table></figure><p>当我们在声明参数的时候，上面的两种表达方式完全相同。</p><p>在template中，我们存在着两种类型的变量。</p><p><strong>从属名称：</strong>template内部出现名称依赖于某个template参数。如果存在嵌套的话，则称为嵌套从属名称，如C::iterator，类型C的从属名称。</p><p><strong>非从属名称：</strong>对于类似于int那种名称，不依赖于template。</p><p>对于从属名称来说，typename有时候表示为一种类型，而有时候则是一个成员白能量，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span></span>&#123;</span><br><span class="line">  C::const_iterator*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当上式C::const_iterator表示一个变量的时候，上面变成一个乘法的表达式，如果他是一个类型的话，那就表示声明了一个local的指针。</strong></p><p>C++是如何区分这种情况的呢，<strong>C++在默认的情况下，处理从属关系的时候优先认为这是一个变量，而不是一个类型，除非你告诉编译器。</strong></p><p>显式告诉编译器这是个类型的方式是通过typename来实现的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> C&amp; container)</span></span>&#123;</span><br><span class="line">  <span class="keyword">typename</span> C::<span class="function">cosnt_iterator <span class="title">iter</span><span class="params">(container.begin())</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>typename只被用来确定嵌套从属类型的名称，在其他地方不要去使用它。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> C&amp; container,         <span class="comment">// 一定不要使用typename</span></span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">typename</span> C::iterator iter)</span></span>;  <span class="comment">// 一定要使用typename</span></span><br></pre></td></tr></table></figure><p>此外，在typename在一个特殊的例子中是不允许使用的，就是 <strong>base class list 以及mem init list即父类列表，以及成员初始化的初始化列表中不允许使用。</strong></p><p>当我们在使用嵌套类型的时候，有时候类型名非常的长，我们希望通过typedef来给他重命名，可以将typedef typename一起连用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;iterT&gt;::value_type value_type;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li>声明template参数时，前缀关键字class和typename可互换。</li><li>请使用关键字typename标识嵌套从属类型的名称，但不得在base class lists或mem init list以他作为base class修饰符。</li></ul><h3 id="43-条款：学习处理模板化基类内的名称"><a href="#43-条款：学习处理模板化基类内的名称" class="headerlink" title="43 条款：学习处理模板化基类内的名称"></a>43 条款：学习处理模板化基类内的名称</h3><p>template的继承和显式的继承有些不同之处：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loggin</span>:</span><span class="keyword">public</span> MsgSender&lt;company&gt;&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMSG</span><span class="params">(<span class="keyword">const</span> MsgSender&lt;Company&gt;)</span></span>&#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">      sendClear(info);  <span class="comment">// 调用父类中的sendClear函数</span></span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码如果实在class的继承中，一定是成立的，但是template继承中则会出错，因为在继承<code>MsgSender&lt;company&gt;</code>的时候，编译器并不知道这是个什么样的class，也就自然不知道这个class中是否有一个sendClear函数了，因此上面的调用将会出错。</p><p>解决方法：</p><ol><li><strong>在base class函数调用动作之前加上this-&gt;</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loggin</span>:</span><span class="keyword">public</span> MsgSender&lt;company&gt;&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMSG</span><span class="params">(<span class="keyword">const</span> MsgSender&lt;Company&gt;)</span></span>&#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">      <span class="keyword">this</span>-&gt;sendClear(info);  <span class="comment">// 调用父类中的sendClear函数</span></span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>使用using声明式，是的父类的方法能够在子类中可见</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loggin</span>:</span><span class="keyword">public</span> MsgSender&lt;company&gt;&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMSG</span><span class="params">(<span class="keyword">const</span> MsgSender&lt;Company&gt;)</span></span>&#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">      <span class="keyword">using</span> MsgSender&lt;company&gt;::sendClear;</span><br><span class="line">      sendClear(info);  <span class="comment">// 调用父类中的sendClear函数</span></span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>明确指出函数在base class内</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> company&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Loggin</span>:</span><span class="keyword">public</span> MsgSender&lt;company&gt;&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendClearMSG</span><span class="params">(<span class="keyword">const</span> MsgSender&lt;Company&gt;)</span></span>&#123;</span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">      MsgSender::sendClear(info);  <span class="comment">// 调用父类中的sendClear函数</span></span><br><span class="line">      <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在template继承的时候，子类对父类的方法一无所知，因此我们需要通过this，或者明确指出父类方法的方式得到函数的声明。</p><p><strong>总结</strong></p><ul><li>可在derived class templates内通过<code>this-&gt;</code>指涉base class template内的成员名称，或由一个明白写出的base class资格的修饰符，使用using 或直接由类调用。</li></ul><h3 id="44-条款：将与参数无关的代码抽离template"><a href="#44-条款：将与参数无关的代码抽离template" class="headerlink" title="44 条款：将与参数无关的代码抽离template"></a>44 条款：将与参数无关的代码抽离template</h3><p>template是一个节约时间与避免代码重复的一个方法。但是有时候我们可能会导致代码膨胀。</p><p>一些指针，vector，list等等，位于父类函数中，将会造成代码的膨胀。</p><p><strong>总结</strong></p><ul><li>template生成多个class和多个参数，所以任何template代码都不该与某个造成膨胀的template参数产生相依的关系。</li><li>因非类型末班参数而造成的代码膨胀，往往可以消除，做法是用函数参数或class成员变量替代template参数</li><li>因类型参数而造成的代码膨胀往往可以降低，做法是让带有完全相同的二进制表述的具现类型共享实现码。</li></ul><h3 id="45-条款：运用成员函数模板接受所有兼容类型"><a href="#45-条款：运用成员函数模板接受所有兼容类型" class="headerlink" title="45 条款：运用成员函数模板接受所有兼容类型"></a>45 条款：运用成员函数模板接受所有兼容类型</h3><p>智能指针是行为上像是一个指针的对象，它提供了指针的所有机能，在STL容器中，我们总是使用智能指针。此外指针的另一很好的优点在于支持<strong>隐式转换</strong>，即子类指针可以隐式的转换为父类指针。但是这种关系在template类模板中是不存在的。</p><p><strong>用具有base-derived关系的对象去具现化某个template的时候，产生出来的的具现体并不具有base-derived的关系。</strong></p><p>一个可行的方法就是实现一个template构造函数，即构造模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    SmartPtr(<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; other);  <span class="comment">// 将一个具现化的u转型为t</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这一构造函数根据对象u创建对象t，而u和t的类型是同一个template的不同具现体，我们称这个函数为泛化copy构造函数。需要注意的是，<strong>上面的前提是说，一个U可以被转型为T。</strong></p><p>我们同样可以在构造函数中完成我们想要达到的转化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    SmartPtr(<span class="keyword">const</span> SmartPtr&lt;U&gt;&amp; other)</span><br><span class="line">      :heldPtr(other.get())&#123;...&#125;  <span class="comment">//  使用u的指针去初始化t变量的指针</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    T* heldPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样的，上述的做法是在 <strong>U指针可以隐式转换为T*的基础上才成立的。</strong></p><p>泛化copy构造函数与普通的copy构造函数之间不存在冲突，因此具现化后的类，依旧会为这个类实现一个copy构造函数。</p><p><strong>总结</strong></p><ul><li>请使用member function templates成员函数模板，生成可接受所有兼容类型的函数。（即上面的u-&gt;t）。</li><li>如果你声明member templates用于泛化copy构造或泛化assignment操作，你还是需要声明正常的copy构造函数和copy assignment操作符，因为编译器默认生成的函数不会因为生成泛化copy构造函数受到影响。</li></ul><h3 id="46-条款：需要类型转换时请为模板定义非成员函数"><a href="#46-条款：需要类型转换时请为模板定义非成员函数" class="headerlink" title="46 条款：需要类型转换时请为模板定义非成员函数"></a>46 条款：需要类型转换时请为模板定义非成员函数</h3><p>当我们在使用template来定义非成员函数，同时这个成员函数的参数需要隐式的转换的话，我们可能会遇到问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">const</span> Rational&lt;T&gt; <span class="keyword">operator</span>* (<span class="keyword">const</span> Rational&lt;T&gt;&amp; lhs,<span class="keyword">const</span> Rational&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure><p>当我们调用上面代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rational&lt;<span class="keyword">int</span>&gt; result = onehalf*<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>将会出现编译错误，因为template类型<code>Rational&lt;T&gt;</code>在具现化的时候需要确定T的类型，当遇到2的时候，C++无法推断出T为int，因此无法通过编译。</p><p>此路不通，我们曲线救国，通过将<code>Rational&lt;T&gt;</code>申请为class Rational的friend函数的方式来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">friend</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> rational&amp; lhs,<span class="keyword">const</span>&amp; rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过友元的方式来制定一个具体的函数，从而避免template进行参数的推导。</p><p>但是上面方法同样会引发一个问题，就是我们通过友元的方式，使得我们可以通过友元来确定函数，但是仅仅是个声明，没有函数的实现，一个最直接的方法就是我们直接将函数的本体定义在Rational乘法里头。</p><p><strong>总结</strong></p><ul><li>当我们需要编写一个class template，而他所提供的与此template相关的函数支持所有参数隐式类型转换时，请将那些函数定义为class template内部的friend函数。</li></ul><h3 id="47-条款：请使用traits-classes表现类型信息"><a href="#47-条款：请使用traits-classes表现类型信息" class="headerlink" title="47 条款：请使用traits classes表现类型信息"></a>47 条款：请使用traits classes表现类型信息</h3><p>在一些状况下，我们需要知道一个类的某些信息。<strong>traits构件</strong>就是做这件事情的，他是一种技术，也是C++程序员所遵守的一种协议。我们将trait放入一个template中去：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TT&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>;</span></span><br></pre></td></tr></table></figure><p>接下来我们确认一个traits中应该包含哪些信息：</p><ul><li>确认若干你希望将来可取得的类型的相关信息，例如对于迭代器，我们希望将来可取的他的分类。</li><li>为该信息选择一个名称</li><li>提供一个template与一组特化版本，内含你希望看到的相关信息</li></ul><p>接下来是如何使用traits：</p><ul><li>建立一个重载函数或函数模板，彼此的差异在于各自的trait参数；</li><li>建立一个控制函数或函数模板，用于调用上述的函数，并传递trait信息。</li></ul><p><strong>总结</strong></p><ul><li>traits class使得类型相关信息在编译期可用，它以template和templates特化完成实现。</li><li>整合重载技术后，trait class有可能在编译期对类型执行if … else 操作。</li></ul><h3 id="48-条款：认识template元编程"><a href="#48-条款：认识template元编程" class="headerlink" title="48 条款：认识template元编程"></a>48 条款：认识template元编程</h3><p>template metaprogramming元编程是编写template-based c++程序并执行与编译期的过程。</p><p><strong>总结</strong></p><ul><li>元编程可将工作由运行期移往编译期，因而得以实现早期错误侦测和更高的执行效率</li><li>TMP可被用来生成 <strong>基于政策选择组合</strong>的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。</li></ul><p>it is a little difficult for me,but never mind !</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2019/11/19 effective cpp 第七章 模板与范型编程&lt;/p&gt;
&lt;p&gt;C++ template最初是为了让我们建立类型安全的容器，如vector，list，map等等，后来随着越来越多的人用上模板之后，人们发现，template这种代码与其处理对象类型分离
      
    
    </summary>
    
      <category term="effective cpp" scheme="https://wenhui-zhou.github.io/categories/effective-cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>effective cpp(六) 继承与面向对象设计</title>
    <link href="https://wenhui-zhou.github.io/2019/11/16/effective-cpp-%E5%85%AD-%E7%BB%A7%E6%89%BF%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/"/>
    <id>https://wenhui-zhou.github.io/2019/11/16/effective-cpp-六-继承与面向对象设计/</id>
    <published>2019-11-16T08:40:17.000Z</published>
    <updated>2019-11-19T10:14:53.249Z</updated>
    
    <content type="html"><![CDATA[<p>2019/11/16 effective cpp 第六章 继承与面向对象设计</p><p>面向对象编程成为一个风靡一时的重要特性，关于C++在面向对象上的一些特性，将在本章进行详细的介绍。</p><ul><li>32 条款：确定你的public继承塑膜出is-a关系</li><li>33 条款：避免遮掩继承而来的名称</li><li>34 条款：区分接口继承和实现继承</li><li>35 条款：考虑virtual函数与外的其他选择</li><li>36 条款：绝不重新定义继承而来的non-virtual函数</li><li>37 条款：绝不重新定义继承而来的缺省参数值</li><li>38 条款：通过符合塑模出has-a或“根据某物实现出”</li><li>39 条款：明智而审慎地使用private继承</li><li>40 条款：明智而审慎地使用多重继承</li></ul><a id="more"></a><h3 id="32-条款：确定你的public继承塑膜出is-a关系"><a href="#32-条款：确定你的public继承塑膜出is-a关系" class="headerlink" title="32 条款：确定你的public继承塑膜出is-a关系"></a>32 条款：确定你的public继承塑膜出is-a关系</h3><p>作者通过一个例子表明立场，说明一个<strong>戒慎恐惧</strong>的东西，将会使人们记得异常牢固。接下来他说我们应该用同样的心态记住下面的话：</p><p><strong>public继承意味着是一种is-a关系</strong>，即子类通过public的方式继承父类，那么子类在任何场合都可以直接转变为父类。</p><p>即D以public的方式继承自B，意味着B比D表现出更一般化的概念，D比B则表现出更加的特殊化。B可以使用的地方D一定可以使用，D可以使用的地方B不一定可以使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span>...&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">student</span>:</span><span class="keyword">public</span> Person&#123;...&#125;;</span><br></pre></td></tr></table></figure><p>上诉的代码表明是一个学生一定是一个人。任何函数希望得到一个person参数的时候，通常也愿意接受一个student对象。即给父类参数传递一个子类对象作为参数，是符合继承的观点，合法的。</p><p><strong>总结</strong></p><ul><li>public继承意味着“is-a”的关系。适用于base classes身上的每一件事情一定也适用于derived class 身上，因为每一个derived classes 对象也都是一个base classes对象。</li></ul><h3 id="33-条款：避免遮掩继承而来的名称"><a href="#33-条款：避免遮掩继承而来的名称" class="headerlink" title="33 条款：避免遮掩继承而来的名称"></a>33 条款：避免遮掩继承而来的名称</h3><p>这个内容与作用域相关，指的是在不同的作用域之中，变量的遮掩。编译器从local领域从发，向外一步步直到找到变量。</p><p>当我们在谈论继承的时候，当位于一个derived class成员函数的内指涉base class内的某物，编译器可以找出所指涉的东西，因为derived classes继承了声明与base class内的所有东西。<strong>子类的作用域嵌套在base class作用域内，子类对象可以调用父类的成员。</strong></p><p>例如下面例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">boid <span class="title">mf4</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述例子中混合了public，private名称，以及一组成员变量和成员函数名称，包含了pure virtual，virtual，non-virtual三种，假设mf4函数实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Derived::mf4()&#123;</span><br><span class="line">  ...</span><br><span class="line">    mf2();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 当编译器遇到mf2的时候，必须估算他所指涉的东西，编译器的做法是查找各个作用域，看看有没有mf2的声明式，首先是local，然后是外围作用域，base的作用域，最外层的global作用域。</p><p>下面我们考虑一个重载带来的问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span>&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span>:<span class="keyword">public</span> Base&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们重载了mf1和mf3函数，base class中的mf1和mf3都被子类的函数所代替，但是此时对于父类中的重载函数将会发生错误：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line">d.mf1(); <span class="comment">//正常调用</span></span><br><span class="line">d.mf1(x); <span class="comment">// 含参数的那个函数也被mf1函数所覆盖，因此调用出现问题</span></span><br><span class="line">d.mf3(); <span class="comment">// 正常调用</span></span><br><span class="line">d.mf3(x); <span class="comment">// 出错</span></span><br></pre></td></tr></table></figure><p>为了解决上面出现的遮掩行为造成的错误，我们可以使用using声明式来达到目的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line">  <span class="keyword">using</span> Base::mf1;</span><br><span class="line">  <span class="keyword">using</span> Base::mf3;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">mf3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用using机制使得继承可以得到完美的实现。子类中调用d.mf3(x)将会到父类中寻找d.mf3(x)函数进行调用。</p><p><strong>这意味着你继承base class并加上重载函数，而你又希望重新定义或覆盖其中的一部分，那么你必须为那些原本会遮掩的每个名称引入一个using声明式，否则某些你希望的名称将会被遮掩。</strong></p><p>另一种情况是，当我们只希望继承父类重载的多个函数中的一个函数的时候，我们使用转交函数的方式，在子类函数中调用父类的函数，使其成为inline：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">private</span> Base&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">mf1</span><span class="params">()</span></span>&#123;  <span class="comment">// 转交函数，只实现了一个版本，有参数的那个版本在子类中未继承</span></span><br><span class="line">      Base::mf1();  <span class="comment">// 使其成为inline</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li>子类内的名称会遮掩base classes内的名称，在public继承下从来没有人希望如此</li><li>为了让遮掩的名称重见天日，可以使用using 声明式或转交函数。</li></ul><h3 id="34-条款：区分接口继承和实现继承"><a href="#34-条款：区分接口继承和实现继承" class="headerlink" title="34 条款：区分接口继承和实现继承"></a>34 条款：区分接口继承和实现继承</h3><p>在类的继承中，可以通过三种方式进行继承：</p><ul><li>继承一个接口（pure virtual）</li><li>继承接口以及接口的部分实现，子类选择覆盖这些实现（impure virtual）</li><li>继承接口以及接口的部分实现，子类不覆盖这些实现（non-virtual）</li></ul><p><strong>成员函数的接口总是会被继承</strong></p><p>pure virtual函数最突出的特性，他们必须被任何继承了他们的具象class重新声明，而且他们在抽象class中通常没有定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shape</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>声明一个pure virtual函数的目的是为了让derived classes只继承函数接口。</strong></p><p>对于shape::draw函数来说，这样是十分合理的，因为每个shape对象都应该有一个draw函数，同时由于shape子类形状各异，因此父类无法提供一个缺省（通用的）实现方式。</p><p>但是令人意外的是：<strong>我们可以为纯虚pure virtual函数提供一份实现代码，但是调用他的唯一途径就是明确指出class的名称。</strong>但是pure virtual依然无法创建对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shape* ps = <span class="keyword">new</span> shape;</span><br><span class="line">shape* ps1 = <span class="keyword">new</span> Rectangle;</span><br><span class="line">ps1-&gt;draw();  <span class="comment">// Rectangle的draw函数</span></span><br><span class="line">ps1-&gt;shape::draw(); <span class="comment">// 调用了父类的draw函数</span></span><br></pre></td></tr></table></figure><p><strong>声明非纯impure virtual函数的目的，就是让derived classes继承该函数的接口和缺省实现。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shape</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码表示每个class都必须支持一个“当遇到错误时可调用”的函数，但每个class可自由处理错误。如果不愿意自己处理错误的话，也可以使用父类的缺省实现。</p><p>但是这就会出现一个问题，当我们继承了一个韩非纯函数的父类的时候，我们可能会忘记实现自己的版本，此时编译器就会为了安排默认的版本，而引发错误，下面这种做法就是为了解决这个问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(cosnt sAirport&amp; destination)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">defaultFly</span><span class="params">(cosnt Ariport&amp; destination)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Airplane::defaultFly(<span class="keyword">const</span> Airport&amp; destination)&#123;</span><br><span class="line">  <span class="comment">//fly函数中的实现部分改到这里来写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述操作将fly函数又impure设置成pure函数，意味着子类必须有自己实现的版本，在缺省的实现部分转移到defaultFly当中去，如果子类不实现fly函数则会报错，如果希望用缺省方式的话，则调用defaultFly函数。</p><p>但是上面这种做法将会导致代码的重复这种情况。</p><p>另一种做法是将默认的实现部分转移到纯虚函数的实现中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Airplane</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(cosnt Airport&amp; destination)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> Airplane::fly(cosnt Airport&amp; destination)&#123;</span><br><span class="line">  <span class="comment">//缺省行为，将飞机飞至指定的目的地</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelA</span>:</span><span class="keyword">public</span> Airplane&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">(<span class="keyword">const</span> Airport&amp; destination)</span></span>&#123;</span><br><span class="line">      Airplane::fly(destination); <span class="comment">// 使用缺省的方式实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br><span class="line"><span class="comment">// 如果你要自己实现fly这个函数的话，可以自己写相应的方法</span></span><br></pre></td></tr></table></figure><p>这种方式避免了再去定义一个defaultFly函数。现在的fly函数被切割成两个部分，其声明部分表现的是接口，其定义部分表现出缺省行为。</p><p><strong>声明non-virtual函数的目的就是为了令derived classes继承函数的接口及一份强制性的实现。</strong></p><p>由于non-virtual函数代表的意义是不变性凌驾于特异性之上，我们绝对不要在子类中重新定义父类中的non-virtual函数。</p><p><strong>总结</strong></p><ul><li>接口继承和实现继承不同。在public继承之下，derived classes总是继承base class的接口。</li><li>pure virtual函数只具体指定接口继承。</li><li>非纯的函数具体制定接口继承及缺省实现继承。</li><li>non-virtual函数具体指定接口继承以及强制性实现继承。</li></ul><h3 id="35-条款：考虑virtual函数与外的其他选择"><a href="#35-条款：考虑virtual函数与外的其他选择" class="headerlink" title="35 条款：考虑virtual函数与外的其他选择"></a>35 条款：考虑virtual函数与外的其他选择</h3><p>我们可以使用一些其他的方式来代替virtual的使用</p><p><strong>template method模式</strong></p><p>这种模式为将虚函数修改为public的non-virtual函数，然后其具体的实现通过定义一个private的virtual函数来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">      ... <span class="comment">// 调用前准备</span></span><br><span class="line">      <span class="keyword">int</span> retval = dohealthValue();</span><br><span class="line">      ... <span class="comment">// 调用后处理</span></span><br><span class="line">      <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">dohealthValue</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 上面的设计令用户通过public non-virtual成员函数佳节调用private virtual函数的模式（NVI non-virtual interface），把non-virtual函数作为一个外覆器，在调用前后都可以进行一些处理，这是这种方法的一个优点，但是缺点是我们需要定义很多private virtual函数。</p><p><strong>籍由Function Pointers实现strategy模式</strong></p><p>利用传入一个函数指针的方式，进行实际的操作。</p><p>函数指针的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">defaultHealth</span><span class="params">(<span class="keyword">const</span> GameCharacter&amp; gc)</span></span>;</span><br><span class="line"><span class="comment">//函数指针如下</span></span><br><span class="line">return_types (*func_pointer)( data_types arg1, data_types arg2, ..);</span><br><span class="line"><span class="keyword">int</span> (*defaultHealth)(<span class="keyword">const</span> GameCharacter&amp;);</span><br><span class="line"><span class="comment">//使用上面的定义之后，就可以用指针defaultHealth来调用函数了</span></span><br></pre></td></tr></table></figure><p>上述这种方法提供了某种弹性，在调用不同的类型的时候，传入不同计算方法的函数的指针，得到不同的计算方式。当我们使用了类外的方法的时候，我们可能会陷入一个陷阱中，就是这个函数只能访问类的public部分，如果我们想进一步的话，就只能降低函数的封装级别了。</p><p><strong>籍由tr1::function完成strategy模式</strong></p><p><strong>C++ Technical Report 1 （TR1</strong>）是ISO/IEC TR 19768, C++ Library Extensions（函式库扩充）的一般名称。TR1是一份文件，内容提出了对C++标准函式库的追加项目。这些追加项目包括了正则表达式、智能指针、哈希表、随机数生成器等。</p><p><strong>function 是一种通用、多态的函数封装</strong>。<strong>std::function 的实例可以对任何可以调用的目标进行存储、复制、和调用操作，这些目标包括函数、lambda 表达式、绑定表达式、以及其它函数对象等</strong>。（c++11起的版本可用）<br>　　function（和bind一样）可以实现类似函数指针的功能，却比函数指针更加灵活（体现在占位符上面），尤其是在很多成员调用同一个函数（仅仅是参数类型不同）的时候比较方便。</p><p><strong>C++中的函数签名(function signature)</strong>：包含了一个函数的信息，包括函数名、参数类型、参数个数、顺序以及它所在的类和命名空间。</p><p>function对象只要签名式满足要求，那么这个对象就可以存储任何可调用物。下面我们使用function来替代上面的函数指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameCharacter</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::str1::function&lt;<span class="keyword">int</span> (<span class="keyword">const</span> GameCharacter&amp;)&gt; healthCalFunc;</span><br><span class="line">    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc):healthFunc(hfc)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">healthValue</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> healthFunc(*<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面代码可以看出来，我们只要传入一下接受一个const reference参数的任意函数都可以，我们可以使用函数，函数对象，成员函数等等。</p><p><strong>古典的strategy模式</strong></p><p>传统的strategy做法将一个健康的计算函数做成一个分离的继承体系中的virtual成员函数。</p><p><strong>替代方案</strong></p><p>本条条款的核心就是可以通过一下几种方式来找到virtual的替代方案：</p><ul><li>使用non-virtual interface手法，那是template method设计模式的一种特殊形式，它以public non-virtual成员函数包裹较低访问性的virtual函数。</li><li>将virtual函数替换为函数指针成员变量，这是strategy设计模式的一种分解形式。</li><li>以tr1::function成员变量替换virtual函数，因而允许使用任何可调用物来搭配一个兼容于需求的签名式。</li><li>将继承体系内的virtual函数替换为另一个继承体系内的virtual函数，这是strategy设计模式的传统实现方法。</li></ul><p><strong>总结</strong></p><ul><li><p>virtual 函数的替代方案包含NVI，以及strategy设计模式的多种形式，NVI手法是一个特殊形式的template method模式。</p></li><li><p>将机能从成员函数一道class外部函数，带来一个缺点，非成员函数无法访问class的non-public成员。</p></li><li>tr1::function对象行为就像一般函数指针，这样的对象可接纳与给定目标签名式兼容的所有可调物。</li></ul><h3 id="36-条款：绝不重新定义继承而来的non-virtual函数"><a href="#36-条款：绝不重新定义继承而来的non-virtual函数" class="headerlink" title="36 条款：绝不重新定义继承而来的non-virtual函数"></a>36 条款：绝不重新定义继承而来的non-virtual函数</h3><p>在一个类中，我们定义了non-virtual函数，意味着我们遵循设计原则，认为这个函数的不变性要大于特异性，因此我们不可以在子类中对这个函数进行覆盖。否则，将同一个元素赋值给父类和子类，将导致不同的行为，这是我们不希望看到的。</p><p><strong>总结</strong></p><ul><li>绝对不要重新定义继承而来的non-virtual函数</li></ul><h3 id="37-条款：绝不重新定义继承而来的缺省参数值"><a href="#37-条款：绝不重新定义继承而来的缺省参数值" class="headerlink" title="37 条款：绝不重新定义继承而来的缺省参数值"></a>37 条款：绝不重新定义继承而来的缺省参数值</h3><p>当我们继承一个父类的时候，如果父类中的virtual函数带有缺省值，我们选择不去重写这个缺省值。原因是：</p><p><strong>virtual函数系动态绑定，而缺省参数值确实静态绑定。</strong>因此缺省的参数值在定义的时候就会被确定，缺省值就是定义这个函数的类给赋予的。如下面代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> shapecolor&#123;red,green,blue&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(shapecolor color = red)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rectangle</span>:</span><span class="keyword">public</span> Shape&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(shapecolor color = green)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">void</span> rectangle::draw(Shape::shapecolor color) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"---"</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; color;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"---"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shape *ps = <span class="keyword">new</span> rectangle();</span><br><span class="line">rectangle* rec = <span class="keyword">new</span> rectangle();</span><br><span class="line">ps-&gt;draw();  <span class="comment">// 使用静态绑定的shape中的缺省值</span></span><br><span class="line">rec-&gt;draw(); <span class="comment">// 使用静态绑定的rectangle中的缺省值</span></span><br></pre></td></tr></table></figure><p>上述代码就可以看出矛盾，同一个对象却有不同的表现，导致缺省值的不同。上述代码的一个解决方案就是使用NVI方式，用non-virtual去调用virtual函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> shapecolor&#123;red,green,blue&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(shapecolor color = red)</span></span>&#123;</span><br><span class="line">        doDraw(color);  </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(shapecolor color)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rectangle</span>:</span><span class="keyword">public</span> shape&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">doDraw</span><span class="params">(shapecolor color)</span> <span class="keyword">const</span></span>;  <span class="comment">// 这里不需要指定缺省的参数值</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>由于non-virtual函数是不会被子类覆盖。这个设计保证了参数值一定是一致的。</p><p><strong>总结</strong></p><ul><li>绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定的，而virtual函数（你唯一需要覆盖的东西）是动态绑定的。</li></ul><p>###38 条款：通过符合塑模出has-a或“根据某物实现出”</p><p>has-a表现出来的是一种复合关系（composition），当某种类型的对象内含它种类型的对象，便是这种关系。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    Address ad; <span class="comment">// 其他类型的生成对象</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">  PhoneNumber num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，还有另一种关系，成为 <strong>is-implemented-in-terms-of</strong> 关系，例如我们实现一个set，直觉上我们可以继承标准库中的set，但是为了资源等考虑，我们打算另辟蹊径。我们可能就会考虑到list的实现，但是我们不能直接继承list，因为list与set不是is-a的关系。但是我们可以在函数中多次使用list结构来构造一个set，<strong>这就是根据某物实现出</strong>的这种关系。</p><p><strong>总结</strong></p><ul><li>复合的意义和public继承完全不同</li><li>在应用域，复合意味着is-a关系。在实现域，复合意味着根据某物来实现。</li></ul><h3 id="39-条款：明智而审慎地使用private继承"><a href="#39-条款：明智而审慎地使用private继承" class="headerlink" title="39 条款：明智而审慎地使用private继承"></a>39 条款：明智而审慎地使用private继承</h3><p>private继承不是一个is-a继承，而是一种子类实现需要使用父类的某些函数性质的 “implemented-in-terms-of”的关系。</p><p>对于private的选择，我们通常会考虑：<strong>当一个意欲成为derived class者想要访问一个意欲成为base class者的protected成分，或者成为重新定义一个或多个virtual函数。</strong>如果满足这个条件的话，我们会考虑使用private继承，但是很多情况下，我们使用复合，将private继承的类作为一个成员变量的方式，能够提供能多的灵活性。</p><p><strong>即：我们可以使用复合的方式来代替private的继承，保证更大的灵活性。</strong></p><p>但是如果我们追求一种更加激进的空间优化，我们会选择使用private继承来代替复合。</p><p>如果我们使用的类满足不带数据成员，没有virtual等条件，满足空白基类最优化EBO的情况下，我们应该优先考虑private继承，但是这种情况基本很少见。</p><p><strong>总结</strong></p><ul><li>private继承意味着 <strong>根据某物实现出</strong>的关系，它通常比复合的级别要低，当时当子类需要访问protected base class的成员，或需要重新定义继承而来的cirtual函数时，是合理的。</li><li>和复合不同，private继承可以造成empty base最优化，这对于严格要求“对象尺寸最小化”的程序开发者而言是很重要的。</li></ul><h3 id="40-条款：明智而审慎地使用多重继承"><a href="#40-条款：明智而审慎地使用多重继承" class="headerlink" title="40 条款：明智而审慎地使用多重继承"></a>40 条款：明智而审慎地使用多重继承</h3><p>当我们设计到多重继承的时候，在子类的使用上将会面临起义的一个问题，共同父类中相同的函数，必须通过类名的方式进行调用。</p><p>对于钻石形的继承关系，我们使用virtual来继承，使得每一个子类都有一份供自己使用的父类成员变量。但是使用virtual将会导致C++编译器在处理这类继承时，生成体积较大的对象，访问速度也比较慢，virtual继承付出的代价更加的明显，规则复杂不够直观。</p><p><strong>忠告</strong></p><ul><li><p>非必须使用virtual bases的时候不要使用它，大部分情况使用non-virtual继承</p></li><li><p>如果必须使用virtual base继承，那么尽量避免在其中放置数据，使得类小一点，以及不会出现难以察觉的赋值问题。</p></li></ul><p>但是有些时候，双重继承也有其合理的用途，保留使用多重继承的看法。如果能用单一继承代替多重继承的话，单一继承是一个非常好的选择。</p><p><strong>总结</strong></p><ul><li>多重继承比单一继承复杂，他可能导致起义性，以及对virtual继承的需要</li><li>virtual继承会增加大小，速度，初始化复杂度等成本，如果virtual base classes不带任何的数据，将会是多重继承最具有使用价值的情况。</li><li>多重继承的确有正当用途，其中一个情节涉及public继承某个interface class和private继承某个协助实现的class的两相组合。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019/11/16 effective cpp 第六章 继承与面向对象设计&lt;/p&gt;
&lt;p&gt;面向对象编程成为一个风靡一时的重要特性，关于C++在面向对象上的一些特性，将在本章进行详细的介绍。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;32 条款：确定你的public继承塑膜出is-a关系&lt;/li&gt;
&lt;li&gt;33 条款：避免遮掩继承而来的名称&lt;/li&gt;
&lt;li&gt;34 条款：区分接口继承和实现继承&lt;/li&gt;
&lt;li&gt;35 条款：考虑virtual函数与外的其他选择&lt;/li&gt;
&lt;li&gt;36 条款：绝不重新定义继承而来的non-virtual函数&lt;/li&gt;
&lt;li&gt;37 条款：绝不重新定义继承而来的缺省参数值&lt;/li&gt;
&lt;li&gt;38 条款：通过符合塑模出has-a或“根据某物实现出”&lt;/li&gt;
&lt;li&gt;39 条款：明智而审慎地使用private继承&lt;/li&gt;
&lt;li&gt;40 条款：明智而审慎地使用多重继承&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="effective cpp" scheme="https://wenhui-zhou.github.io/categories/effective-cpp/"/>
    
    
  </entry>
  
</feed>

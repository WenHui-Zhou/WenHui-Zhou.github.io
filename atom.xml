<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WenHuiZhou</title>
  
  <subtitle>perper（打起精神！）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wenhui-zhou.github.io/"/>
  <updated>2019-11-10T11:23:32.252Z</updated>
  <id>https://wenhui-zhou.github.io/</id>
  
  <author>
    <name>WenHuiZhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>effective cpp(四) 设计与声明</title>
    <link href="https://wenhui-zhou.github.io/2019/11/09/effective-cpp-%E5%9B%9B-%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%A3%B0%E6%98%8E/"/>
    <id>https://wenhui-zhou.github.io/2019/11/09/effective-cpp-四-设计与声明/</id>
    <published>2019-11-09T04:42:31.000Z</published>
    <updated>2019-11-10T11:23:32.252Z</updated>
    
    <content type="html"><![CDATA[<p>2019/11/09 effective cpp 第四章</p><p>良好的cpp接口的设计以及声明是可以令软件作出其最正确的事，包括正确，高效性、封装性、维护性、延展性、以及协议一致性。</p><ul><li>18 条款：让接口容易被正确使用，不易被误用</li><li>19 条款：设计class犹如设计type</li><li>20 条款：宁以 pass-by-reference-to-const 替换 pass-by-value</li><li>21 条款：必须放回对象时，别妄想返回其reference</li><li>22 条款：将成员变量声明为private</li><li>23 条款：宁以non-member、non-friend替换member函数</li><li>24 条款：若所有参数皆需类型转换，请为此采用non-member函数</li><li>25 条款：考虑写出一个不抛异常的swap函数</li></ul><a id="more"></a><h3 id="18-条款：让接口容易被正确使用，不易被误用"><a href="#18-条款：让接口容易被正确使用，不易被误用" class="headerlink" title="18 条款：让接口容易被正确使用，不易被误用"></a>18 条款：让接口容易被正确使用，不易被误用</h3><p>接口开发的目标在于：<strong>让接口容易被正确使用，不易被误用</strong></p><p>但是由于有时候会遇到用户传入的参数和接口能够接受的参数不同，可能会导致错误，这个时候最后通过 <strong>类型系统的方式来预防</strong>，通过导入新的类别来限制数据类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Date(<span class="keyword">const</span> Month&amp; m,<span class="keyword">const</span> Day&amp; d,<span class="keyword">const</span> Year&amp; y)&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Date <span class="title">d</span><span class="params">(Month(<span class="number">3</span>),Day(<span class="number">30</span>),year(<span class="number">1995</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>对数据的限制部分在每一个数据类型的函数内部。明智地选择合适的新类型，能够有效的防止接口被误用。</p><p>另一个预防客户错误的方式是限制类型内可做什么事情，不能做什么事情，常见的限制加上const，阻止用户自定义类型错误。</p><p>另一个准则为除非有好的理由，否则应该尽量令你的types的行为和内置的type的行为一致。例如STL中的所有类均有一个size方法，表示长度。</p><p>如果在接口内部有资源的申请，申请的资源必须在最后得到销毁。因此最好的方法就是将函数的返回值设置为shared_ptr：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str1:：<span class="built_in">shared_ptr</span>&lt;invest&gt; create();</span><br></pre></td></tr></table></figure><p>此外，shared_ptr还允许绑定一个对象释放函数，当对象释放的时候，shared_ptr调用这个函数来释放对象。定义方式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str1::<span class="built_in">shared_ptr</span>&lt;invest&gt; pInt(ptr,deleteMethod);</span><br></pre></td></tr></table></figure><p><code>str1::shared_ptr</code>会自动调用每个使用它的指针专属的删除器，避免跨DLL文件delete导致运行期的错误。<strong>shared_ptr会调用指针的专属删除器</strong>。</p><p>shared_ptr在效率和空间上是用指针的两倍大，使用辅助动态内存，比原始指针要大。</p><p><strong>总结</strong></p><ul><li>设计不容易出错的接口</li><li>保证接口之间的一致性</li><li>阻止误用，建立新类型的方式限制类型上的操作，消除客户资源管理的任务</li><li>Tr1::shared_ptr支持定制删除器，防范DLL问题</li></ul><h3 id="19-条款：设计class犹如设计type"><a href="#19-条款：设计class犹如设计type" class="headerlink" title="19 条款：设计class犹如设计type"></a>19 条款：设计class犹如设计type</h3><p>当你定义了一个新的class，也就定义了一个type，设计好的type有自然的语法和直观的语义，有一下的设计规范：</p><ul><li>新type的对象应该如何创建和销毁</li><li>对象初始化和对象的赋值该有什么样的差别</li><li>新type对象如果被传值（passed by value）该在copy函数中写实现方法</li><li>对type的合法值进行约束</li><li>新的type是否需要配合继承图系</li><li>新type需要什么样的类型转换</li><li>什么样的操作符和函数对新type是合理的</li><li>什么样的标准函数需要驳回</li><li>谁该去用新type成员</li><li>什么是新type的未声明接口</li><li>type的一般化程度</li><li>你真的需要一个新type吗</li></ul><p><strong>总结</strong></p><p>设计一个class的时候，需要充分考虑上面的问题，具体所指可以参考书本84页。</p><h3 id="20-条款：宁以-pass-by-reference-to-const-替换-pass-by-value"><a href="#20-条款：宁以-pass-by-reference-to-const-替换-pass-by-value" class="headerlink" title="20 条款：宁以 pass-by-reference-to-const 替换 pass-by-value"></a>20 条款：宁以 pass-by-reference-to-const 替换 pass-by-value</h3><p>C++默认以传值的方式给函数传递参数，这一过程函数参数的初值都是调用对象的构造函数来实现，当离开这个函数的时候，通过析构函数来回收这些资源，因此传值的方式将会耗费大量的资源和时间。</p><p>一个很好的优化方法就是使用const 引用的方式，这种方式没有任何的构造函数被调用。之所以使用const，是为了保证传入的参数对象不会被改变。</p><p>此外如果直接传值，对于参数类型为父类的情况，传入子类对象，会造成子类特化功能被切割，参数的行为与父类相同，但是如果使用传引用的方式，这种现象不会发生。</p><p>说到这里，我们会好奇，引用到底是个什么东西呢，其实际上运用是通过指针的方式来实现的，传递引用等同于传递指针，<strong>对于内置类型来说，传值方式会比传指针的方式更加高效。</strong> 对于int，float这些类型，直接通过传值的方式更加的高效。</p><p><strong>总结</strong></p><ul><li>尽量以传const引用的方式替换传值的方式，前者通常比较高效，避免对象切割问题</li><li>对于内置类型以及STL迭代器，函数对象来说，直接传值比较高效</li></ul><h3 id="21-条款：必须放回对象时，别妄想返回其reference"><a href="#21-条款：必须放回对象时，别妄想返回其reference" class="headerlink" title="21 条款：必须放回对象时，别妄想返回其reference"></a>21 条款：必须放回对象时，别妄想返回其reference</h3><p>当我们尝试消灭所有的传值行为的时候，我们可能会对函数的返回值下手，这种做法是不可取的。</p><p>所谓的引用，即表明它所指代的对象一定要存在，在函数中我们有两种方式创建对象：</p><p><strong>创建对象在stack内存上</strong></p><p>stack内存存放函数的参数，局部变量值，由编译器自动释放：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Ration&amp; <span class="keyword">operator</span>*(<span class="keyword">const</span> Ration&amp; lhs,<span class="keyword">const</span> Ration&amp; rhs)&#123;</span><br><span class="line">  <span class="function">Ration <span class="title">result</span><span class="params">(lhs.n*rhs.n)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上买代码返回了一个局部变量的引用，但是由于出了这个函数，局部变量就会被销毁，因此这个reference将毫无意义。</p><p><strong>创建对象在heap内存上</strong></p><p>用户自己分配，自己销毁的资源都会分配在heap内存上，有new-delete对来管理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Ration&amp; <span class="keyword">operator</span>*(<span class="keyword">const</span> Ration&amp; lhs,<span class="keyword">const</span> Ration&amp; rhs)&#123;</span><br><span class="line">  Ration* result = <span class="keyword">new</span> Ration(lhs.n*rhs.n);</span><br><span class="line">  <span class="keyword">return</span> *result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面返回的引用是有意义的，但是当我们使用完这个 内存之后，由谁去销毁呢，在一些很复杂的操作里面，程序员往往无法保证资源的完全回收。</p><p><strong>使用static变量</strong></p><p>在函数内部定义static变量，该变量的生命周期是整个程序的生命周期，static变量，全局变量他们的值都是存放在同一块区域，由程序结束后统一回收。</p><p>但这又引发了另一个问题，你想要比较两个数相乘后与另外两个数相乘的大小，但是结果存放在static当中，程序只会保存一份static的结果，因此永远无法比较。</p><p>因此，<strong>如果函数要求返回一个对象，那么我们就承担返回值所产生的构造和析构成本</strong>，不要试图去放回引用。</p><p><strong>总结</strong></p><p>不要返回一个指针或引用指向一个local对象，或指向heap-allocated对象，或指向static对象，而是直接返回该对象（传值）。</p><h3 id="22-条款：将成员变量声明为private"><a href="#22-条款：将成员变量声明为private" class="headerlink" title="22 条款：将成员变量声明为private"></a>22 条款：将成员变量声明为private</h3><p>为保证成员便来那个的约束性，对用户隐藏变量，使得类中的约束条件总会收到维护。如果将一个变量声明为public，破坏了封装性，在我们修改该变量的时候，我们无法预知这个变量所涉及的一切，可能会对程序造成极大的破坏。因此保护类的封装性。protected类型与public相似，其实只有来那个两种访问权限：<strong>private（提供封装）和其他（不提供封装）</strong></p><p><strong>总结</strong></p><ul><li>切记将成员变量声明为private，这可赋予客户访问数据一致性，细微划分访问控制，允许约束条件获得保护，并 提供class作者充分的实现弹性。</li></ul><h3 id="23-条款：宁以non-member、non-friend替换member函数"><a href="#23-条款：宁以non-member、non-friend替换member函数" class="headerlink" title="23 条款：宁以non-member、non-friend替换member函数"></a>23 条款：宁以non-member、non-friend替换member函数</h3><p>这个条款的核心在于：<strong>越少的操作直接接触到数据，对类的封装性，代码的维护越好</strong>。因此如果一些操作可以由非成员函数来完成的话，就不要去写那个成员函数的版本。</p><p>越少的函数接触到数据，我们在改变数据的时候，就可以有越大的灵活度修改这个数据。</p><p>有几种方式可以去实现非类内函数来完成这个操作：</p><ul><li>例如我们指提供了一个完成基础操作的类，我们可以选择另一个类中的函数，传入这个对象，来实现你想要的操作，而不用为基础类添加成员</li><li>C++的一个常用的做法是，将non-member函数与类写在同一个命名空间中，命名空间可以跨越多个源码文件。将所有便利函数放在多个头文件内，但同属于一个命名空间，以为着用户可以轻松扩展这一组便利函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件webbrowser.h</span></span><br><span class="line"><span class="keyword">namespace</span> webbrowserStuff&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">webbrowser</span>&#123;</span>...&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头文件webbrowserbook.h</span></span><br><span class="line"><span class="keyword">namespace</span> webbrowserbook&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 头文件webbrowsercookies.h</span></span><br><span class="line"><span class="keyword">namespace</span> webbrowsercookies&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过include需要的头文件的方式来管理标准程序库，使得那一小部分系统形成编译相依的关系。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//web.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> wweb&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">web</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">get_name</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        web(<span class="built_in">string</span> n):name(n)&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">say_hi</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//web.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"web.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::wweb;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> web::say_hi() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hihi"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li>宁可用non-member函数替代member函数，这可增加类的封装性，包裹性，机能扩充性。</li><li>non-member的函数通常与class定义在同一个命名空间内</li></ul><h3 id="24-条款：若所有参数皆需类型转换，请为此采用non-member函数"><a href="#24-条款：若所有参数皆需类型转换，请为此采用non-member函数" class="headerlink" title="24 条款：若所有参数皆需类型转换，请为此采用non-member函数"></a>24 条款：若所有参数皆需类型转换，请为此采用non-member函数</h3><p>当我们传入参数都需要进行类型转换的时候，如果将类函数写成如下情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ration</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">    <span class="keyword">const</span> Ration <span class="keyword">operator</span>* (<span class="keyword">const</span> Ration&amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Ration <span class="title">oneE</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">Ration result = oneE*<span class="number">2</span>; <span class="comment">// C++将2转换成Ration类型</span></span><br><span class="line">Ration result = <span class="number">2</span>*oneE; <span class="comment">// 编译错误，因为this不可以作为类型转换的变量</span></span><br></pre></td></tr></table></figure><p>只有当参数可位列于参数列中内，这个参数才允许隐式转换，因此一个比较好的方法就是非类内函数去实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Ration <span class="keyword">operator</span>*(<span class="keyword">const</span> Ration&amp; lhs,<span class="keyword">const</span> Ration&amp; rhs)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能够避免使用友元的情况就一定要避免使用它。</p><p><strong>总结</strong></p><p>如果需要为某个函数的所有参数进行类型的转换，那么这个函数必须是个non-member。</p><h3 id="25-条款：考虑写出一个不抛异常的swap函数"><a href="#25-条款：考虑写出一个不抛异常的swap函数" class="headerlink" title="25 条款：考虑写出一个不抛异常的swap函数"></a>25 条款：考虑写出一个不抛异常的swap函数</h3><p>swap函数的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">namspace <span class="built_in">std</span>&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a,T&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要支持copying，swap就会完成交换。但是上面这种方法需要不断的构造，析构。于是我们选择特性化swap，<strong>通过置换指针的方式就可以达到置换的效果</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">widget</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span></span>&#123;</span><br><span class="line">      <span class="keyword">using</span> <span class="built_in">std</span>::swap;  <span class="comment">//令std内的swap函数可见</span></span><br><span class="line">      swap(pInt,other.pInt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;&gt;  <span class="comment">//告诉编译器，这是个全特化的版本</span></span><br><span class="line">  <span class="keyword">void</span> swap&lt;Widget&gt;(Widget&amp; a,Widget&amp; b)</span><br><span class="line">  &#123;</span><br><span class="line">    a.swap(b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此优化copy：</p><ul><li>提供一个public swap成员函数，让它高效置换你的类型的两个对象值，且不能抛出异常。（置换基本类型）。</li><li>在class或template所在命名空间中提供一个non-member swap函数，并令他调用上述的swap成员函数。</li><li>如果你正编写一个class，为你的class特化std::swap，并调用你的swap。</li></ul><p><strong>总结</strong></p><ul><li><p>当std::swap对你的类型效率不高的时候，提供一个swap成员函数，并确保不抛出异常</p></li><li><p>提供一个member swap函数，也应该提供一个non-member swap用来调用前者，对于classes也请特化std::swap。</p></li><li>调用 swap时应该针对std::swap使用using声明式，然后调用swap并且不带任何命名空间资格修饰。</li><li>为“用户定义类型”进行std::template全特化是好的但是千万不要尝试在std内部加上对std而言全新的东西。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019/11/09 effective cpp 第四章&lt;/p&gt;
&lt;p&gt;良好的cpp接口的设计以及声明是可以令软件作出其最正确的事，包括正确，高效性、封装性、维护性、延展性、以及协议一致性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;18 条款：让接口容易被正确使用，不易被误用&lt;/li&gt;
&lt;li&gt;19 条款：设计class犹如设计type&lt;/li&gt;
&lt;li&gt;20 条款：宁以 pass-by-reference-to-const 替换 pass-by-value&lt;/li&gt;
&lt;li&gt;21 条款：必须放回对象时，别妄想返回其reference&lt;/li&gt;
&lt;li&gt;22 条款：将成员变量声明为private&lt;/li&gt;
&lt;li&gt;23 条款：宁以non-member、non-friend替换member函数&lt;/li&gt;
&lt;li&gt;24 条款：若所有参数皆需类型转换，请为此采用non-member函数&lt;/li&gt;
&lt;li&gt;25 条款：考虑写出一个不抛异常的swap函数&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="effective cpp" scheme="https://wenhui-zhou.github.io/categories/effective-cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>EncNet结合上下文的语义分割</title>
    <link href="https://wenhui-zhou.github.io/2019/11/06/EncNet%E7%BB%93%E5%90%88%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E8%AF%AD%E4%B9%89%E5%88%86%E5%89%B2/"/>
    <id>https://wenhui-zhou.github.io/2019/11/06/EncNet结合上下文的语义分割/</id>
    <published>2019-11-06T09:39:32.000Z</published>
    <updated>2019-11-07T06:46:42.407Z</updated>
    
    <content type="html"><![CDATA[<p>《Context Encoding for Semantic Segmentation》是发表在2018年cvpr上的文章，文章的主要insight在于将图像中的内容信息加入到语义分割的网络中，通过一个context encoding module突出图像类别，对分类类别进行简化，降低分割的难度，提升分割的精度。</p><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>目前的分割网络主要的关注点在于pixel-level predict，即对每个像素进行类别的分类。从2016年提出的FCN分割网络开始，图像分割实现了一个端到端的分割，当时由于CNN-pooling的网络设计，使得FCN网络对数据的丢失严重。为了解决这个问题，人们提出了dilated conv以及特征金字塔等（deeplab）结构来解决这个问题，即扩大feature map的感受野的同时，保证feature map的分辨率，保留大部分的数据。</p><p>EncNet另辟蹊径，认为通过图像中给出的类别信息能够对分割种类进行缩小，找到一个比较小的子集，在该类别的子集上进行语义的分割，简化分割问题。本文给出了两个主要的贡献：</p><ol><li>本文提出了一个context encoding mudule模块，以及一个SE-Loss，一个简单的单元来利用全局的场景内容信息学到不同channel的权重，以及学到场景中所包含的类别。</li><li>EncNet，作者的第二个贡献就是提出了EncNet这个网络，能勾在许多公开的语义分割的数据集上取得state of the art的效果。</li></ol><p>下面来看一下作者具体是怎么实现的：</p><p><img src="/images/3D/encnet.png" style="zoom:40%;"></p><h3 id="Context-Encoding-Module"><a href="#Context-Encoding-Module" class="headerlink" title="Context Encoding Module"></a>Context Encoding Module</h3><p><strong>context Enocding</strong></p><p>作者通过使用一系列的卷积层（空洞卷积）去学习一个内在的语义字典的表示，将这个字典作为编码语义，为了方便使用上下文，去学习预测了一组缩放因子用于突出和类别相关的特征图。</p><p>将feature map的大小reshape成二维（WxH）x C，去学习codebook $D = {d_1,d_2,…d_k}$ ,以及一组和视觉中心平滑因子$S = {s_1,s_2,…s_k}$,编码层输出残差编码，通过soft-assignment进行聚合，$e_k = \sum_{i=1}^{N}e_{ik}$，其中$e_{ik}$ 如下：<br>$$<br>\begin{equation}<br>e_{i k}=\frac{\exp \left(-s_{k}\left|r_{i k}\right|^{2}\right)}{\sum_{j=1}^{K} \exp \left(-s_{j}\left|r_{i j}\right|^{2}\right)} r_{i k}<br>\end{equation}<br>$$<br>其中$r_{ik} = x_i - d_k$作为残差加入计算，其中$e = \sum_{k=1}^{K}\phi(e_k)$，对所有的ek进行batch normalization得到e，作为编码层的输出。</p><p><strong>feature attention</strong></p><p>通过编码层输出的e，来学习一组缩放因子，用于强调和抑制一些不同的类别。缩放因子通过全连接层进行学习，最得到一组缩放因子如下：<br>$$<br>\gamma = \sigma(We)<br>$$<br>其中w为全连接层的参数，$\sigma$为sigmoid函数，最终将得到的缩放因子与输入的深度图进行相乘得到最终权重改变后的feature map。</p><p><strong>Semantic Encoding Loss</strong></p><p>作者为了能够更好的理解图片与类别之间的关系，从图像中直接预测出图像中所包含的类别，将编码层的输出传入另一个全连接层中，GT为图片中已有的类别，通过最小化SE-Loss，即二次的交叉熵loss，判断60个类，存在或不存在的方式，来建立图像全局信息与类别之间的映射关系。最终对图像中的类别进行一个削减。</p><h3 id="Context-Encoding-Network"><a href="#Context-Encoding-Network" class="headerlink" title="Context Encoding Network"></a>Context Encoding Network</h3><p>EncNet网络的backbone使用的是resnet，同时使用了之前证明有效的dilated conv，在深度图的state3，和4阶段使用了空洞卷积：</p><p><img src="/images/3D/dilated.png" style="zoom:50%;"></p><p>在stage3位置上同样适用了SE-loss，作为一个额外的正则化的操作，encnet在FCN的基础上进行一些小的改动，通过增加一些轻微的计算量就可以达到一个很好的效果。</p><h3 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h3><p>pixAcc：像素类别预测正确的像素除以所有像素的比例。</p><p>mIoU：每一类预测结果与GT的结果的IoU的平均值。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>看完整篇文章，这篇文章最大的亮点就是认为<strong>飞机不会出现在房间里</strong>，利用图像的feature map，与类别GT，建立一个映射，从而在做最终的逐像素的语义分割的问题时，没必要在所有的类别上做，而是直接在根据图像feature map上映射得到的类别上做，降低了语义分割的难度。</p><p>对图像整个内容信息的提取上，主要由两部分构成，一部分对不同的channel学习一个重要性权重，另一个直接通过图像内容学习一个图像中含有的类别。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《Context Encoding for Semantic Segmentation》是发表在2018年cvpr上的文章，文章的主要insight在于将图像中的内容信息加入到语义分割的网络中，通过一个context encoding module突出图像类别，对分类类别进行简化，降低分割的难度，提升分割的精度。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>推荐系统之评分预测（三）</title>
    <link href="https://wenhui-zhou.github.io/2019/11/06/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%AF%84%E5%88%86%E9%A2%84%E6%B5%8B%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://wenhui-zhou.github.io/2019/11/06/推荐系统之评分预测（三）/</id>
    <published>2019-11-06T02:23:24.000Z</published>
    <updated>2019-11-06T12:40:27.052Z</updated>
    
    <content type="html"><![CDATA[<p>评分问题，根据已有的评分，或者用户、物品的评分规则对物品进行评分的预测。</p><a id="more"></a><p><strong>离线实验方法</strong></p><p>评分的预测基本上都是通过离线实验进行研究的。研究者通过将数据分成训练集和测试集的方式，根据训练好的兴趣模型，对测试集进行评分。一般使用的度量方法为RMSE：<br>$$<br>\operatorname{RMSE}=\frac{\sqrt{\sum_{(u, i) \in T}\left(r_{u i}-\hat{r}_{u i}\right)^{2}}}{|\mathrm{Test}|}<br>$$</p><h3 id="评分预测算法"><a href="#评分预测算法" class="headerlink" title="评分预测算法"></a>评分预测算法</h3><h3 id="平均值"><a href="#平均值" class="headerlink" title="平均值"></a>平均值</h3><p>通过计算训练集中的全局平均值，作为测试集中的评分。</p><p><strong>用户评分平均值</strong></p><p>用户的评分平均值为用户历史评分的平均值，作为他之后评分的一个值。</p><p><strong>物品评分平均值</strong></p><p>对物品的所有评分计算平均值，作为它在训练集中的所有评分的平均值。</p><p><strong>用户分类对物品分类的平均值</strong></p><p>同类的用户对同类的物品的评分的平均值作为物品的评分。</p><p><strong>用户和物品的平均分</strong></p><p>将用户和物品按照评分从高到低分成平均分成N类。</p><p><strong>用户活跃度和物品流行度</strong></p><p>用户活跃度和物品的流程度从大到小平均分成N类。</p><h3 id="基于领域的方法"><a href="#基于领域的方法" class="headerlink" title="基于领域的方法"></a>基于领域的方法</h3><p>基于领域的方法认为一个用户对一个物品的评分需要参考和着高哟高糊兴趣相似的用户对该物品的评分。<br>$$<br>\hat{r}_{u i}=\bar{r}_{u}+\frac{\sum_{v \in S(u, K) \cap N(i)} w_{u v}\left(r_{v i}-\bar{r}_{v}\right)}{\sum_{v \in S(u, K) \cap N(i)}\left|w_{u v}\right|}<br>$$<br>其中w为用户之间的相似度，可以通过皮尔逊系数来计算：<br>$$<br>w_{u v}=\frac{\sum_{i \in I}\left(r_{u i}-\bar{r}_{u}\right) \cdot\left(r_{v i}-\bar{r}_{v}\right)}{\sqrt{\sum_{i \in I}\left(r_{u i}-\bar{r}_{u}\right)^{2} \sum_{i \in I}\left(r_{v i}-\bar{r}_{v}\right)^{2}}}<br>$$<br>基于五瓶的领域算法在预测用户对物品的评价的时候，会参考用户对相似物品评价的评分：<br>$$<br>\hat{r}_{u i}=\bar{r}_{i}+\frac{\sum_{j \in S(u, K) \cap N(u)} w_{i j}\left(r_{u j}-\bar{r}_{i}\right)}{\sum_{j \in S(i, F) \cap W(u)}\left|w_{i j}\right|}<br>$$<br>其中w为普通的优先相似度、皮尔逊系数，修正的余弦相似度三种之一，具体那种效果好，需要看具体的实验。</p><h3 id="隐语义模型与矩阵分解模型"><a href="#隐语义模型与矩阵分解模型" class="headerlink" title="隐语义模型与矩阵分解模型"></a>隐语义模型与矩阵分解模型</h3><p>评分系统可以写成一个评分矩阵R，其中每一个位置就是用户对物品的一个评分。传统的方法通过降维的方式对评分矩阵进行填充。</p><p><strong>传统的SVD分解</strong></p><p>一个直观的想法就是，补全之后的矩阵对不全之前的矩阵扰动最小，补全后的特征值和补全之前的特征值相互差异不大。</p><p>一开始可以使用全局平均值对矩阵进行填充，然后进行矩阵的SVD分解，然后选择其中特征向量topN保留，得到一个降维之后的评分矩阵。</p><p>SVD分解有一个问题，就是它本上是十分稀疏的，95%都是空的，但是通过这种方式进行填充之后变得非常的大，计算复杂度很高，难以实际应用。</p><p><strong>simon Funk SVD</strong></p><p>simon对传统的SVD进行改造，直接将评分矩阵分解成两个低维度的矩阵相乘：<br>$$<br>\hat{r}_{u i}=\sum_{f} p_{u f} q_{i f}<br>$$<br>于是通过最小化RMSE误差，加上参数的正则化项，从而得到：<br>$$<br>C(p, q)=\sum_{(u, i) \in \mathrm{Train}}\left(r_{u i}-\sum_{f=1}^{F} p_{u f} q_{i f}\right)^{2}+\lambda\left(\left|p_{u}\right|^{2}+\left|q_{i}\right|^{2}\right)<br>$$<br>通过随机梯度下降法，去学习p，q矩阵，最终得到评分表中的缺失的评分。</p><p><strong>加入偏执的LFM</strong></p><p>在上一个方法的基础上，有人提出了许多改进的方法，提出了很多偏执，对算法进行修正：<br>$$<br>\hat{r}_{u i}=\mu+b_{u}+b_{i}+p_{u}^{T} \cdot q_{i}<br>$$<br>u为评分的全局平均数，b为用户喜好的偏执（用户评分随意或者很苛刻的情况），后一个b为物品品质的偏执（评分都很高，或都很低的情况）。</p><p><strong>加入时间信息</strong></p><p>基于领域的融合时间的模型，考虑用户评分年时间对推荐结果的影响：<br>$$<br>\begin{equation}<br>\hat{r}_{u i t}=\frac{\sum_{j \in N(u) \cap S(i, K)} f\left(w_{i j}, \Delta t\right) r_{u j}}{\sum_{j \in N(u) \cap S(i, K)} f\left(w_{i j}, \Delta t\right)}<br>\end{equation}<br>$$</p><p>$$<br>\begin{equation}<br>\begin{array}{c}{f\left(w_{i j}, \Delta t\right)=\sigma\left(\delta \cdot w_{i j} \cdot \exp \left(\frac{-|\Delta t|}{\beta}\right)+\gamma\right)} \ {\sigma(x)=\frac{1}{1+\exp (-x)}}\end{array}<br>\end{equation}<br>$$</p><p>随着$\Delta t$d的变大，影响力就会变小。</p><p><strong>模型的融合</strong></p><p>模型融合基本上分成两种方式：</p><ul><li>模型级联融合，上一个模型的输出最为下一个模型的输入，每个模型在上一个模型的基础上进行学习。</li><li>模型加权融合，用K个模型去预测最终的结果，首先将训练集A分成A1，A2，然后在A1上训练K个模型，利用A2训练集，去学习每个模型的权重。然后在B上进行最终的评分预测，这样的好处就是防止模型过拟合。</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><strong>时间上上下文信息</strong></p><p>用户的兴趣以及推荐的物品与时间的关系十分的相关，必要将时间加入到推荐算法当中去。例如在协同过滤的基础上加上时间衰减函数，如判断两个物体的相似性：<br>$$<br>\begin{equation}<br>\operatorname{sim}(i, j)=\frac{\sum_{u \in N(0) \cap N(i)} f\left(\left|t_{u i}-t_{u |}\right|\right)}{\sqrt{|N(i)||N(j)|}}<br>\end{equation}<br>$$<br>其中时间衰减函数如下：<br>$$<br>\begin{equation}<br>f\left(\left|t_{u i}-t_{u j}\right|\right)=\frac{1}{1+\alpha\left|t_{u i}-t_{u j}\right|}<br>\end{equation}<br>$$<br>当两个商品购买的时间相差比较远的话，时间衰减函数那一项就会比较小。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;评分问题，根据已有的评分，或者用户、物品的评分规则对物品进行评分的预测。&lt;/p&gt;
    
    </summary>
    
      <category term="推荐系统" scheme="https://wenhui-zhou.github.io/categories/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>effective cpp(三) 资源管理</title>
    <link href="https://wenhui-zhou.github.io/2019/11/05/effective-cpp-%E4%B8%89-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    <id>https://wenhui-zhou.github.io/2019/11/05/effective-cpp-三-资源管理/</id>
    <published>2019-11-05T07:58:01.000Z</published>
    <updated>2019-11-06T16:29:09.579Z</updated>
    
    <content type="html"><![CDATA[<p>2019/11/05 effective cpp 第三章</p><p>CPP程序运行中，将会动态申请内存、文件描述器、互斥锁等一些重要的资源，必须及时归还系统。</p><ul><li>13 条款：以对象管理资源</li><li>14 条款：</li></ul><a id="more"></a><h3 id="13-条款：以对象管理资源"><a href="#13-条款：以对象管理资源" class="headerlink" title="13 条款：以对象管理资源"></a>13 条款：以对象管理资源</h3><p>若一个基类通过一个工厂函数，得到若干个子类的地址指针，在使用完这些子类之后，需要将他们回收，下面写一个回收的函数对他们进行回收：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Invest* ptr = create();</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的代码可以完美的运行，但是在一些特定的情况下，如果程序在delete之前中途退出了，这将导致分配的资源无法得到释放。一个比较可靠的做法是：</p><p><strong>把资源放进对象内，当需要销毁资源的时候，使用C++的析构函数自动调用机制，确保资源的释放。</strong></p><p><strong>auto_ptr</strong></p><p>许多资源被动态分配到heap内，被用于函数内。它们应该在控制流离开那个函数的时候被释放，auto_ptr智能指针就是为此设计的一个<strong>类指针对象</strong>，由析构函数对其所指对象调用delete。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">auto_ptr</span>&lt;invest&gt; Ptr(create());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的做法体现了两条回收资源的设计：</p><ul><li><strong>获得资源后，立即放入管理对象内：</strong>资源对象创建的最佳时期就是资源获取的时机。最好的方式是获取资源的同一个语句内使用它初始化某个管理对象</li><li><strong>管理对象运用析构函数确保资源被释放：</strong>不论控制流如何离开区块，一旦对象被销毁，析构函数自动销毁所获得的资源。</li></ul><p>auto_ptr对象离开它的有效范围之后，就将自动销毁分配的资源。但是有一个缺陷，它不允许多个auto_ptr指向同一块区域，这样会造成一个对象被多次的删除。为了防止这个问题，auto_ptr中有一个特性，如果通过拷贝函数复制他们，之前的指针将会变成null，复制后的指针得到资源的唯一拥有权。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>&lt;invest&gt; ptr1(create());</span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;invest&gt; ptr2(ptr1);  <span class="comment">// 此时ptr1变成null</span></span><br></pre></td></tr></table></figure><p>auto_ptr的替代方案使用<code>tr1::shared_ptr</code>，这个对象类将持续追踪共有多少指针指向某个资源，但是在环形引用时无法打破。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; </span><br><span class="line"> tr1::<span class="built_in">shared_ptr</span>&lt;invest&gt; ptr(create());</span><br><span class="line"> tr1::<span class="built_in">shared_ptr</span>&lt;invest&gt; ptr1(ptr); <span class="comment">// ptr，ptr1指向同一个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子告诉我们，当我们手动释放资源的时候，容易发生错误，罐装式的资源管理类如auto_ptr, shared_ptr可以比较好的准守这条规则。</p><p><strong>总结</strong></p><ul><li>防止资源浪费，使用RAII对象，在他们的构造函数中获得资源，在析构函数中释放资源。</li><li>使用RAII中的tr1::shared_ptr，auto_ptr是两个比较好的选择，shared_ptr具有比较正常的copy。</li></ul><h3 id="14-条款：在资源管理类中小心copying行为"><a href="#14-条款：在资源管理类中小心copying行为" class="headerlink" title="14 条款：在资源管理类中小心copying行为"></a>14 条款：在资源管理类中小心copying行为</h3><p>通常使用auto_ptr,shared_ptr作为资源管理类，但是有些资源并非在heap-based，不实用使用上述的两种资源管理类，因此需要建立自己的资源管理类。</p><p>自己定义的资源管理类通常在构造函数的部分申请得到资源，在析构函数中释放资源，这种类型的资源包括了互斥锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>：</span><br><span class="line">    explicit Lock(Mutex* pm):mutexPtr(pm)&#123;  // 在初始化资源类的时候，初始化资源</span><br><span class="line">      lock(mutexPtr);</span><br><span class="line">  &#125;</span><br><span class="line">  ~Lock()&#123;unlock(mutexPtr);&#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">   Mutex* mutexPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，对于资源管理类来说，如果对象被复制，我们需要处理对象的复制问题。可以让它继承UnCopyable对象，禁止对象的复制。或者使用shared_ptr的方法，<strong>使用引用计数法</strong>，使用shared_ptr来定义指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;Mutex&gt; mutexPtr;</span><br></pre></td></tr></table></figure><p>这时候就可以不用定义虚析构函数了，当指针被回收的时候，资源就会被回收。</p><p><strong>转移底层的资源拥有权</strong></p><p>使用类似于auto_ptr的做法，copy的时候，保证资源的唯一性。</p><p><strong>总结</strong></p><ul><li>复制RAII对象（资源管理对象）需要一并复制它所管理的资源，资源的copying行为决定了RAII对象的copying行为。</li><li>普遍常见的RAII copying行为通常为：抑制copying，使用引用计数法，转移底层资源的拥有权。</li></ul><h3 id="15-条款：在资源管理类中提供对原始资源的访问"><a href="#15-条款：在资源管理类中提供对原始资源的访问" class="headerlink" title="15 条款：在资源管理类中提供对原始资源的访问"></a>15 条款：在资源管理类中提供对原始资源的访问</h3><p>资源管理类通常是我们设计来保证资源的正常申请和销毁的，但是有些情况是，我们调用一些函数的时候需要直接访问内部的资源（例如一些指针类）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1::<span class="built_in">shared_ptr</span>&lt;Invest&gt; pInt(create()); <span class="comment">// pInt是一个资源类对象</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daysHeld</span><span class="params">(<span class="keyword">const</span> Invest* pi)</span></span>; <span class="comment">// pi是一个invest* 对象</span></span><br></pre></td></tr></table></figure><p>当我们要调用daysHeld()函数的时候，传入的参数如果为pInt的话会发生错误，因为pInt是一个资源类对象，因此我们需要从这个资源类对象中取出其中的指针资源。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daysHeld(pInt.get());</span><br></pre></td></tr></table></figure><p>shared_ptr,auto_ptr继承了原是指针中的<code>-&gt;,*</code>操作，并且可以通过get函数得到资源的直接访问。</p><p>当我们选择自己实现资源管理类的时候，我们也需要实现一个get函数，实现显示的函数变换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Font</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    explicit Font(Fhandle fh):f(fh)&#123;&#125;</span><br><span class="line">    ~Font()&#123;release(fh);&#125;</span><br><span class="line">    <span class="function">FHandle <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> fh;&#125; <span class="comment">// 实现直接获取资源的函数</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    FHandle fh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过实现<code>operator FHandle() const {return fh;}</code>函数可以实现隐式的变换，但是这样容易造成错误的发生，因此建议使用显式的变换（get的方式）。</p><p><strong>总结</strong></p><ul><li>API中往往要求访问原始资源，所以每一个RAII类中应该要实现一个直接获取志愿的方法（get方法）。</li><li>对原始资源的访问可能是显式变换或者隐式的变换，一般而言显式变换比较安全。</li></ul><h3 id="16-条款：成对使用new和delete时要采取相同形式"><a href="#16-条款：成对使用new和delete时要采取相同形式" class="headerlink" title="16 条款：成对使用new和delete时要采取相同形式"></a>16 条款：成对使用new和delete时要采取相同形式</h3><p>new在被使用的时候，可以申请单个内存（<code>new int</code>）或多个内存（<code>new int[10]</code>），delete再回收内存的时候，也有回收单一内存和连续内存的区别，需要注意的是，new和delete行为必须一致（单一内存和多内存的一致。）</p><p><strong>总结</strong></p><ul><li>new中使用[]必须在delete中也使用[]（连续内存），new中不使用[]，delete中也不能使用[]（单一）。</li></ul><p>下面补充一下CPP中new和delete的用法：</p><p><strong>new的使用</strong></p><p>new负责C++中的动态内存分配，动态内存位于heap上。在不使用这段内存的时候，程序需要负责将这段内存回收掉。</p><p>new指令初始化内存，返回内存分配的初始地址：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pointer-variable = <span class="keyword">new</span> data-type;</span><br><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br></pre></td></tr></table></figure><p>可以<strong>使用括号的方式初始化对象</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><strong>使用中括号[]的方式分配一整块内存空间：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>传统的申请内存的方式为<code>int a[10];</code> 这个空间由编译器申请，在使用结束之后也由编译器进行回收。但是自己申请的内存会一直存在，直到自己delete处理掉。</p><p><strong>delete的使用</strong></p><p>使用delete对new申请的数组进行清空：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p; <span class="comment">// 删除单个元素</span></span><br><span class="line"><span class="keyword">delete</span>[] p; <span class="comment">// 删除整段空间</span></span><br></pre></td></tr></table></figure><h3 id="17-条款：以独立语句将newed对象置入智能指针"><a href="#17-条款：以独立语句将newed对象置入智能指针" class="headerlink" title="17 条款：以独立语句将newed对象置入智能指针"></a>17 条款：以独立语句将newed对象置入智能指针</h3><p>可以使用智能指针的方式来管理new申请的内存：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str1::<span class="built_in">shared_ptr</span>&lt;Widget&gt; pw(<span class="keyword">new</span> Widget);</span><br></pre></td></tr></table></figure><p>存在一种情况，当我们使用资源管理类来管理内存的时候，可能会出现内存泄漏。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process(str1::<span class="built_in">shared_ptr</span>&lt;Wdiget&gt;(<span class="keyword">new</span> Widget),priority());</span><br></pre></td></tr></table></figure><p>上面代码可能的执行顺序是(顺序不一定)：</p><ol><li>new widget</li><li>priority</li><li>Shared_ptr构造函数</li></ol><p>如果第二步抛出异常，那么造成内存泄漏，因此：<strong>newed对象应当写一个单独的语句</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1::<span class="built_in">shared_ptr</span>&lt;Widget&gt; pw(<span class="keyword">new</span> Widget);</span><br><span class="line">process(pw,priority());</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li>以单独的语句将newed对象存储在智能指针内，确保资源不会泄露。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019/11/05 effective cpp 第三章&lt;/p&gt;
&lt;p&gt;CPP程序运行中，将会动态申请内存、文件描述器、互斥锁等一些重要的资源，必须及时归还系统。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;13 条款：以对象管理资源&lt;/li&gt;
&lt;li&gt;14 条款：&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="effective cpp" scheme="https://wenhui-zhou.github.io/categories/effective-cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>推荐系统之用户标签数据(二)</title>
    <link href="https://wenhui-zhou.github.io/2019/11/05/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E4%B9%8B%E7%94%A8%E6%88%B7%E6%A0%87%E7%AD%BE%E6%95%B0%E6%8D%AE-%E4%BA%8C/"/>
    <id>https://wenhui-zhou.github.io/2019/11/05/推荐系统之用户标签数据-二/</id>
    <published>2019-11-05T02:16:10.000Z</published>
    <updated>2019-11-06T16:30:16.199Z</updated>
    
    <content type="html"><![CDATA[<p>推荐系统的目的是链接用户的兴趣和物品，通常的连接方式可以通过：</p><ol><li>推荐与用户喜欢的物品相似的物品</li><li>推荐与用户兴趣相似的人所喜欢的物品</li><li>给用户推荐那些他喜欢的特征，例如利用用户标签</li></ol><p><strong>标签是一种无层次化结构的，用来描述信息的关键词，它可以用来描述物体的语义。</strong></p><a id="more"></a><h3 id="标签系统中推荐问题"><a href="#标签系统中推荐问题" class="headerlink" title="标签系统中推荐问题"></a>标签系统中推荐问题</h3><p><strong>用户为什么进行标注</strong></p><p>用户通常会给予社会维度、功能维度、传达信息的维度上对物品进行标注。</p><p><strong>用户如何打标签</strong></p><p>用户打标注的标签同样符合一个长尾分布，一些不流行的标签呈现一个长尾。</p><p><strong>用户打什么样的标签</strong></p><ul><li>表明物品是什么</li><li>物品的种类</li><li>用户的观点</li><li>谁拥有用户</li><li>用户相关的标签</li><li>用户的任务</li><li>类型</li><li>时间，人物，地点，语言，奖项</li></ul><h3 id="基于标签的推荐系统"><a href="#基于标签的推荐系统" class="headerlink" title="基于标签的推荐系统"></a>基于标签的推荐系统</h3><p><strong>数据的设计</strong></p><p>一个用户标签的行为的数据集一般由一个三元组的集合表示：(u,i,b)表示用户u给物品i打上了标签b。将数据随机分成10份，分割的键值是用户和物品，其中9份作为训练集，1份作为测试集。</p><p><strong>实验指标</strong></p><p>准确率、召回率、覆盖率、余弦相似度、新颖性（平均热门度）</p><p><strong>一个简单的算法</strong></p><p>利用用户标签进行个性化的推荐，一个直接的想法：</p><ol><li>统计每个用户最常用的标签</li><li>对每个标签，统计被打过这个标签次数最多的物品</li><li>对每个用户找到他最常用的标签，然后给他推荐具有这些标签的最热门的物品</li></ol><p>因此可以归纳出兴趣公式：<br>$$<br>p(u, i)=\sum_{b} n_{u, b} n_{b, i}<br>$$<br>$n_{u,b}$表示用户u打过标签b的次数，$n_{b,i}$ 表示物品i被打过b标签的次数。</p><p><strong>算法的改进：TF-IDF</strong></p><p>对于热门标签，它在许多物品上都有出现过，因此上述的公式对热门标签对应的热门物品给了过大的权重，系统将会倾向于推荐热门的物品，因此将降低推荐结果的新颖性，因此对<strong>热门标签</strong>进行惩罚：<br>$$<br>p(u, i)=\sum_{b} \frac{n_{u, b}}{\log \left(1+n_{b}^{(u)}\right)} n_{b, i}<br>$$<br>此外对<strong>热门物品</strong>进行惩罚：<br>$$<br>p(u, i)=\sum_{b} \frac{n_{u, b}}{\log \left(1+n_{b}^{(u)}\right)} \frac{n_{b, i}}{\log \left(1+n_{i}^{(u)}\right)}<br>$$<br><strong>数据稀疏性</strong></p><p>对于一些新用户或新物品，用户集合中的标签数量很小，可以我们可以将与已有标签相似的标签加入到用户标签中。</p><p>可以利用基于领域的方法，当两个标签同时出现在许多物品的标签集合中时，我们就可以认为这两个标签具有较大的相似度，可以使用余弦相似性进行计算，计算的方式时两个标签的交集除以他们的各自的平方开根号。<br>$$<br>\operatorname{sim}\left(b, b^{\prime}\right)=\frac{\sum_{i \in N(b) \cap V(b)} n_{b i} n_{b ; i}}{\sqrt{\sum_{i \in N(b)} n_{b, i}^{2} \sum_{i \in N(b)} n_{b^{\prime}, i}^{2}}}<br>$$<br><strong>标签清理</strong></p><p>有许多标签仅仅反应了用户的心情（例如不好笑），不能作为用户的兴趣，我们需要对这类标签进行过滤。去除一些停止词，同义词，等等方式去除不良标签。</p><h3 id="给用户推荐标签"><a href="#给用户推荐标签" class="headerlink" title="给用户推荐标签"></a>给用户推荐标签</h3><p>给用户推荐标签指给出一些选项供用户选择，这样的好处有：</p><ul><li>方便用户输入标签</li><li>提高标签的质量</li></ul><p><strong>如何给用户推荐标签</strong></p><ul><li>给用户推荐系统中推荐最热门的标签</li><li>给用户推荐物品i上最热门的标签</li><li>给用户推荐他常用的标签</li><li><strong>结合上述两种方法的加权结果</strong>（用得最多）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;推荐系统的目的是链接用户的兴趣和物品，通常的连接方式可以通过：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;推荐与用户喜欢的物品相似的物品&lt;/li&gt;
&lt;li&gt;推荐与用户兴趣相似的人所喜欢的物品&lt;/li&gt;
&lt;li&gt;给用户推荐那些他喜欢的特征，例如利用用户标签&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;标签是一种无层次化结构的，用来描述信息的关键词，它可以用来描述物体的语义。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="推荐系统" scheme="https://wenhui-zhou.github.io/categories/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
</feed>

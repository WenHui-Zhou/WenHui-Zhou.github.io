<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WenHuiZhou</title>
  
  <subtitle>perper（打起精神！）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wenhui-zhou.github.io/"/>
  <updated>2020-02-08T15:54:16.769Z</updated>
  <id>https://wenhui-zhou.github.io/</id>
  
  <author>
    <name>WenHuiZhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OpenPose: Realtime Multi-Person 2D Pose Estimation using Part Affinity Fields</title>
    <link href="https://wenhui-zhou.github.io/2020/02/05/OpenPose-Realtime-Multi-Person-2D-Pose-Estimation-using-Part-Affinity-Fields/"/>
    <id>https://wenhui-zhou.github.io/2020/02/05/OpenPose-Realtime-Multi-Person-2D-Pose-Estimation-using-Part-Affinity-Fields/</id>
    <published>2020-02-05T08:27:15.000Z</published>
    <updated>2020-02-08T15:54:16.769Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是2017年发表在CVPR上，作者开源了代码openpose，openpose代码完整，在推动人体识别，起到了巨大的作用。</p><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>人体姿态估计</strong>是理解视频图像的一个核心问题，一种比较简单的方法是two-step的框架，首先检测出图像中的人，然后解决人体姿态估计的问题。这种方法的问题在于，算法执行时间与图片中的人数呈正比，同时若第一步未检出行人，将会出现比较严重的漏检。</p><p>这篇文章提出一种<strong>bottom-up approach</strong>，这种方法检测出人体的部分，然后parsing成人体姿态的结果。这种方法执行时间与人数无关。</p><h3 id="architecture-网络框架"><a href="#architecture-网络框架" class="headerlink" title="architecture 网络框架"></a>architecture 网络框架</h3><p><img src="/images/nlp/image-20200205200758114.png" alt="image-20200205200758114" style="zoom:50%;"></p><ul><li>首先通过baseline10层的VGG-19网络，生成feature map</li><li>将feature map 分为两路，通过多层的CNN生成：<ul><li><strong>a set of Part Confidence Maps</strong> 身体部位的置信度</li><li><strong>a set of Part Affinity Fields (PAFs)</strong> 部位亲和场</li></ul></li><li><strong>Part Confidence Maps</strong>: a set of 2D confidence maps <strong>S</strong> for body part locations. Each joint location has a map.也就是说，每一个节点都对应了一张map，如果有25个节点的时候，就会有25张map。</li><li><strong>Part Affinity Fields (PAFs)</strong>: a set of 2D vector fields <strong>L</strong> which encodes the degree of association between parts.  生成parts之间的单位向量场。</li><li>Finally, the <strong>Confidence Maps</strong> and <strong>Part Affinity Fields</strong> are processed by a greedy algorithm to obtain the poses for each person in the image 联合置信图以及亲合场得出图像中每一个人的pose</li></ul><h3 id="confidence-maps"><a href="#confidence-maps" class="headerlink" title="confidence maps"></a>confidence maps</h3><p>置信图指的是一张2D表示的置信度图，可以定位到图像中关节点的像素上。</p><p>令$J$作为人体的的关节点总数，confidence map如下：<br>$$<br>\text { the set } S=\left(S_{1}, S_{2}, \ldots, S_{J}\right) \text { where } S_{j} \in R^{w \times h}, j \in 1 \ldots J<br>$$<br>总的来说，每一张map都对应一个节点，并且与输入的图片有着相同的size。</p><h3 id="Part-Affinity-Fields（PAFs）"><a href="#Part-Affinity-Fields（PAFs）" class="headerlink" title="Part Affinity Fields（PAFs）"></a>Part Affinity Fields（PAFs）</h3><p>PAF指的是流向量场，流向量场用来编码第一部分成对的关节点对，例如nose，neck，elbow等等：<br>$$<br>\text { the set } L=\left(L_{1}, L_{2}, \ldots, L_{C}\right) \text { where } L_{c} \in R^{w \times h \times 2}, c \in 1 \ldots C<br>$$<br>如果一个点在他的body part上（腿），那么这个点的值是一个2D单位向量，从起点joint指向终点的joint。</p><p><img src="/images/nlp/image-20200206214339000.png" alt="image-20200206214339000" style="zoom:40%;"></p><p>如上所述，整个流程分成两个步骤，第一个阶段生成PAF流向量场，第二个向量生成关节点密度场。</p><h3 id="Multi-Person-Parsing-using-PAFs"><a href="#Multi-Person-Parsing-using-PAFs" class="headerlink" title="Multi-Person Parsing using PAFs"></a>Multi-Person Parsing using PAFs</h3><p>从图像中找出人体姿态的步骤如下：</p><ul><li><strong>Step 1</strong>: Find <strong>all joints</strong> locations using the <strong>confidence maps</strong>.</li><li><strong>Step 2</strong>: Find which joints go together to <strong>form limbs (body parts)</strong> using the <strong>part affinity fields</strong> and joints in step 1.</li><li><strong>Step 3</strong>: <strong>Associate limbs that belong to the same person</strong> and get the final list of human poses.</li></ul><h3 id="如何生成人体limb"><a href="#如何生成人体limb" class="headerlink" title="如何生成人体limb"></a>如何生成人体limb</h3><ul><li>首先将生成的PAFs放大到输入的尺寸，</li><li>对于每一个limb类型，例如对wrist_elbow：<ul><li>从深度图中拿到所有的wrist和elbow的关节点的位置</li><li>对每一个起点peak和终点peak：<ul><li>用终点减去起点，然后归一化之后得到单位方向向量</li><li>每一对起点和终点之间的点，计算他们的PAFs的值</li><li>通过这中间所有点的PAFs值得平均值，计算当前limb connection的score</li><li>添加一个score来惩罚long distance：<code>min(0.5*paf_height/limb_dist - 1,0)</code></li><li>添加当前的limb连接到limb connecton candidate中</li></ul></li><li>对limb connection candidate进行排序</li><li>对于每一个候选连接，如果source和destination未被选中，则添加这个connection到最终的list当中</li></ul></li></ul><h3 id="pytorch-implementaton"><a href="#pytorch-implementaton" class="headerlink" title="pytorch implementaton"></a>pytorch implementaton</h3><p>giithub链接：https:/github.com/tensorboy/pytorch_Realtime_Multi-Person_Pose_Estimation</p><h3 id="preference"><a href="#preference" class="headerlink" title="preference"></a>preference</h3><ul><li>https:/towardsdatascience.com/cvpr-2017-openpose-realtime-multi-person-2d-pose-estimation-using-part-affinity-fields-f2ce18d720e8</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是2017年发表在CVPR上，作者开源了代码openpose，openpose代码完整，在推动人体识别，起到了巨大的作用。&lt;/p&gt;
    
    </summary>
    
      <category term="论文阅读" scheme="https://wenhui-zhou.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>朴素贝叶斯法(4)</title>
    <link href="https://wenhui-zhou.github.io/2020/01/30/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95-4/"/>
    <id>https://wenhui-zhou.github.io/2020/01/30/朴素贝叶斯法-4/</id>
    <published>2020-01-30T05:24:41.000Z</published>
    <updated>2020-02-02T07:34:23.207Z</updated>
    
    <content type="html"><![CDATA[<p>《统计学习方法》第4章 朴素贝叶斯法</p><p>朴素贝叶斯法是基于贝叶斯定理与特征条件独立假设的分类方法，对于给定的数据集，首先基于特征条件独立假设学习输入、输出的联合概率分布。对于给定的输入x，利用贝叶斯定理求出后验概率最大的输出y。<br>$$<br>P\left(\omega_{i} | \mathbf{x}\right)=\frac{p\left(\mathbf{x} | \omega_{i}\right) P\left(\omega_{i}\right)}{p(\mathbf{x})}=\frac{p\left(\mathbf{x} | \omega_{i}\right) P\left(\omega_{i}\right)}{\sum_{i=1}^{c} p\left(\mathbf{x} | \omega_{j}\right) P\left(\omega_{j}\right)}<br>$$<br>将后验问题转化为先验的形式。</p><a id="more"></a><h3 id="贝叶斯用于模式分类"><a href="#贝叶斯用于模式分类" class="headerlink" title="贝叶斯用于模式分类"></a>贝叶斯用于模式分类</h3><p><img src="/images/nlp/image-20200130155020167.png" alt="image-20200130155020167" style="zoom:50%;"></p><p><strong>通过上述分类器设计的方法，拼凑出贝叶斯公式的右半部分，贝叶斯决策的关键在于得到一个准确的类先验概率</strong>。</p><h3 id="类先验的概率密度估计"><a href="#类先验的概率密度估计" class="headerlink" title="类先验的概率密度估计"></a>类先验的概率密度估计</h3><p>概率密度估计也是一个非常重要的研究方向，通常有三种方法：</p><ul><li>参数法：假定类先验的概率密度已知，如高斯分布</li><li>非参数法：parzen窗，k-nn等</li><li>半参数法：混合高斯分布（GM），期望最大化（EM）</li></ul><p><strong>高斯分布的一些知识点</strong></p><p>一维高斯分布：<br>$$<br>p(x)=\frac{1}{\sqrt{2 \pi} \sigma} \exp \left[-\frac{1}{2}\left(\frac{x-\mu}{\sigma}\right)^{2}\right]<br>$$<br>混合高斯分布如下：</p><p><img src="/images/nlp/image-20200130161716499.png" alt="image-20200130161716499" style="zoom:50%;"></p><p><img src="/images/nlp/image-20200130162547374.png" alt="image-20200130162547374" style="zoom:50%;"></p><p>当数据分布符合高斯分布的时候，可以认为概率密度函数符合高斯分布：</p><p><img src="/images/nlp/image-20200130163925001.png" alt="image-20200130163925001" style="zoom:50%;"></p><p>从而得到类的后验概率的估计。</p><h3 id="离散变量贝叶斯决策"><a href="#离散变量贝叶斯决策" class="headerlink" title="离散变量贝叶斯决策"></a>离散变量贝叶斯决策</h3><p>此类问题例如问卷调查，医疗诊断等问题。</p><p><strong>独立二值特征</strong></p><p><img src="/images/nlp/image-20200131200632117.png" alt="image-20200131200632117" style="zoom:50%;"></p><p>二值特征的特点是两个特征之间相互独立，因此概率值为相乘：<br>$$<br>p^{x_i}_i(1-q_i)^{1-x_i}<br>$$<br><strong>复合模式分类</strong></p><p><img src="/images/nlp/image-20200131203920471.png" alt="image-20200131203920471" style="zoom:50%;"></p><h3 id="最大似然和贝叶斯参数估计"><a href="#最大似然和贝叶斯参数估计" class="headerlink" title="最大似然和贝叶斯参数估计"></a>最大似然和贝叶斯参数估计</h3><p><strong>参数估计</strong></p><p>给定分类器结构和函数形式，从而训练样本估计参数。使用最大似然（maximum likehood），贝叶斯估计（bayesian estimation）来估计模型的参数。</p><p><strong>最大似然估计</strong></p><p>最大似然估计的前提是默认知道了模型的形式。</p><p><img src="/images/nlp/image-20200131205146516.png" alt="image-20200131205146516" style="zoom:50%;"></p><p>最大似然估计的原理如上，样本间分布相互独立，概率密度的格式为：$p(x|w_i,\theta_i)$，通过估计参数$\theta$得出最后的结果，原理如下：</p><p><img src="/images/nlp/image-20200131212844576.png" alt="image-20200131212844576" style="zoom:50%;"></p><p>最大似然公式，通过最大求导令导数为零的方式来计算模型参数如下。</p><p><img src="/images/nlp/image-20200131215730451.png" alt="image-20200131215730451" style="zoom:50%;"></p><p>举个例子，概率密度函数形式为高斯混合函数：</p><p><img src="/images/nlp/image-20200131220410254.png" alt="image-20200131220410254" style="zoom:50%;"></p><p>通过求导数为0的方式，计算出模型的关键参数为 $\mu$ 以及 $\sum$ ，计算过程如下：</p><p><img src="/images/nlp/image-20200131222132022.png" alt="image-20200131222132022" style="zoom:50%;"></p><p><img src="/images/nlp/image-20200131222144463.png" alt="image-20200131222144463" style="zoom:50%;"></p><p><img src="/images/nlp/image-20200201151054278.png" alt="image-20200201151054278" style="zoom:60%;"></p><p><strong>贝叶斯参数估计</strong></p><p><img src="/images/nlp/image-20200131234433018.png" alt="image-20200131234433018" style="zoom:50%;"></p><p>主要原理是假设已经知道先验，用贝叶斯公式去估计模型的参数的后验分布，通常对于一些服从高斯分布的数据适用。</p><p><img src="/images/nlp/image-20200131234727931.png" alt="image-20200131234727931" style="zoom:50%;"></p><p>贝叶斯估计的步骤以及需要的条件。</p><p><img src="/images/nlp/image-20200201151321933.png" alt="image-20200201151321933" style="zoom:60%;"></p><p><strong>最大似然估计和贝叶斯估计的区别</strong></p><blockquote><p>最大似然估计和贝叶斯估计最大区别便在于估计的参数不同，最大似然估计要估计的参数θ被当作是固定形式的一个未知变量，然后我们结合真实数据通过最大化似然函数来求解这个固定形式的未知变量！</p></blockquote><blockquote><p>贝叶斯估计则是将参数视为是有某种已知先验分布的随机变量，意思便是这个参数他不是一个固定的未知数，而是符合一定先验分布如：随机变量θ符合正态分布等！那么在贝叶斯估计中除了类条件概率密度p(x|w)符合一定的先验分布，参数θ也符合一定的先验分布。我们通过贝叶斯规则将参数的先验分布转化成后验分布进行求解！</p></blockquote><h3 id="期望最大法EM"><a href="#期望最大法EM" class="headerlink" title="期望最大法EM"></a>期望最大法EM</h3><p><img src="/images/nlp/image-20200201153104416.png" alt="image-20200201153104416" style="zoom:50%;"></p><p>数据存在好数据以及bad数据，通过以及的参数，以及好的数据，共同来对缺失数据求期望。</p><p><img src="/images/nlp/image-20200201153235737.png" alt="image-20200201153235737" style="zoom:50%;"></p><p>步骤如上，首先计算预测函数的期望E。M步计算期望函数的最大化结果，直到模型性能提升程度小于阈值。</p><p>EM算法在高斯模型上的使用步骤：</p><p><img src="/images/nlp/image-20200201154032629.png" alt="image-20200201154032629" style="zoom:50%;"></p><p><img src="/images/nlp/image-20200201154122745.png" alt="image-20200201154122745" style="zoom:50%;"></p><h3 id="隐形马尔科夫模型"><a href="#隐形马尔科夫模型" class="headerlink" title="隐形马尔科夫模型"></a>隐形马尔科夫模型</h3><p>硬性马尔科夫模型是统计模型，用来描述一个含有未知参数的马尔科夫过程，其难点是从观测到的结果或参数中获得该过程的隐含参数，下面举个例子来说明：</p><p><img src="/images/nlp/image-20200201163743843.png" alt="image-20200201163743843" style="zoom:50%;"></p><p>我们有以上三种骰子，假设我们开始掷骰子，随机挑选骰子后记录得到的数字，最后得到的结果为一串3数字序列：1 6 3 5 2 7 3 5 2 4</p><p>这串数字叫做<strong>可见状态链</strong>，此外还有一个<strong>隐含的状态链</strong>，即选择骰子的序号：D6 D8 D8 D6 D4 D8 D6 D6 D4 D8。</p><p>马尔科夫链其实指的是这个隐含状态链，每个状态之间存在一个<strong>转换概率</strong>，例如D6后面下一个状态的概率都是1/3，其实我们也可以人为的设置骰子之间的转换概率。此外还有一个<strong>输出概率</strong>的概念，即在隐含状态和可见状态之间的输出概率。即D6骰子输出一个数字的概率是1/6，这个输出概率我们也是可以设置的。</p><p><img src="/images/nlp/image-20200201164743562.png" alt="image-20200201164743562" style="zoom:50%;"></p><p>通常我们在应用hhm的时候，这些状态信息是存在缺失的，因此hhm模型相关的算法主要分为三类：</p><ul><li><strong>知道骰子有几种（隐含状态数量），每种骰子是什么（转换概率），根据掷骰子掷出的结果（可见状态链），我想知道每次掷出来的都是哪种骰子（隐含状态链）</strong><ul><li>这个问题在语音识别领域称为解码问题，一种解法是求最大似然状态路径，即求一串骰子序列，该序列输出该观测结果的概率最大</li><li>第二种解法是求每次掷骰子是哪种骰子的概率。</li></ul></li><li><strong>知道骰子有几种（隐含状态数量），每种骰子是什么 （转换概率），根据掷骰子掷出的结果（可见状态链），我想知道掷出这个结果的概率。</strong> <ul><li>即根据模型去求解当前输出结果的概率大小，判断模型是否和数据相互匹配</li></ul></li><li><strong>知道骰子有几种（隐含状态数量），不知道每种骰子是什么（转换概率），观测到很多次掷骰子的结果 （可见状态链 ），我想反推出每种骰子是什么（转换概率）</strong><ul><li>这是个很常见的问题，根据可观测到的大量的可见状态链，去反推hhm模型中的参数，极可能是骰子的转换概率等</li></ul></li></ul><p><strong>破解骰子序列问题</strong></p><p><strong>求解最大似然路径问题：</strong>已知到骰子的结果序列，但是不知道用了哪种骰子，最简单的方法就是穷举从中选择最大概率序列。另一种选择方法为：<strong>viterbi algorithm</strong></p><p><strong>viterbi algorithm</strong></p><p>每次计算产生结果的骰子的序号时，选择最大概率的骰子作为当前位置上的骰子。我们发现，我们要求最大概率骰子序列时要做这么几件事情。首先，不管序列多长，要从序列长度为1算起，算序列长度为1时取到每个骰子的最大概率。然后，逐渐增加长度，每增加一次长度，重新算一遍在这个长度下最后一个位置取到每个骰子的最大概率。因为上一个长度下的取到每个骰子的最大概率都算过了，重新计算的话其实不难。当我们算到最后一位时，就知道最后一位是哪个骰子的概率最大了。然后，我们要把对应这个最大概率的序列从后往前推出来。<strong>只有算到最后，计算出最大的序列概率之后，才能确定序列上骰子是哪个。</strong></p><p><strong>谁动了骰子的问题</strong></p><p>当出现一段序列，你怀疑骰子被别人动过手脚，因此我们需要计算一下有问题骰子出现这段序列的概率是多少，正常的骰子出现这段序列的概率是多少。计算这段序列的概率就是所有结果的加和。计算这个问题的方法叫做<strong>forward algorithm</strong></p><p><strong>forward algorithm</strong></p><p>前向算法的计算方法为计算可能产生这个序列的所有的骰子的概率之和。例如这个三个骰子的情况，所有的概率之和计算如下：</p><p><img src="/images/nlp/image-20200202144838271.png" alt="image-20200202144838271" style="zoom:50%;"></p><p><strong>hhm总结</strong></p><p>以上两种方法，viterbi 以及forward算法一种计算序列上的最短路径，一种是计算产生所有的结果可能的骰子序列概率的加和算法。</p><h3 id="非参数方法"><a href="#非参数方法" class="headerlink" title="非参数方法"></a>非参数方法</h3><p><img src="/images/nlp/image-20200202150246277.png" alt="image-20200202150246277" style="zoom:50%;"></p><p>常用的密度估计算法如下：</p><p><img src="/images/nlp/image-20200202150336756.png" alt="image-20200202150336756" style="zoom:50%;"></p><p><strong>parzen window</strong></p><p><img src="/images/nlp/image-20200202151729629.png" alt="image-20200202151729629" style="zoom:50%;"></p><p>如上式，利用parzen window计算样本的概率密度分布，其中$h_n$为超参数。</p><p><img src="/images/nlp/image-20200202152404784.png" alt="image-20200202152404784" style="zoom:50%;"></p><p><strong>k近邻估计</strong></p><p><img src="/images/nlp/image-20200202152640531.png" alt="image-20200202152640531" style="zoom:50%;"></p><p>当收敛条件满足时，趋近于贝叶斯错误率。当k的个数为1时：</p><p><img src="/images/nlp//image-20200202152902374.png" alt="image-20200202152902374" style="zoom:50%;"></p><p><img src="/images/nlp/image-20200202153225602.png" alt="image-20200202153225602" style="zoom:50%;"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《统计学习方法》第4章 朴素贝叶斯法&lt;/p&gt;
&lt;p&gt;朴素贝叶斯法是基于贝叶斯定理与特征条件独立假设的分类方法，对于给定的数据集，首先基于特征条件独立假设学习输入、输出的联合概率分布。对于给定的输入x，利用贝叶斯定理求出后验概率最大的输出y。&lt;br&gt;$$&lt;br&gt;P\left(\omega_{i} | \mathbf{x}\right)=\frac{p\left(\mathbf{x} | \omega_{i}\right) P\left(\omega_{i}\right)}{p(\mathbf{x})}=\frac{p\left(\mathbf{x} | \omega_{i}\right) P\left(\omega_{i}\right)}{\sum_{i=1}^{c} p\left(\mathbf{x} | \omega_{j}\right) P\left(\omega_{j}\right)}&lt;br&gt;$$&lt;br&gt;将后验问题转化为先验的形式。&lt;/p&gt;
    
    </summary>
    
      <category term="统计学习方法" scheme="https://wenhui-zhou.github.io/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>k近邻法(3)</title>
    <link href="https://wenhui-zhou.github.io/2020/01/29/k%E8%BF%91%E9%82%BB%E6%B3%95-3/"/>
    <id>https://wenhui-zhou.github.io/2020/01/29/k近邻法-3/</id>
    <published>2020-01-29T05:08:45.000Z</published>
    <updated>2020-01-29T16:29:18.333Z</updated>
    
    <content type="html"><![CDATA[<p>《统计学习方法》第三章 k近邻法</p><a id="more"></a><h3 id="k近邻模型"><a href="#k近邻模型" class="headerlink" title="k近邻模型"></a>k近邻模型</h3><p>k近邻算法是一类基本的分类回归方法，假定给定一个训练数据集，其中实例类别已定，对新的实例，根据其k个最近邻的训练实例的类别通过多数表决等方式进行预测。其中k值得选择，距离度量以及分类决策规则是k近邻法的三个基本要素：</p><ul><li><p>优点</p><ul><li>精度高</li><li>对异常值不敏感</li><li>无数据输入假定</li></ul></li><li><p>缺点</p><ul><li>计算复杂度高</li><li>空间复杂度高</li></ul></li><li><p>适用数据范围</p><ul><li>数值型和标称型</li></ul></li></ul><p><strong>工作原理</strong></p><p>存在一个数据集，且数据集中样本与标签存在一一对应的关系，输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似数据（最近邻）的分类标签作为新数据的分类类别。</p><p><strong>距离量度</strong></p><p>我们在确定两个向量是否属于同一类别的时候，我们需要利用一个距离量度来决定该实例的类别，距离定义方式有以下几种：</p><p>$L_p$距离：<br>$$<br>L_{p}\left(x_{i}, x_{j}\right)=\left(\sum_{l=1}^{n}\left|x_{i}^{(l)}-x_{j}^{(l)}\right|^{p}\right)^{\frac{1}{p}}<br>$$<br>欧氏距离，L1以及L无穷距离：<br>$$<br>\begin{aligned} L_{2}\left(x_{i}, x_{j}\right) &amp;=\left(\sum_{l=1}^{n}\left|x_{i}^{(l)}-x_{j}^{(l)}\right|^{2}\right)^{\frac{1}{2}} \ L_{1}\left(x_{i}, x_{j}\right) &amp;=\sum_{l=1}^{n}\left|x_{i}^{(l)}-x_{j}^{(l)}\right| \ L_{\infty}\left(x_{i}, x_{j}\right) &amp;=\max _{l}\left|x_{i}^{(l)}-x_{j}^{(l)}\right| \end{aligned}<br>$$<br><strong>k值选择</strong></p><ul><li><p>如果选择较小的K值</p><ul><li>学 习”的近似误差（approximation error)会减小，但 “学习”的估计误差（estimation error) 会增大</li><li>噪声敏感</li><li>K值的减小就意味着整体模型变得复杂，容易发生过 拟合</li></ul></li><li><p>如果选择较大的K值</p><ul><li>减少学习的估计误差，但缺点是学习的近似误差会增大.</li><li>K值的增大 就意味着整体的模型变得简单.</li></ul></li></ul><h3 id="KD-tree"><a href="#KD-tree" class="headerlink" title="KD tree"></a>KD tree</h3><p>实现k近邻法时，主要考虑的问题是如何对训练数据进行快速k近邻搜索，为了提高这种搜索的效率，可以考虑使用特殊的结构存储训练数据，以减少计算距离的次数，一个常用的存储结构就是kd tree。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《统计学习方法》第三章 k近邻法&lt;/p&gt;
    
    </summary>
    
      <category term="统计学习方法" scheme="https://wenhui-zhou.github.io/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>感知机(2)</title>
    <link href="https://wenhui-zhou.github.io/2020/01/29/%E6%84%9F%E7%9F%A5%E6%9C%BA-2/"/>
    <id>https://wenhui-zhou.github.io/2020/01/29/感知机-2/</id>
    <published>2020-01-28T16:09:19.000Z</published>
    <updated>2020-01-28T17:17:52.217Z</updated>
    
    <content type="html"><![CDATA[<p>《统计学习方法》第二章《感知机》</p><a id="more"></a><h3 id="感知机模型"><a href="#感知机模型" class="headerlink" title="感知机模型"></a>感知机模型</h3><p>感知机是一个二分类线性分类模型，输入为实例特征向量，输出为1或-1。感知器对应输出空间中将实例划分为正负两类。</p><ul><li>输入为实例的特征向量，输出为实例的类别，取+1和-1；</li><li>感知机对应于输入空间中将实例划分为正负两类的分离超平面，属于判别模型；</li><li>导入基于误分类的损失函数；</li><li>利用梯度下降法对损失函数进行极小化；</li><li>感知机学习算法具有简单而易于实现的优点，分为原始形式和对偶形式；</li></ul><p>感知机函数如下：<br>$$<br>f(x)=\operatorname{sign}(w \cdot x+b)<br>$$<br>其中w为模型参数，b为偏置。</p><p><img src="../images/nlp/image-20200129004532357.png" alt="image-20200129004532357" style="zoom:50%;"></p><h3 id="感知机学习策略"><a href="#感知机学习策略" class="headerlink" title="感知机学习策略"></a>感知机学习策略</h3><p>通过定义一个损失函数，来达到感知机的学习的目的。我们选择误分点到分界点的距离作为损失函数，误分点到超平面的距离为：<br>$$<br>\frac{1}{|w|}\left|w \cdot x_{0}+b\right|<br>$$<br>误分点的性质为：<br>$$<br>-y_{i}\left(w \cdot x_{i}+b\right)&gt;0<br>$$<br>因此损失函数为所有误分点的距离集合：<br>$$<br>-\frac{1}{|w|} \sum_{x_{i} \in \mathcal{M}} y_{i}\left(w \cdot x_{i}+b\right)<br>$$<br>其中前面的系数可以忽略。</p><h3 id="感知机的学习算法"><a href="#感知机的学习算法" class="headerlink" title="感知机的学习算法"></a>感知机的学习算法</h3><p>通过随机梯度下降法，分别对w和b进行求导，得到下一步参数的更新：<br>$$<br>\nabla_{w} L(w, b)=-\sum_{x_{i} \in M} y_{i} x_{i} \quad \nabla_{b} L(w, b)=-\sum_{x_{i}, m} y_{i}<br>$$</p><p>$$<br>w \leftarrow w+\eta y_{i} x_{i} \quad b \leftarrow b+\eta y_{i}<br>$$</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>还有一些算法优化的可行性验证这里就忽略了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《统计学习方法》第二章《感知机》&lt;/p&gt;
    
    </summary>
    
      <category term="统计学习方法" scheme="https://wenhui-zhou.github.io/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>统计学习方法概述</title>
    <link href="https://wenhui-zhou.github.io/2020/01/26/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0/"/>
    <id>https://wenhui-zhou.github.io/2020/01/26/统计学习方法概述/</id>
    <published>2020-01-26T05:42:16.000Z</published>
    <updated>2020-01-26T12:01:21.778Z</updated>
    
    <content type="html"><![CDATA[<p>第一章 《统计学习方法概论》</p><p>这一部分介绍了统计学习的一些基本概念，基本问题，基本方法等，作为统计学习的一个引入。</p><p>写《统计学习方法》这个系列博客的目的在于在找工作前，对机器学习方法重新温顾一下，在肺炎国难当前，争分夺秒，把这本书看完！</p><p>这本书在网上有着广泛的讨论，笔记，代码一应俱全，因此这个系列将会参考这些资料：</p><ul><li><a href="https://github.com/SmirkCao/Lihang" target="_blank" rel="noopener">https://github.com/SmirkCao/Lihang</a> （笔记）</li><li><a href="https://www.jiqizhixin.com/articles/2019-11-11-15" target="_blank" rel="noopener">https://www.jiqizhixin.com/articles/2019-11-11-15</a> （课件）</li><li><a href="https://github.com/fengdu78/lihang-code" target="_blank" rel="noopener">https://github.com/fengdu78/lihang-code</a> （代码）</li></ul><a id="more"></a><h3 id="部分符号"><a href="#部分符号" class="headerlink" title="部分符号"></a>部分符号</h3><p>$H$: 希尔伯特空间</p><ul><li>希尔伯特空间 = 无限维+度量+线性+范数+内积 = 无限维 + 欧几里得空间</li></ul><h3 id="统计学习"><a href="#统计学习" class="headerlink" title="统计学习"></a>统计学习</h3><p><strong>特点</strong></p><p>基于数据构建概率统计模型，并运用该模型进行预测与分析的一门学科。是基于数据驱动的。</p><p><strong>对象</strong></p><p>对象是数据，提取数据特征，抽象出数据模型；</p><p>统计学习的一条基本假设是：同类数据具有一定的统计规律性</p><p><strong>目的</strong></p><p>通过构建模型对已知数据的概率建模，使得模型对未知数据进行准确的预测与分析。</p><p><strong>方法</strong></p><p>统计学习方法包含三要素：模型，策略，算法</p><h3 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h3><p><strong>基本概念</strong></p><p><strong>输入空间、特征空间、输出空间</strong></p><p>输入空间指输入的数据的集合；特征空间指所有特征向量所存在的空间；输出空间指输出的集合所在的空间。</p><p><strong>联合概率分布</strong></p><p>监督学习假设输入与输出遵循联合概率分布$P(X,Y)$函数。</p><p><strong>假设空间</strong></p><p>监督学习的目的在于学习一个由输入到输出的一个映射。映射就是有模型来表示的。假设空间就是所有的映射的集合，我们的目的就是找到最好的一个映射。</p><p><strong>问题的形式化</strong></p><p>通过成对的数据样本，学习一个函数映射，即条件概率分布（决策函数）$P(Y|X)$，该函数描述了输入与输出随机变量之间的映射关系。</p><h3 id="统计学习三要素"><a href="#统计学习三要素" class="headerlink" title="统计学习三要素"></a>统计学习三要素</h3><p>方法 = 模型 + 策略 + 算法</p><p><strong>模型</strong></p><p>在监督学习中，<strong>模型就是所要学习的条件概率分布或决策函数</strong>，模型的假设空间包含所有可能的条件概率函数。</p><p><strong>策略</strong></p><p>引入损失函数来度量模型的性能好坏，预测效果越好的模型损失函数的值越小。</p><p>损失函数的期望：<br>$$<br>R_{\mathrm{exp}}(f)=E_{P}[L(Y, f(X))]=\int_{x \times y} L(y, f(x)) P(x, y) \mathrm{d} x \mathrm{d} y<br>$$<br>上式是模型$f(x)$关于联合分布$P(X,Y)$的平均意义下的损失，称为风险函数或期望损失。</p><p><strong>经验风险最小化与结构风险最小化</strong></p><p>经验风险指在训练集上的损失的平均值，经验风险最小化模型：<br>$$<br>\min _{f \in \mathcal{F}} \frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)<br>$$<br>当样本容量很小的时候，模型优化经验风险最小化会导致模型的<strong>过拟合</strong>发生。</p><p><strong>结构风险最小化</strong> structure risk minimization，为防止过拟合提出的策略，等价于正则化（regularization），加入正则化项regularizer，或罚项 penalty term：<br>$$<br>R_{\operatorname{srm}}(f)=\frac{1}{N} \sum_{i=1}^{N} L\left(y_{i}, f\left(x_{i}\right)\right)+\lambda J(f)<br>$$<br><strong>算法</strong></p><p>算法指模型训练过程中的优化策略。如果最优化问题有显式的解析式，那么这个最优化问题就比较简单，但是通常解析解不存在，这就需要用数值计算的方法去求解。统计学习方法可以利用已有的最优化算法进行模型的优化。</p><h3 id="模型评估与模型选择"><a href="#模型评估与模型选择" class="headerlink" title="模型评估与模型选择"></a>模型评估与模型选择</h3><p>当我们一味追求训练数据上的拟合能力的时候，往往将导致模型发生过拟合。<img src="/images/nlp/image-20200126191036412.png" alt="image-20200126191036412" style="zoom:50%;"></p><p>因此在选择模型的时候，需要在模型的复杂度与预测的误差上做出最优的选择。</p><h3 id="正则化与交叉验证"><a href="#正则化与交叉验证" class="headerlink" title="正则化与交叉验证"></a>正则化与交叉验证</h3><p>模型选择的典型方法是正则化，正则化是结构化方向最小化策略的实现，模型越复杂正则化值就会越大：<br>$$<br>L(w)=\frac{1}{N} \sum_{i=1}^{N}\left(f\left(x_{i} ; w\right)-y_{i}\right)^{2}+\frac{\lambda}{2}|w|^{2}<br>$$<br><strong>交叉验证</strong></p><p>交叉验证的思想是将数据进行切分，分成训练集，测试集以及验证集等，例如留一验证法等。</p><h3 id="泛化能力"><a href="#泛化能力" class="headerlink" title="泛化能力"></a>泛化能力</h3><p>泛化能力指模型对未知数据的预测结果，可以通过比较两个函数的泛化误差的上界来比较两种方法的好坏。</p><h3 id="生成模型与判别模型"><a href="#生成模型与判别模型" class="headerlink" title="生成模型与判别模型"></a>生成模型与判别模型</h3><p>生成模型表示了给定输入X产生Y的生成关系，判别模型给定X，输出X的类别。</p><h3 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h3><p>分类问题即对输入进行分类，分类的评价指标是准确率和召回率。</p><ul><li>TP  true positive</li><li>FN  false negative</li><li>FP  false positive</li><li>TN  true negative</li></ul><p>$$<br>P = \frac{TP}{TP+FP}<br>$$</p><p>$$<br>R = \frac{TP}{TP + FN}<br>$$</p><p>F1 值：<br>$$<br>F_1 = \frac{2TP}{2TP + FP + FN}<br>$$</p><h3 id="标注问题"><a href="#标注问题" class="headerlink" title="标注问题"></a>标注问题</h3><p>输入：观测序列</p><p>输出：标记序列或状态序列</p><p>如对一个长句子的标注。</p><h3 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h3><p>回归问题数据是连续的，同时常常使用著名的最小二乘法来求解。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本章概要的介绍了一下统计学习的各个方法，如果深入到深入学习来说，可以看出来有很多东西没有涉及到，但是对于机器学习基础来说，足够了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一章 《统计学习方法概论》&lt;/p&gt;
&lt;p&gt;这一部分介绍了统计学习的一些基本概念，基本问题，基本方法等，作为统计学习的一个引入。&lt;/p&gt;
&lt;p&gt;写《统计学习方法》这个系列博客的目的在于在找工作前，对机器学习方法重新温顾一下，在肺炎国难当前，争分夺秒，把这本书看完！&lt;/p&gt;
&lt;p&gt;这本书在网上有着广泛的讨论，笔记，代码一应俱全，因此这个系列将会参考这些资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/SmirkCao/Lihang&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SmirkCao/Lihang&lt;/a&gt; （笔记）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jiqizhixin.com/articles/2019-11-11-15&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jiqizhixin.com/articles/2019-11-11-15&lt;/a&gt; （课件）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/fengdu78/lihang-code&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/fengdu78/lihang-code&lt;/a&gt; （代码）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="统计学习方法" scheme="https://wenhui-zhou.github.io/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WenHuiZhou</title>
  
  <subtitle>perper（打起精神！）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wenhui-zhou.github.io/"/>
  <updated>2019-09-06T09:03:04.821Z</updated>
  <id>https://wenhui-zhou.github.io/</id>
  
  <author>
    <name>WenHuiZhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux 环境安装</title>
    <link href="https://wenhui-zhou.github.io/2019/09/06/linux-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
    <id>https://wenhui-zhou.github.io/2019/09/06/linux-环境安装/</id>
    <published>2019-09-06T07:05:25.000Z</published>
    <updated>2019-09-06T09:03:04.821Z</updated>
    
    <content type="html"><![CDATA[<p>linux 环境下的python3.6安装，以及Linux系统的一些设置。</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>今天进行了linux环境的配置，感觉十分的尽兴，安装过程十分的舒适，一些配置环节比较知道来龙去脉，配置起来很过隐。感触是对linux环境比较熟悉，对这一块的帮助是很大的，其次是也知道了其他人做法其中的道理。</p><h3 id="python3-6的安装"><a href="#python3-6的安装" class="headerlink" title="python3.6的安装"></a>python3.6的安装</h3><p>linux系统默认的python版本有两个，分别是python2.7和python3.5，这次想安装一个比较常用的python3.6。现实条件是我只是一个用户权限的使用者，因此很多sodu操作无法执行。下面基础部分我跳过，重点放在linux环境的配置上。</p><p>去官网下载python3.6.tgz安装包，然后安装的时候因为没有root权限（正常安装python3.6，安装文件会放在/usr/bin,/local/bin这些地方），我在目录下新建了一个python3.6目录用来存放安装文件。安装过程：<a href="https://my.oschina.net/moonrain/blog/739612，其中`./configure`" target="_blank" rel="noopener">https://my.oschina.net/moonrain/blog/739612，其中`./configure`</a> 修改为<code>./configure --prefix=./python36</code>。</p><p>因为默认的python的版本是2.7,这时候需要修改成python3.6，（其实比较明智的做法是用virtualenv创建一个以pyhton3.6版本的环境就可以了。）首先在<code>.bashrc</code>中添加python3.6中bin的路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=&apos;./python/bin:$PATH&apos;</span><br></pre></td></tr></table></figure><p>然后创建别名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias python=./python3.6/bin/python3.6</span><br></pre></td></tr></table></figure><p>最后source ./bashrc修改完成。</p><p>然后还差一点，pip指向的是系统的python2.7，pip3指向的是python3.6，我尝试过修改别名，发现不起效果，最后发现原来系统配置的时候都会source 一下系统的bash，将pip修改为原来的。没办法着时候转向virtualenv。</p><h3 id="virtualenv"><a href="#virtualenv" class="headerlink" title="virtualenv"></a>virtualenv</h3><p>用了好久了virtualenv之后，现在才意识到这个环境包的好用之处，相比annaconda简洁多了，推荐指数max。安装过程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install virtualenv</span><br></pre></td></tr></table></figure><p>virtualenv中默认使用的python是当前python指向的python版本，当然也可以自己设置成自己指定python的版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtualenv -p ./python3.6/bin/python3 zhou_env</span><br></pre></td></tr></table></figure><p>激活virtualenv：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source zhou_env/bin/activate</span><br></pre></td></tr></table></figure><p>下面就可以正常的在python3.6的环境中使用pip了，嗑盐了。</p><p>退出虚拟环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure><p>下面贴一个关于linux文件夹先后顺序的链接：</p><p><a href="https://perper.site/2019/04/24/linux配置环境/" target="_blank" rel="noopener">https://perper.site/2019/04/24/linux%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;linux 环境下的python3.6安装，以及Linux系统的一些设置。&lt;/p&gt;
    
    </summary>
    
      <category term="tool" scheme="https://wenhui-zhou.github.io/categories/tool/"/>
    
    
  </entry>
  
  <entry>
    <title>Image Super-Resolution Using Very Deep Residual Channel Attention Networks(RCAN)</title>
    <link href="https://wenhui-zhou.github.io/2019/09/05/Image-Super-Resolution-Using-Very-Deep-Residual-Channel-Attention-Networks-RCAN/"/>
    <id>https://wenhui-zhou.github.io/2019/09/05/Image-Super-Resolution-Using-Very-Deep-Residual-Channel-Attention-Networks-RCAN/</id>
    <published>2019-09-05T02:16:31.000Z</published>
    <updated>2019-09-10T09:15:22.020Z</updated>
    
    <content type="html"><![CDATA[<p>RCAN这篇文章是2018年发表在ECCV上的一篇poster，作者<a href="http://yulunzhang.com/" target="_blank" rel="noopener">Yunlun Zhang</a>也是该领域的一个大牛。在文中作者对比了各项性能指标，均达到了state of the art的效果。在目前超分辨率领域越做越细的前提下，以提升指标性能为目的的文章越来越不好发表了。下面介绍一下文章的思路、highlight希望能够有点启发。</p><p>arxiv： <a href="https://arxiv.org/pdf/1807.02758.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1807.02758.pdf</a></p><p>github：<a href="https://github.com/yulunzhang/RCAN" target="_blank" rel="noopener">https://github.com/yulunzhang/RCAN</a></p><a id="more"></a><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>在超分辨率领域中，深度的卷积模型十分的重要，但是训练起来十分的困难；低频的输入或特征中有着很丰富的信息，但是这些信息在网络中被同等的对待，阻碍了卷积网络表达特征的能力。</p><p>为了解决上述问题，作者提出一个残差通道注意力网络（RCAN），通过提出<strong>RIR（residual in residual）</strong>模块来构建深度的网络，RIR中包含着许多的RG（residual group），RG中包含着许多的residual block，以及许多长连接跳跃（LSC）。RIR允许低频信息通过多个跳跃直接传播，使得网络集中学习图像中的高频部分。作者提出<strong>CA（channel attention）</strong> 通道注意力机制，通过考虑通道间的相互依赖性，来重新调整通道特征。</p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>作者在这部分内容中列举了很多网络，目的是说明深度的网络在超分辨率问题上是有效果的。作者提出的RIR结构，提升网络的深度。对于低频信息的相互依赖性问题，作者提出了CA方法来调整通道的特征。</p><h3 id="Residual-Channel-Attention-Network（RCAN）"><a href="#Residual-Channel-Attention-Network（RCAN）" class="headerlink" title="Residual Channel Attention Network（RCAN）"></a>Residual Channel Attention Network（RCAN）</h3><p>RCAN的网络结构如下图所示：</p><p><img src="../images/SR/rcan-net.png" alt=""></p><p>RCAN网络结构由四部分组成，第一部分是卷积浅层特征提取模块，第二部分是RIR深层特征提取模块，第三部分是上采样模块，第四部分是重建模块，网络最后的卷积层具有三个通道，表示输出的颜色。 </p><p>RCAN网络损失函数采用L1损失：<br>$$<br>L(\Theta)=\frac{1}{N} \sum_{i=1}^{N}\left|H_{R C A N}\left(I_{L R}^{i}\right)-I_{H R}^{i}\right|_{1}<br>$$</p><h3 id="Residual-in-Residual-RIR"><a href="#Residual-in-Residual-RIR" class="headerlink" title="Residual in Residual (RIR)"></a>Residual in Residual (RIR)</h3><p>RIR结构中包含着若干个（10）residual groups（RG）结构以及long skip connection。每一个RG中包含着如果个（20）residual channel attention block（RCAB）模块，内部含有许多短的连接。</p><p>RIR结构通过堆叠残差块，利用skip connection这种结构来克服网络难以训练的问题。</p><h3 id="channel-attention（CA）"><a href="#channel-attention（CA）" class="headerlink" title="channel attention（CA）"></a>channel attention（CA）</h3><p><img src="../images/SR/ca.png" alt=""></p><p>输入是一个 H×W×C（64） 的特征，我们先进行一个空间的全局平均池化得到一个 1×1×C 的通道描述。接着，再经过一个下采样层和一个上采样层得到每一个通道的权重系数，将权重系数和原来的特征相乘即可得到缩放后的新特征，整个过程实际上就是对不同通道的特征重新进行了加权分配。</p><p>其中，下采样和上采样层都利用 1×1 的卷积来实现，下采样层的通道数减少 r 倍，激活函数为 Relu，上采样层的激活函数为 Sigmoid。在论文中，作者采用的通道数 C=64，r = 16。</p><h3 id="Residual-channel-attention-Block（RCAB）"><a href="#Residual-channel-attention-Block（RCAB）" class="headerlink" title="Residual channel attention Block（RCAB）"></a>Residual channel attention Block（RCAB）</h3><p><img src="../images/SR/rcab.png" alt=""></p><p>输入一个特征 input，我们首先进行一个卷积-Relu-卷积操作得到 f，然后 f 再经过一个 CA 模块进行重新缩放得到 x，最后将 x 和 input 相加得到输出特征。其中，卷积操作都采用 3×3 的卷积核。</p><h3 id="实现的细节"><a href="#实现的细节" class="headerlink" title="实现的细节"></a>实现的细节</h3><p>RIR中RG个数：10；RG中RCAB的个数：20，conv的大小：3 x 3，channel：64</p><p>通道下采样的scale：16，C/16 = 4。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RCAN这篇文章是2018年发表在ECCV上的一篇poster，作者&lt;a href=&quot;http://yulunzhang.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Yunlun Zhang&lt;/a&gt;也是该领域的一个大牛。在文中作者对比了各项性能指标，均达到了state of the art的效果。在目前超分辨率领域越做越细的前提下，以提升指标性能为目的的文章越来越不好发表了。下面介绍一下文章的思路、highlight希望能够有点启发。&lt;/p&gt;
&lt;p&gt;arxiv： &lt;a href=&quot;https://arxiv.org/pdf/1807.02758.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://arxiv.org/pdf/1807.02758.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;github：&lt;a href=&quot;https://github.com/yulunzhang/RCAN&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/yulunzhang/RCAN&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="super resolution" scheme="https://wenhui-zhou.github.io/categories/super-resolution/"/>
    
    
      <category term="SR" scheme="https://wenhui-zhou.github.io/tags/SR/"/>
    
  </entry>
  
  <entry>
    <title>超分辨率论文摘要阅读</title>
    <link href="https://wenhui-zhou.github.io/2019/09/03/%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87%E8%AE%BA%E6%96%87%E6%91%98%E8%A6%81%E9%98%85%E8%AF%BB/"/>
    <id>https://wenhui-zhou.github.io/2019/09/03/超分辨率论文摘要阅读/</id>
    <published>2019-09-03T07:40:23.000Z</published>
    <updated>2019-09-04T04:14:32.421Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博客的主要目的为了记录阅读的超分辨率论文的摘要部分，了解超分辨率领域的研究前沿进度。</p><a id="more"></a><h3 id="值得注意的网页"><a href="#值得注意的网页" class="headerlink" title="值得注意的网页"></a>值得注意的网页</h3><ol><li>github上关于超分辨率领域的SOAT论文的整理：<a href="https://github.com/YapengTian/Single-Image-Super-Resolution" target="_blank" rel="noopener">https://github.com/YapengTian/Single-Image-Super-Resolution</a></li><li>知乎上关于超分辨率一些大牛的主页： <a href="https://www.zhihu.com/search?type=content&amp;q=超分辨率" target="_blank" rel="noopener">https://www.zhihu.com/search?type=content&amp;q=%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87</a></li></ol><h3 id="论文阅读"><a href="#论文阅读" class="headerlink" title="论文阅读"></a>论文阅读</h3><h4 id="Xuaner-Zhang-Qifeng-Chen-Ren-Ng-and-Vladlen-Koltun-Zoom-to-Learn-Learn-to-Zoom-CVPR-2019-Paper"><a href="#Xuaner-Zhang-Qifeng-Chen-Ren-Ng-and-Vladlen-Koltun-Zoom-to-Learn-Learn-to-Zoom-CVPR-2019-Paper" class="headerlink" title="Xuaner Zhang, Qifeng Chen, Ren Ng, and Vladlen Koltun. Zoom to Learn, Learn to Zoom, CVPR 2019. [Paper]"></a>Xuaner Zhang, Qifeng Chen, Ren Ng, and Vladlen Koltun. Zoom to Learn, Learn to Zoom, CVPR 2019. <a href="http://vladlen.info/papers/zoom.pdf" target="_blank" rel="noopener">[Paper]</a></h4><p>作者将超分辨率方法应用在数字变焦中，他认为真实的图片能够比生成的图片更能保留数据的细节，网络的性能也将更好。那些在制作的数据集上训练的模型，通常在实际场景下性能不好，因此本文使用单反去直接制作数据集。高分辨率使用长焦距拍摄，低分辨率使用短焦距拍摄。</p><p>由于使用单反采集的数据高低配置无法完全对齐，因此作者提出了CoBi loss function，完美的解决了这个问题。这就是本文的主要insight。</p><h3 id="Image-Super-Resolution-Using-Very-Deep-Residual-Channel-Attention-Networks"><a href="#Image-Super-Resolution-Using-Very-Deep-Residual-Channel-Attention-Networks" class="headerlink" title="Image Super-Resolution Using Very Deep Residual Channel Attention Networks"></a>Image Super-Resolution Using Very Deep Residual Channel Attention Networks</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博客的主要目的为了记录阅读的超分辨率论文的摘要部分，了解超分辨率领域的研究前沿进度。&lt;/p&gt;
    
    </summary>
    
      <category term="论文阅读" scheme="https://wenhui-zhou.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="超分辨率" scheme="https://wenhui-zhou.github.io/tags/%E8%B6%85%E5%88%86%E8%BE%A8%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>电阻率成像数据分析</title>
    <link href="https://wenhui-zhou.github.io/2019/08/30/%E7%94%B5%E9%98%BB%E7%8E%87%E6%88%90%E5%83%8F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    <id>https://wenhui-zhou.github.io/2019/08/30/电阻率成像数据分析/</id>
    <published>2019-08-30T01:52:41.000Z</published>
    <updated>2019-09-05T02:40:05.688Z</updated>
    
    <content type="html"><![CDATA[<p><strong>电阻率成像(ERI)</strong> 是一种地球物理技术，用于通过在表面或在一个或多个钻孔中的电极进行的电阻率测量来对底层亚表面结构进行成像。</p><a id="more"></a><h3 id="电阻率数据的采集"><a href="#电阻率数据的采集" class="headerlink" title="电阻率数据的采集"></a>电阻率数据的采集</h3><p>方位电阻率成像测井是在双侧向测井基础上发展起来的，在主电极或屏蔽电极中部沿圆周剖分成12个长方形小电极（见图），每个电极的定向方位成30°辐射，12个方位电极电位彼此相等。</p><p><img src="../images/SR/bettery.png" alt=""></p><p>电流的大小反映了该方向内地层电阻率的变化。测量每个方位电极的供电电流和环状监督电极M 3 （M 4 ）相对铠装电缆钢丝外皮的电位，可计算该方向地层的视电阻率。</p><p> 地层中不同的岩石（泥岩、砂岩、石灰岩）、流体其电阻率是不同的，通过测量<strong>井壁</strong> 各点的电阻率值，然后将电阻率值的相对高低用灰度或色度图表示出来。井壁可以表示成一张黑白/彩色图像。</p><p>颜色映射如下：</p><p><img src="../images/SR/color-map.png" width="400" align="middle"> </p><p> 得到的电阻率成像图像如下：</p><p><img src="../images/SR/162.jpg" alt="162"></p><h3 id="电阻率数据的分析"><a href="#电阻率数据的分析" class="headerlink" title="电阻率数据的分析"></a>电阻率数据的分析</h3><p>微电极测井使用的电极紧贴井壁，电阻数据是测井井周一圈的数据，因此同一个水平面上数据的空间位置十分的接近。数据在空间关系上有一定的相关性。</p><p><img src="../images/SR/fmi1.jpg" alt=""></p><p><img src="../images/SR/fmi.png" alt=""></p><p>上图中的绿线是地层的分层线。对电阻率的分析过程是将电阻率数据传入一个专业软件中，将会自动生成一些简单的分层线，然后采用人工标注的方式，对电阻率数据标注进行完善。最终得到完善的电阻率标注图。</p><p>对超分辨率问题来说，有什么内在的约束？</p><p>得到新数据时，需要明白测量的精度（2.5mm），井口的大小这些数据。</p><p>反演的概念：通过一些观察到的局部信息，反推相关过程发生的原因以及机制。根据结果或信息反推事件发生的过程称为反演，而对事件发生过程的预测则称为正演。例如根据地表上探测到的部分数据，来推测地表以下的地质结构。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;电阻率成像(ERI)&lt;/strong&gt; 是一种地球物理技术，用于通过在表面或在一个或多个钻孔中的电极进行的电阻率测量来对底层亚表面结构进行成像。&lt;/p&gt;
    
    </summary>
    
      <category term="super resolution" scheme="https://wenhui-zhou.github.io/categories/super-resolution/"/>
    
    
  </entry>
  
  <entry>
    <title>并查集，python示例</title>
    <link href="https://wenhui-zhou.github.io/2019/08/27/%E5%B9%B6%E6%9F%A5%E9%9B%86%EF%BC%8Cpython%E7%A4%BA%E4%BE%8B/"/>
    <id>https://wenhui-zhou.github.io/2019/08/27/并查集，python示例/</id>
    <published>2019-08-27T12:09:07.000Z</published>
    <updated>2019-08-27T13:43:59.021Z</updated>
    
    <content type="html"><![CDATA[<p>并查集是一种数据结构，在合并不相交的集合，用来判断一个图中是否有环这种问题时，具有很高的性能。</p><a id="more"></a><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>并查集的主要操作就是为一个集合中的元素找到一个代表（根节点）。并查集的基本操作是合并两个集合，当拿到两个节点，第一步需要找到各自节点的根，然后选择一个节点作为新的代表，那么就完成了两个集合的合并。</p><h3 id="并查集实现"><a href="#并查集实现" class="headerlink" title="并查集实现"></a>并查集实现</h3><p>并查集可以使用一个数组来表示，数组表示图上的节点，下标表示节点的编号，数组的值表示该下标的父节点是哪一个。例如A[0] = 1 表示节点0的父节点是节点1.</p><p>并查集的实现过程主要分为两步，一步是实现节点的根的查找，另一步是实现两个集合的合并，这里包含了节点的路径压缩。</p><p>下面实现find_root算法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">joint = <span class="number">10</span></span><br><span class="line">parent = [<span class="number">-1</span>]*<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_root</span><span class="params">(parent,x)</span>:</span></span><br><span class="line">  x_root = x</span><br><span class="line">  <span class="keyword">while</span> parent[x_root] != <span class="number">-1</span>:</span><br><span class="line">    x_root = parent[x_root]</span><br><span class="line">  <span class="keyword">return</span> x_root</span><br></pre></td></tr></table></figure><p>上面代码说明当x不是根节点时，循环继续往上找，当x时根节点时则返回。</p><p>下面是union的算法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union_joint</span><span class="params">(parent,x,y)</span>:</span></span><br><span class="line">  x = find_root(parent,x)</span><br><span class="line">  y = find_root(parent,y)</span><br><span class="line">  <span class="keyword">if</span> x == y:</span><br><span class="line">    print(<span class="string">'circle'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    parent[x] = y</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>上诉代码如果返回的结果是0的话则说明存在一个环，否则不存在环。</p><p>存在一种极端的情况，即每次union合成的集合它形成了一个很长的链，每次寻找一个节点的根需要遍历一下整个节点，复杂度太高，下面在union中引入路径压缩的思想，即引入另一个数组rank，表明当前节点的位置，当进行union的时候，rank小的数连接到rank大的树底下，当两个rank相同的时候，可以随意连接，但是连接之后作为父节点的rank需要加1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rank = [<span class="number">0</span>]*joint</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span><span class="params">(parent,x,y,rank)</span>:</span></span><br><span class="line">  x = find_root(parent,x)</span><br><span class="line">  y = find_root(parent,y)</span><br><span class="line">  <span class="keyword">if</span> x == y:</span><br><span class="line">    print(<span class="string">'circle'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> rank[x] &gt; rank[y]:</span><br><span class="line">      parent[y] = x</span><br><span class="line">    <span class="keyword">elif</span> rank[x] &lt; rank[y]:</span><br><span class="line">      parent[x] = y</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      parent[x] = y</span><br><span class="line">      rank[y] += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在判断一个图是否存在环的时候，依次遍历图的所有边，如果union返回的结果是0的话，表明有环。</p><p>下面是一道lettcode的题目，思路就是用并查集来求解：</p><p><a href="https://leetcode.com/problems/friend-circles/" target="_blank" rel="noopener">547.Friend Circles</a></p><p>思路是将朋友的关系用边来表示，最后看parent数组中有多少根节点（等于-1）。</p><p>解法代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCircleNum</span><span class="params">(self, M)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type M: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        edge = []</span><br><span class="line">        <span class="keyword">if</span> M == [] <span class="keyword">or</span> M[<span class="number">0</span>] == []:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(M)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(M[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> i &lt;= j:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> M[i][j] == <span class="number">1</span>:</span><br><span class="line">                    edge.append([i,j])</span><br><span class="line">                </span><br><span class="line">        parent = [<span class="number">-1</span>]*len(M)</span><br><span class="line">        rank = [<span class="number">0</span>]*len(M)</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find_root</span><span class="params">(parent,x)</span>:</span></span><br><span class="line">            x_root = x</span><br><span class="line">            <span class="keyword">while</span> parent[x_root] != <span class="number">-1</span>:</span><br><span class="line">                x_root = parent[x_root]</span><br><span class="line">            <span class="keyword">return</span> x_root</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">union_joint</span><span class="params">(parent,x,y,rank)</span>:</span></span><br><span class="line">            x = find_root(parent,x)</span><br><span class="line">            y = find_root(parent,y)</span><br><span class="line">            <span class="keyword">if</span> x  != y:</span><br><span class="line">                <span class="keyword">if</span> rank[x] &lt; rank[y]:</span><br><span class="line">                    parent[x] = y</span><br><span class="line">                <span class="keyword">elif</span> rank[x] &gt; rank[y]:</span><br><span class="line">                    parent[y] = x</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    parent[x] = y</span><br><span class="line">                    rank[y] += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> edge:</span><br><span class="line">            union_joint(parent,e[<span class="number">0</span>],e[<span class="number">1</span>],rank)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> parent:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">-1</span>:</span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并查集是一种数据结构，在合并不相交的集合，用来判断一个图中是否有环这种问题时，具有很高的性能。&lt;/p&gt;
    
    </summary>
    
      <category term="算法扫盲" scheme="https://wenhui-zhou.github.io/categories/%E7%AE%97%E6%B3%95%E6%89%AB%E7%9B%B2/"/>
    
    
      <category term="算法" scheme="https://wenhui-zhou.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>

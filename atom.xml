<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WenHuiZhou</title>
  
  <subtitle>perper（打起精神！）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wenhui-zhou.github.io/"/>
  <updated>2019-10-29T18:00:24.995Z</updated>
  <id>https://wenhui-zhou.github.io/</id>
  
  <author>
    <name>WenHuiZhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于职业生涯规划以及时间安排的一些思考</title>
    <link href="https://wenhui-zhou.github.io/2019/10/30/%E5%85%B3%E4%BA%8E%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E8%A7%84%E5%88%92%E4%BB%A5%E5%8F%8A%E6%97%B6%E9%97%B4%E5%AE%89%E6%8E%92%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>https://wenhui-zhou.github.io/2019/10/30/关于职业生涯规划以及时间安排的一些思考/</id>
    <published>2019-10-29T17:19:56.000Z</published>
    <updated>2019-10-29T18:00:24.995Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="welcome to my blog,enter password to read." />    <label for="pass">welcome to my blog,enter password to read.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      welcome to my blog,enter password to read.
    
    </summary>
    
    
      <category term="职业规划" scheme="https://wenhui-zhou.github.io/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>编译器gcc，g++，clang，cmake，make介绍</title>
    <link href="https://wenhui-zhou.github.io/2019/10/27/%E7%BC%96%E8%AF%91%E5%99%A8gcc%EF%BC%8Cg-%EF%BC%8Cclang%EF%BC%8Ccmake%EF%BC%8Cmake%E4%BB%8B%E7%BB%8D/"/>
    <id>https://wenhui-zhou.github.io/2019/10/27/编译器gcc，g-，clang，cmake，make介绍/</id>
    <published>2019-10-27T13:22:52.000Z</published>
    <updated>2019-10-28T11:07:20.931Z</updated>
    
    <content type="html"><![CDATA[<p>这篇post主要介绍在mac上使用CLion编写cpp代码的时候，cpp编译以及链接的一些知识。</p><a id="more"></a><h3 id="cpp程序编译执行过程"><a href="#cpp程序编译执行过程" class="headerlink" title="cpp程序编译执行过程"></a>cpp程序编译执行过程</h3><ul><li><strong>编译</strong>：将源代码翻译成机器语言，生成目标文件<ul><li>预处理：拷贝#include 文件代码，#define 宏定义的替换 ，处理条件编译指令 （#ifndef #ifdef #endif）等，输出.i文件。</li><li>编译优化：进行cpp词法语法分析，确定所有指令是否符合规则，后翻译成汇编代码文件.s。</li><li>汇编：将汇编代码翻译成目标机器代码.o文件。</li></ul></li><li><strong>链接</strong>：由于目标文件调用了其他源文件，因此这一步需要将有关的源文件链接起来，生成.exe。</li></ul><h3 id="cpp使用的编译器gcc，g-，clang"><a href="#cpp使用的编译器gcc，g-，clang" class="headerlink" title="cpp使用的编译器gcc，g++，clang"></a><strong>cpp使用的编译器gcc，g++，clang</strong></h3><ul><li><strong>gcc</strong>: 最开始的时候是 GNU C Compiler, 如你所知，就是一个c编译器。但是后来因为这个项目里边集成了更多其他不同语言的编译器，GCC就代表 the GNU Compiler Collection，所以表示一堆编译器的合集。</li><li><strong>g++</strong>：是GCC的c++编译器。</li><li><strong>clang</strong>：是mac上另起炉灶写的一个C语言、C++、Objective-C、Objective-C++语言的<strong>轻量级编译器</strong>。源代码发布于BSD协议下。Clang将支持其普通lambda表达式、返回类型的简化处理以及更好的处理constexpr关键字。</li></ul><p><strong>clang和gcc相比比gcc编译速度更快一些，而且错误提示更人性化。</strong></p><h3 id="make，cmake"><a href="#make，cmake" class="headerlink" title="make，cmake"></a>make，cmake</h3><p>光有gcc还不够，如果这时候我们开发的工程使用的文件很多，那就需要一个一个去编译，工作量很大。一些大型的IDE如VS studio，CLion使用clang编译器，使用cmake链接工具，对源码进行编译。</p><p><strong>make</strong></p><p>make类似于一个目录，是一个文件编译的批处理工具，本身没有编译的功能。make的作用就是告诉编译器，各种各样的编译规则，先做什么后做什么，这些规则写在makefile文件中。</p><p>make用于构建项目，其中一条很重要的规则就是依赖关系，当某些文件发生改变，直接或间接依赖这些文件的目标就要进行重新的构建。make用来构建管理文件，不一定用于编译。</p><p><strong>cmake</strong></p><p>构建一个项目需要了解构建的规则，并写出makefile文件，但是编译构建本身是个复杂过程，不同的项目构建规则会有所不同，要自己写出一个makefile文件比较困难。</p><p>cmake工具是根据平台（跨平台）和配置自动生成项目的makefile文件，然后给make使用。</p><p>cmake根据CMakeLists.txt文件（组态档）去生成makefile。在不使用CLion等这类IDE的情况下，这个CMakeLists.txt需要自己来写，下面是一个CMakeLists.txt：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.8</span>)</span><br><span class="line"><span class="keyword">project</span>(First_Code)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="comment">#set(CMAKE_CXX_FLAGS "-std=c++0x $&#123;CMAKE_CXX_FLAGS&#125; -g -ftest-coverage -fprofile-arcs")</span></span><br><span class="line"><span class="comment">#set(CMAKE_CXX_FLAGS "$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11")</span></span><br><span class="line"><span class="keyword">set</span>(SOURCE_FILES main.cpp <span class="keyword">test</span>.cpp assignment.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(First_Code <span class="variable">$&#123;SOURCE_FILES&#125;</span>)</span><br></pre></td></tr></table></figure><p>但是不用担心，CMakeLists.txt IDE也会负责生成。</p><h3 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h3><p>  C++11，（即ISO/IEC 14882:2011），是目前的C++编程语言的最新正式标准。它取代了第二版标准(第一版公开于1998年，第二版于2003年更新，分别通称C++98以及C++03，两者差异很小)。新的标准包含核心语言的新机能，而且扩展C++标准程序库。C++11新标准由C++标准委员会于2011年8月12日公布，并于2011年9月出版。此次标准为C++98发布后13年来第一次重大修正。</p><p><strong>gcc4.7以及之后，全面支持c++11。</strong></p><h3 id="MAC更换CLion编译器"><a href="#MAC更换CLion编译器" class="headerlink" title="MAC更换CLion编译器"></a>MAC更换CLion编译器</h3><p>在terminal输入<code>gcc -v</code>发现出来的是APPLE的clang编译器，由于更习惯使用GUN的gcc编译器，因此打算安装一个，同时保留原有的clang。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew search gcc // 查看有哪些gcc</span><br><span class="line">brew install gcc //安装最新版本的gcc，目前电脑上用的是gcc9.2</span><br></pre></td></tr></table></figure><p>上诉过程安装完成之后，gcc的位置在：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/Cellar/gcc/9.2.0_1/bin</span><br></pre></td></tr></table></figure><p>将这个路径加入到CLion所使用的编译器上，同时修改cmake参数(preference 中修改)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-D CMAKE_CXX_COMPILER=/usr/local/bin/g++-9</span><br></pre></td></tr></table></figure><h3 id="CLion-中新建项目的目录结构"><a href="#CLion-中新建项目的目录结构" class="headerlink" title="CLion 中新建项目的目录结构"></a>CLion 中新建项目的目录结构</h3><p>CLion是通过cmake来构建文件的，手动在CLion中生成cpp文件，系统件制动修改cmakeLists.txt</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇post主要介绍在mac上使用CLion编写cpp代码的时候，cpp编译以及链接的一些知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="learning cpp" scheme="https://wenhui-zhou.github.io/tags/learning-cpp/"/>
    
  </entry>
  
  <entry>
    <title>cpp STL方法介绍</title>
    <link href="https://wenhui-zhou.github.io/2019/10/27/cpp-STL%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
    <id>https://wenhui-zhou.github.io/2019/10/27/cpp-STL方法介绍/</id>
    <published>2019-10-27T11:34:48.000Z</published>
    <updated>2019-10-29T16:37:39.708Z</updated>
    
    <content type="html"><![CDATA[<p>这篇post主要目的是对cpp提供的Standard Template Library标准模板库中一些重要的方法进行学习，记录，以便今后学习。</p><a id="more"></a><h3 id="STL概述"><a href="#STL概述" class="headerlink" title="STL概述"></a>STL概述</h3><p>在开始STL之前，像大家介绍一下一个全能的头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>这个头文件include了在STL中所有的头文件，方便我们使用而不用去担心这些方法所在的库。</p><p>STL库中有四类重要的部分：</p><ul><li>Algorithm：该部分提供的算法定义在容器上，用于操作容器上的元素。</li><li>containers：定义了一些常用的容器，如vector，map等等</li><li>functor：算子，是个函数，用于定制化STL函数，如sort，传入functor定制排序方式</li><li>iterator：迭代器，用于遍历整个序列</li></ul><h3 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h3><p><strong>sort(begin_adress,end_adress,compare)</strong></p><p>排序算法是定义在所有容器上的一个排序函数，其内部实现是快排，时间复杂度是$O(nlogn)$.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">9</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>&#125;;</span><br><span class="line">sort(arr,arr+<span class="number">10</span>); <span class="comment">//升序排序</span></span><br><span class="line">sort(arr,arr+<span class="number">10</span>,greater&lt;<span class="keyword">int</span>&gt;()); <span class="comment">// 降序排序</span></span><br><span class="line"><span class="comment">// 特殊数组的排序</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">interval</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> val1;</span><br><span class="line">  <span class="keyword">int</span> val2;</span><br><span class="line">&#125;;</span><br><span class="line">interval arr[] = &#123;&#123;<span class="number">2</span>,<span class="number">2</span>&#125;,&#123;<span class="number">4</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;</span><br><span class="line"><span class="keyword">bool</span> compareInterval(interval v1,interval v2)&#123;</span><br><span class="line">  <span class="keyword">return</span> v1.val1 &lt; v2.val2; <span class="comment">// 如果第一个数小的话，先排序</span></span><br><span class="line">&#125;</span><br><span class="line">sort(arr,arr+<span class="number">10</span>,compareInterval); <span class="comment">// 得到按第一个元素排序的数组</span></span><br></pre></td></tr></table></figure><p><strong>bool binary_search(start_adress,end_adress,value_find)</strong></p><p>二分搜索查找value_find这个元素，该数组已经被排序过了，复杂度为$O(logn)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">if</span>(binary_search(arr,arr+<span class="number">10</span>,<span class="number">2</span>))&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"get it "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>bool all_of(begin_adress,end_adress,lambda_func)</strong></p><p>该函数判断是否arr中的所有元素都满足lambda中的规则</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">STL_allof</span><span class="params">(<span class="keyword">int</span>*a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lens = <span class="keyword">sizeof</span>(a)/ <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">    all_of(a,a+lens,[](<span class="keyword">int</span> x)&#123;<span class="keyword">return</span> x &gt;= <span class="number">0</span>;&#125;) ? <span class="built_in">cout</span>&lt;&lt;<span class="string">"all are positive"</span> : <span class="built_in">cout</span>&lt;&lt;<span class="string">"no all positive"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>bool any_of(begin_adress,end_adress,lambda_func)</strong></p><p>只要有一个满足要求的，就返回true</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">any_of(arr_begin,arr_end,[](<span class="keyword">int</span> x)&#123; <span class="keyword">return</span> x == <span class="number">0</span>;&#125;) <span class="comment">//返回bool</span></span><br></pre></td></tr></table></figure><p><strong>bool none_of(begin_adress,end_adress,lambda_func)</strong></p><p>所有都不满足情况的时候，返回true</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">none_of(arr_begin,arr_end,[](<span class="keyword">int</span> x)&#123; <span class="keyword">return</span> x == <span class="number">0</span>;&#125;) <span class="comment">//返回bool</span></span><br></pre></td></tr></table></figure><p><strong>copy_n(arr1,size,arr2)</strong></p><p>将arr1中的前size个元素拷贝到arr2中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> arr2[<span class="number">10</span>];</span><br><span class="line">copy_n(arr,<span class="number">10</span>,arr2);</span><br></pre></td></tr></table></figure><h3 id="containers"><a href="#containers" class="headerlink" title="containers"></a>containers</h3><p><strong>序列容器</strong></p><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><p>向量是一个动态数组，数组的大小随着元素的个数而变化，内存空间是连续分布的，因此可以使用迭代器。向vector末尾插入元素要花费的时间是不确定的，因为有时候vector可能会扩容，此外插入和删除要花线性的时间。</p><p><strong>iterators</strong></p><p>vector是在内存上连续的一段存储空间，因此允许使用迭代器，vector的迭代器有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">vec.begin(); <span class="comment">// 指向第一个元素</span></span><br><span class="line">vec.end(); <span class="comment">// 指向最后一个元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = vec.begin();i!=vec.end();i++)&#123;...&#125;</span><br><span class="line">vec.rbegin(); <span class="comment">//指向最后一个，反向迭代</span></span><br><span class="line">vec.rend();  <span class="comment">// 指向第一个，作为后向的终点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = vec.rbegin();i!=vec.end();i++)&#123;...&#125;</span><br><span class="line"><span class="comment">// 此外上诉两种指针都有一个c（const）的版本，如vec.rbegin()</span></span><br><span class="line"><span class="comment">//这个版本返回的迭代器是const类型的，不可改变迭代器所指向元素的值</span></span><br></pre></td></tr></table></figure><p><strong>capacity</strong></p><p>vector是一个可变长度的向量，当vector在添加元素的时候，会选择增长向量的容量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">vec.size(); <span class="comment">//实际长度</span></span><br><span class="line">vec.capacity(); <span class="comment">//已经分配的长度</span></span><br><span class="line">vec.max_size(); <span class="comment">// 可分配的最大长度</span></span><br><span class="line">vec.empty(); <span class="comment">// 判断是否为空</span></span><br><span class="line">vec.shrink_to_fit(); <span class="comment">// 将容量减小到容器的容量大小</span></span><br></pre></td></tr></table></figure><p><strong>访问元素</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">vec[<span class="number">1</span>];</span><br><span class="line">vec.front();</span><br><span class="line">vec.back();</span><br><span class="line">vec.at(pos);</span><br><span class="line">vec.data(); <span class="comment">// 返回指针指向第一个地址</span></span><br></pre></td></tr></table></figure><p><strong>修改元素</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">vec.assign(val,time); <span class="comment">//vec赋值，time个val的值</span></span><br><span class="line">vec.push_back(val);</span><br><span class="line">vec.pop_back(val);</span><br><span class="line">vec.insert(insert_adress,val);</span><br><span class="line">vec.erase(adress);</span><br><span class="line">vec.clear(); <span class="comment">// 清空</span></span><br><span class="line">vec.emplace(adress,val); <span class="comment">// 插入元素，并且避免不必要的复制</span></span><br><span class="line">vec.emplace_back(val); <span class="comment">// 末尾插入</span></span><br><span class="line">vec.swap(vec2); <span class="comment">// 交换vec和vec1的元素</span></span><br></pre></td></tr></table></figure><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list是由<strong>双向链表</strong>实现的数据结构，它在空间中不连续，元素的访问速度不如vector，但是对元素的删除，插入操作十分的快速。</p><p>他的很多函数与vector类似，下面列举一下特殊的一下操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; ll = &#123;<span class="number">1</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>&#125;;</span><br><span class="line">ll.sort();</span><br><span class="line">ll.reverse();</span><br><span class="line">ll.push_front();</span><br><span class="line">ll.erase(adress) <span class="keyword">or</span> ll.erase(begin,end);</span><br><span class="line">ll.remove(val); <span class="comment">//删掉val</span></span><br><span class="line">ll.unique(); <span class="comment">// 删除重复元素</span></span><br><span class="line">ll.splice(l1.begin(),l2); <span class="comment">// 链表的拼接</span></span><br><span class="line">ll.merge(<span class="number">12</span>); <span class="comment">// 两个排序后的链表融合</span></span><br></pre></td></tr></table></figure><p><strong>deque</strong></p><p>双向队列，可以两头操作，效率比vector高，但是不一定保证地址是连续的。</p><p>deque和vector的操作基本一致，唯一的不同在于deque允许头插。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">que.push_front(val);</span><br><span class="line">que.pop_front(val);</span><br></pre></td></tr></table></figure><p><strong>froward_list</strong></p><p>单向链表，与list类似，但只支持一个方向，同时所占用的存储空间更小。基本操作和list类似。</p><p><strong>queue</strong></p><p>单向队列，基本方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">que.push(val); <span class="comment">// 插到队列尾巴</span></span><br><span class="line">que.pop();  <span class="comment">// 删除队列头部元素</span></span><br><span class="line"><span class="built_in">queue</span>.empty();</span><br><span class="line"><span class="built_in">queue</span>.size();</span><br></pre></td></tr></table></figure><p><strong>priority queue</strong></p><p>优先队列中，队头的元素是最大的，但是队列的排列顺序不是按照顺序排序的。优先队列使用起来应该很方便，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">que.push(val);</span><br><span class="line">que.push(val);</span><br><span class="line">que.pop();</span><br><span class="line">que.top();</span><br></pre></td></tr></table></figure><p>优先队列是一种最大堆的结构。也可以用优先队列构建最小堆。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; gg;</span><br></pre></td></tr></table></figure><p><strong>stack</strong></p><p>栈是先进先出的一个结构，只有一端开放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack.empty();</span><br><span class="line">stack.push(val);</span><br><span class="line">stack.pop();</span><br><span class="line">stack.top();</span><br></pre></td></tr></table></figure><p><strong>关联容器</strong></p><p><strong>set</strong></p><p>集合容器，他要求内部元素没有重复的，他的常用的方法有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; gg;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>,greater&lt;<span class="keyword">int</span>&gt;&gt; gg; <span class="comment">//从大到小</span></span><br><span class="line">begin();</span><br><span class="line">end();</span><br><span class="line">empty();</span><br><span class="line">gg.insert(val); <span class="comment">// set中的元素都是有序的</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; gg = &#123;vec.begin(),vec.end()&#125;;</span><br><span class="line">gg.lower_bound(val); <span class="comment">//. 返回低于或等于val</span></span><br><span class="line">gg.upper_bound(val); <span class="comment">// 返回高于或等于val的第一个迭代器位置</span></span><br></pre></td></tr></table></figure><p><strong>multiset</strong></p><p>这个容器类似于set，但是和set有一个不同之处在于multiset可以允许重复。</p><p><strong>map</strong></p><p>字典，键值对。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; amap;</span><br><span class="line">amap.insert(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">21</span>));</span><br><span class="line">amap.insert(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">23</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; amap[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">auto</span> ptr = amap.begin();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ptr-&gt;first&lt;&lt; <span class="string">" "</span>&lt;&lt; ptr-&gt;second;</span><br><span class="line">amap.erase(amap.begin());</span><br><span class="line">amap.erase(<span class="number">4</span>);<span class="comment">//key</span></span><br></pre></td></tr></table></figure><p><strong>multimap</strong></p><p>操作基本与map相同，不相同的是，multimap允许有相同的key。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇post主要目的是对cpp提供的Standard Template Library标准模板库中一些重要的方法进行学习，记录，以便今后学习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="learning cpp" scheme="https://wenhui-zhou.github.io/tags/learning-cpp/"/>
    
  </entry>
  
  <entry>
    <title>cpp语法快速回顾</title>
    <link href="https://wenhui-zhou.github.io/2019/10/25/cpp%E8%AF%AD%E6%B3%95%E5%BF%AB%E9%80%9F%E5%9B%9E%E9%A1%BE/"/>
    <id>https://wenhui-zhou.github.io/2019/10/25/cpp语法快速回顾/</id>
    <published>2019-10-24T16:57:12.000Z</published>
    <updated>2019-10-28T15:06:12.276Z</updated>
    
    <content type="html"><![CDATA[<p>cpp的一些基本的语法的回顾，主要是一些比较小规模的语法特性的记录。</p><p>​    <a id="more"></a></p><p><strong>第一个可执行的cpp代码</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>cpp程序编译执行过程</strong></p><ul><li>编译：将源代码翻译成机器语言，生成目标文件<ul><li>预处理：拷贝#include 文件代码，#define 宏定义的替换 ，处理条件编译指令 （#ifndef #ifdef #endif）等，输出.i文件。</li><li>编译优化：进行cpp词法语法分析，确定所有指令是否符合规则，后翻译成汇编代码文件.s。</li><li>汇编：将汇编代码翻译成目标机器代码.o文件。</li></ul></li><li>链接：由于目标文件调用了其他源文件，因此这一步需要将有关的源文件链接起来，生成.exe。</li></ul><p><strong>#define宏定义</strong></p><p>宏定义用一个字符串代替一串字符串，在cpp编译的预处理阶段，将字符串的位置替换成原来的长字符串，这种设计方式的好处是1）修改代码方面。2）对一些很短的代码，如果写成一个函数，将花费大量的系统调用时间，因此宏定义可以提升代码效率，但是目标代码空间就会变大。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi 3.14 <span class="comment">//对象宏，定义变量</span></span></span><br><span class="line"><span class="comment">// 函数宏，这种方式直接将字符串展开，需要注意代码运算优先级的问题</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN(A,B) ((A) &lt; (B) ?(A):(B))</span></span><br></pre></td></tr></table></figure><p><strong>条件编译</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NULL</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>#与##运算符</strong></p><p><strong>#</strong>起到将指令变成字符串的作用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACRO(x) #x</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;MACRO(HOW ARE)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// "HOW ARE"</span></span><br></pre></td></tr></table></figure><p><strong>##</strong>起到链接前后内容的作用，将参数连在一起。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACFUNS(x,y) x##y</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ACFUNS(<span class="string">"aa"</span>,<span class="string">"bb"</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// aabb</span></span><br></pre></td></tr></table></figure><p><strong>typedef申明</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="keyword">wchar_t</span>;</span><br></pre></td></tr></table></figure><p>使用wchar_t来表示short int 这种类型，起了一个新名字。</p><p><strong>enum枚举类</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> color&#123;red,blue,black&#125; c; <span class="comment">//值为0，1，2</span></span><br><span class="line">c = blue; <span class="comment">//等于为c赋值为1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; c; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><strong>声明与定义</strong></p><p>cpp语言支持分离时编译，允许将程序分割成多个模块，声明与定义分离（.h / .cpp）,静态库(lib)包含声明以及方法，动态库(.lib,dll)仅包含声明，dll中为方法。</p><p>声明的作用是在编译器链接代码的阶段，告诉程序该变量的存在。可以在多个文件中，多次声明，使用关键字：</p><p><code>extern int a;</code>声明了一个变量a。定义的过程只能有一次。</p><p><code>extern</code>关键字常用在多个文件同时使用同一个变量或者函数的时候。</p><p><strong>变量的初始值</strong></p><p>当一个变量是全局变量，系统会默认初始值为0。当变量是局部变量，系统不会赋初始值。</p><p><strong>定义常量</strong></p><p>常量不可以修改它的值，两种方式定义常量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDTH 10</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> HEIGHT = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p><strong>修饰符类型</strong></p><p>修饰符用于改变基本数据类型char，int，double的含义。可以使用的修饰符有： <code>signed,unsigned,long short</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* <span class="keyword">restrict</span> restar = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">制定只有restar这个指针可以指向这一块内存，其他指针都不能访问</span><br></pre></td></tr></table></figure><p><strong>存储类</strong></p><p>auto 关键字声明变量根据初始化值自动推断<strong>变量</strong>的类型，声明函数返回的<strong>占位符</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">auto</span> s = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><p><strong>static</strong>告诉编译器在程序声明周期内保持局部变量的存在，在编译阶段进行赋值，其他阶段不会进行初始化操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        func();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出为5，4，3，2，1.... 其中static i只会被初始化一次</span></span><br></pre></td></tr></table></figure><p><strong>thread_local</strong>关键字声明的变量仅仅可以在其上创建的线程上访问，仅仅可以用来声明变量。</p><p><code>thread_local int x;</code></p><p><strong>位运算符</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">00111100</span></span><br><span class="line">B = <span class="number">00001101</span></span><br><span class="line">A&amp;B = <span class="number">00001100</span></span><br><span class="line">A|B = <span class="number">00111101</span></span><br><span class="line">A^B = <span class="number">00110001</span></span><br><span class="line">~A = <span class="number">11000011</span></span><br><span class="line">A &lt;&lt;= <span class="number">1</span>; <span class="comment">//A = 01111000</span></span><br><span class="line">A &gt;&gt;= <span class="number">1</span>; <span class="comment">//A = 00011110</span></span><br><span class="line"><span class="keyword">sizeof</span>(A); <span class="comment">//返回A的大小</span></span><br><span class="line">b = &amp;A; <span class="comment">// 取地址</span></span><br><span class="line">c = *b; <span class="comment">// 取出b中的值</span></span><br></pre></td></tr></table></figure><p><strong>函数定义</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传参数方式可以分为传值，传指针，传地址三种</span></span><br></pre></td></tr></table></figure><p><strong>lambda表达式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameter)-&gt; <span class="keyword">return</span>-type&#123;body&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> funa = [s](<span class="keyword">int</span> a,<span class="keyword">int</span> b)-&gt; <span class="keyword">int</span>&#123;<span class="keyword">return</span> a+b+s;&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; funa(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><strong>数学运算</strong></p><p>数学运算的方法在<cmath>头文件中。</cmath></p><p><strong>随机数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">j = rand()</span><br></pre></td></tr></table></figure><p><strong>数组</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">10</span>,<span class="number">10</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>字符串</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c风格字符串</span></span><br><span class="line"><span class="keyword">char</span> gre[] = &#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;gre;</span><br><span class="line"><span class="built_in">strcpy</span>(str1,str2); <span class="comment">// str2给str1赋值</span></span><br><span class="line"><span class="built_in">strcat</span>(str1,str2); <span class="comment">// str1+str2</span></span><br><span class="line"><span class="built_in">strcmp</span>(s1,s2);<span class="comment">//比较s1，s2</span></span><br><span class="line"><span class="built_in">strchr</span>(s1,ch); <span class="comment">// 返回指针，指针位置为ch第一次出现的位置</span></span><br><span class="line"><span class="built_in">strstr</span>(s1,s2);<span class="comment">// 放回指针，指向第一次出现s2的位置</span></span><br></pre></td></tr></table></figure><p><strong>string 字符串操作</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> a = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">string</span> b = <span class="string">"el"</span>;</span><br><span class="line">a.find_first_of(b); <span class="comment">// 等于a.find(b);</span></span><br><span class="line">a.find_last_of(b);</span><br><span class="line">s.size();</span><br><span class="line"><span class="keyword">if</span>(a.find(b) == <span class="built_in">string</span>::npos)&#123;</span><br><span class="line">    <span class="keyword">return</span> “dont exists”;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>指针</strong></p><p>cpp中每个变量都有一个内存位置，这个内存位置可以通过<code>&amp;</code> 取址符来得到，他表示内存中的一个地址。</p><p>指针是一个变量，它的值就是地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line"><span class="keyword">int</span> var = <span class="number">10</span>;</span><br><span class="line">ip = &amp;var;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ip; <span class="comment">//取去ip中的值</span></span><br><span class="line"><span class="keyword">int</span> *ptr[<span class="number">10</span>]; <span class="comment">//指针数组，数组中存指针</span></span><br><span class="line"><span class="comment">//指针可以允许加减，数组和指针很类似，一个定义在数组开头的指针用法和数组相同</span></span><br><span class="line"><span class="keyword">int</span> var[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">int</span> *ip = var;</span><br><span class="line">ip++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ip[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p><strong>引用</strong></p><p>引用变量是为变量起了一个别名，引用在创建的时候必须初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; r = a;</span><br><span class="line"><span class="comment">//传参数的时候可以使用引用，不用传值，快。</span></span><br><span class="line"><span class="comment">// 函数返回类型为引用类型的时候，操作和其他类型的一样，返回一个引用，就可以对这个引用进行赋值的过一些操作了。</span></span><br></pre></td></tr></table></figure><p><strong>结构体</strong></p><p>cpp中定义数据类型使用结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span> <span class="title">b1</span>;</span></span><br><span class="line"><span class="comment">//使用typedef定义别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Book</span>&#123;</span></span><br><span class="line">      <span class="keyword">int</span> count;</span><br><span class="line">      <span class="built_in">string</span> name;</span><br><span class="line">&#125;Book;</span><br><span class="line">Book b1,b2;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b1.name;</span><br><span class="line"><span class="comment">//指针调用</span></span><br><span class="line">Book *ptr = &amp;b1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ptr-&gt;name;</span><br></pre></td></tr></table></figure><p><strong>类</strong></p><p>类是cpp的核心，通常被用与用户定制自己的数据以及方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">int</span> width;</span><br><span class="line">      <span class="keyword">int</span> height;</span><br><span class="line">      Box(); <span class="comment">//构造函数，函数进行定义，初始化的入口</span></span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">get_area</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width*height;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Box b1; <span class="comment">//定义了一个Box的类型变量</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; b1.width;</span><br><span class="line">Box* ptr = &amp;b1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ptr-&gt;get_area();</span><br></pre></td></tr></table></figure><p><strong>拷贝构造函数</strong></p><p>利用已经存在的类对象，对新类进行初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box b2 = b1;</span><br></pre></td></tr></table></figure><p><strong>友元函数</strong></p><p>友元函数设计的思路是说，一个非A类内的函数，希望获得完整的A类内成员的访问权限，这时候需要在A类对该函数进行一下注册，用friend最为前缀（适用于多人协作的项目）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> mon;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">detial</span><span class="params">(A a1)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">detail</span><span class="params">(A a1)</span></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; a1.val; <span class="comment">//允许访问私有变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>this 指针</strong></p><p>成员函数均有一个隐含的this指针参数，用于指向对象。</p><p><strong>类内静态成员变量，静态函数</strong></p><p>类中允许定义static变量，该变量在所有类的对象中是共享的，该变量属于类，不属于对象，不可以在类的构造函数中初始化static变量，而是通过<code>A::变量 =  init</code>的方式进行初始化。</p><p>static声明的函数，与任何对象都没有关系，该函数与类同在，只能访问静态成员变量，与其他静态成员函数。</p><p><strong>继承</strong></p><p>我理解继承是这种大型工程中非常有灵性的一种设计，通过底层写一些通用的模版类，底下的继承类就有很好的一致性，以及少写了很多重复性的工作，此外通过子类中定制自己的成员，呈现一种放散式的结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">book</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> page = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">string</span> name = <span class="string">"island"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">detail</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt; <span class="keyword">this</span>.page &lt;&lt; <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">finance</span>:</span> <span class="keyword">public</span> book&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">    finance(<span class="keyword">int</span> pro);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">detail</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">finance::finance(<span class="keyword">int</span> pro):book()&#123;</span><br><span class="line">  <span class="keyword">this</span>.profit = pro;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> finance::detail()&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span>.page &lt;&lt; <span class="keyword">this</span>.name &lt;&lt; <span class="keyword">this</span>.pro;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体来说，<strong>继承不会继承积累的构造函数，友元函数，重载运算符。</strong>从设计的角度上看，友元这一类函数会破坏类的封装性，子类不接受友元是很正确的决定，而构造函数有专门的作用，因此，不继承构造函数也是可以理解的。</p><p><strong>基类构造函数</strong></p><p>所谓的基类构造函数，构造的时候，需要对父类进行初始化，很容易理解。初始化的方式就是通过构造函数表来初始化，在构造函数定义的时候使用，成员变量也允许那时候初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">finance::finance(<span class="keyword">int</span> profit,<span class="keyword">int</span> page,<span class="built_in">string</span> name):Book(page,name),profit(profit)&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>重载运算符</strong></p><p>我认为这一步的设计思路是是我们设计的类和基础类型的变量能够使用一些类似于<strong>+，-，x，/</strong>这种方便的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">   Box <span class="keyword">operator</span>+(Box b)&#123;</span><br><span class="line">     Box box;</span><br><span class="line">     box.width = <span class="keyword">this</span>.width + b.width;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Box b1,b2;</span><br><span class="line">b = b1 + b2;</span><br></pre></td></tr></table></figure><p><strong>重载函数</strong></p><p>重载函数指的是同一个函数，但是随着输入的参数不同，调用的具体函数也是不同的。这样的设计思路在于，是一个函数用起来更加灵活，例如对于不同级别的类别都需要登入操作，但是入口不同。就可以利用重载的思路来实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">log</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> user = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> vip = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">int</span> user)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">int</span> user,<span class="keyword">int</span> vip)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多态</strong></p><p>多态的设计思路，有这样一种情况，当子类与父类中同时有某个方法。我们可以用父类的指针来存放所有的子类的地址。但是每个子类调用一个工友的方法，各自应该有各自的方案。例如大家办护照都去公安局，但是每个人有不同的办理方案，这种情况就是多态。</p><p>要实现多态的话，在需要实现多态的函数前加上<strong>virtual</strong>关键字，告诉编译器，在编译的时候不要链接该函数，而是得到调用函数的时候，看变量的类型来确定用什么函数。这个叫<strong>做动态链接</strong>。</p><p>静态链接则是写死了，每次用父类的对象调用的都是父类的方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shape</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> width = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">    shape(<span class="keyword">int</span> w,<span class="keyword">int</span> h):width(w),height(h);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">area</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"shape"</span> ；</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">triangle</span>:</span><span class="keyword">public</span> shape&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    triangle(<span class="keyword">int</span> a,<span class="keyword">int</span> b):shape(a,b)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"triangle area"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> a*b / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rectangle</span>:</span><span class="keyword">public</span> shape&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    rectangle(<span class="keyword">int</span> a,<span class="keyword">int</span> b):shape(a,b)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">"rectangle area"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> a*b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shape* sh;</span><br><span class="line"><span class="function">rectangle <span class="title">rec</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">triangle <span class="title">tri</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="comment">// 正方形面积</span></span><br><span class="line">sh = &amp;rec;</span><br><span class="line">sh-&gt;area();</span><br><span class="line"><span class="comment">// 三角形面积</span></span><br><span class="line">sh = $tri;</span><br><span class="line">sh-&gt;area();</span><br></pre></td></tr></table></figure><p><strong>虚基类virtual</strong></p><p>虚基类提出的设计思路是说，如果一个类同时继承两个类，而这两个类又同时继承自同一个父类，因此在子类这就会出现最高父类的两个拷贝。因此多继承很多时候会产生很多二义性的问题，因此在设计函数的时候要尽可能避免。出现这种情况可以用virtual进行虚继承。<code>class B : virtual public A{...}</code>。</p><p><strong>抽象类</strong></p><p>设计抽象类的设计思想是说，面向对象的系统可能会使用一个抽象基类为所有的外部应用程序提供一个适当的、通用的、标准化的接口。因此会在基类设计一个<strong>virtual</strong>抽象类，规定一下子类的接口参数的格式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shape</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    shape(<span class="keyword">int</span> a,<span class="keyword">int</span> b):width(a),weight(b)&#123;&#125;</span><br><span class="line">  <span class="comment">// 提供纯虚函数接口，子类必须覆盖</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">get_area</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rectangle</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    rectangle(<span class="keyword">int</span> a,<span class="keyword">int</span> b):shape(a,b)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_area</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.width*<span class="keyword">this</span>.weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>文件的读写</strong></p><p>文件的读写定义在两个库函数中，<strong>ifstream,ofstream</strong>，写入过程使用&lt;&lt;，读出过程使用&gt;&gt;。</p><p><strong>异常处理</strong></p><p>cpp中提供了<code>try,catch,throw</code>用来保护代码，抛出错误。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="comment">//保护代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(ExceptionName e1)&#123;</span><br><span class="line">  <span class="comment">//catch 内容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(ExceptionName e2)&#123;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//catch 模块</span></span><br><span class="line"><span class="keyword">if</span>(error)&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">"error message"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>cpp动态内存</strong></p><p>栈：在函数内部声明的所有变量都将用栈来存储</p><p>堆：这部分内存程序未使用，在程序运行时可动态分配内存。</p><p>cpp允许使用<strong>new</strong>给变量分配堆内内存，返回动态内存的起始位置，同时可以使用<strong>delete</strong>将这部分内存删除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>* ptr = <span class="keyword">new</span> <span class="keyword">double</span>;</span><br><span class="line">*ptr = <span class="number">12.32</span>;</span><br><span class="line"><span class="comment">//数组申请空间</span></span><br><span class="line"><span class="keyword">int</span> * ptr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="keyword">delete</span>[] ptr;</span><br><span class="line"><span class="comment">// 二维数组</span></span><br><span class="line"><span class="keyword">int</span> ** ptr = <span class="keyword">new</span> <span class="keyword">int</span> *[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">  ptr[i] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">Box* ptr = <span class="keyword">new</span> Box[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">delete</span> [] ptr;</span><br></pre></td></tr></table></figure><p><strong>命名空间</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> first_space&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">     ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">first_space::func();</span><br></pre></td></tr></table></figure><p><strong>cpp模板</strong></p><p>模板指<strong>函数模板</strong>和<strong>类模板</strong>，是一种参数化类型机制，在泛型编程（泛型允许程序员使用<strong>未指定</strong>类型的变量，在<strong>实例化</strong>时作为参数指明这些类型）中十分的重要。常用的cpp模版例如<strong>vector</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 用T表示一种类型的变量</span></span><br><span class="line"><span class="function">T <span class="title">Max_val</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a &gt; b ? a:b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">Max_val(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">Max_val(<span class="number">1.2</span>,<span class="number">3.4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">stack</span>&#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt; elems;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp; val)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">stack</span>&lt;T&gt;:</span>:push(T <span class="keyword">const</span>&amp; val)&#123;</span><br><span class="line">  elems.push(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; int_stack;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="built_in">string</span>&gt; str_stack;</span><br></pre></td></tr></table></figure><p><strong>const&amp;</strong></p><p>在一些库函数，模板类的函数中进场发现这种传参数，传指数的方法,这种方法用引用减少数值传递过程中需要消耗的时间。返回值是const&amp;是个引用，如果是const的话，程序还需要另外开辟空间。同时这样使用可以函数返回值还可以作为左值，因此建议今后写代码带上引用。</p><p><strong>void*</strong></p><p><code>void *</code>是一种指针类型，常用在<code>函数参数、函数返回值</code>中需要兼容不同指针类型的地方。它类似于指针类型中的原始基类，所有的指针可以对它赋值，它也可以转化为任何指针类型，但是是否合理需要看函数的原始定义。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* c;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> * ptr = &amp;a;</span><br><span class="line">c = ptr;</span><br><span class="line"><span class="keyword">int</span> * d = (<span class="keyword">int</span> *) c;</span><br></pre></td></tr></table></figure><p><strong>cpp多进程/线程</strong></p><ul><li>进程：程序需要并发执行</li><li>线程：一个进程中含多个线程，线程负责同一段程序中的并发</li></ul><p>使用 POSIX 编写多线程 C++ 程序。POSIX支持linux上的并行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">// 线程的运行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">say_hello</span><span class="params">(<span class="keyword">void</span>* args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello Runoob！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义线程的 id 变量，多个变量使用数组</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tids[NUM_THREADS];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//参数依次是：创建的线程id，线程参数，调用的函数，传入的函数参数</span></span><br><span class="line">        <span class="keyword">int</span> ret = pthread_create(&amp;tids[i], <span class="literal">NULL</span>, say_hello, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="built_in">cout</span> &lt;&lt; <span class="string">"pthread_create error: error_code="</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等各个线程退出后，进程才结束，否则进程强制结束了，线程可能还没反应过来；</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>cpp中的STL（standard template library）</strong></p><p>STL库中包含了许多模板类，实现了很多容器，算法以及迭代器等等。</p><ul><li>算法algorithm：这些算法类大多是作用在容器上</li><li>容器：如vector，map，set等等</li><li>迭代器</li><li>Functors：算子，类似于sort的时候用算法自定义排序的方式，作为参数传入</li></ul><p>为STL专门开一个post，日常使用和刷题都会比较经常使用：<a href="https://perper.site/2019/10/27/cpp-STL%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">链接</a></p><p><strong>cpp标准库</strong></p><p>这个库是继承自C语言的，包括标准函数库和标准对象库。</p><p><strong>#include</strong></p><p>cpp中include一个头文件在编译阶段等同于件这个头文件中的代码展开，因此cpp中发生相互引用时将会报错，当你在不确定是否存在相互引用的时候，建议加上include保护：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> FOLDER_METHOD_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOLDER_METHOD_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>Google 开源风格指南中建议的include顺序：</p><p> <code>dir/foo.cc</code> 或 <code>dir/foo_test.cc</code> 的主要作用是实现或测试 <code>dir2/foo2.h</code> 的功能, <code>foo.cc</code> 中包含头文件的次序如下:</p><blockquote><ol><li><code>dir2/foo2.h</code> (优先位置, 详情如下)</li><li>C 系统文件</li><li>C++ 系统文件</li><li>其他库的 <code>.h</code> 文件</li><li>本项目内 <code>.h</code> 文件</li></ol></blockquote><p>这种优先的顺序排序保证当 <code>dir2/foo2.h</code> 遗漏某些必要的库时， <code>dir/foo.cc</code> 或 <code>dir/foo_test.cc</code> 的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。</p><p>.cpp中不必要包含include自己的h文件，程序链接的时候会自动找到他们的对应关系。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>重新回顾了一下cpp的一些语法重点，发现这本语言相比较于其他语言来说，有很大的自由度，自由发挥的地方非常的多。同时有为写一些大工程而设计上的思路。总体来说，比较感兴趣，由于使用CLion来作为编辑器，通过一种更加原生的方式写代码，编译代码，感觉要比直接用VS studio要有深刻的理解。</p><p>这一页博客要常常回来回顾回顾！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cpp的一些基本的语法的回顾，主要是一些比较小规模的语法特性的记录。&lt;/p&gt;
&lt;p&gt;​
    
    </summary>
    
    
      <category term="learning cpp" scheme="https://wenhui-zhou.github.io/tags/learning-cpp/"/>
    
  </entry>
  
  <entry>
    <title>DeepLab 总结</title>
    <link href="https://wenhui-zhou.github.io/2019/10/22/DeepLab-%E6%80%BB%E7%BB%93/"/>
    <id>https://wenhui-zhou.github.io/2019/10/22/DeepLab-总结/</id>
    <published>2019-10-22T02:15:32.000Z</published>
    <updated>2019-10-25T10:46:48.770Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="项目总结" scheme="https://wenhui-zhou.github.io/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>

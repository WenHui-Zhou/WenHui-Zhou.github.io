<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WenHuiZhou</title>
  
  <subtitle>perper（打起精神！）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wenhui-zhou.github.io/"/>
  <updated>2020-02-20T18:25:25.914Z</updated>
  <id>https://wenhui-zhou.github.io/</id>
  
  <author>
    <name>WenHuiZhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>聚类</title>
    <link href="https://wenhui-zhou.github.io/2020/02/19/%E8%81%9A%E7%B1%BB/"/>
    <id>https://wenhui-zhou.github.io/2020/02/19/聚类/</id>
    <published>2020-02-19T10:48:46.000Z</published>
    <updated>2020-02-20T18:25:25.914Z</updated>
    
    <content type="html"><![CDATA[<p>物以类聚，人以群分。</p><a id="more"></a><h3 id="聚类简述"><a href="#聚类简述" class="headerlink" title="聚类简述"></a>聚类简述</h3><p>将数据分成多个类别，在同一个类别内对象之间就有较高的相似性，不同类对象之间的差异性则较大。对一批没有标注数据的样本，相似的归为一类，不相似的归为其他类，称为聚类分析，聚类的质量拒绝于度量标准的选择。</p><h3 id="聚类方法分类"><a href="#聚类方法分类" class="headerlink" title="聚类方法分类"></a>聚类方法分类</h3><ul><li>聚类类型<ul><li>统计聚类方法：基于全局数据的聚类，即从全体 样本中通过距离比较，获得聚类中心（马氏距离）</li><li>概念聚类方法：将数据按按一定的方式和准则进 行分组，得到的分组代表着不同的概念。</li><li>按度量方法分类：距离（k-means），密度，连通性（谱聚类）</li></ul></li></ul><h3 id="距离与相似度度量"><a href="#距离与相似度度量" class="headerlink" title="距离与相似度度量"></a>距离与相似度度量</h3><p><img src="/images/nlp/image-20200219191644847.png" alt="image-20200219191644847" style="zoom:40%;"></p><p><img src="/images/nlp/image-20200219191715323.png" alt="image-20200219191715323" style="zoom:40%;"></p><p><img src="/images/nlp/image-20200219191752693.png" alt="image-20200219191752693" style="zoom:40%;"></p><h3 id="最大似然估计"><a href="#最大似然估计" class="headerlink" title="最大似然估计"></a>最大似然估计</h3><p>给定一个包含n个无类别标签的数据集，假定这些样本符合一个形式已知，但是参数位置的函数：<br>$$<br>p(\mathbf{x} | \boldsymbol{\theta})=\sum_{j=1}^{c} p\left(\mathbf{x} | \omega_{j}, \boldsymbol{\theta}_{j}\right) P\left(\omega_{j}\right)<br>$$<br>采用最大似然方法对参数$\theta$ 进行估计。</p><p>最大似然估计的方式是首先对函数取对数，随后计算对$\theta$的梯度，令梯度等于零，求解其中待估计的参数$\theta$。</p><p><img src="/images/nlp/image-20200221005723555.png" alt="image-20200221005723555" style="zoom:40%;"></p><h3 id="K-均值聚类"><a href="#K-均值聚类" class="headerlink" title="K-均值聚类"></a>K-均值聚类</h3><p><img src="/images/nlp/image-20200221015505581.png" alt="image-20200221015505581" style="zoom:50%;"></p><p><img src="/images/nlp/image-20200221015600990.png" alt="image-20200221015600990" style="zoom:50%;"></p><p><img src="/images/nlp/image-20200221015922143.png" alt="image-20200221015922143" style="zoom:50%;"></p><p><img src="/images/nlp/image-20200221022258398.png" alt="image-20200221022258398" style="zoom:50%;"></p><p><img src="/images/nlp/image-20200221022334981.png" alt="image-20200221022334981" style="zoom:50%;"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;物以类聚，人以群分。&lt;/p&gt;
    
    </summary>
    
      <category term="统计学习方法" scheme="https://wenhui-zhou.github.io/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>神经网络</title>
    <link href="https://wenhui-zhou.github.io/2020/02/17/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>https://wenhui-zhou.github.io/2020/02/17/神经网络/</id>
    <published>2020-02-17T10:17:06.000Z</published>
    <updated>2020-02-18T06:12:04.239Z</updated>
    
    <content type="html"><![CDATA[<p>神经网络是一个并行的分布式处理结构，由处理单元及其链接的无向通道组成。</p><a id="more"></a><h3 id="人工神经元"><a href="#人工神经元" class="headerlink" title="人工神经元"></a>人工神经元</h3><p>人工神经元接受一个输入，经过激活函数，得到一个输出。</p><p><img src="/images/nlp/image-20200217190314746.png" alt="image-20200217190314746" style="zoom:40%;"></p><p><strong>激活函数</strong></p><p><img src="/images/nlp/image-20200217195205430.png" alt="image-20200217195205430" style="zoom:40%;"></p><p><img src="/images/nlp/image-20200217195431829.png" alt="image-20200217195431829" style="zoom:40%;"></p><h3 id="单层感知器"><a href="#单层感知器" class="headerlink" title="单层感知器"></a>单层感知器</h3><p><img src="/images/nlp/image-20200217200553358.png" alt="image-20200217200553358" style="zoom:40%;"></p><p><img src="/images/nlp/image-20200217200623566.png" alt="image-20200217200623566" style="zoom:40%;"></p><p><img src="/images/nlp/image-20200217210505691.png" alt="image-20200217210505691" style="zoom:40%;"></p><p><img src="/images/nlp/image-20200217214410100.png" alt="image-20200217214410100" style="zoom:40%;"></p><h3 id="多层感知器"><a href="#多层感知器" class="headerlink" title="多层感知器"></a>多层感知器</h3><p><img src="/images/nlp/image-20200217224218769.png" alt="image-20200217224218769" style="zoom:40%;"></p><p><strong>误差反向传播算法BP</strong></p><p>利用输出后的误差来估计输出层的前一层的误差，再用这个误差去估计更前一层的误差，从而获得各层的误差估计。</p><p><img src="/images/nlp/image-20200217225713435.png" alt="image-20200217225713435" style="zoom:40%;"></p><p><img src="/images/nlp/image-20200217231110300.png" alt="image-20200217231110300" style="zoom:40%;"></p><p>反向传播如下：</p><p><img src="/images/nlp/image-20200217231224975.png" alt="image-20200217231224975" style="zoom:40%;"></p><p><img src="/images/nlp/image-20200217233040444.png" alt="image-20200217233040444" style="zoom:40%;"></p><p><img src="/images/nlp/image-20200217233643956.png" alt="image-20200217233643956" style="zoom:40%;"></p><p><img src="/images/nlp/image-20200217233705608.png" alt="image-20200217233705608" style="zoom:40%;"></p><p><img src="/images/nlp/image-20200217234019319.png" alt="image-20200217234019319" style="zoom:40%;"></p><p><strong>人工神经网络到深度网络的演化</strong></p><p><img src="/images/nlp/image-20200218121400892.png" alt="image-20200218121400892" style="zoom:40%;"></p><p>网络发展的趋势是参数越来越多，网络越来越深。</p><p><img src="/images/nlp/image-20200218122631866.png" alt="image-20200218122631866" style="zoom:40%;"></p><h3 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h3><p><img src="/images/nlp/image-20200218123425909.png" alt="image-20200218123425909" style="zoom:40%;"></p><p><img src="/images/nlp/image-20200218123610159.png" alt="image-20200218123610159" style="zoom:40%;"></p><p><img src="/images/nlp/image-20200218123655620.png" alt="image-20200218123655620" style="zoom:40%;"></p><p><img src="/images/nlp/image-20200218123747946.png" alt="image-20200218123747946" style="zoom:40%;"></p><p>对于自然图像而言，我们希望从图像底层开始进行学习，而非利用人为设计的特征，如果直接将图像作为输入，采用全连接的方式，将造成巨大的计算量，因此我们提出卷积神经网络：</p><ul><li>局部连接：每次计算仅考虑卷积核大小的区域<ul><li>对图像而言，局部领域内的像素联系比较紧密，距离较远的像素相关性则比较弱</li><li>卷积核对局部信息进行感知，在高层则将局部信息综合起来得到全局信息</li></ul></li><li>权值共享：克服参数过多问题<ul><li>利用一个参数待学习的卷积核（3x3），对图像进行卷积过滤，每个卷积核可视为学习一种参数</li></ul></li></ul><p><img src="/images/nlp/image-20200218125212298.png" alt="image-20200218125212298" style="zoom:40%;"></p><p>采用卷积得到的结果得到的仍然是一个较高维度的结果，在如此高维的特征下设计分类器容易产生过拟合，并且计算量较大。</p><p>因此一个方法就是对不同位置上的特征进行聚合：</p><p><img src="/images/nlp/image-20200218125659834.png" alt="image-20200218125659834" style="zoom:40%;"></p><p><img src="/images/nlp/image-20200218133024988.png" alt="image-20200218133024988" style="zoom:40%;"></p><h3 id="自编码器（autoencoder）"><a href="#自编码器（autoencoder）" class="headerlink" title="自编码器（autoencoder）"></a>自编码器（autoencoder）</h3><p><img src="/images/nlp/image-20200218133233532.png" alt="image-20200218133233532" style="zoom:40%;"></p><p><img src="/images/nlp/image-20200218134846541.png" alt="image-20200218134846541" style="zoom:40%;"></p><p><img src="/images/nlp/image-20200218135048551.png" alt="image-20200218135048551" style="zoom:40%;"></p><h3 id="RNN网络"><a href="#RNN网络" class="headerlink" title="RNN网络"></a>RNN网络</h3><p><img src="/images/nlp/image-20200218140718801.png" alt="image-20200218140718801" style="zoom:40%;"></p><p><img src="/images/nlp/image-20200218140918045.png" alt="image-20200218140918045" style="zoom:40%;"></p><p><img src="/images/nlp/image-20200218141105912.png" alt="image-20200218141105912" style="zoom:40%;"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;神经网络是一个并行的分布式处理结构，由处理单元及其链接的无向通道组成。&lt;/p&gt;
    
    </summary>
    
      <category term="统计学习方法" scheme="https://wenhui-zhou.github.io/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>线性判别函数</title>
    <link href="https://wenhui-zhou.github.io/2020/02/16/%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB%E5%87%BD%E6%95%B0/"/>
    <id>https://wenhui-zhou.github.io/2020/02/16/线性判别函数/</id>
    <published>2020-02-16T13:53:23.000Z</published>
    <updated>2020-02-16T16:10:05.733Z</updated>
    
    <content type="html"><![CDATA[<p><strong>线性判别函数</strong>：用于分类的判别函数的参数形式已知，通过从样本来估计判别函数的参数。</p><a id="more"></a><h3 id="模式分类的途径"><a href="#模式分类的途径" class="headerlink" title="模式分类的途径"></a>模式分类的途径</h3><ul><li>估计类条件概率密度函数，然后通过贝叶斯得到后验概率，用于决策</li><li>直接估计后验概率：k-近邻分类器等</li><li>使用判别函数，直接决策</li></ul><h3 id="线性判别函数与决策面"><a href="#线性判别函数与决策面" class="headerlink" title="线性判别函数与决策面"></a>线性判别函数与决策面</h3><p><img src="/images/nlp/image-20200216222218691.png" alt="image-20200216222218691" style="zoom:40%;"></p><p><img src="/images/nlp/image-20200216222522730.png" alt="image-20200216222522730" style="zoom:40%;"></p><p><strong>多类情况-判别器</strong></p><ul><li>one-vs-all：构造C的二分类器，逐一比较</li><li>one-vs-one：两两配对，构造c/2个二分类器</li></ul><p><strong>增广性</strong></p><p>对线性判别函数采用其次增广表示，使得决策平面过原点，具有一些很好地分类性质。</p><p><img src="/images/nlp/image-20200216230032056.png" alt="image-20200216230032056" style="zoom:40%;"></p><h3 id="感知准则函数"><a href="#感知准则函数" class="headerlink" title="感知准则函数"></a>感知准则函数</h3><p><img src="/images/nlp/image-20200216230427121.png" alt="image-20200216230427121" style="zoom:40%;"></p><p><img src="/images/nlp/image-20200216231014083.png" alt="image-20200216231014083" style="zoom:40%;"></p><p>越靠近区域中间的解向量，越能对新的样本正确分类，可以对解区进行限制：</p><p><img src="/images/nlp/image-20200216233948027.png" alt="image-20200216233948027" style="zoom:40%;"></p><p>感知器准则：最小化错分样本</p><p><img src="/images/nlp/image-20200216234659412.png" alt="image-20200216234659412" style="zoom:40%;"></p><p><img src="/images/nlp/image-20200216234827162.png" alt="image-20200216234827162" style="zoom:40%;"></p><p><img src="/images/nlp/image-20200216235836881.png" alt="image-20200216235836881" style="zoom:40%;"></p><p><img src="/images/nlp/image-20200217000045647.png" alt="image-20200217000045647" style="zoom:40%;"></p><p><img src="/images/nlp/image-20200217000108761.png" alt="image-20200217000108761" style="zoom:40%;"></p><p><img src="/images/nlp/image-20200217000130566.png" alt="image-20200217000130566" style="zoom:40%;"></p><p><img src="/images/nlp/image-20200217000842488.png" alt="image-20200217000842488" style="zoom:40%;"></p><p><img src="/images/nlp/image-20200217000608368.png" alt="image-20200217000608368" style="zoom:40%;"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;线性判别函数&lt;/strong&gt;：用于分类的判别函数的参数形式已知，通过从样本来估计判别函数的参数。&lt;/p&gt;
    
    </summary>
    
      <category term="统计学习方法" scheme="https://wenhui-zhou.github.io/categories/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Learn To Rank</title>
    <link href="https://wenhui-zhou.github.io/2020/02/14/Learn-To-Rank/"/>
    <id>https://wenhui-zhou.github.io/2020/02/14/Learn-To-Rank/</id>
    <published>2020-02-14T13:53:54.000Z</published>
    <updated>2020-02-16T10:57:18.734Z</updated>
    
    <content type="html"><![CDATA[<p>Learn To Rank是一种学习方法，通过训练模型来解决排序的问题，在信息检索，NLP，Data Mining领域有着很多的应用。</p><a id="more"></a><h3 id="排序问题"><a href="#排序问题" class="headerlink" title="排序问题"></a>排序问题</h3><p>在信息检索中，给定一个query，搜索引擎会召回（<strong>粗筛选</strong>）一系列相关的Documents（term匹配，keyword匹配，semantic匹配），之后对这些Documents排序，最后输出Top N的Documents。</p><p>排序问题即使用一个模型 f(q,d)来对该query下的documents进行排序，这个模型可以是人工设定一些参数的模型，也可以是用<strong>机器学习算法自动训练出来的模型</strong>。在Web Search领域，因为在Web Search 中，有很多信息可以用来<strong>确定query-doc pair的相关性</strong>，而另一方面，由于大量的搜索日志的存在，可以将<strong>用户的点击行为日志作为training data</strong>，使得通过机器学习自动得到排序模型成为可能。</p><p><strong>排序问题的核心在于找出query和doc之间的相关性，对相关性进行排序。</strong></p><p>learn to rank 是监督学习，分为train和test两个阶段：</p><p><img src="/images/nlp/image-20200214232441639.png" alt="image-20200214232441639"></p><h3 id="training-data-set-的生成"><a href="#training-data-set-的生成" class="headerlink" title="training data set 的生成"></a>training data set 的生成</h3><p>由于learning to rank是监督学习，因此对每一条记录都需要label。通常feature vector容易获取，而label实际上反映了query-doc pair的真实相关程度。通常有两种label的获取方式：</p><ul><li>人工标注，即对抽样出来作为training data的query-doc pair人为地进行相关程度的判断和标注，一般标注的相关程度分为5档：perfect，excellent，good，fair，bad。<ul><li>例如，query=“Microsoft”。document为Microsoft的官网是perfect；介绍Microsoft的wikipedia则是excellent；一篇将Microsoft作为其主要话题的网页则是good；一篇只是提到了Microsoft这个词的网页则是fair，而一篇跟Microsoft毫不相关的网页则是bad。人工标注的方法可以通过多人同时进行，最后以类似投票表决的方式决定一个query-doc pair的相关程度，这样可以相对减少各个人的观点不同带来的误差。</li></ul></li><li>通过搜索日志获取。搜索日志记录了人们在实际生活中的搜索行为和相应的点击行为，点击行为隐含了query-doc pair的相关性，所以可以被用来作为query-doc pair的相关程度的判断。一种最简单的方法就是利用同一个query下，不同doc的点击数的多少来作为它们相关程度的大小。</li></ul><p>通过搜索日志的方式获取的方法存在一些偏差，即用户偏向于点击位置靠前的doc，即便这个doc并不相关或者相关性不高。因此有一些tricky和general的方法用来处理这种“position bias”的偏差：</p><ol><li>当位置靠后的doc的点击数都比位置靠前的doc的点击数要高了，那么靠后的doc的相关性肯定要比靠前的doc的相关性大。</li><li>Joachims等人则提出了一系列去除bias的方法，例如 Click &gt; Skip Above, Last Click &gt; Skip Above, Click &gt; Earlier Click, Click &gt; Skip Previous, Click &gt; No Click Next等。</li><li>一个doc的点击数比另一个doc的点击数多，并不一定说明前者比后者更相关。但即使前者比后者位置靠前，两者的点击数相差5-10倍，这时候我们还是愿意相信前者更加相关。</li><li>click model，根据用户的点击信息对用户真正看到的doc进行“筛选”，进而能更准确地看出用户到底看到了哪些doc，没有看到哪些doc，更准确反应点击数/展示数（即展现CTR）来确定各个doc的相关性大小。</li></ol><h3 id="feature-的生成"><a href="#feature-的生成" class="headerlink" title="feature 的生成"></a>feature 的生成</h3><p>一般Learning to Rank的模型的feature分为两大类：relevance 和 importance（hotness），即query-doc pair 的相关性feature，和doc本身的热门程度的feature。两者中具有代表性的分别是 BM25 和 PageRank。</p><h3 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h3><p>比较模型的输出结果，和真实结果（ground truth）之间的差异大小。用于Information Retrieval的排序衡量指标通常有：NDCG，MAP等。</p><p><strong>NDCG</strong></p><p>NDCG表示了从第1位doc到第k位doc的“归一化累积折扣信息增益值”，主要思想是相关性高且等级高的结果，值应该比较高。</p><ul><li>高关联度的结果比一般关联度的结果更影响最终的指标得分</li><li>有高关联度的结果出现在更靠前的位置的时候，指标会越高</li></ul><p><strong>CG：累计增益cumulative gain</strong></p><p>只考虑到了相关性的关联程度，没有考虑到位置的因素，是一个搜素结果相关性分数的总和。<br>$$<br>\mathrm{CG}_{\mathrm{p}}=\sum_{i=1}^{p} r e l_{i}<br>$$<br>rel表示i的相关性。</p><p><strong>折损累计增益（DCG）</strong>：</p><p>即对每一个CG的结果，除以一个折算值，目的是为了排名越靠前的结果影响力越大：<br>$$<br>\mathrm{DCG}_{\mathrm{p}}=\sum_{i=1}^{p} \frac{r e l_{i}}{\log _{2}(i+1)}=r e l_{1}+\sum_{i=2}^{p} \frac{r e l_{i}}{\log _{2}(i+1)}<br>$$<br><strong>归一化折损累计增益（NDCG）</strong></p><p>归一化之后的折损累积增益，由于搜索的词不同，因此返回的检索数量是不同的，DCG是一个累加值，因此没法针对两个不同的结果进行比较，需要求一个归一化之后的结果：<br>$$<br>\mathrm{nDCG}_{\mathrm{p}}=\frac{D C G_{p}}{I D C G_{p}}<br>$$<br>其中IDCG是理想情况下最大的DCG：<br>$$<br>\mathrm{IDCG}_{\mathrm{p}}=\sum_{i=1}^{|R E L|} \frac{2^{r e l_{i}}-1}{\log _{2}(i+1)}<br>$$<br>即从大到小，取前p个结果组成的集合。</p><p><strong>MAP</strong></p><p>对每个相关文档检索出准确率平均值的算术平均值。首先对每一个query计算一个AP：<br>$$<br>A P=\frac{\sum_{j=1}^{n_{i}} P(j) \cdot y_{i, j}}{\sum_{j=1}^{n_{i}} y_{i, j}}<br>$$<br>$y_{ij}$即每个doc的label（1和0），而每个query-doc pair的P值代表了到$d_{ij}$这个doc所在的位置为止的precision：<br>$$<br>P(j)=\frac{\sum_{k: \pi_{i}(k) \leq \pi_{i}(j)} y_{i, k}}{\pi_{i}(j)}<br>$$<br>其中pi表示排序中的位置。</p><h3 id="Formulation"><a href="#Formulation" class="headerlink" title="Formulation"></a>Formulation</h3><p>通过建立一个损失函数，即经验风险函数，通过最小化这个函数来达到模型训练的目的：<br>$$<br>\hat{R}(F)=\frac{1}{m} \sum_{i=1}^{m} L\left(F\left(\mathbf{x}_{i}\right), \mathbf{y}_{i}\right)<br>$$<br>由于上式优化函数不连续，因此我们寻求一个替代函数，通过优化次优函数得到次优解，替代方案有许多种，可以选择的方法有：</p><p><strong>pointwise loss</strong></p><p>平方误差：<br>$$<br>L^{\prime}(F(\mathbf{x}), \mathbf{y})=\sum_{i=1}^{n}\left(f\left(x_{i}\right)-y_{i}\right)^{2}<br>$$<br><strong>pairwise loss</strong></p><p>例如hinge loss，exponential loss，logistic loss等<br>$$<br>L^{\prime}(F(\mathbf{x}), \mathbf{y})=\sum_{i=1}^{n-1} \sum_{j=i+1}^{n} \phi\left(\operatorname{sign}\left(y_{i}-y_{j}\right), f\left(x_{i}\right)-f\left(x_{j}\right)\right)<br>$$<br><strong>listwise loss</strong><br>$$<br>L^{\prime}(F(\mathbf{x}), \mathbf{y})=\exp (-N D C G)<br>$$</p><h3 id="Learn-To-Rank"><a href="#Learn-To-Rank" class="headerlink" title="Learn To Rank"></a>Learn To Rank</h3><p><strong>pointwise：</strong>输入数据为单个doc以及query</p><p><strong>pairwise：</strong>输入数据为同一个query对应的两个doc，以及query</p><p><strong>listwise：</strong>输入数据为同一个query对应的若干doc，以及query</p><p>pointwise和pairwise方法将排序问题转化为classification，regression，ordinal classification等问题。而listwise方法则将一个ranking list作为一个instance来进行训练，其实会考虑每个query下所有doc之间的顺序关系。</p><p>这三种类型的Learning to Rank方法的具体算法一般有：</p><p>1) <strong>Pointwise</strong>: Subset Ranking, McRank, Prank, OC SVM</p><p>2) <strong>Pairwise</strong>: Ranking SVM, RankBoost, RankNet, GBRank, IR SVM, Lambda Rank, LambdaMart</p><p>3) <strong>Listwise</strong>: ListNet, ListMLE, AdaRank, SVM MAP, Soft Rank</p><p><strong>inference</strong></p><p>本文为学习笔记，参考如下网页：<a href="https://www.cnblogs.com/bentuwuying/p/6681943.html" target="_blank" rel="noopener">https://www.cnblogs.com/bentuwuying/p/6681943.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Learn To Rank是一种学习方法，通过训练模型来解决排序的问题，在信息检索，NLP，Data Mining领域有着很多的应用。&lt;/p&gt;
    
    </summary>
    
      <category term="webSearch" scheme="https://wenhui-zhou.github.io/categories/webSearch/"/>
    
    
  </entry>
  
  <entry>
    <title>OpenPose: Realtime Multi-Person 2D Pose Estimation using Part Affinity Fields</title>
    <link href="https://wenhui-zhou.github.io/2020/02/05/OpenPose-Realtime-Multi-Person-2D-Pose-Estimation-using-Part-Affinity-Fields/"/>
    <id>https://wenhui-zhou.github.io/2020/02/05/OpenPose-Realtime-Multi-Person-2D-Pose-Estimation-using-Part-Affinity-Fields/</id>
    <published>2020-02-05T08:27:15.000Z</published>
    <updated>2020-02-16T06:36:22.947Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章是2017年发表在CVPR上，作者开源了代码openpose，openpose代码完整，在推动人体识别，起到了巨大的作用。</p><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>人体姿态估计</strong>是理解视频图像的一个核心问题，一种比较简单的方法是two-step的框架，首先检测出图像中的人，然后解决人体姿态估计的问题。这种方法的问题在于，算法执行时间与图片中的人数呈正比，同时若第一步未检出行人，将会出现比较严重的漏检。</p><p>这篇文章提出一种<strong>bottom-up approach</strong>，这种方法检测出人体的部分，然后parsing成人体姿态的结果。这种方法执行时间与人数无关。</p><h3 id="architecture-网络框架"><a href="#architecture-网络框架" class="headerlink" title="architecture 网络框架"></a>architecture 网络框架</h3><p><img src="/images/nlp/image-20200205200758114.png" alt="image-20200205200758114" style="zoom:50%;"></p><ul><li>首先通过baseline10层的VGG-19网络，生成feature map</li><li>将feature map 分为两路，通过多层的CNN生成：<ul><li><strong>a set of Part Confidence Maps</strong> 身体部位的置信度</li><li><strong>a set of Part Affinity Fields (PAFs)</strong> 部位亲和场</li></ul></li><li><strong>Part Confidence Maps</strong>: a set of 2D confidence maps <strong>S</strong> for body part locations. Each joint location has a map.也就是说，每一个节点都对应了一张map，如果有25个节点的时候，就会有25张map。</li><li><strong>Part Affinity Fields (PAFs)</strong>: a set of 2D vector fields <strong>L</strong> which encodes the degree of association between parts.  生成parts之间的单位向量场。</li><li>Finally, the <strong>Confidence Maps</strong> and <strong>Part Affinity Fields</strong> are processed by a greedy algorithm to obtain the poses for each person in the image 联合置信图以及亲合场得出图像中每一个人的pose</li></ul><h3 id="confidence-maps"><a href="#confidence-maps" class="headerlink" title="confidence maps"></a>confidence maps</h3><p>置信图指的是一张2D表示的置信度图，可以定位到图像中关节点的像素上。</p><p>令$J$作为人体的的关节点总数，confidence map如下：<br>$$<br>\text { the set } S=\left(S_{1}, S_{2}, \ldots, S_{J}\right) \text { where } S_{j} \in R^{w \times h}, j \in 1 \ldots J<br>$$<br>总的来说，每一张map都对应一个节点，并且与输入的图片有着相同的size。</p><h3 id="Part-Affinity-Fields（PAFs）"><a href="#Part-Affinity-Fields（PAFs）" class="headerlink" title="Part Affinity Fields（PAFs）"></a>Part Affinity Fields（PAFs）</h3><p>PAF指的是流向量场，流向量场用来编码第一部分成对的关节点对，例如nose，neck，elbow等等：<br>$$<br>\text { the set } L=\left(L_{1}, L_{2}, \ldots, L_{C}\right) \text { where } L_{c} \in R^{w \times h \times 2}, c \in 1 \ldots C<br>$$<br>如果一个点在他的body part上（腿），那么这个点的值是一个2D单位向量，从起点joint指向终点的joint。</p><p><img src="/images/nlp/image-20200206214339000.png" alt="image-20200206214339000" style="zoom:40%;"></p><p>如上所述，整个流程分成两个步骤，第一个阶段生成PAF流向量场，第二个向量生成关节点密度场。</p><h3 id="Multi-Person-Parsing-using-PAFs"><a href="#Multi-Person-Parsing-using-PAFs" class="headerlink" title="Multi-Person Parsing using PAFs"></a>Multi-Person Parsing using PAFs</h3><p>从图像中找出人体姿态的步骤如下：</p><ul><li><strong>Step 1</strong>: Find <strong>all joints</strong> locations using the <strong>confidence maps</strong>.</li><li><strong>Step 2</strong>: Find which joints go together to <strong>form limbs (body parts)</strong> using the <strong>part affinity fields</strong> and joints in step 1.</li><li><strong>Step 3</strong>: <strong>Associate limbs that belong to the same person</strong> and get the final list of human poses.</li></ul><h3 id="如何生成人体limb"><a href="#如何生成人体limb" class="headerlink" title="如何生成人体limb"></a>如何生成人体limb</h3><ul><li>首先将生成的PAFs放大到输入的尺寸，</li><li>对于每一个limb类型，例如对wrist_elbow：<ul><li>从深度图中拿到所有的wrist和elbow的关节点的位置</li><li>对每一个起点peak和终点peak：<ul><li>用终点减去起点，然后归一化之后得到单位方向向量</li><li>每一对起点和终点之间的点，计算他们的PAFs的值</li><li>通过这中间所有点的PAFs值得平均值，计算当前limb connection的score</li><li>添加一个score来惩罚long distance：<code>min(0.5*paf_height/limb_dist - 1,0)</code></li><li>添加当前的limb连接到limb connecton candidate中</li></ul></li><li>对limb connection candidate进行排序</li><li>对于每一个候选连接，如果source和destination未被选中，则添加这个connection到最终的list当中</li></ul></li></ul><h3 id="pytorch-implementaton"><a href="#pytorch-implementaton" class="headerlink" title="pytorch implementaton"></a>pytorch implementaton</h3><p>giithub链接：https:/github.com/tensorboy/pytorch_Realtime_Multi-Person_Pose_Estimation</p><h3 id="preference"><a href="#preference" class="headerlink" title="preference"></a>preference</h3><ul><li><a href="https://blog.csdn.net/qq_14845119/article/details/98192997" target="_blank" rel="noopener">https:/towardsdatascience.com/cvpr-2017-openpose-realtime-multi-person-2d-pose-estimation-using-part-affinity-fields-f2ce18d720e8</a></li><li><a href="https://blog.csdn.net/qq_14845119/article/details/98192997" target="_blank" rel="noopener">https://blog.csdn.net/qq_14845119/article/details/98192997</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章是2017年发表在CVPR上，作者开源了代码openpose，openpose代码完整，在推动人体识别，起到了巨大的作用。&lt;/p&gt;
    
    </summary>
    
      <category term="论文阅读" scheme="https://wenhui-zhou.github.io/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
    
  </entry>
  
</feed>

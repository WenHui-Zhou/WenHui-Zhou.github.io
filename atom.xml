<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WenHuiZhou</title>
  
  <subtitle>perper（打起精神！）</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wenhui-zhou.github.io/"/>
  <updated>2019-11-01T14:53:37.810Z</updated>
  <id>https://wenhui-zhou.github.io/</id>
  
  <author>
    <name>WenHuiZhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>effective cpp 1: 让自己习惯cpp</title>
    <link href="https://wenhui-zhou.github.io/2019/10/31/effective-cpp-1-%E8%AE%A9%E8%87%AA%E5%B7%B1%E4%B9%A0%E6%83%AFcpp/"/>
    <id>https://wenhui-zhou.github.io/2019/10/31/effective-cpp-1-让自己习惯cpp/</id>
    <published>2019-10-31T11:37:49.000Z</published>
    <updated>2019-11-01T14:53:37.810Z</updated>
    
    <content type="html"><![CDATA[<p>2019/10/31，effective cpp第一章：</p><ul><li>01条款：视c++为一个语言联邦</li><li>02条款：尽量以const, enum,inline替换 #define</li><li>03条款：尽可能使用 const</li><li>04条款：确定对象被使用前已被初始化</li></ul><a id="more"></a><h3 id="01-条款：视c-为一个语言联邦"><a href="#01-条款：视c-为一个语言联邦" class="headerlink" title="01 条款：视c++为一个语言联邦"></a>01 条款：视c++为一个语言联邦</h3><p>c++最初从c语言发展而来，最初的名称是c with classes，同时这们语言接受了很多的不同的观点，特性，和编程的设计。使得cpp有着巨大的弹性和威力，因此在cpp不同的语言领域内，将有不同的最优用法。</p><p>cpp有着四个主要的次语言：</p><ul><li>C语言，cpp很多编程上的特性继承至C语言</li><li>面向对象的C++：很多关于类的操作在这一部分引入</li><li>template C++：C++的范型编程，<strong>唯template适用</strong></li><li>STL：标准模板库，里头有着大量的容器，迭代器等</li></ul><p><strong>总结</strong></p><p>C++由上面四种次语言组成，不存在一组高效编程的守则，而是视适用的次语言而定。</p><h3 id="02-条款：-尽量以const-enum-inline替换-define"><a href="#02-条款：-尽量以const-enum-inline替换-define" class="headerlink" title="02 条款： 尽量以const, enum,inline替换 #define"></a>02 条款： 尽量以const, enum,inline替换 #define</h3><p>将cpp程序转化成机器能够看懂的语言，需要经过预处理，编译，汇编，链接这些步骤。<strong>#define</strong>在预处理阶段就会被处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define RATIO 1.25</span><br></pre></td></tr></table></figure><p>在编译器处理源代码阶段，define定义的符号将会被移走，因此RATIO可能根本就没进入<strong>符号表。</strong>当出现错误的时候，根据报错信息将很难定位错误，因此最好将define进行替换，也就是<strong>编译器替换预处理器。</strong></p><p><strong>符号表</strong></p><p>符号表在程序的编译阶段，将函数以及变量名地址记录起来，在链接阶段，根据符号表中记录的内容，去链接程序。</p><p><strong>用const替换define</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> ratio = <span class="number">1.25</span>;</span><br></pre></td></tr></table></figure><p>由于常量的定义经常在头文件之中，因此定义常量指针的时候，通常也将指针定义成const。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> author = <span class="string">"names"</span>;</span><br></pre></td></tr></table></figure><p>当我们需要创建一个类的常量的时候，需要在声明的时候，加一个static，使得这个常量只有一份实体，而且将这个常量的定义域限制在类内。</p><p>最后可以使用enum来代替define：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span>&#123;num1 = <span class="number">1</span>,num2 = <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; num1 &lt;&lt; num2;</span><br></pre></td></tr></table></figure><p>enum将数字符号化，也无法取到enum的地址。</p><p>此外，使用宏定义的另外一部分作用是定义一个简单的函数，避免函数调用带来的麻烦，同时不必要制定变量的类型（需要是同一个类别的），在宏定义的时候，注意为我每一个变量添加一个括号。</p><p>但是我们完全没必要去定义define，而是使用inline去替代：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">callwith</span><span class="params">(<span class="keyword">const</span> T&amp; a ,<span class="keyword">const</span> T&amp; b)</span></span>&#123;</span><br><span class="line">  f(a&gt;b ? a:b); <span class="comment">// 谁大调用谁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li>对于单纯的变量，使用const，enum替换define</li><li>对于宏定义的函数，改成template + inline的形式</li></ul><h3 id="条款-03：尽可能使用-const"><a href="#条款-03：尽可能使用-const" class="headerlink" title="条款 03：尽可能使用 const"></a>条款 03：尽可能使用 const</h3><p>const的原则，<strong>你在可以使用它的时候就使用它</strong>，</p><p>const 是一个语义的束缚，说明内容不可修改，因此只要有这样的一种约束在，就应该声明出来，获得编译器的协助。</p><p>const声明指针的时候有以下几种方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> greeting[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p = greeting; <span class="comment">// 指针所指内容为const</span></span><br><span class="line"><span class="keyword">char</span> <span class="keyword">const</span>* p = greeting; <span class="comment">// const在*左边，与上相同</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p = greeting; <span class="comment">// 指针为const，内容可变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p = greeting; <span class="comment">//指针，内容都不变</span></span><br></pre></td></tr></table></figure><p><strong>令函数的返回值为一个常量值，往往可以降低造成意外的风险</strong></p><p>函数的返回值，正常不应该作为一个变量来被其他赋值，因为这个不符合逻辑，如果可以被直接赋值的话，函数就没什么用了。因此对于大多数函数的返回值来说，可以加上const。</p><p><strong>const成员函数</strong></p><p>const成员函数指的是在一个类里头，这个函数用const进行了标注，表明这个函数是只读的不可以在函数内部对数据成员进行修改，格式如下,const在函数的最后：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> position) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tex[position];</span><br><span class="line">  &#125;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将函数定义成const，可以容易得知这个函数无法修改对象的值；同时使得操作const对象成为可能。</p><p><strong>真实程序中，const对象大多用于传参数，passed-by-pointer-to-const；passed-by-reference-to-const</strong>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">point</span><span class="params">(cosnt TextBlock&amp; ctb)</span></span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; ctb[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一些类中，const标注的函数其内部不允许对成员数据进行修改，但是也存在例外，<strong>mutable</strong>变量定义的变量将改变一些值的const属性，允许在const函数中修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">block</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">mutable</span> <span class="keyword">int</span> len;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> block::length() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">  len = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> len; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>const和non-const函数允许函数进行重载，</strong>但是在使用的时候应该避免写两个函数，而是在non-const函数中，通过类型的转换来调用const类型的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">block</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> position) <span class="keyword">const</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">char</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> position)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;(<span class="keyword">static_cast</span>&lt;cosnt block&amp;&gt;)(*<span class="keyword">this</span>)[position];</span><br><span class="line">    <span class="comment">// const_cast 去掉const</span></span><br><span class="line">    <span class="comment">// static_cast 将this转换为const类型，调用上一个函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结</strong></p><ul><li>const可以施加于任何作用域内的对象，函数参数，返回值，成员函数。</li><li>在能够使用const的时候尽量使用const，利用编译器规则为你排除错误。</li><li>编译器强制实行bitwise constness，编写程序的时候应该遵守逻辑上的const（避免const函数，有些指针是const，但是其内部的值可以修改）。</li><li>const和非const函数有本质上的相似的话，应该使用non-const的版本去调用，避免代码重复。</li></ul><h3 id="条款-04：确定对象被使用前已被初始化"><a href="#条款-04：确定对象被使用前已被初始化" class="headerlink" title="条款 04：确定对象被使用前已被初始化"></a>条款 04：确定对象被使用前已被初始化</h3><p>明天来！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019/10/31，effective cpp第一章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;01条款：视c++为一个语言联邦&lt;/li&gt;
&lt;li&gt;02条款：尽量以const, enum,inline替换 #define&lt;/li&gt;
&lt;li&gt;03条款：尽可能使用 const&lt;/li&gt;
&lt;li&gt;04条款：确定对象被使用前已被初始化&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="effective cpp" scheme="https://wenhui-zhou.github.io/categories/effective-cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>FastFCN: 大工不巧</title>
    <link href="https://wenhui-zhou.github.io/2019/10/31/FastFCN-%E5%A4%A7%E5%B7%A5%E4%B8%8D%E5%B7%A7/"/>
    <id>https://wenhui-zhou.github.io/2019/10/31/FastFCN-大工不巧/</id>
    <published>2019-10-31T08:33:31.000Z</published>
    <updated>2019-11-01T06:48:38.559Z</updated>
    
    <content type="html"><![CDATA[<p>FastFCN是自动化所2019年cvpr上的一个工作，提出JPU模块，代替dilated conv，在保证网络精度的前提下，大大降低网络的计算复杂度，是的FPS得到提升。</p><p>这些年来计算机视觉得到广泛的发展，网络结构也越来越复杂，这篇文章做了一些下修改，可以说耳目一新，结构十分简单，结果十分有效。</p><a id="more"></a><h3 id="语义分割常用的提取feature-map"><a href="#语义分割常用的提取feature-map" class="headerlink" title="语义分割常用的提取feature map"></a>语义分割常用的提取feature map</h3><p><img src="../images/3D/fcn_struct.png" style="zoom:80%;"></p><p><strong>a）FCN结构：</strong>通过一个全卷积的网络，直接得到图像分割后的结果。缺点是图像中的特征丢失。</p><p><strong>b）encoder-decoder结构：</strong>encoder结构得到高层次的特征，decoder阶段通过结合多层次的特征来得到一个多尺度融合的feature map，缺点是仍然存在数据的丢失（pooling 结构）</p><p><strong>c） DilatedFCN：</strong>利用空洞卷积替换pooling层，扩大feature map感受野的同时，没有降低feature map的分辨率。但是这种结构导致了很大的计算量。</p><p>###JPU结构</p><p>作者提出JPU（joint pyramid upsampling）结构，替换DilateFCN中的空洞卷积结构，能够大大的减少内存以及时间上的消耗。</p><p><img src="../images/jpu.png" alt="image-20191101134143826" style="zoom:60%;"></p><p>###FastFCN结构 </p><p><img src="../images/fastfcn.png" alt="image-20191101134311586" style="zoom:50%;"></p><p>FastFCN的backbone采用的是原始的FCN的结构，将FCN的最后三层输入JPU模块中进行训练，最终在许多任务上都得到一个性能一致，但速度得到提升的网络。</p><p><strong>mIoU：</strong>对每一类计算真实标签和预测标签的交并比，然后对所有类别求一个平均得到最后的结果。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章对FCN的网络中的dilated conv进行了一个很小的修改，达到一个比较合理的结果，文章非常的简单，不过可能是因为过于简单的原因，文中也有许多可有可无的内容，总之，对于做工程来说，得到一个FPS比较快的网络还是比较好的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;FastFCN是自动化所2019年cvpr上的一个工作，提出JPU模块，代替dilated conv，在保证网络精度的前提下，大大降低网络的计算复杂度，是的FPS得到提升。&lt;/p&gt;
&lt;p&gt;这些年来计算机视觉得到广泛的发展，网络结构也越来越复杂，这篇文章做了一些下修改，可以说耳目一新，结构十分简单，结果十分有效。&lt;/p&gt;
    
    </summary>
    
    
      <category term="论文阅读" scheme="https://wenhui-zhou.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>关于职业生涯规划以及时间安排的一些思考</title>
    <link href="https://wenhui-zhou.github.io/2019/10/30/%E5%85%B3%E4%BA%8E%E8%81%8C%E4%B8%9A%E7%94%9F%E6%B6%AF%E8%A7%84%E5%88%92%E4%BB%A5%E5%8F%8A%E6%97%B6%E9%97%B4%E5%AE%89%E6%8E%92%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>https://wenhui-zhou.github.io/2019/10/30/关于职业生涯规划以及时间安排的一些思考/</id>
    <published>2019-10-29T17:19:56.000Z</published>
    <updated>2019-10-29T18:00:24.995Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="welcome to my blog,enter password to read." />    <label for="pass">welcome to my blog,enter password to read.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      welcome to my blog,enter password to read.
    
    </summary>
    
    
      <category term="职业规划" scheme="https://wenhui-zhou.github.io/tags/%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>编译器gcc，g++，clang，cmake，make介绍</title>
    <link href="https://wenhui-zhou.github.io/2019/10/27/%E7%BC%96%E8%AF%91%E5%99%A8gcc%EF%BC%8Cg-%EF%BC%8Cclang%EF%BC%8Ccmake%EF%BC%8Cmake%E4%BB%8B%E7%BB%8D/"/>
    <id>https://wenhui-zhou.github.io/2019/10/27/编译器gcc，g-，clang，cmake，make介绍/</id>
    <published>2019-10-27T13:22:52.000Z</published>
    <updated>2019-10-28T11:07:20.931Z</updated>
    
    <content type="html"><![CDATA[<p>这篇post主要介绍在mac上使用CLion编写cpp代码的时候，cpp编译以及链接的一些知识。</p><a id="more"></a><h3 id="cpp程序编译执行过程"><a href="#cpp程序编译执行过程" class="headerlink" title="cpp程序编译执行过程"></a>cpp程序编译执行过程</h3><ul><li><strong>编译</strong>：将源代码翻译成机器语言，生成目标文件<ul><li>预处理：拷贝#include 文件代码，#define 宏定义的替换 ，处理条件编译指令 （#ifndef #ifdef #endif）等，输出.i文件。</li><li>编译优化：进行cpp词法语法分析，确定所有指令是否符合规则，后翻译成汇编代码文件.s。</li><li>汇编：将汇编代码翻译成目标机器代码.o文件。</li></ul></li><li><strong>链接</strong>：由于目标文件调用了其他源文件，因此这一步需要将有关的源文件链接起来，生成.exe。</li></ul><h3 id="cpp使用的编译器gcc，g-，clang"><a href="#cpp使用的编译器gcc，g-，clang" class="headerlink" title="cpp使用的编译器gcc，g++，clang"></a><strong>cpp使用的编译器gcc，g++，clang</strong></h3><ul><li><strong>gcc</strong>: 最开始的时候是 GNU C Compiler, 如你所知，就是一个c编译器。但是后来因为这个项目里边集成了更多其他不同语言的编译器，GCC就代表 the GNU Compiler Collection，所以表示一堆编译器的合集。</li><li><strong>g++</strong>：是GCC的c++编译器。</li><li><strong>clang</strong>：是mac上另起炉灶写的一个C语言、C++、Objective-C、Objective-C++语言的<strong>轻量级编译器</strong>。源代码发布于BSD协议下。Clang将支持其普通lambda表达式、返回类型的简化处理以及更好的处理constexpr关键字。</li></ul><p><strong>clang和gcc相比比gcc编译速度更快一些，而且错误提示更人性化。</strong></p><h3 id="make，cmake"><a href="#make，cmake" class="headerlink" title="make，cmake"></a>make，cmake</h3><p>光有gcc还不够，如果这时候我们开发的工程使用的文件很多，那就需要一个一个去编译，工作量很大。一些大型的IDE如VS studio，CLion使用clang编译器，使用cmake链接工具，对源码进行编译。</p><p><strong>make</strong></p><p>make类似于一个目录，是一个文件编译的批处理工具，本身没有编译的功能。make的作用就是告诉编译器，各种各样的编译规则，先做什么后做什么，这些规则写在makefile文件中。</p><p>make用于构建项目，其中一条很重要的规则就是依赖关系，当某些文件发生改变，直接或间接依赖这些文件的目标就要进行重新的构建。make用来构建管理文件，不一定用于编译。</p><p><strong>cmake</strong></p><p>构建一个项目需要了解构建的规则，并写出makefile文件，但是编译构建本身是个复杂过程，不同的项目构建规则会有所不同，要自己写出一个makefile文件比较困难。</p><p>cmake工具是根据平台（跨平台）和配置自动生成项目的makefile文件，然后给make使用。</p><p>cmake根据CMakeLists.txt文件（组态档）去生成makefile。在不使用CLion等这类IDE的情况下，这个CMakeLists.txt需要自己来写，下面是一个CMakeLists.txt：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.8</span>)</span><br><span class="line"><span class="keyword">project</span>(First_Code)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">11</span>)</span><br><span class="line"><span class="comment">#set(CMAKE_CXX_FLAGS "-std=c++0x $&#123;CMAKE_CXX_FLAGS&#125; -g -ftest-coverage -fprofile-arcs")</span></span><br><span class="line"><span class="comment">#set(CMAKE_CXX_FLAGS "$&#123;CMAKE_CXX_FLAGS&#125; -std=c++11")</span></span><br><span class="line"><span class="keyword">set</span>(SOURCE_FILES main.cpp <span class="keyword">test</span>.cpp assignment.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(First_Code <span class="variable">$&#123;SOURCE_FILES&#125;</span>)</span><br></pre></td></tr></table></figure><p>但是不用担心，CMakeLists.txt IDE也会负责生成。</p><h3 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h3><p>  C++11，（即ISO/IEC 14882:2011），是目前的C++编程语言的最新正式标准。它取代了第二版标准(第一版公开于1998年，第二版于2003年更新，分别通称C++98以及C++03，两者差异很小)。新的标准包含核心语言的新机能，而且扩展C++标准程序库。C++11新标准由C++标准委员会于2011年8月12日公布，并于2011年9月出版。此次标准为C++98发布后13年来第一次重大修正。</p><p><strong>gcc4.7以及之后，全面支持c++11。</strong></p><h3 id="MAC更换CLion编译器"><a href="#MAC更换CLion编译器" class="headerlink" title="MAC更换CLion编译器"></a>MAC更换CLion编译器</h3><p>在terminal输入<code>gcc -v</code>发现出来的是APPLE的clang编译器，由于更习惯使用GUN的gcc编译器，因此打算安装一个，同时保留原有的clang。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew search gcc // 查看有哪些gcc</span><br><span class="line">brew install gcc //安装最新版本的gcc，目前电脑上用的是gcc9.2</span><br></pre></td></tr></table></figure><p>上诉过程安装完成之后，gcc的位置在：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/Cellar/gcc/9.2.0_1/bin</span><br></pre></td></tr></table></figure><p>将这个路径加入到CLion所使用的编译器上，同时修改cmake参数(preference 中修改)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-D CMAKE_CXX_COMPILER=/usr/local/bin/g++-9</span><br></pre></td></tr></table></figure><h3 id="CLion-中新建项目的目录结构"><a href="#CLion-中新建项目的目录结构" class="headerlink" title="CLion 中新建项目的目录结构"></a>CLion 中新建项目的目录结构</h3><p>CLion是通过cmake来构建文件的，手动在CLion中生成cpp文件，系统件制动修改cmakeLists.txt</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇post主要介绍在mac上使用CLion编写cpp代码的时候，cpp编译以及链接的一些知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="learning cpp" scheme="https://wenhui-zhou.github.io/tags/learning-cpp/"/>
    
  </entry>
  
  <entry>
    <title>cpp STL方法介绍</title>
    <link href="https://wenhui-zhou.github.io/2019/10/27/cpp-STL%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
    <id>https://wenhui-zhou.github.io/2019/10/27/cpp-STL方法介绍/</id>
    <published>2019-10-27T11:34:48.000Z</published>
    <updated>2019-10-30T15:42:10.274Z</updated>
    
    <content type="html"><![CDATA[<p>这篇post主要目的是对cpp提供的Standard Template Library标准模板库中一些重要的方法进行学习，记录，以便今后学习。</p><a id="more"></a><h3 id="STL概述"><a href="#STL概述" class="headerlink" title="STL概述"></a>STL概述</h3><p>在开始STL之前，像大家介绍一下一个全能的头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>这个头文件include了在STL中所有的头文件，方便我们使用而不用去担心这些方法所在的库。</p><p>STL库中有四类重要的部分：</p><ul><li>Algorithm：该部分提供的算法定义在容器上，用于操作容器上的元素。</li><li>containers：定义了一些常用的容器，如vector，map等等</li><li>functor：算子，是个函数，用于定制化STL函数，如sort，传入functor定制排序方式</li><li>iterator：迭代器，用于遍历整个序列</li></ul><h3 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h3><p><strong>sort(begin_adress,end_adress,compare)</strong></p><p>排序算法是定义在所有容器上的一个排序函数，其内部实现是快排，时间复杂度是$O(nlogn)$.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">9</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>&#125;;</span><br><span class="line">sort(arr,arr+<span class="number">10</span>); <span class="comment">//升序排序</span></span><br><span class="line">sort(arr,arr+<span class="number">10</span>,greater&lt;<span class="keyword">int</span>&gt;()); <span class="comment">// 降序排序</span></span><br><span class="line"><span class="comment">// 特殊数组的排序</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">interval</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> val1;</span><br><span class="line">  <span class="keyword">int</span> val2;</span><br><span class="line">&#125;;</span><br><span class="line">interval arr[] = &#123;&#123;<span class="number">2</span>,<span class="number">2</span>&#125;,&#123;<span class="number">4</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;</span><br><span class="line"><span class="keyword">bool</span> compareInterval(interval v1,interval v2)&#123;</span><br><span class="line">  <span class="keyword">return</span> v1.val1 &lt; v2.val2; <span class="comment">// 如果第一个数小的话，先排序</span></span><br><span class="line">&#125;</span><br><span class="line">sort(arr,arr+<span class="number">10</span>,compareInterval); <span class="comment">// 得到按第一个元素排序的数组</span></span><br></pre></td></tr></table></figure><p><strong>bool binary_search(start_adress,end_adress,value_find)</strong></p><p>二分搜索查找value_find这个元素，该数组已经被排序过了，复杂度为$O(logn)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">if</span>(binary_search(arr,arr+<span class="number">10</span>,<span class="number">2</span>))&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"get it "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>bool all_of(begin_adress,end_adress,lambda_func)</strong></p><p>该函数判断是否arr中的所有元素都满足lambda中的规则</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">STL_allof</span><span class="params">(<span class="keyword">int</span>*a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lens = <span class="keyword">sizeof</span>(a)/ <span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">    all_of(a,a+lens,[](<span class="keyword">int</span> x)&#123;<span class="keyword">return</span> x &gt;= <span class="number">0</span>;&#125;) ? <span class="built_in">cout</span>&lt;&lt;<span class="string">"all are positive"</span> : <span class="built_in">cout</span>&lt;&lt;<span class="string">"no all positive"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>bool any_of(begin_adress,end_adress,lambda_func)</strong></p><p>只要有一个满足要求的，就返回true</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">any_of(arr_begin,arr_end,[](<span class="keyword">int</span> x)&#123; <span class="keyword">return</span> x == <span class="number">0</span>;&#125;) <span class="comment">//返回bool</span></span><br></pre></td></tr></table></figure><p><strong>bool none_of(begin_adress,end_adress,lambda_func)</strong></p><p>所有都不满足情况的时候，返回true</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">none_of(arr_begin,arr_end,[](<span class="keyword">int</span> x)&#123; <span class="keyword">return</span> x == <span class="number">0</span>;&#125;) <span class="comment">//返回bool</span></span><br></pre></td></tr></table></figure><p><strong>copy_n(arr1,size,arr2)</strong></p><p>将arr1中的前size个元素拷贝到arr2中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> arr2[<span class="number">10</span>];</span><br><span class="line">copy_n(arr,<span class="number">10</span>,arr2);</span><br></pre></td></tr></table></figure><h3 id="containers"><a href="#containers" class="headerlink" title="containers"></a>containers</h3><p><strong>序列容器</strong></p><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><p>向量是一个动态数组，数组的大小随着元素的个数而变化，内存空间是连续分布的，因此可以使用迭代器。向vector末尾插入元素要花费的时间是不确定的，因为有时候vector可能会扩容，此外插入和删除要花线性的时间。</p><p><strong>iterators</strong></p><p>vector是在内存上连续的一段存储空间，因此允许使用迭代器，vector的迭代器有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">vec.begin(); <span class="comment">// 指向第一个元素</span></span><br><span class="line">vec.end(); <span class="comment">// 指向最后一个元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = vec.begin();i!=vec.end();i++)&#123;...&#125;</span><br><span class="line">vec.rbegin(); <span class="comment">//指向最后一个，反向迭代</span></span><br><span class="line">vec.rend();  <span class="comment">// 指向第一个，作为后向的终点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = vec.rbegin();i!=vec.end();i++)&#123;...&#125;</span><br><span class="line"><span class="comment">// 此外上诉两种指针都有一个c（const）的版本，如vec.rbegin()</span></span><br><span class="line"><span class="comment">//这个版本返回的迭代器是const类型的，不可改变迭代器所指向元素的值</span></span><br></pre></td></tr></table></figure><p><strong>capacity</strong></p><p>vector是一个可变长度的向量，当vector在添加元素的时候，会选择增长向量的容量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">vec.size(); <span class="comment">//实际长度</span></span><br><span class="line">vec.capacity(); <span class="comment">//已经分配的长度</span></span><br><span class="line">vec.max_size(); <span class="comment">// 可分配的最大长度</span></span><br><span class="line">vec.empty(); <span class="comment">// 判断是否为空</span></span><br><span class="line">vec.shrink_to_fit(); <span class="comment">// 将容量减小到容器的容量大小</span></span><br></pre></td></tr></table></figure><p><strong>访问元素</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">vec[<span class="number">1</span>];</span><br><span class="line">vec.front();</span><br><span class="line">vec.back();</span><br><span class="line">vec.at(pos);</span><br><span class="line">vec.data(); <span class="comment">// 返回指针指向第一个地址</span></span><br></pre></td></tr></table></figure><p><strong>修改元素</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">vec.assign(val,time); <span class="comment">//vec赋值，time个val的值</span></span><br><span class="line">vec.push_back(val);</span><br><span class="line">vec.pop_back(val);</span><br><span class="line">vec.insert(insert_adress,val);</span><br><span class="line">vec.erase(adress);</span><br><span class="line">vec.clear(); <span class="comment">// 清空</span></span><br><span class="line">vec.emplace(adress,val); <span class="comment">// 插入元素，并且避免不必要的复制</span></span><br><span class="line">vec.emplace_back(val); <span class="comment">// 末尾插入</span></span><br><span class="line">vec.swap(vec2); <span class="comment">// 交换vec和vec1的元素</span></span><br></pre></td></tr></table></figure><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list是由<strong>双向链表</strong>实现的数据结构，它在空间中不连续，元素的访问速度不如vector，但是对元素的删除，插入操作十分的快速。</p><p>他的很多函数与vector类似，下面列举一下特殊的一下操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; ll = &#123;<span class="number">1</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>&#125;;</span><br><span class="line">ll.sort();</span><br><span class="line">ll.reverse();</span><br><span class="line">ll.push_front();</span><br><span class="line">ll.erase(adress) <span class="keyword">or</span> ll.erase(begin,end);</span><br><span class="line">ll.remove(val); <span class="comment">//删掉val</span></span><br><span class="line">ll.unique(); <span class="comment">// 删除重复元素</span></span><br><span class="line">ll.splice(l1.begin(),l2); <span class="comment">// 链表的拼接</span></span><br><span class="line">ll.merge(<span class="number">12</span>); <span class="comment">// 两个排序后的链表融合</span></span><br></pre></td></tr></table></figure><p><strong>deque</strong></p><p>双向队列，可以两头操作，效率比vector高，但是不一定保证地址是连续的。</p><p>deque和vector的操作基本一致，唯一的不同在于deque允许头插。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">que.push_front(val);</span><br><span class="line">que.pop_front(val);</span><br></pre></td></tr></table></figure><p><strong>froward_list</strong></p><p>单向链表，与list类似，但只支持一个方向，同时所占用的存储空间更小。基本操作和list类似。</p><p><strong>queue</strong></p><p>单向队列，基本方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">que.push(val); <span class="comment">// 插到队列尾巴</span></span><br><span class="line">que.pop();  <span class="comment">// 删除队列头部元素</span></span><br><span class="line"><span class="built_in">queue</span>.empty();</span><br><span class="line"><span class="built_in">queue</span>.size();</span><br></pre></td></tr></table></figure><p><strong>priority queue</strong></p><p>优先队列中，队头的元素是最大的，但是队列的排列顺序不是按照顺序排序的。优先队列使用起来应该很方便，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line">que.push(val);</span><br><span class="line">que.push(val);</span><br><span class="line">que.pop();</span><br><span class="line">que.top();</span><br></pre></td></tr></table></figure><p>优先队列是一种最大堆的结构。也可以用优先队列构建最小堆。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; gg;</span><br></pre></td></tr></table></figure><p><strong>stack</strong></p><p>栈是先进先出的一个结构，只有一端开放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack.empty();</span><br><span class="line">stack.push(val);</span><br><span class="line">stack.pop();</span><br><span class="line">stack.top();</span><br></pre></td></tr></table></figure><p><strong>关联容器</strong></p><p><strong>set</strong></p><p>集合容器，他要求内部元素没有重复的，他的常用的方法有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; gg;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>,greater&lt;<span class="keyword">int</span>&gt;&gt; gg; <span class="comment">//从大到小</span></span><br><span class="line">begin();</span><br><span class="line">end();</span><br><span class="line">empty();</span><br><span class="line">gg.insert(val); <span class="comment">// set中的元素都是有序的</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; gg = &#123;vec.begin(),vec.end()&#125;;</span><br><span class="line">gg.lower_bound(val); <span class="comment">//. 返回低于或等于val</span></span><br><span class="line">gg.upper_bound(val); <span class="comment">// 返回高于或等于val的第一个迭代器位置</span></span><br></pre></td></tr></table></figure><p><strong>multiset</strong></p><p>这个容器类似于set，但是和set有一个不同之处在于multiset可以允许重复。</p><p><strong>map</strong></p><p>字典，键值对。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; amap;</span><br><span class="line">amap.insert(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">21</span>));</span><br><span class="line">amap.insert(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">23</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; amap[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">auto</span> ptr = amap.begin();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ptr-&gt;first&lt;&lt; <span class="string">" "</span>&lt;&lt; ptr-&gt;second;</span><br><span class="line">amap.erase(amap.begin());</span><br><span class="line">amap.erase(<span class="number">4</span>);<span class="comment">//key</span></span><br></pre></td></tr></table></figure><p><strong>multimap</strong></p><p>操作基本与map相同，不相同的是，multimap允许有相同的key。</p><p><strong>unordered_set</strong></p><p>背后使用hash表来存储，key没有顺序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; stringset;</span><br><span class="line">stringset.insert(<span class="string">"code"</span>);</span><br><span class="line">stringset.find(key); <span class="comment">//返回一个迭代器的位置</span></span><br></pre></td></tr></table></figure><p><strong>unordered_multiset</strong></p><p>与unordered_set相似，但是允许元素重复。</p><p><strong>unordered_map</strong></p><p>与map相似，但是其中的元素key的顺序不是按顺序的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">double</span>&gt; umap;</span><br><span class="line">umap['id'] = 11;</span><br><span class="line">umap.insert(make_pair(<span class="string">"e"</span>,<span class="number">2.33</span>));</span><br><span class="line">umap.find(key);</span><br></pre></td></tr></table></figure><p><strong>unordered_multimap</strong></p><p>与unordered_map相类似，但是允许有key的重复。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇post主要目的是对cpp提供的Standard Template Library标准模板库中一些重要的方法进行学习，记录，以便今后学习。&lt;/p&gt;
    
    </summary>
    
    
      <category term="learning cpp" scheme="https://wenhui-zhou.github.io/tags/learning-cpp/"/>
    
  </entry>
  
</feed>
